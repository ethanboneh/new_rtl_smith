{"original_entry": {"instruction": "\nDesign and implement two Verilog modules:\n\n1.  A module named `full_adder` that performs a 1-bit binary addition of three inputs (two data bits and a carry-in) and produces a sum bit and a carry-out bit.\n    *   Module name: `full_adder`\n    *   Inputs: `input a`, `input b`, `input cin`\n    *   Outputs: `output s`, `output cout`\n\n2.  A module named `adder_4bit` that performs a 4-bit binary addition of two 4-bit inputs and a carry-in, producing a 4-bit sum and a carry-out. This module should be structured using instances of your `full_adder` module.\n    *   Module name: `adder_4bit`\n    *   Inputs: `input [3:0] A`, `input [3:0] B`, `input Cin`\n    *   Outputs: `output [3:0] S`, `output Cout`\n\nProvide the Verilog code for both modules.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule adder_4bit(\n\tinput [3:0] A,\n\tinput [3:0] B,\n\tinput Cin,\n\toutput [3:0] S,\n\toutput Cout\n\t);\n\nwire c1, c2, c3;\n\nfull_adder fa1(A[0], B[0], Cin, S[0], c1);\nfull_adder fa2(A[1], B[1], c1, S[1], c2);\nfull_adder fa3(A[2], B[2], c2, S[2], c3);\nfull_adder fa4(A[3], B[3], c3, S[3], Cout);\n\nendmodule\n\nmodule full_adder(\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput s,\n\toutput cout\n\t);\n\nassign s = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\nCODE END"}, "clean_code": "module adder_4bit(\n\tinput [3:0] A,\n\tinput [3:0] B,\n\tinput Cin,\n\toutput [3:0] S,\n\toutput Cout\n\t);\n\nwire c1, c2, c3;\n\nfull_adder fa1(A[0], B[0], Cin, S[0], c1);\nfull_adder fa2(A[1], B[1], c1, S[1], c2);\nfull_adder fa3(A[2], B[2], c2, S[2], c3);\nfull_adder fa4(A[3], B[3], c3, S[3], Cout);\n\nendmodule\n\nmodule full_adder(\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput s,\n\toutput cout\n\t);\n\nassign s = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "corrupted_code": "module adder_4bit(\n\tinput [3:0] A,\n\tinput [3:0] B,\n\tinput Cin,\n\toutput [3:0] S,\n\toutput Cout\n\t);\n\nwire c1, c2, c3;\n\nfull_adder fa1(A[0], B[0], Cin, S[0], c1);\nfull_adder fa2(A[1], B[1], c1, S[1], c2);\nfull_adder fa3(A[2], B[2], c2, S[2], c3);\nfull_adder fa4(A[3], B[3], c3, S[3], Cout);\n\nendmodule\n\nmodule full_adder(\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput s,\n\toutput cout\n\t);\n\nassign s = a ^ b ^ cin;\nassign cout = (a | b) | (cin & (a ^ b));\n\nendmodule", "corruption_explanation": "Changed operator from '&' to '|'", "modification_type": "change_operator", "modification_line": 27, "original_snippet": "&", "modified_snippet": "|", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '&' to '|'\n   \u2022 Line 27: Original: &\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 27.\n   \u2022 Restore the original code: &\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 3, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "verified_different": true, "timestamp": "2025-12-09T21:52:30.964787"}
{"original_entry": {"instruction": "\nDesign a Verilog module named `addfxp` that implements a synchronous fixed-point adder with configurable latency. The module should have the following interface:\n\nInputs:\n*   `input signed [width-1:0] a`\n*   `input signed [width-1:0] b`\n*   `input clk`\n\nOutput:\n*   `output signed [width-1:0] q`\n\nParameters:\n*   `parameter width = 16` (Data width)\n*   `parameter cycles = 1` (Latency in clock cycles)\n\nThe module should compute the sum `a + b` and output the result `q` exactly `cycles` clock cycles after the inputs `a` and `b` are sampled on a positive edge of `clk`. The inputs and output are signed fixed-point numbers of size `width`.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule addfxp(a, b, q, clk);\n\n   parameter width = 16, cycles=1;\n   \n   input signed [width-1:0]  a, b;\n   input                     clk;   \n   output signed [width-1:0] q;\n   reg signed [width-1:0]    res[cycles-1:0];\n\n   assign                    q = res[cycles-1];\n   \n   integer                   i;   \n   \n   always @(posedge clk) begin\n     res[0] <= a+b;\n      for (i=1; i < cycles; i = i+1)\n        res[i] <= res[i-1];\n      \n   end\n   \nendmodule\nCODE END"}, "clean_code": "module addfxp(a, b, q, clk);\n\n   parameter width = 16, cycles=1;\n   \n   input signed [width-1:0]  a, b;\n   input                     clk;   \n   output signed [width-1:0] q;\n   reg signed [width-1:0]    res[cycles-1:0];\n\n   assign                    q = res[cycles-1];\n   \n   integer                   i;   \n   \n   always @(posedge clk) begin\n     res[0] <= a+b;\n      for (i=1; i < cycles; i = i+1)\n        res[i] <= res[i-1];\n      \n   end\n   \nendmodule", "corrupted_code": "module addfxp(a, b, q, clk);\n\n   parameter width = 17, cycles=1;\n   \n   input signed [width-1:0]  a, b;\n   input                     clk;   \n   output signed [width-1:0] q;\n   reg signed [width-1:0]    res[cycles-1:0];\n\n   assign                    q = res[cycles-1];\n   \n   integer                   i;   \n   \n   always @(posedge clk) begin\n     res[0] <= a+b;\n      for (i=1; i < cycles; i = i+1)\n        res[i] <= res[i-1];\n      \n   end\n   \nendmodule", "corruption_explanation": "Changed constant from 16 to 17", "modification_type": "change_constant", "modification_line": 3, "original_snippet": "16", "modified_snippet": "17", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 16 to 17\n   \u2022 Line 3: Original: 16\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 3.\n   \u2022 Restore the original code: 16\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 10, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "verified_different": true, "timestamp": "2025-12-09T21:52:30.967112"}
{"original_entry": {"instruction": "\nDesign two Verilog modules:\n\n1.  A single-bit full adder module named `full_adder`. It should have inputs `A`, `B`, and `Cin` (all single bits) and outputs `S` (sum) and `Cout` (carry-out) (both single bits).\n2.  A 4-bit ripple-carry adder module named `adder`. This module should utilize the `full_adder` module. It should have 4-bit inputs `A` and `B`, a single-bit input `Cin`, a 4-bit output `S` (sum), and a single-bit output `Cout` (final carry-out).\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule adder(A, B, Cin, S, Cout);\n    input [3:0] A, B;\n    input Cin;\n    output [3:0] S;\n    output Cout;\n\n    wire c1, c2, c3;\n\n    full_adder fa0(A[0], B[0], Cin, S[0], c1);\n    full_adder fa1(A[1], B[1], c1, S[1], c2);\n    full_adder fa2(A[2], B[2], c2, S[2], c3);\n    full_adder fa3(A[3], B[3], c3, S[3], Cout);\n\nendmodule\nmodule full_adder(A, B, Cin, S, Cout);\n    input A, B, Cin;\n    output S, Cout;\n    assign {Cout, S} = A + B + Cin;\nendmodule\nCODE END"}, "clean_code": "module adder(A, B, Cin, S, Cout);\n    input [3:0] A, B;\n    input Cin;\n    output [3:0] S;\n    output Cout;\n\n    wire c1, c2, c3;\n\n    full_adder fa0(A[0], B[0], Cin, S[0], c1);\n    full_adder fa1(A[1], B[1], c1, S[1], c2);\n    full_adder fa2(A[2], B[2], c2, S[2], c3);\n    full_adder fa3(A[3], B[3], c3, S[3], Cout);\n\nendmodule\nmodule full_adder(A, B, Cin, S, Cout);\n    input A, B, Cin;\n    output S, Cout;\n    assign {Cout, S} = A + B + Cin;\nendmodule", "corrupted_code": "module adder(A, B, Cin, S, Cout);\n    input [3:1] A, B;\n    input Cin;\n    output [3:0] S;\n    output Cout;\n\n    wire c1, c2, c3;\n\n    full_adder fa0(A[0], B[0], Cin, S[0], c1);\n    full_adder fa1(A[1], B[1], c1, S[1], c2);\n    full_adder fa2(A[2], B[2], c2, S[2], c3);\n    full_adder fa3(A[3], B[3], c3, S[3], Cout);\n\nendmodule\nmodule full_adder(A, B, Cin, S, Cout);\n    input A, B, Cin;\n    output S, Cout;\n    assign {Cout, S} = A + B + Cin;\nendmodule", "corruption_explanation": "Changed bit width from [3:0] to [3:1]", "modification_type": "change_bit_width", "modification_line": 2, "original_snippet": "[3:0]", "modified_snippet": "[3:1]", "issue_description": "The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_bit_width modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed bit width from [3:0] to [3:1]\n   \u2022 Line 2: Original: [3:0]\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 2.\n   \u2022 Restore the original code: [3:0]\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change bit width.", "complexity": 1, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "swap_port_signals"], "verified_different": true, "timestamp": "2025-12-09T21:52:30.968981"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `binary_counter`.\nThis module should implement a synchronous binary counter with an asynchronous reset.\nIt should include a parameter named `MAX_COUNT` with a default value of 15, which determines the maximum value the counter reaches before wrapping around.\n\nThe module interface should be defined as follows:\n-   Input `clk`: The clock signal.\n-   Input `reset`: The asynchronous reset signal (active high).\n-   Output `count`: A 4-bit register (`reg [3:0]`) holding the current count value.\n-   Output `overflow`: A register (`reg`) indicating when the counter has just wrapped around.\n\nThe behavior of the module should be:\n-   When the `reset` input is high, the `count` output should immediately reset to 0, and the `overflow` output should be cleared to 0.\n-   On the positive edge of the `clk` signal, when `reset` is low:\n    -   If the current value of `count` is equal to the `MAX_COUNT` parameter, the `count` should wrap around to 0 on the next clock cycle, and the `overflow` output should be set high for one clock cycle.\n    -   Otherwise (if the current value of `count` is less than `MAX_COUNT`), the `count` should increment by 1, and the `overflow` output should be cleared to 0.\n\nUse non-blocking assignments (`<=`) for all sequential logic updates.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule binary_counter\n#(parameter MAX_COUNT=15)\n(\n  input clk,\n  input reset,\n  output reg [3:0]count,  // 4 bits for 16 counts\n  output reg overflow\n);\n\n  always @(posedge clk or posedge reset)\n  begin\n    if (reset)\n    begin\n      count <= 0;\n      overflow <= 0;\n    end\n    else if (count == MAX_COUNT)\n    begin\n      count <= 0;\n      overflow <= 1;\n    end\n    else\n    begin\n      count <= count + 1;\n      overflow <= 0;\n    end\n  end\n\nendmodule\nCODE END"}, "clean_code": "module binary_counter\n#(parameter MAX_COUNT=15)\n(\n  input clk,\n  input reset,\n  output reg [3:0]count,  // 4 bits for 16 counts\n  output reg overflow\n);\n\n  always @(posedge clk or posedge reset)\n  begin\n    if (reset)\n    begin\n      count <= 0;\n      overflow <= 0;\n    end\n    else if (count == MAX_COUNT)\n    begin\n      count <= 0;\n      overflow <= 1;\n    end\n    else\n    begin\n      count <= count + 1;\n      overflow <= 0;\n    end\n  end\n\nendmodule", "corrupted_code": "module binary_counter\n#(parameter MAX_COUNT=15)\n(\n  input clk,\n  input reset,\n  output reg [3:0]count,  // 4 bits for 16 counts\n  output reg overflow\n);\n\n  always @(posedge clk or posedge reset)\n  begin\n    if (reset)\n    begin\n      count <= 0;\n\n    end\n    else if (count == MAX_COUNT)\n    begin\n      count <= 0;\n      overflow <= 1;\n    end\n    else\n    begin\n      count <= count + 1;\n      overflow <= 0;\n    end\n  end\n\nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 15, "original_snippet": "overflow <= 0;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 15: Original: overflow <= 0;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 15.\n   \u2022 Restore the original code: overflow <= 0;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 11, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "verified_different": true, "timestamp": "2025-12-09T21:52:30.972036"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `ram_RAMB18E1` with the following interface and behavior.\n\n**Interface:**\n*   **Parameters:**\n    *   `LOC`: string type, default value \"RAMB18_X0Y0\"\n    *   `WRITE_MODE_A`: string type, default value \"WRITE_FIRST\"\n*   **Inputs:**\n    *   `clk`: 1-bit wire\n    *   `din`: 8-bit wire\n*   **Outputs:**\n    *   `dout`: 8-bit wire\n\n**Behavior:**\nThe module should contain an internal 8-bit state register (or equivalent storage) which is initialized to all zeros. On the positive edge of the `clk` signal, if the parameter `WRITE_MODE_A` has the string value 'WRITE_FIRST', this internal 8-bit state is updated. The update involves effectively shifting the current 8-bit state one position to the right. The most significant bit (bit 7) of the state is loaded with the value of the least significant bit of the `din` input (`din[0]`). The bit previously in the least significant position (bit 0) is discarded. The output `dout` should continuously reflect the current value of this internal 8-bit state.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule ram_RAMB18E1 #(parameter LOC = \"RAMB18_X0Y0\", parameter WRITE_MODE_A = \"WRITE_FIRST\")\n(\n    input wire clk,\n    input wire [7:0] din,\n    output wire [7:0] dout\n);\n\nreg [7:0] mem [0:31];\n\ninteger i;\n\ninitial begin\n    for (i = 0; i < 32; i = i + 1) begin\n        mem[i] = 8'h00;\n    end\nend\n\nalways @(posedge clk) begin\n    if (WRITE_MODE_A == \"WRITE_FIRST\") begin\n        mem[0] <= {din, mem[0][7:1]};\n    end\nend\n\nassign dout = mem[0];\n\nendmodule\nCODE END"}, "clean_code": "module ram_RAMB18E1 #(parameter LOC = \"RAMB18_X0Y0\", parameter WRITE_MODE_A = \"WRITE_FIRST\")\n(\n    input wire clk,\n    input wire [7:0] din,\n    output wire [7:0] dout\n);\n\nreg [7:0] mem [0:31];\n\ninteger i;\n\ninitial begin\n    for (i = 0; i < 32; i = i + 1) begin\n        mem[i] = 8'h00;\n    end\nend\n\nalways @(posedge clk) begin\n    if (WRITE_MODE_A == \"WRITE_FIRST\") begin\n        mem[0] <= {din, mem[0][7:1]};\n    end\nend\n\nassign dout = mem[0];\n\nendmodule", "corrupted_code": "module ram_RAMB18E1 #(parameter LOC = \"RAMB18_X0Y0\", parameter WRITE_MODE_A = \"WRITE_FIRST\")\n(\n    input wire clk,\n    input wire [7:0] din,\n    output wire [7:0] dout\n);\n\nreg [7:0] mem [0:31];\n\ninteger i;\n\ninitial begin\n    for (i = 0; i < 32; i = i + 1) begin\n        mem[i] = 8'h00;\n    end\nend\n\nalways @(posedge clk) begin\n    if (!(WRITE_MODE_A == \"WRITE_FIRST\")) begin\n        mem[0] <= {din, mem[0][7:1]};\n    end\nend\n\nassign dout = mem[0];\n\nendmodule", "corruption_explanation": "Inverted condition: 'WRITE_MODE_A == \"WRITE_FIRST\"' -> '!(WRITE_MODE_A == \"WRITE_FIRST\")'", "modification_type": "invert_condition", "modification_line": 19, "original_snippet": "if (WRITE_MODE_A == \"WRITE_FIRST\") begin", "modified_snippet": "if (!(WRITE_MODE_A == \"WRITE_FIRST\")) begin", "issue_description": "The buggy code has an inverted condition in an if statement. Instead of checking if(x), it checks if(!x), causing the logic to execute when it shouldn't and skip execution when it should. All conditional behavior is reversed from intended functionality.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_condition modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted condition: 'WRITE_MODE_A == \"WRITE_FIRST\"' -> '!(WRITE_MODE_A == \"WRITE_FIRST\")'\n   \u2022 Line 19: Original: if (WRITE_MODE_A == \"WRITE_FIRST\") begin\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 19.\n   \u2022 Restore the original code: if (WRITE_MODE_A == \"WRITE_FIRST\") begin\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert condition.", "complexity": 5, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "verified_different": true, "timestamp": "2025-12-09T21:52:30.973138"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `random_num_gen` that generates an 8-bit pseudo-random number. The module should have the following interface: inputs `clk` (clock), `rst` (synchronous reset), `start` (enable), and an 8-bit output `rand_num`. The core of the generator is an 8-bit state register. On the positive edge of the clock, if `rst` is asserted, this state register should be cleared. If `rst` is not asserted and `start` is asserted, the state register should update to a new value calculated from its current state using a specific algorithm that shifts the state and incorporates feedback. The 8-bit output `rand_num` should continuously reflect the current value of this state register.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule random_num_gen (\n  input clk,\n  input rst,\n  input start,\n  output reg [7:0] rand_num\n);\n\nparameter n = 8; // width of the random number\n\nreg [7:0] lfsr_reg;\nreg feedback;\n\nalways @ (posedge clk) begin\n  if (rst) begin\n    lfsr_reg <= 8'b0;\n  end\n  else if (start) begin\n    feedback = lfsr_reg[0] ^ lfsr_reg[1] ^ lfsr_reg[3] ^ lfsr_reg[4];\n    lfsr_reg <= {lfsr_reg[6:0], feedback};\n  end\nend\n\nalways @* begin\n  rand_num = lfsr_reg;\nend\n\nendmodule\nCODE END"}, "clean_code": "module random_num_gen (\n  input clk,\n  input rst,\n  input start,\n  output reg [7:0] rand_num\n);\n\nparameter n = 8; // width of the random number\n\nreg [7:0] lfsr_reg;\nreg feedback;\n\nalways @ (posedge clk) begin\n  if (rst) begin\n    lfsr_reg <= 8'b0;\n  end\n  else if (start) begin\n    feedback = lfsr_reg[0] ^ lfsr_reg[1] ^ lfsr_reg[3] ^ lfsr_reg[4];\n    lfsr_reg <= {lfsr_reg[6:0], feedback};\n  end\nend\n\nalways @* begin\n  rand_num = lfsr_reg;\nend\n\nendmodule", "corrupted_code": "module random_num_gen (\n  input clk,\n  input rst,\n  input start,\n  output reg [7:0] rand_num\n);\n\nparameter n = 8; // width of the random number\n\nreg [7:0] lfsr_reg;\nreg feedback;\n\nalways @ (posedge clk) begin\n  if (rst) begin\n    lfsr_reg <= 8'b0;\n  end\n  else if (start) begin\n    feedback = lfsr_reg[0] ^ lfsr_reg[1] ^ lfsr_reg[3] ^ lfsr_reg[4];\n    lfsr_reg <= {lfsr_reg[6:0], feedback};\n  end\nend\n\n\n\nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 23, "original_snippet": "always @* begin\n  rand_num = lfsr_reg;\nend", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 23: Original: always @* begin\n  rand_num = lfsr_reg;\nend\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 23.\n   \u2022 Restore the original code: always @* begin\n  rand_num = lfsr_reg;\nend\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 5, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "verified_different": true, "timestamp": "2025-12-09T21:52:30.974363"}
