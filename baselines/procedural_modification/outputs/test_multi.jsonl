{"original_entry": {"instruction": "\nDesign and implement two Verilog modules:\n\n1.  A module named `full_adder` that performs a 1-bit binary addition of three inputs (two data bits and a carry-in) and produces a sum bit and a carry-out bit.\n    *   Module name: `full_adder`\n    *   Inputs: `input a`, `input b`, `input cin`\n    *   Outputs: `output s`, `output cout`\n\n2.  A module named `adder_4bit` that performs a 4-bit binary addition of two 4-bit inputs and a carry-in, producing a 4-bit sum and a carry-out. This module should be structured using instances of your `full_adder` module.\n    *   Module name: `adder_4bit`\n    *   Inputs: `input [3:0] A`, `input [3:0] B`, `input Cin`\n    *   Outputs: `output [3:0] S`, `output Cout`\n\nProvide the Verilog code for both modules.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule adder_4bit(\n\tinput [3:0] A,\n\tinput [3:0] B,\n\tinput Cin,\n\toutput [3:0] S,\n\toutput Cout\n\t);\n\nwire c1, c2, c3;\n\nfull_adder fa1(A[0], B[0], Cin, S[0], c1);\nfull_adder fa2(A[1], B[1], c1, S[1], c2);\nfull_adder fa3(A[2], B[2], c2, S[2], c3);\nfull_adder fa4(A[3], B[3], c3, S[3], Cout);\n\nendmodule\n\nmodule full_adder(\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput s,\n\toutput cout\n\t);\n\nassign s = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\nCODE END"}, "clean_code": "module adder_4bit(\n\tinput [3:0] A,\n\tinput [3:0] B,\n\tinput Cin,\n\toutput [3:0] S,\n\toutput Cout\n\t);\n\nwire c1, c2, c3;\n\nfull_adder fa1(A[0], B[0], Cin, S[0], c1);\nfull_adder fa2(A[1], B[1], c1, S[1], c2);\nfull_adder fa3(A[2], B[2], c2, S[2], c3);\nfull_adder fa4(A[3], B[3], c3, S[3], Cout);\n\nendmodule\n\nmodule full_adder(\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput s,\n\toutput cout\n\t);\n\nassign s = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "corrupted_code": "module adder_4bit(\n\tinput [3:0] A,\n\tinput [3:0] B,\n\tinput Cin,\n\toutput [3:0] S,\n\toutput Cout\n\t);\n\nwire c1, c2, c3;\n\nfull_adder fa1(A[0], B[0], Cin, S[0], c1);\nfull_adder fa2(A[1], B[1], c1, S[1], c2);\nfull_adder fa3(A[2], B[2], c2, S[2], c3);\nfull_adder fa4(A[3], B[3], c3, S[3], Cout);\n\nendmodule\n\nmodule full_adder(\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput s,\n\toutput cout\n\t);\n\nassign s = a ^ b ^ cin;\nassign cout = (a | b) | (cin & (a ^ b));\n\nendmodule", "corruption_explanation": "Changed operator from '&' to '|'", "modification_type": "change_operator", "modification_line": 27, "original_snippet": "&", "modified_snippet": "|", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '&' to '|'\n   \u2022 Line 27: Original: &\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 27.\n   \u2022 Restore the original code: &\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 3, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "timestamp": "2025-12-25T16:41:52.110971", "corruption_index": 0}
{"original_entry": {"instruction": "\nDesign and implement two Verilog modules:\n\n1.  A module named `full_adder` that performs a 1-bit binary addition of three inputs (two data bits and a carry-in) and produces a sum bit and a carry-out bit.\n    *   Module name: `full_adder`\n    *   Inputs: `input a`, `input b`, `input cin`\n    *   Outputs: `output s`, `output cout`\n\n2.  A module named `adder_4bit` that performs a 4-bit binary addition of two 4-bit inputs and a carry-in, producing a 4-bit sum and a carry-out. This module should be structured using instances of your `full_adder` module.\n    *   Module name: `adder_4bit`\n    *   Inputs: `input [3:0] A`, `input [3:0] B`, `input Cin`\n    *   Outputs: `output [3:0] S`, `output Cout`\n\nProvide the Verilog code for both modules.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule adder_4bit(\n\tinput [3:0] A,\n\tinput [3:0] B,\n\tinput Cin,\n\toutput [3:0] S,\n\toutput Cout\n\t);\n\nwire c1, c2, c3;\n\nfull_adder fa1(A[0], B[0], Cin, S[0], c1);\nfull_adder fa2(A[1], B[1], c1, S[1], c2);\nfull_adder fa3(A[2], B[2], c2, S[2], c3);\nfull_adder fa4(A[3], B[3], c3, S[3], Cout);\n\nendmodule\n\nmodule full_adder(\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput s,\n\toutput cout\n\t);\n\nassign s = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\nCODE END"}, "clean_code": "module adder_4bit(\n\tinput [3:0] A,\n\tinput [3:0] B,\n\tinput Cin,\n\toutput [3:0] S,\n\toutput Cout\n\t);\n\nwire c1, c2, c3;\n\nfull_adder fa1(A[0], B[0], Cin, S[0], c1);\nfull_adder fa2(A[1], B[1], c1, S[1], c2);\nfull_adder fa3(A[2], B[2], c2, S[2], c3);\nfull_adder fa4(A[3], B[3], c3, S[3], Cout);\n\nendmodule\n\nmodule full_adder(\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput s,\n\toutput cout\n\t);\n\nassign s = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "corrupted_code": "module adder_4bit(\n\tinput [3:0] A,\n\tinput [3:0] B,\n\tinput Cin,\n\toutput [3:0] S,\n\toutput Cout\n\t);\n\nwire c1, c2, c3;\n\nfull_adder fa1(A[0], B[0], Cin, S[0], c1);\nfull_adder fa2(A[1], B[1], c1, S[1], c2);\nfull_adder fa3(A[2], B[2], c2, S[2], c3);\nfull_adder fa4(A[3], B[3], c3, S[3], Cout);\n\nendmodule\n\nmodule full_adder(\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput s,\n\toutput cout\n\t);\n\nassign s = a ^ b ^ cin;\nassign s = 1'b0;  // Conflicting assignment\nassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "corruption_explanation": "Added conflicting driver for signal 's'", "modification_type": "add_multiple_driver", "modification_line": 25, "original_snippet": "assign s = a ^ b ^ cin;", "modified_snippet": "assign s = a ^ b ^ cin;\nassign s = 1'b0;  // Conflicting assignment", "issue_description": "The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_multiple_driver modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added conflicting driver for signal 's'\n   \u2022 Line 25: Original: assign s = a ^ b ^ cin;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 25.\n   \u2022 Restore the original code: assign s = a ^ b ^ cin;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add multiple driver.", "complexity": 3, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["add_multiple_driver"], "verified_different": true, "timestamp": "2025-12-25T16:41:52.111861", "corruption_index": 1}
{"original_entry": {"instruction": "\nWrite a Verilog module named `bitwise_or_twos_complement`. The module should implement combinational logic based on the following interface and behavior:\n\nModule Name: `bitwise_or_twos_complement`\n\nInterface:\n- Input: `input [3:0] a`\n- Input: `input [3:0] b`\n- Output: `output reg [3:0] out`\n\nFunctionality:\nThe module should perform the bitwise OR operation on inputs `a` and `b`. It should then calculate the two's complement of this bitwise OR result. Additionally, the module should compute the difference between `a` and `b` (`a - b`). The final output `out` should be assigned the value of the two's complement of the bitwise OR result.\n\nEnsure the module name and the input/output port declarations (names, widths, and type for the output) match exactly as specified above.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule bitwise_or_twos_complement (\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] out\n);\n\n// Bitwise OR block\nreg [3:0] or_result;\nalways @* begin\n    or_result = a | b;\nend\n\n// 2's complement block\nreg [3:0] twos_comp_result;\nalways @* begin\n    twos_comp_result = ~or_result + 1;\nend\n\n// Difference block\nreg [3:0] diff;\nalways @* begin\n    diff = a - b;\nend\n\n// Output assignment\nalways @* begin\n    out = twos_comp_result;\nend\n\nendmodule\nCODE END"}, "clean_code": "module bitwise_or_twos_complement (\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] out\n);\n\n// Bitwise OR block\nreg [3:0] or_result;\nalways @* begin\n    or_result = a | b;\nend\n\n// 2's complement block\nreg [3:0] twos_comp_result;\nalways @* begin\n    twos_comp_result = ~or_result + 1;\nend\n\n// Difference block\nreg [3:0] diff;\nalways @* begin\n    diff = a - b;\nend\n\n// Output assignment\nalways @* begin\n    out = twos_comp_result;\nend\n\nendmodule", "corrupted_code": "module bitwise_or_twos_complement (\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] out\n);\n\n// Bitwise OR block\nreg [3:0] or_result;\nalways @* begin\n    or_result = a | b;\nend\n\n// 2's complement block\nreg [3:0] twos_comp_result;\nalways @* begin\n    twos_comp_result = ~or_result + 2;\nend\n\n// Difference block\nreg [3:0] diff;\nalways @* begin\n    diff = a - b;\nend\n\n// Output assignment\nalways @* begin\n    out = twos_comp_result;\nend\n\nendmodule", "corruption_explanation": "Changed constant from 1 to 2", "modification_type": "change_constant", "modification_line": 16, "original_snippet": "1", "modified_snippet": "2", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 1 to 2\n   \u2022 Line 16: Original: 1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 16.\n   \u2022 Restore the original code: 1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 7, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["change_constant"], "verified_different": true, "timestamp": "2025-12-25T16:41:52.112908", "corruption_index": 0}
{"original_entry": {"instruction": "\nWrite a Verilog module named `bitwise_or_twos_complement`. The module should implement combinational logic based on the following interface and behavior:\n\nModule Name: `bitwise_or_twos_complement`\n\nInterface:\n- Input: `input [3:0] a`\n- Input: `input [3:0] b`\n- Output: `output reg [3:0] out`\n\nFunctionality:\nThe module should perform the bitwise OR operation on inputs `a` and `b`. It should then calculate the two's complement of this bitwise OR result. Additionally, the module should compute the difference between `a` and `b` (`a - b`). The final output `out` should be assigned the value of the two's complement of the bitwise OR result.\n\nEnsure the module name and the input/output port declarations (names, widths, and type for the output) match exactly as specified above.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule bitwise_or_twos_complement (\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] out\n);\n\n// Bitwise OR block\nreg [3:0] or_result;\nalways @* begin\n    or_result = a | b;\nend\n\n// 2's complement block\nreg [3:0] twos_comp_result;\nalways @* begin\n    twos_comp_result = ~or_result + 1;\nend\n\n// Difference block\nreg [3:0] diff;\nalways @* begin\n    diff = a - b;\nend\n\n// Output assignment\nalways @* begin\n    out = twos_comp_result;\nend\n\nendmodule\nCODE END"}, "clean_code": "module bitwise_or_twos_complement (\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] out\n);\n\n// Bitwise OR block\nreg [3:0] or_result;\nalways @* begin\n    or_result = a | b;\nend\n\n// 2's complement block\nreg [3:0] twos_comp_result;\nalways @* begin\n    twos_comp_result = ~or_result + 1;\nend\n\n// Difference block\nreg [3:0] diff;\nalways @* begin\n    diff = a - b;\nend\n\n// Output assignment\nalways @* begin\n    out = twos_comp_result;\nend\n\nendmodule", "corrupted_code": "module bitwise_or_twos_complement (\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] out\n);\n\n// Bitwise OR block\nreg [3:0] or_result;\nalways @* begin\n    or_result = a | b;\nend\n\n// 2's complement block\nreg [3:0] twos_comp_result;\nalways @* begin\n\nend\n\n// Difference block\nreg [3:0] diff;\nalways @* begin\n    diff = a - b;\nend\n\n// Output assignment\nalways @* begin\n    out = twos_comp_result;\nend\n\nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 16, "original_snippet": "twos_comp_result = ~or_result + 1;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 16: Original: twos_comp_result = ~or_result + 1;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 16.\n   \u2022 Restore the original code: twos_comp_result = ~or_result + 1;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 7, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["remove_assignment"], "verified_different": true, "timestamp": "2025-12-25T16:41:52.113933", "corruption_index": 1}
{"original_entry": {"instruction": "\nDesign a Verilog module named `addfxp` that implements a synchronous fixed-point adder with configurable latency. The module should have the following interface:\n\nInputs:\n*   `input signed [width-1:0] a`\n*   `input signed [width-1:0] b`\n*   `input clk`\n\nOutput:\n*   `output signed [width-1:0] q`\n\nParameters:\n*   `parameter width = 16` (Data width)\n*   `parameter cycles = 1` (Latency in clock cycles)\n\nThe module should compute the sum `a + b` and output the result `q` exactly `cycles` clock cycles after the inputs `a` and `b` are sampled on a positive edge of `clk`. The inputs and output are signed fixed-point numbers of size `width`.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule addfxp(a, b, q, clk);\n\n   parameter width = 16, cycles=1;\n   \n   input signed [width-1:0]  a, b;\n   input                     clk;   \n   output signed [width-1:0] q;\n   reg signed [width-1:0]    res[cycles-1:0];\n\n   assign                    q = res[cycles-1];\n   \n   integer                   i;   \n   \n   always @(posedge clk) begin\n     res[0] <= a+b;\n      for (i=1; i < cycles; i = i+1)\n        res[i] <= res[i-1];\n      \n   end\n   \nendmodule\nCODE END"}, "clean_code": "module addfxp(a, b, q, clk);\n\n   parameter width = 16, cycles=1;\n   \n   input signed [width-1:0]  a, b;\n   input                     clk;   \n   output signed [width-1:0] q;\n   reg signed [width-1:0]    res[cycles-1:0];\n\n   assign                    q = res[cycles-1];\n   \n   integer                   i;   \n   \n   always @(posedge clk) begin\n     res[0] <= a+b;\n      for (i=1; i < cycles; i = i+1)\n        res[i] <= res[i-1];\n      \n   end\n   \nendmodule", "corrupted_code": "module addfxp(a, b, q, clk);\n\n   parameter width = 16, cycles=1;\n   \n   input signed [width-1:0]  a, b;\n   input                     clk;   \n   output signed [width-1:0] q;\n   reg signed [width-1:0]    res[cycles-1:0];\n\n   assign                    q = res[cycles-1];\n   \n   integer                   i;   \n   \n   always @(posedge clk) begin\n     res[0] = a+b;\n      for (i=1; i < cycles; i = i+1)\n        res[i] <= res[i-1];\n      \n   end\n   \nendmodule", "corruption_explanation": "Changed non-blocking (<=) to blocking (=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 15, "original_snippet": "res[0] <= a+b;", "modified_snippet": "res[0] = a+b;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 10, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "timestamp": "2025-12-25T16:41:52.114979", "corruption_index": 0}
{"original_entry": {"instruction": "\nDesign a Verilog module named `addfxp` that implements a synchronous fixed-point adder with configurable latency. The module should have the following interface:\n\nInputs:\n*   `input signed [width-1:0] a`\n*   `input signed [width-1:0] b`\n*   `input clk`\n\nOutput:\n*   `output signed [width-1:0] q`\n\nParameters:\n*   `parameter width = 16` (Data width)\n*   `parameter cycles = 1` (Latency in clock cycles)\n\nThe module should compute the sum `a + b` and output the result `q` exactly `cycles` clock cycles after the inputs `a` and `b` are sampled on a positive edge of `clk`. The inputs and output are signed fixed-point numbers of size `width`.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule addfxp(a, b, q, clk);\n\n   parameter width = 16, cycles=1;\n   \n   input signed [width-1:0]  a, b;\n   input                     clk;   \n   output signed [width-1:0] q;\n   reg signed [width-1:0]    res[cycles-1:0];\n\n   assign                    q = res[cycles-1];\n   \n   integer                   i;   \n   \n   always @(posedge clk) begin\n     res[0] <= a+b;\n      for (i=1; i < cycles; i = i+1)\n        res[i] <= res[i-1];\n      \n   end\n   \nendmodule\nCODE END"}, "clean_code": "module addfxp(a, b, q, clk);\n\n   parameter width = 16, cycles=1;\n   \n   input signed [width-1:0]  a, b;\n   input                     clk;   \n   output signed [width-1:0] q;\n   reg signed [width-1:0]    res[cycles-1:0];\n\n   assign                    q = res[cycles-1];\n   \n   integer                   i;   \n   \n   always @(posedge clk) begin\n     res[0] <= a+b;\n      for (i=1; i < cycles; i = i+1)\n        res[i] <= res[i-1];\n      \n   end\n   \nendmodule", "corrupted_code": "module addfxp(a, b, q, clk);\n\n   parameter width = 16, cycles=1;\n   \n   input signed [width-1:0]  a, b;\n   input                     clk;   \n   output signed [width-1:0] q;\n   reg signed [width-1:0]    res[cycles-1:0];\n\n   assign                    q = res[cycles-1];\n   \n   integer                   i;   \n   \n   always @(clk) begin\n     res[0] <= a+b;\n      for (i=1; i < cycles; i = i+1)\n        res[i] <= res[i-1];\n      \n   end\n   \nendmodule", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 14, "original_snippet": "always @(posedge clk)", "modified_snippet": "always @(clk)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 14: Original: always @(posedge clk)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 14.\n   \u2022 Restore the original code: always @(posedge clk)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 10, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_sensitivity_list"], "verified_different": true, "timestamp": "2025-12-25T16:41:52.115841", "corruption_index": 1}
