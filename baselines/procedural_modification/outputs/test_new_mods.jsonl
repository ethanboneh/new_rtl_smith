{"original_entry": {"instruction": "\nDesign and implement two Verilog modules:\n\n1.  A module named `full_adder` that performs a 1-bit binary addition of three inputs (two data bits and a carry-in) and produces a sum bit and a carry-out bit.\n    *   Module name: `full_adder`\n    *   Inputs: `input a`, `input b`, `input cin`\n    *   Outputs: `output s`, `output cout`\n\n2.  A module named `adder_4bit` that performs a 4-bit binary addition of two 4-bit inputs and a carry-in, producing a 4-bit sum and a carry-out. This module should be structured using instances of your `full_adder` module.\n    *   Module name: `adder_4bit`\n    *   Inputs: `input [3:0] A`, `input [3:0] B`, `input Cin`\n    *   Outputs: `output [3:0] S`, `output Cout`\n\nProvide the Verilog code for both modules.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule adder_4bit(\n\tinput [3:0] A,\n\tinput [3:0] B,\n\tinput Cin,\n\toutput [3:0] S,\n\toutput Cout\n\t);\n\nwire c1, c2, c3;\n\nfull_adder fa1(A[0], B[0], Cin, S[0], c1);\nfull_adder fa2(A[1], B[1], c1, S[1], c2);\nfull_adder fa3(A[2], B[2], c2, S[2], c3);\nfull_adder fa4(A[3], B[3], c3, S[3], Cout);\n\nendmodule\n\nmodule full_adder(\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput s,\n\toutput cout\n\t);\n\nassign s = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\nCODE END"}, "clean_code": "module adder_4bit(\n\tinput [3:0] A,\n\tinput [3:0] B,\n\tinput Cin,\n\toutput [3:0] S,\n\toutput Cout\n\t);\n\nwire c1, c2, c3;\n\nfull_adder fa1(A[0], B[0], Cin, S[0], c1);\nfull_adder fa2(A[1], B[1], c1, S[1], c2);\nfull_adder fa3(A[2], B[2], c2, S[2], c3);\nfull_adder fa4(A[3], B[3], c3, S[3], Cout);\n\nendmodule\n\nmodule full_adder(\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput s,\n\toutput cout\n\t);\n\nassign s = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "corrupted_code": "module adder_4bit(\n\tinput [3:0] A,\n\tinput [3:0] B,\n\tinput Cin,\n\toutput [3:0] S,\n\toutput Cout\n\t);\n\nwire c1, c2, c3;\n\nfull_adder fa1(A[0], B[0], Cin, S[0], c1);\nfull_adder fa2(A[1], B[1], c1, S[1], c2);\nfull_adder fa3(A[2], B[2], c2, S[2], c3);\nfull_adder fa4(A[3], B[3], c3, S[3], Cout);\n\nendmodule\n\nmodule full_adder(\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput s,\n\toutput cout\n\t);\n\nassign s = a ^ b ^ cin;\nassign cout = (a | b) | (cin & (a ^ b));\n\nendmodule", "corruption_explanation": "Changed operator from '&' to '|'", "modification_type": "change_operator", "modification_line": 27, "original_snippet": "&", "modified_snippet": "|", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '&' to '|'\n   \u2022 Line 27: Original: &\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 27.\n   \u2022 Restore the original code: &\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 3, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "timestamp": "2025-12-09T21:37:03.081493"}
{"original_entry": {"instruction": "\nDesign a Verilog module named `addfxp` that implements a synchronous fixed-point adder with configurable latency. The module should have the following interface:\n\nInputs:\n*   `input signed [width-1:0] a`\n*   `input signed [width-1:0] b`\n*   `input clk`\n\nOutput:\n*   `output signed [width-1:0] q`\n\nParameters:\n*   `parameter width = 16` (Data width)\n*   `parameter cycles = 1` (Latency in clock cycles)\n\nThe module should compute the sum `a + b` and output the result `q` exactly `cycles` clock cycles after the inputs `a` and `b` are sampled on a positive edge of `clk`. The inputs and output are signed fixed-point numbers of size `width`.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule addfxp(a, b, q, clk);\n\n   parameter width = 16, cycles=1;\n   \n   input signed [width-1:0]  a, b;\n   input                     clk;   \n   output signed [width-1:0] q;\n   reg signed [width-1:0]    res[cycles-1:0];\n\n   assign                    q = res[cycles-1];\n   \n   integer                   i;   \n   \n   always @(posedge clk) begin\n     res[0] <= a+b;\n      for (i=1; i < cycles; i = i+1)\n        res[i] <= res[i-1];\n      \n   end\n   \nendmodule\nCODE END"}, "clean_code": "module addfxp(a, b, q, clk);\n\n   parameter width = 16, cycles=1;\n   \n   input signed [width-1:0]  a, b;\n   input                     clk;   \n   output signed [width-1:0] q;\n   reg signed [width-1:0]    res[cycles-1:0];\n\n   assign                    q = res[cycles-1];\n   \n   integer                   i;   \n   \n   always @(posedge clk) begin\n     res[0] <= a+b;\n      for (i=1; i < cycles; i = i+1)\n        res[i] <= res[i-1];\n      \n   end\n   \nendmodule", "corrupted_code": "module addfxp(a, b, q, clk);\n\n   parameter width = 17, cycles=1;\n   \n   input signed [width-1:0]  a, b;\n   input                     clk;   \n   output signed [width-1:0] q;\n   reg signed [width-1:0]    res[cycles-1:0];\n\n   assign                    q = res[cycles-1];\n   \n   integer                   i;   \n   \n   always @(posedge clk) begin\n     res[0] <= a+b;\n      for (i=1; i < cycles; i = i+1)\n        res[i] <= res[i-1];\n      \n   end\n   \nendmodule", "corruption_explanation": "Changed constant from 16 to 17", "modification_type": "change_constant", "modification_line": 3, "original_snippet": "16", "modified_snippet": "17", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 16 to 17\n   \u2022 Line 3: Original: 16\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 3.\n   \u2022 Restore the original code: 16\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 10, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:37:03.083865"}
{"original_entry": {"instruction": "\nDesign two Verilog modules:\n\n1.  A single-bit full adder module named `full_adder`. It should have inputs `A`, `B`, and `Cin` (all single bits) and outputs `S` (sum) and `Cout` (carry-out) (both single bits).\n2.  A 4-bit ripple-carry adder module named `adder`. This module should utilize the `full_adder` module. It should have 4-bit inputs `A` and `B`, a single-bit input `Cin`, a 4-bit output `S` (sum), and a single-bit output `Cout` (final carry-out).\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule adder(A, B, Cin, S, Cout);\n    input [3:0] A, B;\n    input Cin;\n    output [3:0] S;\n    output Cout;\n\n    wire c1, c2, c3;\n\n    full_adder fa0(A[0], B[0], Cin, S[0], c1);\n    full_adder fa1(A[1], B[1], c1, S[1], c2);\n    full_adder fa2(A[2], B[2], c2, S[2], c3);\n    full_adder fa3(A[3], B[3], c3, S[3], Cout);\n\nendmodule\nmodule full_adder(A, B, Cin, S, Cout);\n    input A, B, Cin;\n    output S, Cout;\n    assign {Cout, S} = A + B + Cin;\nendmodule\nCODE END"}, "clean_code": "module adder(A, B, Cin, S, Cout);\n    input [3:0] A, B;\n    input Cin;\n    output [3:0] S;\n    output Cout;\n\n    wire c1, c2, c3;\n\n    full_adder fa0(A[0], B[0], Cin, S[0], c1);\n    full_adder fa1(A[1], B[1], c1, S[1], c2);\n    full_adder fa2(A[2], B[2], c2, S[2], c3);\n    full_adder fa3(A[3], B[3], c3, S[3], Cout);\n\nendmodule\nmodule full_adder(A, B, Cin, S, Cout);\n    input A, B, Cin;\n    output S, Cout;\n    assign {Cout, S} = A + B + Cin;\nendmodule", "corrupted_code": "module adder(A, B, Cin, S, Cout);\n    input [3:1] A, B;\n    input Cin;\n    output [3:0] S;\n    output Cout;\n\n    wire c1, c2, c3;\n\n    full_adder fa0(A[0], B[0], Cin, S[0], c1);\n    full_adder fa1(A[1], B[1], c1, S[1], c2);\n    full_adder fa2(A[2], B[2], c2, S[2], c3);\n    full_adder fa3(A[3], B[3], c3, S[3], Cout);\n\nendmodule\nmodule full_adder(A, B, Cin, S, Cout);\n    input A, B, Cin;\n    output S, Cout;\n    assign {Cout, S} = A + B + Cin;\nendmodule", "corruption_explanation": "Changed bit width from [3:0] to [3:1]", "modification_type": "change_bit_width", "modification_line": 2, "original_snippet": "[3:0]", "modified_snippet": "[3:1]", "issue_description": "The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_bit_width modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed bit width from [3:0] to [3:1]\n   \u2022 Line 2: Original: [3:0]\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 2.\n   \u2022 Restore the original code: [3:0]\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change bit width.", "complexity": 1, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "swap_port_signals"], "timestamp": "2025-12-09T21:37:03.085747"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `binary_counter`.\nThis module should implement a synchronous binary counter with an asynchronous reset.\nIt should include a parameter named `MAX_COUNT` with a default value of 15, which determines the maximum value the counter reaches before wrapping around.\n\nThe module interface should be defined as follows:\n-   Input `clk`: The clock signal.\n-   Input `reset`: The asynchronous reset signal (active high).\n-   Output `count`: A 4-bit register (`reg [3:0]`) holding the current count value.\n-   Output `overflow`: A register (`reg`) indicating when the counter has just wrapped around.\n\nThe behavior of the module should be:\n-   When the `reset` input is high, the `count` output should immediately reset to 0, and the `overflow` output should be cleared to 0.\n-   On the positive edge of the `clk` signal, when `reset` is low:\n    -   If the current value of `count` is equal to the `MAX_COUNT` parameter, the `count` should wrap around to 0 on the next clock cycle, and the `overflow` output should be set high for one clock cycle.\n    -   Otherwise (if the current value of `count` is less than `MAX_COUNT`), the `count` should increment by 1, and the `overflow` output should be cleared to 0.\n\nUse non-blocking assignments (`<=`) for all sequential logic updates.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule binary_counter\n#(parameter MAX_COUNT=15)\n(\n  input clk,\n  input reset,\n  output reg [3:0]count,  // 4 bits for 16 counts\n  output reg overflow\n);\n\n  always @(posedge clk or posedge reset)\n  begin\n    if (reset)\n    begin\n      count <= 0;\n      overflow <= 0;\n    end\n    else if (count == MAX_COUNT)\n    begin\n      count <= 0;\n      overflow <= 1;\n    end\n    else\n    begin\n      count <= count + 1;\n      overflow <= 0;\n    end\n  end\n\nendmodule\nCODE END"}, "clean_code": "module binary_counter\n#(parameter MAX_COUNT=15)\n(\n  input clk,\n  input reset,\n  output reg [3:0]count,  // 4 bits for 16 counts\n  output reg overflow\n);\n\n  always @(posedge clk or posedge reset)\n  begin\n    if (reset)\n    begin\n      count <= 0;\n      overflow <= 0;\n    end\n    else if (count == MAX_COUNT)\n    begin\n      count <= 0;\n      overflow <= 1;\n    end\n    else\n    begin\n      count <= count + 1;\n      overflow <= 0;\n    end\n  end\n\nendmodule", "corrupted_code": "module binary_counter\n#(parameter MAX_COUNT=15)\n(\n  input clk,\n  input reset,\n  output reg [3:0]count,  // 4 bits for 16 counts\n  output reg overflow\n);\n\n  always @(posedge clk or posedge reset)\n  begin\n    if (reset)\n    begin\n      count <= 0;\n\n    end\n    else if (count == MAX_COUNT)\n    begin\n      count <= 0;\n      overflow <= 1;\n    end\n    else\n    begin\n      count <= count + 1;\n      overflow <= 0;\n    end\n  end\n\nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 15, "original_snippet": "overflow <= 0;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 15: Original: overflow <= 0;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 15.\n   \u2022 Restore the original code: overflow <= 0;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 11, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:37:03.088790"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `ram_RAMB18E1` with the following interface and behavior.\n\n**Interface:**\n*   **Parameters:**\n    *   `LOC`: string type, default value \"RAMB18_X0Y0\"\n    *   `WRITE_MODE_A`: string type, default value \"WRITE_FIRST\"\n*   **Inputs:**\n    *   `clk`: 1-bit wire\n    *   `din`: 8-bit wire\n*   **Outputs:**\n    *   `dout`: 8-bit wire\n\n**Behavior:**\nThe module should contain an internal 8-bit state register (or equivalent storage) which is initialized to all zeros. On the positive edge of the `clk` signal, if the parameter `WRITE_MODE_A` has the string value 'WRITE_FIRST', this internal 8-bit state is updated. The update involves effectively shifting the current 8-bit state one position to the right. The most significant bit (bit 7) of the state is loaded with the value of the least significant bit of the `din` input (`din[0]`). The bit previously in the least significant position (bit 0) is discarded. The output `dout` should continuously reflect the current value of this internal 8-bit state.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule ram_RAMB18E1 #(parameter LOC = \"RAMB18_X0Y0\", parameter WRITE_MODE_A = \"WRITE_FIRST\")\n(\n    input wire clk,\n    input wire [7:0] din,\n    output wire [7:0] dout\n);\n\nreg [7:0] mem [0:31];\n\ninteger i;\n\ninitial begin\n    for (i = 0; i < 32; i = i + 1) begin\n        mem[i] = 8'h00;\n    end\nend\n\nalways @(posedge clk) begin\n    if (WRITE_MODE_A == \"WRITE_FIRST\") begin\n        mem[0] <= {din, mem[0][7:1]};\n    end\nend\n\nassign dout = mem[0];\n\nendmodule\nCODE END"}, "clean_code": "module ram_RAMB18E1 #(parameter LOC = \"RAMB18_X0Y0\", parameter WRITE_MODE_A = \"WRITE_FIRST\")\n(\n    input wire clk,\n    input wire [7:0] din,\n    output wire [7:0] dout\n);\n\nreg [7:0] mem [0:31];\n\ninteger i;\n\ninitial begin\n    for (i = 0; i < 32; i = i + 1) begin\n        mem[i] = 8'h00;\n    end\nend\n\nalways @(posedge clk) begin\n    if (WRITE_MODE_A == \"WRITE_FIRST\") begin\n        mem[0] <= {din, mem[0][7:1]};\n    end\nend\n\nassign dout = mem[0];\n\nendmodule", "corrupted_code": "module ram_RAMB18E1 #(parameter LOC = \"RAMB18_X0Y0\", parameter WRITE_MODE_A = \"WRITE_FIRST\")\n(\n    input wire clk,\n    input wire [7:0] din,\n    output wire [7:0] dout\n);\n\nreg [7:0] mem [0:31];\n\ninteger i;\n\ninitial begin\n    for (i = 0; i < 32; i = i + 1) begin\n        mem[i] = 8'h00;\n    end\nend\n\nalways @(posedge clk) begin\n    if (!(WRITE_MODE_A == \"WRITE_FIRST\")) begin\n        mem[0] <= {din, mem[0][7:1]};\n    end\nend\n\nassign dout = mem[0];\n\nendmodule", "corruption_explanation": "Inverted condition: 'WRITE_MODE_A == \"WRITE_FIRST\"' -> '!(WRITE_MODE_A == \"WRITE_FIRST\")'", "modification_type": "invert_condition", "modification_line": 19, "original_snippet": "if (WRITE_MODE_A == \"WRITE_FIRST\") begin", "modified_snippet": "if (!(WRITE_MODE_A == \"WRITE_FIRST\")) begin", "issue_description": "The buggy code has an inverted condition in an if statement. Instead of checking if(x), it checks if(!x), causing the logic to execute when it shouldn't and skip execution when it should. All conditional behavior is reversed from intended functionality.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_condition modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted condition: 'WRITE_MODE_A == \"WRITE_FIRST\"' -> '!(WRITE_MODE_A == \"WRITE_FIRST\")'\n   \u2022 Line 19: Original: if (WRITE_MODE_A == \"WRITE_FIRST\") begin\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 19.\n   \u2022 Restore the original code: if (WRITE_MODE_A == \"WRITE_FIRST\") begin\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert condition.", "complexity": 5, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:37:03.089887"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `random_num_gen` that generates an 8-bit pseudo-random number. The module should have the following interface: inputs `clk` (clock), `rst` (synchronous reset), `start` (enable), and an 8-bit output `rand_num`. The core of the generator is an 8-bit state register. On the positive edge of the clock, if `rst` is asserted, this state register should be cleared. If `rst` is not asserted and `start` is asserted, the state register should update to a new value calculated from its current state using a specific algorithm that shifts the state and incorporates feedback. The 8-bit output `rand_num` should continuously reflect the current value of this state register.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule random_num_gen (\n  input clk,\n  input rst,\n  input start,\n  output reg [7:0] rand_num\n);\n\nparameter n = 8; // width of the random number\n\nreg [7:0] lfsr_reg;\nreg feedback;\n\nalways @ (posedge clk) begin\n  if (rst) begin\n    lfsr_reg <= 8'b0;\n  end\n  else if (start) begin\n    feedback = lfsr_reg[0] ^ lfsr_reg[1] ^ lfsr_reg[3] ^ lfsr_reg[4];\n    lfsr_reg <= {lfsr_reg[6:0], feedback};\n  end\nend\n\nalways @* begin\n  rand_num = lfsr_reg;\nend\n\nendmodule\nCODE END"}, "clean_code": "module random_num_gen (\n  input clk,\n  input rst,\n  input start,\n  output reg [7:0] rand_num\n);\n\nparameter n = 8; // width of the random number\n\nreg [7:0] lfsr_reg;\nreg feedback;\n\nalways @ (posedge clk) begin\n  if (rst) begin\n    lfsr_reg <= 8'b0;\n  end\n  else if (start) begin\n    feedback = lfsr_reg[0] ^ lfsr_reg[1] ^ lfsr_reg[3] ^ lfsr_reg[4];\n    lfsr_reg <= {lfsr_reg[6:0], feedback};\n  end\nend\n\nalways @* begin\n  rand_num = lfsr_reg;\nend\n\nendmodule", "corrupted_code": "module random_num_gen (\n  input clk,\n  input rst,\n  input start,\n  output reg [7:0] rand_num\n);\n\nparameter n = 8; // width of the random number\n\nreg [7:0] lfsr_reg;\nreg feedback;\n\nalways @ (posedge clk) begin\n  if (rst) begin\n    lfsr_reg <= 8'b0;\n  end\n  else if (start) begin\n    feedback = lfsr_reg[0] ^ lfsr_reg[1] ^ lfsr_reg[3] ^ lfsr_reg[4];\n    lfsr_reg <= {lfsr_reg[6:0], feedback};\n  end\nend\n\n\n\nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 23, "original_snippet": "always @* begin\n  rand_num = lfsr_reg;\nend", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 23: Original: always @* begin\n  rand_num = lfsr_reg;\nend\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 23.\n   \u2022 Restore the original code: always @* begin\n  rand_num = lfsr_reg;\nend\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 5, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:37:03.091124"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `sync_load_counter` with the following interface:\nInputs:\n*   `clk`: Clock signal.\n*   `reset`: Synchronous reset signal.\n*   `load`: Synchronous load signal.\n*   `L [3:0]`: 4-bit data input for loading.\n*   `areset`: Asynchronous reset signal.\nOutputs:\n*   `count [3:0]`: 4-bit counter output.\n\nImplement a 4-bit up-counter that operates based on the positive edge of the `clk` signal, except for the asynchronous reset. The counter should prioritize operations as follows:\n1.  An active high `areset` signal should immediately (asynchronously) reset the `count` to 4'b0000, overriding all other conditions.\n2.  If `areset` is inactive, an active high `reset` signal should synchronously reset the `count` to 4'b0000 on the next clock edge.\n3.  If both `areset` and `reset` are inactive, an active high `load` signal should synchronously load the value from `L` into `count` on the next clock edge.\n4.  If `areset`, `reset`, and `load` are all inactive, the `count` should increment by 1 on the next clock edge.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule sync_load_counter (\n    input clk,\n    input reset,\n    input load,\n    input [3:0] L,\n    input areset,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            count <= 4'b0000;\n        end else if (reset) begin\n            count <= 4'b0000;\n        end else if (load) begin\n            count <= L;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\nCODE END"}, "clean_code": "module sync_load_counter (\n    input clk,\n    input reset,\n    input load,\n    input [3:0] L,\n    input areset,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            count <= 4'b0000;\n        end else if (reset) begin\n            count <= 4'b0000;\n        end else if (load) begin\n            count <= L;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule", "corrupted_code": "module sync_load_counter (\n    input clk,\n    input reset,\n    input load,\n    input [3:0] L,\n    input areset,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            count <= 4'b0000;\n        end else if (reset) begin\n\n        end else if (load) begin\n            count <= L;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 14, "original_snippet": "count <= 4'b0000;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 14: Original: count <= 4'b0000;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 14.\n   \u2022 Restore the original code: count <= 4'b0000;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 9, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:37:03.092026"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `synchronous_counter`. This module should implement a 4-bit binary-coded decimal (BCD) counter.\n\nThe module should have the following interface:\nInputs:\n- `clk`: Clock signal.\n- `reset`: Asynchronous reset signal.\n- `enable`: Counter enable signal.\n\nOutput:\n- `count_out`: A 4-bit register holding the current count value.\n\nThe counter should behave as follows:\n- When the `reset` signal is high, the counter should asynchronously reset its output `count_out` to 4'b0000.\n- On the positive edge of the `clk` signal, if `reset` is low and `enable` is high, the counter should increment its value.\n- The counter should count from 0 (4'b0000) up to 9 (4'b1001).\n- After reaching the value 9 (4'b1001) and being enabled on the next clock edge, the counter should wrap around and reset its value to 0 (4'b0000).\n- If `reset` is low and `enable` is low on the positive edge of `clk`, the counter should hold its current value.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule synchronous_counter(\n    input clk,\n    input reset,\n    input enable,\n    output reg [3:0] count_out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_out <= 4'b0000;\n        end else if (enable) begin\n            if (count_out == 4'b1001) begin\n                count_out <= 4'b0000;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\n\nendmodule\nCODE END"}, "clean_code": "module synchronous_counter(\n    input clk,\n    input reset,\n    input enable,\n    output reg [3:0] count_out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_out <= 4'b0000;\n        end else if (enable) begin\n            if (count_out == 4'b1001) begin\n                count_out <= 4'b0000;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\n\nendmodule", "corrupted_code": "module synchronous_counter(\n    input clk,\n    input reset,\n    input enable,\n    output reg [3:0] count_out\n);\n\n    always @(posedge clk or posedge reset) begin\n        \n        end\n    end\n\nendmodule", "corruption_explanation": "Removed a conditional block", "modification_type": "remove_conditional", "modification_line": 9, "original_snippet": "if (reset) begin\n            count_out <= 4'b0000;\n        end else if (enable) begin\n            if (count_out == 4'b1001) begin\n                count_out <= 4'b0000;\n            end else begin\n     ", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing a conditional block. This removes important control logic, causing the design to skip necessary state transitions or data processing. Test cases that depend on the conditional behavior will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_conditional modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed a conditional block\n   \u2022 Line 9: Original: if (reset) begin\n            count_out <= 4'b0000;\n        end else if (enable) begin\n            if (count_out == 4'b1001) begin\n                count_out <= 4'b0000;\n            end else begin\n     \n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 9.\n   \u2022 Restore the original code: if (reset) begin\n            count_out <= 4'b0000;\n        end else if (enable) begin\n            if (count_out == 4'b1001) begin\n                count_out <= 4'b0000;\n            end else begin\n     \n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove conditional.", "complexity": 9, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:37:03.093006"}
{"original_entry": {"instruction": "\nWrite a Verilog module that implements a simple logic function with a control signal.\nThe module must be named `my_module` and have the following interface:\nInputs: `A1`, `A2`, `A3`, `A4`, `B1`\nOutput: `X`\n\nThe module's behavior should be such that the output `X` is the result of one of two operations, selected by the input `B1`. Specifically:\n- If `B1` is true (logic 1), `X` should be the logical conjunction (AND) of inputs `A1` and `A2`.\n- If `B1` is false (logic 0), `X` should be the logical disjunction (OR) of inputs `A3` and `A4`.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule my_module (\n    input  A1,\n    input  A2,\n    input  A3,\n    input  A4,\n    input  B1,\n    output X\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // AND gate implementation\n    wire and_out;\n    assign and_out = A1 & A2;\n\n    // OR gate implementation\n    wire or_out;\n    assign or_out = A3 | A4;\n\n    // Output selection based on B1\n    assign X = B1 ? and_out : or_out;\n\nendmodule\nCODE END"}, "clean_code": "module my_module (\n    input  A1,\n    input  A2,\n    input  A3,\n    input  A4,\n    input  B1,\n    output X\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // AND gate implementation\n    wire and_out;\n    assign and_out = A1 & A2;\n\n    // OR gate implementation\n    wire or_out;\n    assign or_out = A3 | A4;\n\n    // Output selection based on B1\n    assign X = B1 ? and_out : or_out;\n\nendmodule", "corrupted_code": "module my_module (\n    input  A1,\n    input  A2,\n    input  A3,\n    input  A4,\n    input  B1,\n    output X\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // AND gate implementation\n    wire and_out;\n    assign and_out = A1 & A2;\n\n    // OR gate implementation\n    wire or_out;\n\n    // Output selection based on B1\n    assign X = B1 ? and_out : or_out;\n\nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 22, "original_snippet": "assign or_out = A3 | A4;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 22: Original: assign or_out = A3 | A4;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 22.\n   \u2022 Restore the original code: assign or_out = A3 | A4;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver"], "timestamp": "2025-12-09T21:37:03.093914"}
{"original_entry": {"instruction": "\nWrite the Verilog code for a 3-to-8 decoder module.\nThe module must be named `decoder_3to8`.\nIt has the following interface:\n-   Inputs: `input A`, `input B`, `input C` (single bits)\n-   Outputs: `output Y0`, `output Y1`, `output Y2`, `output Y3`, `output Y4`, `output Y5`, `output Y6`, `output Y7` (single bits)\n\nImplement the standard active-high decoder functionality where output `Yi` is asserted when the binary input `ABC` (with `A` as the most significant bit) represents the decimal value `i`. Your implementation should be purely combinational.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule decoder_3to8 (\n    input A,\n    input B,\n    input C,\n    output reg Y0,\n    output reg Y1,\n    output reg Y2,\n    output reg Y3,\n    output reg Y4,\n    output reg Y5,\n    output reg Y6,\n    output reg Y7\n);\n\nalways @ (A or B or C) begin\n    Y0 = ~(A | B | C);\n    Y1 = ~(A | B | ~C);\n    Y2 = ~(A | ~B | C);\n    Y3 = ~(A | ~B | ~C);\n    Y4 = ~(~A | B | C);\n    Y5 = ~(~A | B | ~C);\n    Y6 = ~(~A | ~B | C);\n    Y7 = ~(~A | ~B | ~C);\nend\n\nendmodule\nCODE END"}, "clean_code": "module decoder_3to8 (\n    input A,\n    input B,\n    input C,\n    output reg Y0,\n    output reg Y1,\n    output reg Y2,\n    output reg Y3,\n    output reg Y4,\n    output reg Y5,\n    output reg Y6,\n    output reg Y7\n);\n\nalways @ (A or B or C) begin\n    Y0 = ~(A | B | C);\n    Y1 = ~(A | B | ~C);\n    Y2 = ~(A | ~B | C);\n    Y3 = ~(A | ~B | ~C);\n    Y4 = ~(~A | B | C);\n    Y5 = ~(~A | B | ~C);\n    Y6 = ~(~A | ~B | C);\n    Y7 = ~(~A | ~B | ~C);\nend\n\nendmodule", "corrupted_code": "module decoder_3to8 (\n    input A,\n    input B,\n    input C,\n    output reg Y0,\n    output reg Y1,\n    output reg Y2,\n    output reg Y3,\n    output reg Y4,\n    output reg Y5,\n    output reg Y6,\n    output reg Y7\n);\n\nalways @(A or B) begin\n    Y0 = ~(A | B | C);\n    Y1 = ~(A | B | ~C);\n    Y2 = ~(A | ~B | C);\n    Y3 = ~(A | ~B | ~C);\n    Y4 = ~(~A | B | C);\n    Y5 = ~(~A | B | ~C);\n    Y6 = ~(~A | ~B | C);\n    Y7 = ~(~A | ~B | ~C);\nend\n\nendmodule", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 15, "original_snippet": "always @ (A or B or C)", "modified_snippet": "always @(A or B)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 15: Original: always @ (A or B or C)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 15.\n   \u2022 Restore the original code: always @ (A or B or C)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 7, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_always_block"], "timestamp": "2025-12-09T21:37:03.094755"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `accumulator` that implements a synchronous accumulator.\nModule Interface:\nInputs:\n  `clk` (single bit)\n  `reset` (single bit, synchronous reset)\n  `in` (8 bits, `[7:0]`)\nOutputs:\n  `out` (16 bits, `[15:0]`)\n\nBehavior:\nOn the positive edge of `clk`, if `reset` is asserted, the accumulator should be reset to 0. Otherwise, the 8-bit input `in` should be added to the current accumulated value, and the result should be stored as the new accumulated value. The output `out` should always represent the current accumulated value.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule accumulator (\n  input clk,\n  input reset,\n  input [7:0] in,\n  output [15:0] out\n);\n\n  reg [15:0] acc_reg; // register to hold the accumulated sum\n\n  always @(posedge clk) begin\n    if (reset) begin\n      acc_reg <= 16'd0; // clear the register to zero\n    end else begin\n      acc_reg <= acc_reg + in; // add the input signal to the register\n    end\n  end\n\n  assign out = acc_reg; // output the current value of the accumulator register\n\nendmodule\nCODE END"}, "clean_code": "module accumulator (\n  input clk,\n  input reset,\n  input [7:0] in,\n  output [15:0] out\n);\n\n  reg [15:0] acc_reg; // register to hold the accumulated sum\n\n  always @(posedge clk) begin\n    if (reset) begin\n      acc_reg <= 16'd0; // clear the register to zero\n    end else begin\n      acc_reg <= acc_reg + in; // add the input signal to the register\n    end\n  end\n\n  assign out = acc_reg; // output the current value of the accumulator register\n\nendmodule", "corrupted_code": "module accumulator (\n  input clk,\n  input reset,\n  input [7:0] in,\n  output [15:0] out\n);\n\n  reg [15:0] acc_reg; // register to hold the accumulated sum\n\n  always @(posedge clk) begin\n    \n  end\n\n  assign out = acc_reg; // output the current value of the accumulator register\n\nendmodule", "corruption_explanation": "Removed a conditional block", "modification_type": "remove_conditional", "modification_line": 11, "original_snippet": "if (reset) begin\n      acc_reg <= 16'd0; // clear the register to zero\n    end else begin\n      acc_reg <= acc_reg + in; // add the input signal to the register\n    end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing a conditional block. This removes important control logic, causing the design to skip necessary state transitions or data processing. Test cases that depend on the conditional behavior will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_conditional modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed a conditional block\n   \u2022 Line 11: Original: if (reset) begin\n      acc_reg <= 16'd0; // clear the register to zero\n    end else begin\n      acc_reg <= acc_reg + in; // add the input signal to the register\n    end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 11.\n   \u2022 Restore the original code: if (reset) begin\n      acc_reg <= 16'd0; // clear the register to zero\n    end else begin\n      acc_reg <= acc_reg + in; // add the input signal to the register\n    end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove conditional.", "complexity": 5, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:37:03.095662"}
{"original_entry": {"instruction": "\nWrite the Verilog code for a module named `BLOCK2A`. The module has inputs `PIN2`, `GIN1`, `GIN2`, and `PHI`, and an output `GOUT`. All inputs and outputs should have these exact names. The logic for the output `GOUT` should be evaluated and updated only on the positive edge of the `PHI` clock. The behavior of the module is as follows:\n\n*   If the input `GIN2` is high, the output `GOUT` must be forced to a low state (0), overriding any other logic.\n*   If the input `GIN2` is low, the output `GOUT` should reflect the result of an exclusive OR (XOR) operation between the inputs `PIN2` and `GIN1`.\n\nThe output `GOUT` should maintain its value between positive clock edges.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule BLOCK2A ( PIN2, GIN1, GIN2, PHI, GOUT );\ninput  PIN2;\ninput  GIN1;\ninput  GIN2;\ninput  PHI;\noutput GOUT;\n\nreg GOUT_reg;\n\nalways @(posedge PHI) begin\n    if (GIN2 == 1'b1) begin\n        GOUT_reg <= 1'b0;\n    end else begin\n        if ((PIN2 == 1'b0 && GIN1 == 1'b1) || (PIN2 == 1'b1 && GIN1 == 1'b0)) begin\n            GOUT_reg <= 1'b1;\n        end else begin\n            GOUT_reg <= 1'b0;\n        end\n    end\nend\n\nassign GOUT = GOUT_reg;\n\nendmodule\nCODE END"}, "clean_code": "module BLOCK2A ( PIN2, GIN1, GIN2, PHI, GOUT );\ninput  PIN2;\ninput  GIN1;\ninput  GIN2;\ninput  PHI;\noutput GOUT;\n\nreg GOUT_reg;\n\nalways @(posedge PHI) begin\n    if (GIN2 == 1'b1) begin\n        GOUT_reg <= 1'b0;\n    end else begin\n        if ((PIN2 == 1'b0 && GIN1 == 1'b1) || (PIN2 == 1'b1 && GIN1 == 1'b0)) begin\n            GOUT_reg <= 1'b1;\n        end else begin\n            GOUT_reg <= 1'b0;\n        end\n    end\nend\n\nassign GOUT = GOUT_reg;\n\nendmodule", "corrupted_code": "module BLOCK2A ( PIN2, GIN1, GIN2, PHI, GOUT );\ninput  PIN2;\ninput  GIN1;\ninput  GIN2;\ninput  PHI;\noutput GOUT;\n\nreg GOUT_reg;\n\nalways @(posedge PHI) begin\n    if (GIN2 == 1'b1) begin\n        GOUT_reg <= 1'b0;\n    end else begin\n        if ((PIN2 == 1'b0 && GIN1 == 1'b1) || (PIN2 == 1'b1 && GIN1 == 1'b0)) begin\n            GOUT_reg <= 1'b1;\n        end else begin\n            1 <= GOUT_reg'b0;\n        end\n    end\nend\n\nassign GOUT = GOUT_reg;\n\nendmodule", "corruption_explanation": "Swapped operands: 'GOUT_reg <= 1' -> '1 <= GOUT_reg'", "modification_type": "swap_operands", "modification_line": 17, "original_snippet": "GOUT_reg <= 1", "modified_snippet": "1 <= GOUT_reg", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'GOUT_reg <= 1' -> '1 <= GOUT_reg'\n   \u2022 Line 17: Original: GOUT_reg <= 1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 17.\n   \u2022 Restore the original code: GOUT_reg <= 1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 12, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:37:03.096614"}
{"original_entry": {"instruction": "\nDesign a Verilog module named `Span12Mux_v0`.\nThe module should have the following interface:\n-   Input `I`: 12 bits wide (`[11:0]`)\n-   Input `S`: 4 bits wide (`[3:0]`)\n-   Output `O`: 12 bits wide (`[11:0]`)\n\nThe module should implement the following behavior:\n-   The output `O` should be equal to the input `I` if the decimal value represented by the input `S` is between 0 and 11 (inclusive).\n-   If the decimal value of `S` is any other value (i.e., 12, 13, 14, or 15), the output `O` should be 0.\n-   The output should update combinatorially based on the inputs `S` and `I`.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule Span12Mux_v0(I, S, O);\n  input [11:0] I;\n  input [3:0] S;\n  output reg [11:0] O;\n\n  always @ (S or I) begin\n    case (S)\n      4'b0000: O <= I;\n      4'b0001: O <= I;\n      4'b0010: O <= I;\n      4'b0011: O <= I;\n      4'b0100: O <= I;\n      4'b0101: O <= I;\n      4'b0110: O <= I;\n      4'b0111: O <= I;\n      4'b1000: O <= I;\n      4'b1001: O <= I;\n      4'b1010: O <= I;\n      4'b1011: O <= I;\n      default: O <= 0;\n    endcase\n  end\nendmodule\nCODE END"}, "clean_code": "module Span12Mux_v0(I, S, O);\n  input [11:0] I;\n  input [3:0] S;\n  output reg [11:0] O;\n\n  always @ (S or I) begin\n    case (S)\n      4'b0000: O <= I;\n      4'b0001: O <= I;\n      4'b0010: O <= I;\n      4'b0011: O <= I;\n      4'b0100: O <= I;\n      4'b0101: O <= I;\n      4'b0110: O <= I;\n      4'b0111: O <= I;\n      4'b1000: O <= I;\n      4'b1001: O <= I;\n      4'b1010: O <= I;\n      4'b1011: O <= I;\n      default: O <= 0;\n    endcase\n  end\nendmodule", "corrupted_code": "module Span12Mux_v0(I, S, O);\n  input [11:0] I;\n  input [3:0] S;\n  output reg [11:0] O;\n\n  always @ (S or I) begin\n    case (S)\n      4'b0000: O <= I;\n      4'b0001: O <= I;\n      4'b0010: O <= I;\n      4'b0011: O <= I;\n      4'b0100: O <= I;\n      4'b0101: O <= I;\n      4'b0110: O <= I;\n      4'b0111: O <= I;\n      4'b1000: O <= I;\n      4'b1001: O <= I;\n      4'b1010: O <= I;\n      4'b1011: O <= I;\n      endcase\n  end\nendmodule", "corruption_explanation": "Removed default case (may cause incomplete case warning)", "modification_type": "remove_case_default", "modification_line": 7, "original_snippet": "case (S)\n      4'b0000: O <= I;\n      4'b0001: O <= I;\n      4'b0010: O <= I;\n      4'b0011: O <= I;\n      4'b0100: O <= I;\n      4'b0101: O <= I;\n      4'b0110: O <= I;\n      4'b0111: O <= I;\n      4", "modified_snippet": "case (S)\n      4'b0000: O <= I;\n      4'b0001: O <= I;\n      4'b0010: O <= I;\n      4'b0011: O <= I;\n      4'b0100: O <= I;\n      4'b0101: O <= I;\n      4'b0110: O <= I;\n      4'b0111: O <= I;\n      4", "issue_description": "The buggy code is missing the default case in a case statement. This creates an incomplete case statement that can infer latches in combinational blocks or cause undefined behavior for unhandled values. Linting tools will flag this as CASEINCOMPLETE or LATCH warning.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_case_default modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed default case (may cause incomplete case warning)\n   \u2022 Line 7: Original: case (S)\n      4'b0000: O <= I;\n      4'b0001: O <= I;\n      4'b0010: O <= I;\n      4'b0011: O <= I;\n      4'b0100: O <= I;\n      4'b0101: O <= I;\n      4'b0110: O <= I;\n      4'b0111: O <= I;\n      4\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 7.\n   \u2022 Restore the original code: case (S)\n      4'b0000: O <= I;\n      4'b0001: O <= I;\n      4'b0010: O <= I;\n      4'b0011: O <= I;\n      4'b0100: O <= I;\n      4'b0101: O <= I;\n      4'b0110: O <= I;\n      4'b0111: O <= I;\n      4\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove case default.", "complexity": 15, "applicable_modifications": ["remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "shuffle_case_items", "remove_always_block"], "timestamp": "2025-12-09T21:37:03.099337"}
{"original_entry": {"instruction": "\nWrite Verilog code for a module named `addsub_4bit`. The module has the following interface: inputs `input [3:0] O`, `input [3:0] A`, `input C`, and outputs `output reg [3:0] S`, `output reg [3:0] D`, `output reg B`.\n\nThe module should operate as follows:\n- When input `C` is high (1), it should perform a 4-bit addition of `O` and `A`. The 4-bit sum (ignoring any carry-out) should be assigned to output `S`. In this mode, outputs `D` and `B` should be cleared.\n- When input `C` is low (0), it should perform a 4-bit subtraction of `A` from `O` (`O - A`). The 4-bit difference should be assigned to output `D`. Output `B` should indicate if a borrow was required for this subtraction (i.e., `B` should be 1 if `O` is less than `A`, and 0 otherwise). In this mode, output `S` should be cleared.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule addsub_4bit (\n    input [3:0] O,\n    input [3:0] A,\n    input C,\n    output reg [3:0] S,\n    output reg [3:0] D,\n    output reg B\n);\n\nalways @(*) begin\n    if (C == 1'b1) begin\n        S = O + A;\n        D = 4'b0;\n        B = 1'b0;\n    end else begin\n        S = 4'b0;\n        if (O < A) begin\n            D = (O + 16) - A;\n            B = 1'b1;\n        end else begin\n            D = O - A;\n            B = 1'b0;\n        end\n    end\nend\n\nendmodule\nCODE END"}, "clean_code": "module addsub_4bit (\n    input [3:0] O,\n    input [3:0] A,\n    input C,\n    output reg [3:0] S,\n    output reg [3:0] D,\n    output reg B\n);\n\nalways @(*) begin\n    if (C == 1'b1) begin\n        S = O + A;\n        D = 4'b0;\n        B = 1'b0;\n    end else begin\n        S = 4'b0;\n        if (O < A) begin\n            D = (O + 16) - A;\n            B = 1'b1;\n        end else begin\n            D = O - A;\n            B = 1'b0;\n        end\n    end\nend\n\nendmodule", "corrupted_code": "module addsub_4bit (\n    input [3:0] O,\n    input [4:0] A,\n    input C,\n    output reg [3:0] S,\n    output reg [3:0] D,\n    output reg B\n);\n\nalways @(*) begin\n    if (C == 1'b1) begin\n        S = O + A;\n        D = 4'b0;\n        B = 1'b0;\n    end else begin\n        S = 4'b0;\n        if (O < A) begin\n            D = (O + 16) - A;\n            B = 1'b1;\n        end else begin\n            D = O - A;\n            B = 1'b0;\n        end\n    end\nend\n\nendmodule", "corruption_explanation": "Changed bit width from [3:0] to [4:0]", "modification_type": "change_bit_width", "modification_line": 3, "original_snippet": "[3:0]", "modified_snippet": "[4:0]", "issue_description": "The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_bit_width modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed bit width from [3:0] to [4:0]\n   \u2022 Line 3: Original: [3:0]\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 3.\n   \u2022 Restore the original code: [3:0]\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change bit width.", "complexity": 8, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "invert_condition", "remove_always_block"], "timestamp": "2025-12-09T21:37:03.100242"}
{"original_entry": {"instruction": "\nDesign a Verilog module named `starter_dut`.\nThis module should implement a simple synchronous register with an asynchronous reset.\nThe module should have the following interface:\nInputs:\n- `clk`: The clock signal.\n- `rst`: An active-high asynchronous reset signal.\n- `data_in` [7:0]: An 8-bit input data bus.\n- `valid_in`: A single-bit input validity flag.\nOutputs:\n- `data_out` [7:0]: An 8-bit output data bus representing the registered `data_in`.\n- `valid_out`: A single-bit output validity flag representing the registered `valid_in`.\n\nOn the positive edge of the clock, the outputs `data_out` and `valid_out` should be updated with the current values of the inputs `data_in` and `valid_in`, respectively.\nWhen the `rst` signal is asserted (high), both `data_out` and `valid_out` should be immediately reset to 0, regardless of the clock state.\nWrite the Verilog code for this module.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule starter_dut (\n   data_out, valid_out,\n   clk, rst, data_in, valid_in\n   ) ;\n   input clk;\n   input rst;\n   input [7:0] data_in;\n   input valid_in;\n   output [7:0] data_out;\n   output valid_out;\n\n   reg [7:0]\t\tdata_out;\n   reg\t\t\tvalid_out;\n\n   always @(posedge clk or posedge rst) begin\n      if (rst) begin\n\t data_out <= 'h0;\n\t valid_out <= 'h0;\n      end\n      else begin\n\t data_out <= data_in;\n\t valid_out <= valid_in;\n      end\n   end\nendmodule \nCODE END"}, "clean_code": "module starter_dut (\n   data_out, valid_out,\n   clk, rst, data_in, valid_in\n   ) ;\n   input clk;\n   input rst;\n   input [7:0] data_in;\n   input valid_in;\n   output [7:0] data_out;\n   output valid_out;\n\n   reg [7:0]\t\tdata_out;\n   reg\t\t\tvalid_out;\n\n   always @(posedge clk or posedge rst) begin\n      if (rst) begin\n\t data_out <= 'h0;\n\t valid_out <= 'h0;\n      end\n      else begin\n\t data_out <= data_in;\n\t valid_out <= valid_in;\n      end\n   end\nendmodule", "corrupted_code": "module starter_dut (\n   data_out, valid_out,\n   clk, rst, data_in, valid_in\n   ) ;\n   input clk;\n   input rst;\n   input [7:0] data_in;\n   input valid_in;\n   output [7:0] data_out;\n   output valid_out;\n\n   reg [7:0]\t\tdata_out;\n   reg\t\t\tvalid_out;\n\n   \n      else begin\n\t data_out <= data_in;\n\t valid_out <= valid_in;\n      end\n   end\nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 15, "original_snippet": "always @(posedge clk or posedge rst) begin\n      if (rst) begin\n\t data_out <= 'h0;\n\t valid_out <= 'h0;\n      end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 15: Original: always @(posedge clk or posedge rst) begin\n      if (rst) begin\n\t data_out <= 'h0;\n\t valid_out <= 'h0;\n      end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 15.\n   \u2022 Restore the original code: always @(posedge clk or posedge rst) begin\n      if (rst) begin\n\t data_out <= 'h0;\n\t valid_out <= 'h0;\n      end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 4, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:37:03.101102"}
