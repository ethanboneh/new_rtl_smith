{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Comparator", "design_name": "comparator_3bit", "module_name": "comparator_3bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 3-bit comparator for comparing binary numbers.\n\nModule name:  \n    comparator_3bit               \nInput ports:\n    A [2:0]: First 3-bit input operand (the first binary number to compare).\n    B [2:0]: Second 3-bit input operand (the second binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 3-bit binary numbers A and B using combinational logic.\n- The outputs A_greater, A_equal, and A_less are determined based on the comparison of A and B.\n- A_greater is set to 1 if A > B, A_equal is set to 1 if A == B, and A_less is set to 1 if A < B.\n\nOutput Encoding: The outputs are mutually exclusive, meaning only one of the three outputs will be high (1) at any given time, based on the comparison results.\n\nGive me the complete code.\n\n "}, "clean_code": "module comparator_3bit (\n    input [2:0] A,\n    input [2:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    assign A_greater = (A > B) ? 1'b1 : 1'b0;\n    assign A_equal = (A == B) ? 1'b1 : 1'b0;\n    assign A_less = (A < B) ? 1'b1 : 1'b0;\n\nendmodule", "corrupted_code": "module comparator_3bit (\n    input [2:0] A,\n    input [2:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    assign A_greater <= (A > B) ? 1'b1 : 1'b0;\n    assign A_equal = (A == B) ? 1'b1 : 1'b0;\n    assign A_less = (A < B) ? 1'b1 : 1'b0;\n\nendmodule", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 9, "original_snippet": "_greater = (A > B) ? 1'b1 : 1'b0;", "modified_snippet": "_greater <= (A > B) ? 1'b1 : 1'b0;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 3, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.061584", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Comparator", "design_name": "comparator_3bit", "module_name": "comparator_3bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 3-bit comparator for comparing binary numbers.\n\nModule name:  \n    comparator_3bit               \nInput ports:\n    A [2:0]: First 3-bit input operand (the first binary number to compare).\n    B [2:0]: Second 3-bit input operand (the second binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 3-bit binary numbers A and B using combinational logic.\n- The outputs A_greater, A_equal, and A_less are determined based on the comparison of A and B.\n- A_greater is set to 1 if A > B, A_equal is set to 1 if A == B, and A_less is set to 1 if A < B.\n\nOutput Encoding: The outputs are mutually exclusive, meaning only one of the three outputs will be high (1) at any given time, based on the comparison results.\n\nGive me the complete code.\n\n "}, "clean_code": "module comparator_3bit (\n    input [2:0] A,\n    input [2:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    assign A_greater = (A > B) ? 1'b1 : 1'b0;\n    assign A_equal = (A == B) ? 1'b1 : 1'b0;\n    assign A_less = (A < B) ? 1'b1 : 1'b0;\n\nendmodule", "corrupted_code": "module comparator_3bit (\n    input [2:0] A,\n    input [2:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    assign A_greater = (A > B) ? 1'b1 : 1'b0;\n    assign A_equal = (A != B) ? 1'b1 : 1'b0;\n    assign A_less = (A < B) ? 1'b1 : 1'b0;\n\nendmodule", "corruption_explanation": "Changed operator from '==' to '!='", "modification_type": "change_operator", "modification_line": 10, "original_snippet": "==", "modified_snippet": "!=", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '==' to '!='\n   \u2022 Line 10: Original: ==\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 10.\n   \u2022 Restore the original code: ==\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 3, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.062395", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Comparator", "design_name": "comparator_3bit", "module_name": "comparator_3bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 3-bit comparator for comparing binary numbers.\n\nModule name:  \n    comparator_3bit               \nInput ports:\n    A [2:0]: First 3-bit input operand (the first binary number to compare).\n    B [2:0]: Second 3-bit input operand (the second binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 3-bit binary numbers A and B using combinational logic.\n- The outputs A_greater, A_equal, and A_less are determined based on the comparison of A and B.\n- A_greater is set to 1 if A > B, A_equal is set to 1 if A == B, and A_less is set to 1 if A < B.\n\nOutput Encoding: The outputs are mutually exclusive, meaning only one of the three outputs will be high (1) at any given time, based on the comparison results.\n\nGive me the complete code.\n\n "}, "clean_code": "module comparator_3bit (\n    input [2:0] A,\n    input [2:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    assign A_greater = (A > B) ? 1'b1 : 1'b0;\n    assign A_equal = (A == B) ? 1'b1 : 1'b0;\n    assign A_less = (A < B) ? 1'b1 : 1'b0;\n\nendmodule", "corrupted_code": "module comparator_3bit (\n    input [2:0] A,\n    input [2:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    assign A_greater = (A > B) ? 1'b1 : 1'b0;\n    assign A_equal = (A == B) ? 1'b1 : 1'b0;\n\nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 11, "original_snippet": "assign A_less = (A < B) ? 1'b1 : 1'b0;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 11: Original: assign A_less = (A < B) ? 1'b1 : 1'b0;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 11.\n   \u2022 Restore the original code: assign A_less = (A < B) ? 1'b1 : 1'b0;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 3, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver"], "stacked_count": 1, "applied_modifications": ["remove_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.062998", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Comparator", "design_name": "comparator_3bit", "module_name": "comparator_3bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 3-bit comparator for comparing binary numbers.\n\nModule name:  \n    comparator_3bit               \nInput ports:\n    A [2:0]: First 3-bit input operand (the first binary number to compare).\n    B [2:0]: Second 3-bit input operand (the second binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 3-bit binary numbers A and B using combinational logic.\n- The outputs A_greater, A_equal, and A_less are determined based on the comparison of A and B.\n- A_greater is set to 1 if A > B, A_equal is set to 1 if A == B, and A_less is set to 1 if A < B.\n\nOutput Encoding: The outputs are mutually exclusive, meaning only one of the three outputs will be high (1) at any given time, based on the comparison results.\n\nGive me the complete code.\n\n "}, "clean_code": "module comparator_3bit (\n    input [2:0] A,\n    input [2:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    assign A_greater = (A > B) ? 1'b1 : 1'b0;\n    assign A_equal = (A == B) ? 1'b1 : 1'b0;\n    assign A_less = (A < B) ? 1'b1 : 1'b0;\n\nendmodule", "corrupted_code": "module comparator_3bit (\n    input [2:0] A,\n    input [2:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    assign A_greater = (A > B) ? 1'b1 : 1'b0;\n\n    assign A_less = (A < B) ? 1'b1 : 1'b0;\n\nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 10, "original_snippet": "assign A_equal = (A == B) ? 1'b1 : 1'b0;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 10: Original: assign A_equal = (A == B) ? 1'b1 : 1'b0;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 10.\n   \u2022 Restore the original code: assign A_equal = (A == B) ? 1'b1 : 1'b0;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 3, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver"], "stacked_count": 1, "applied_modifications": ["remove_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.063459", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Comparator", "design_name": "comparator_3bit", "module_name": "comparator_3bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 3-bit comparator for comparing binary numbers.\n\nModule name:  \n    comparator_3bit               \nInput ports:\n    A [2:0]: First 3-bit input operand (the first binary number to compare).\n    B [2:0]: Second 3-bit input operand (the second binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 3-bit binary numbers A and B using combinational logic.\n- The outputs A_greater, A_equal, and A_less are determined based on the comparison of A and B.\n- A_greater is set to 1 if A > B, A_equal is set to 1 if A == B, and A_less is set to 1 if A < B.\n\nOutput Encoding: The outputs are mutually exclusive, meaning only one of the three outputs will be high (1) at any given time, based on the comparison results.\n\nGive me the complete code.\n\n "}, "clean_code": "module comparator_3bit (\n    input [2:0] A,\n    input [2:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    assign A_greater = (A > B) ? 1'b1 : 1'b0;\n    assign A_equal = (A == B) ? 1'b1 : 1'b0;\n    assign A_less = (A < B) ? 1'b1 : 1'b0;\n\nendmodule", "corrupted_code": "module comparator_3bit (\n    input [2:0] A,\n    input [2:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    assign A_greater = (A > B) ? 1'b1 : 1'b0;\n    assign A_equal = (A != B) ? 1'b1 : 1'b0;\n    assign A_less = (A < B) ? 1'b1 : 1'b0;\n\nendmodule", "corruption_explanation": "Changed operator from '==' to '!='", "modification_type": "change_operator", "modification_line": 10, "original_snippet": "==", "modified_snippet": "!=", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '==' to '!='\n   \u2022 Line 10: Original: ==\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 10.\n   \u2022 Restore the original code: ==\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 3, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.064009", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Comparator", "design_name": "comparator_3bit", "module_name": "comparator_3bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 3-bit comparator for comparing binary numbers.\n\nModule name:  \n    comparator_3bit               \nInput ports:\n    A [2:0]: First 3-bit input operand (the first binary number to compare).\n    B [2:0]: Second 3-bit input operand (the second binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 3-bit binary numbers A and B using combinational logic.\n- The outputs A_greater, A_equal, and A_less are determined based on the comparison of A and B.\n- A_greater is set to 1 if A > B, A_equal is set to 1 if A == B, and A_less is set to 1 if A < B.\n\nOutput Encoding: The outputs are mutually exclusive, meaning only one of the three outputs will be high (1) at any given time, based on the comparison results.\n\nGive me the complete code.\n\n "}, "clean_code": "module comparator_3bit (\n    input [2:0] A,\n    input [2:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    assign A_greater = (A > B) ? 1'b1 : 1'b0;\n    assign A_equal = (A == B) ? 1'b1 : 1'b0;\n    assign A_less = (A < B) ? 1'b1 : 1'b0;\n\nendmodule", "corrupted_code": "module comparator_3bit (\n    input [2:0] A,\n    input [2:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    assign A_greater <= (A > B) ? 1'b1 : 1'b0;\n    assign A_equal = (A == B) ? 1'b1 : 1'b0;\n    assign A_less = (A < B) ? 1'b1 : 1'b0;\n\nendmodule", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 9, "original_snippet": "_greater = (A > B) ? 1'b1 : 1'b0;", "modified_snippet": "_greater <= (A > B) ? 1'b1 : 1'b0;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 3, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.064499", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Comparator", "design_name": "comparator_3bit", "module_name": "comparator_3bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 3-bit comparator for comparing binary numbers.\n\nModule name:  \n    comparator_3bit               \nInput ports:\n    A [2:0]: First 3-bit input operand (the first binary number to compare).\n    B [2:0]: Second 3-bit input operand (the second binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 3-bit binary numbers A and B using combinational logic.\n- The outputs A_greater, A_equal, and A_less are determined based on the comparison of A and B.\n- A_greater is set to 1 if A > B, A_equal is set to 1 if A == B, and A_less is set to 1 if A < B.\n\nOutput Encoding: The outputs are mutually exclusive, meaning only one of the three outputs will be high (1) at any given time, based on the comparison results.\n\nGive me the complete code.\n\n "}, "clean_code": "module comparator_3bit (\n    input [2:0] A,\n    input [2:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    assign A_greater = (A > B) ? 1'b1 : 1'b0;\n    assign A_equal = (A == B) ? 1'b1 : 1'b0;\n    assign A_less = (A < B) ? 1'b1 : 1'b0;\n\nendmodule", "corrupted_code": "module comparator_3bit (\n    input [2:0] A,\n    input [2:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    assign A_greater = (A < B) ? 1'b1 : 1'b0;\n    assign A_equal = (A == B) ? 1'b1 : 1'b0;\n    assign A_less = (A < B) ? 1'b1 : 1'b0;\n\nendmodule", "corruption_explanation": "Changed operator from '>' to '<'", "modification_type": "change_operator", "modification_line": 9, "original_snippet": ">", "modified_snippet": "<", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '>' to '<'\n   \u2022 Line 9: Original: >\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 9.\n   \u2022 Restore the original code: >\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 3, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.064969", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Comparator", "design_name": "comparator_3bit", "module_name": "comparator_3bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 3-bit comparator for comparing binary numbers.\n\nModule name:  \n    comparator_3bit               \nInput ports:\n    A [2:0]: First 3-bit input operand (the first binary number to compare).\n    B [2:0]: Second 3-bit input operand (the second binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 3-bit binary numbers A and B using combinational logic.\n- The outputs A_greater, A_equal, and A_less are determined based on the comparison of A and B.\n- A_greater is set to 1 if A > B, A_equal is set to 1 if A == B, and A_less is set to 1 if A < B.\n\nOutput Encoding: The outputs are mutually exclusive, meaning only one of the three outputs will be high (1) at any given time, based on the comparison results.\n\nGive me the complete code.\n\n "}, "clean_code": "module comparator_3bit (\n    input [2:0] A,\n    input [2:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    assign A_greater = (A > B) ? 1'b1 : 1'b0;\n    assign A_equal = (A == B) ? 1'b1 : 1'b0;\n    assign A_less = (A < B) ? 1'b1 : 1'b0;\n\nendmodule", "corrupted_code": "module comparator_3bit (\n    input [2:0] A,\n    input [2:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    assign A_greater = (A > B) ? 1'b1 : 1'b0;\n    assign A_equal = (A == B) ? 1'b1 : 1'b1;\n    assign A_less = (A < B) ? 1'b1 : 1'b0;\n\nendmodule", "corruption_explanation": "Changed constant from 1'b0 to 1'b1", "modification_type": "change_constant", "modification_line": 10, "original_snippet": "1'b0", "modified_snippet": "1'b1", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 1'b0 to 1'b1\n   \u2022 Line 10: Original: 1'b0\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 10.\n   \u2022 Restore the original code: 1'b0\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 3, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver"], "stacked_count": 1, "applied_modifications": ["change_constant"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.065556", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Comparator", "design_name": "comparator_3bit", "module_name": "comparator_3bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 3-bit comparator for comparing binary numbers.\n\nModule name:  \n    comparator_3bit               \nInput ports:\n    A [2:0]: First 3-bit input operand (the first binary number to compare).\n    B [2:0]: Second 3-bit input operand (the second binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 3-bit binary numbers A and B using combinational logic.\n- The outputs A_greater, A_equal, and A_less are determined based on the comparison of A and B.\n- A_greater is set to 1 if A > B, A_equal is set to 1 if A == B, and A_less is set to 1 if A < B.\n\nOutput Encoding: The outputs are mutually exclusive, meaning only one of the three outputs will be high (1) at any given time, based on the comparison results.\n\nGive me the complete code.\n\n "}, "clean_code": "module comparator_3bit (\n    input [2:0] A,\n    input [2:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    assign A_greater = (A > B) ? 1'b1 : 1'b0;\n    assign A_equal = (A == B) ? 1'b1 : 1'b0;\n    assign A_less = (A < B) ? 1'b1 : 1'b0;\n\nendmodule", "corrupted_code": "module comparator_3bit (\n    input [2:0] A,\n    input [2:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    assign A_greater = (A > B) ? 1'b0 : 1'b0;\n    assign A_equal = (A == B) ? 1'b1 : 1'b0;\n    assign A_less = (A < B) ? 1'b1 : 1'b0;\n\nendmodule", "corruption_explanation": "Changed constant from 1'b1 to 1'b0", "modification_type": "change_constant", "modification_line": 9, "original_snippet": "1'b1", "modified_snippet": "1'b0", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 1'b1 to 1'b0\n   \u2022 Line 9: Original: 1'b1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 9.\n   \u2022 Restore the original code: 1'b1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 3, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver"], "stacked_count": 1, "applied_modifications": ["change_constant"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.066013", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Comparator", "design_name": "comparator_3bit", "module_name": "comparator_3bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 3-bit comparator for comparing binary numbers.\n\nModule name:  \n    comparator_3bit               \nInput ports:\n    A [2:0]: First 3-bit input operand (the first binary number to compare).\n    B [2:0]: Second 3-bit input operand (the second binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 3-bit binary numbers A and B using combinational logic.\n- The outputs A_greater, A_equal, and A_less are determined based on the comparison of A and B.\n- A_greater is set to 1 if A > B, A_equal is set to 1 if A == B, and A_less is set to 1 if A < B.\n\nOutput Encoding: The outputs are mutually exclusive, meaning only one of the three outputs will be high (1) at any given time, based on the comparison results.\n\nGive me the complete code.\n\n "}, "clean_code": "module comparator_3bit (\n    input [2:0] A,\n    input [2:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    assign A_greater = (A > B) ? 1'b1 : 1'b0;\n    assign A_equal = (A == B) ? 1'b1 : 1'b0;\n    assign A_less = (A < B) ? 1'b1 : 1'b0;\n\nendmodule", "corrupted_code": "module comparator_3bit (\n    input [2:0] A,\n    input [2:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    assign A_greater = (A > B) ? 1'b1 : 1'b0;\nassign A_greater = 1'b0;  // Conflicting assignment\n    assign A_equal = (A == B) ? 1'b1 : 1'b0;\n    assign A_less = (A < B) ? 1'b1 : 1'b0;\n\nendmodule", "corruption_explanation": "Added conflicting driver for signal 'A_greater'", "modification_type": "add_multiple_driver", "modification_line": 8, "original_snippet": "assign A_greater = (A > B) ? 1'b1 : 1'b0;", "modified_snippet": "assign A_greater = (A > B) ? 1'b1 : 1'b0;\nassign A_greater = 1'b0;  // Conflicting assignment", "issue_description": "The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_multiple_driver modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added conflicting driver for signal 'A_greater'\n   \u2022 Line 8: Original: assign A_greater = (A > B) ? 1'b1 : 1'b0;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 8.\n   \u2022 Restore the original code: assign A_greater = (A > B) ? 1'b1 : 1'b0;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add multiple driver.", "complexity": 3, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver"], "stacked_count": 1, "applied_modifications": ["add_multiple_driver"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.066498", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Comparator", "design_name": "comparator_4bit", "module_name": "comparator_4bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 4-bit comparator with multiple bit-level comparators in combinational logic.\n\nModule name:  \n    comparator_4bit               \nInput ports:\n    A [3:0]: First 4-bit input operand (binary number to compare).\n    B [3:0]: Second 4-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 4-bit binary numbers A and B using combinational logic.\n- A subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\n- Carry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\n- If no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\n- If A and B are equal, the result of subtraction is zero (A_equal).\n\nOutput Encoding: The outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\n\n "}, "clean_code": "module comparator_4bit(\n    input [3:0] A,   // First 4-bit input operand\n    input [3:0] B,   // Second 4-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [3:0] diff;  \n    wire cout;       \n\n    assign {cout, diff} = A - B;\n\n    // A > B: if there's no borrow and the difference isn't zero\n    assign A_greater = (~cout && diff != 4'b0000);\n\n    assign A_equal = (A == B);\n\n    assign A_less = cout;\n\nendmodule\n", "corrupted_code": "module comparator_4bit(\n    input [3:0] A,   // First 4-bit input operand\n    input [3:0] B,   // Second 4-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [4:0] diff;  \n    wire cout;       \n\n    assign {cout, diff} = A - B;\n\n    // A > B: if there's no borrow and the difference isn't zero\n    assign A_greater = (~cout && diff != 4'b0000);\n\n    assign A_equal = (A == B);\n\n    assign A_less = cout;\n\nendmodule\n", "corruption_explanation": "Changed bit width from [3:0] to [4:0]", "modification_type": "change_bit_width", "modification_line": 9, "original_snippet": "[3:0]", "modified_snippet": "[4:0]", "issue_description": "The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_bit_width modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed bit width from [3:0] to [4:0]\n   \u2022 Line 9: Original: [3:0]\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 9.\n   \u2022 Restore the original code: [3:0]\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change bit width.", "complexity": 7, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver"], "stacked_count": 1, "applied_modifications": ["change_bit_width"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.068268", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Comparator", "design_name": "comparator_4bit", "module_name": "comparator_4bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 4-bit comparator with multiple bit-level comparators in combinational logic.\n\nModule name:  \n    comparator_4bit               \nInput ports:\n    A [3:0]: First 4-bit input operand (binary number to compare).\n    B [3:0]: Second 4-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 4-bit binary numbers A and B using combinational logic.\n- A subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\n- Carry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\n- If no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\n- If A and B are equal, the result of subtraction is zero (A_equal).\n\nOutput Encoding: The outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\n\n "}, "clean_code": "module comparator_4bit(\n    input [3:0] A,   // First 4-bit input operand\n    input [3:0] B,   // Second 4-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [3:0] diff;  \n    wire cout;       \n\n    assign {cout, diff} = A - B;\n\n    // A > B: if there's no borrow and the difference isn't zero\n    assign A_greater = (~cout && diff != 4'b0000);\n\n    assign A_equal = (A == B);\n\n    assign A_less = cout;\n\nendmodule\n", "corrupted_code": "module comparator_4bit(\n    input [3:0] A,   // First 4-bit input operand\n    input [3:0] B,   // Second 4-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [3:0] diff;  \n    wire cout;       \n\n    assign {cout, diff} = A - B;\n\n    // A > B: if there's no borrow and the difference isn't zero\n    assign A_greater = (~cout && diff != 4'b0000);\n\n    assign A_equal = (A == B);\n\n    assign A_less <= cout;\n\nendmodule\n", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 19, "original_snippet": "_less = cout;", "modified_snippet": "_less <= cout;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 7, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.069062", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Comparator", "design_name": "comparator_4bit", "module_name": "comparator_4bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 4-bit comparator with multiple bit-level comparators in combinational logic.\n\nModule name:  \n    comparator_4bit               \nInput ports:\n    A [3:0]: First 4-bit input operand (binary number to compare).\n    B [3:0]: Second 4-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 4-bit binary numbers A and B using combinational logic.\n- A subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\n- Carry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\n- If no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\n- If A and B are equal, the result of subtraction is zero (A_equal).\n\nOutput Encoding: The outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\n\n "}, "clean_code": "module comparator_4bit(\n    input [3:0] A,   // First 4-bit input operand\n    input [3:0] B,   // Second 4-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [3:0] diff;  \n    wire cout;       \n\n    assign {cout, diff} = A - B;\n\n    // A > B: if there's no borrow and the difference isn't zero\n    assign A_greater = (~cout && diff != 4'b0000);\n\n    assign A_equal = (A == B);\n\n    assign A_less = cout;\n\nendmodule\n", "corrupted_code": "module comparator_4bit(\n    input [3:0] A,   // First 4-bit input operand\n    input [3:0] B,   // Second 4-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [3:0] diff;  \n    wire cout;       \n\n    assign {cout, diff} = A - B;\n\n    // A > B: if there's no borrow and the difference isn't zero\n    assign A_greater = (~cout && diff != 4'b0000);\n\n    assign A_less = cout;\n\nendmodule\n", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 16, "original_snippet": "assign A_equal = (A == B);", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 16: Original: assign A_equal = (A == B);\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 16.\n   \u2022 Restore the original code: assign A_equal = (A == B);\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 7, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver"], "stacked_count": 1, "applied_modifications": ["remove_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.069739", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Comparator", "design_name": "comparator_4bit", "module_name": "comparator_4bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 4-bit comparator with multiple bit-level comparators in combinational logic.\n\nModule name:  \n    comparator_4bit               \nInput ports:\n    A [3:0]: First 4-bit input operand (binary number to compare).\n    B [3:0]: Second 4-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 4-bit binary numbers A and B using combinational logic.\n- A subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\n- Carry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\n- If no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\n- If A and B are equal, the result of subtraction is zero (A_equal).\n\nOutput Encoding: The outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\n\n "}, "clean_code": "module comparator_4bit(\n    input [3:0] A,   // First 4-bit input operand\n    input [3:0] B,   // Second 4-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [3:0] diff;  \n    wire cout;       \n\n    assign {cout, diff} = A - B;\n\n    // A > B: if there's no borrow and the difference isn't zero\n    assign A_greater = (~cout && diff != 4'b0000);\n\n    assign A_equal = (A == B);\n\n    assign A_less = cout;\n\nendmodule\n", "corrupted_code": "module comparator_4bit(\n    input [3:0] A,   // First 4-bit input operand\n    input [3:0] B,   // Second 4-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [3:0] diff;  \n    wire cout;       \n\n    assign {cout, diff} = A - B;\n\n    // A > B: if there's no borrow and the difference isn't zero\n    assign A_greater = (~cout && diff != 4'b0000);\n\n    assign A_equal = (A == B);\n\n    assign A_less <= cout;\n\nendmodule\n", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 19, "original_snippet": "_less = cout;", "modified_snippet": "_less <= cout;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 7, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.070511", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Comparator", "design_name": "comparator_4bit", "module_name": "comparator_4bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 4-bit comparator with multiple bit-level comparators in combinational logic.\n\nModule name:  \n    comparator_4bit               \nInput ports:\n    A [3:0]: First 4-bit input operand (binary number to compare).\n    B [3:0]: Second 4-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 4-bit binary numbers A and B using combinational logic.\n- A subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\n- Carry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\n- If no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\n- If A and B are equal, the result of subtraction is zero (A_equal).\n\nOutput Encoding: The outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\n\n "}, "clean_code": "module comparator_4bit(\n    input [3:0] A,   // First 4-bit input operand\n    input [3:0] B,   // Second 4-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [3:0] diff;  \n    wire cout;       \n\n    assign {cout, diff} = A - B;\n\n    // A > B: if there's no borrow and the difference isn't zero\n    assign A_greater = (~cout && diff != 4'b0000);\n\n    assign A_equal = (A == B);\n\n    assign A_less = cout;\n\nendmodule\n", "corrupted_code": "module comparator_4bit(\n    input [3:0] A,   // First 4-bit input operand\n    input [3:0] B,   // Second 4-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [3:0] diff;  \n    wire cout;       \n\n    assign {cout, diff} = A - B;\n\n    // A > B: if there's no borrow and the difference isn't zero\n    assign A_greater = (~cout && diff == 4'b0000);\n\n    assign A_equal = (A == B);\n\n    assign A_less = cout;\n\nendmodule\n", "corruption_explanation": "Changed operator from '!=' to '=='", "modification_type": "change_operator", "modification_line": 15, "original_snippet": "!=", "modified_snippet": "==", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '!=' to '=='\n   \u2022 Line 15: Original: !=\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 15.\n   \u2022 Restore the original code: !=\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 7, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.071236", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Comparator", "design_name": "comparator_4bit", "module_name": "comparator_4bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 4-bit comparator with multiple bit-level comparators in combinational logic.\n\nModule name:  \n    comparator_4bit               \nInput ports:\n    A [3:0]: First 4-bit input operand (binary number to compare).\n    B [3:0]: Second 4-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 4-bit binary numbers A and B using combinational logic.\n- A subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\n- Carry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\n- If no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\n- If A and B are equal, the result of subtraction is zero (A_equal).\n\nOutput Encoding: The outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\n\n "}, "clean_code": "module comparator_4bit(\n    input [3:0] A,   // First 4-bit input operand\n    input [3:0] B,   // Second 4-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [3:0] diff;  \n    wire cout;       \n\n    assign {cout, diff} = A - B;\n\n    // A > B: if there's no borrow and the difference isn't zero\n    assign A_greater = (~cout && diff != 4'b0000);\n\n    assign A_equal = (A == B);\n\n    assign A_less = cout;\n\nendmodule\n", "corrupted_code": "module comparator_4bit(\n    input [3:0] A,   // First 4-bit input operand\n    input [3:0] B,   // Second 4-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [3:0] diff;  \n    wire cout;       \n\n    assign {cout, diff} = A - B;\n\n    // A > B: if there's no borrow and the difference isn't zero\n    assign A_greater = (~cout || diff != 4'b0000);\n\n    assign A_equal = (A == B);\n\n    assign A_less = cout;\n\nendmodule\n", "corruption_explanation": "Changed operator from '&&' to '||'", "modification_type": "change_operator", "modification_line": 15, "original_snippet": "&&", "modified_snippet": "||", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '&&' to '||'\n   \u2022 Line 15: Original: &&\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 15.\n   \u2022 Restore the original code: &&\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 7, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.071972", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Comparator", "design_name": "comparator_4bit", "module_name": "comparator_4bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 4-bit comparator with multiple bit-level comparators in combinational logic.\n\nModule name:  \n    comparator_4bit               \nInput ports:\n    A [3:0]: First 4-bit input operand (binary number to compare).\n    B [3:0]: Second 4-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 4-bit binary numbers A and B using combinational logic.\n- A subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\n- Carry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\n- If no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\n- If A and B are equal, the result of subtraction is zero (A_equal).\n\nOutput Encoding: The outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\n\n "}, "clean_code": "module comparator_4bit(\n    input [3:0] A,   // First 4-bit input operand\n    input [3:0] B,   // Second 4-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [3:0] diff;  \n    wire cout;       \n\n    assign {cout, diff} = A - B;\n\n    // A > B: if there's no borrow and the difference isn't zero\n    assign A_greater = (~cout && diff != 4'b0000);\n\n    assign A_equal = (A == B);\n\n    assign A_less = cout;\n\nendmodule\n", "corrupted_code": "module comparator_4bit(\n    input [3:0] A,   // First 4-bit input operand\n    input [3:0] B,   // Second 4-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [3:0] diff;  \n    wire cout;       \n\n    assign {cout, diff} = A - B;\n\n    // A > B: if there's no borrow and the difference isn't zero\n    assign A_greater = (~cout && diff != 4'b0000);\n\n    assign A_equal = (A == B);\n\n    assign A_less <= cout;\n\nendmodule\n", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 19, "original_snippet": "_less = cout;", "modified_snippet": "_less <= cout;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 7, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.072735", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Comparator", "design_name": "comparator_4bit", "module_name": "comparator_4bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 4-bit comparator with multiple bit-level comparators in combinational logic.\n\nModule name:  \n    comparator_4bit               \nInput ports:\n    A [3:0]: First 4-bit input operand (binary number to compare).\n    B [3:0]: Second 4-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 4-bit binary numbers A and B using combinational logic.\n- A subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\n- Carry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\n- If no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\n- If A and B are equal, the result of subtraction is zero (A_equal).\n\nOutput Encoding: The outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\n\n "}, "clean_code": "module comparator_4bit(\n    input [3:0] A,   // First 4-bit input operand\n    input [3:0] B,   // Second 4-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [3:0] diff;  \n    wire cout;       \n\n    assign {cout, diff} = A - B;\n\n    // A > B: if there's no borrow and the difference isn't zero\n    assign A_greater = (~cout && diff != 4'b0000);\n\n    assign A_equal = (A == B);\n\n    assign A_less = cout;\n\nendmodule\n", "corrupted_code": "module comparator_4bit(\n    input [3:0] A,   // First 4-bit input operand\n    input [3:0] B,   // Second 4-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [3:0] diff;  \n    wire cout;       \n\n    assign {cout, diff} = A - B;\n\n    // A > B: if there's no borrow and the difference isn't zero\n    assign A_greater = (~cout && diff != 4'b0000);\n\n    assign A_less = cout;\n\nendmodule\n", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 16, "original_snippet": "assign A_equal = (A == B);", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 16: Original: assign A_equal = (A == B);\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 16.\n   \u2022 Restore the original code: assign A_equal = (A == B);\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 7, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver"], "stacked_count": 1, "applied_modifications": ["remove_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.073400", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Comparator", "design_name": "comparator_4bit", "module_name": "comparator_4bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 4-bit comparator with multiple bit-level comparators in combinational logic.\n\nModule name:  \n    comparator_4bit               \nInput ports:\n    A [3:0]: First 4-bit input operand (binary number to compare).\n    B [3:0]: Second 4-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 4-bit binary numbers A and B using combinational logic.\n- A subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\n- Carry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\n- If no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\n- If A and B are equal, the result of subtraction is zero (A_equal).\n\nOutput Encoding: The outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\n\n "}, "clean_code": "module comparator_4bit(\n    input [3:0] A,   // First 4-bit input operand\n    input [3:0] B,   // Second 4-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [3:0] diff;  \n    wire cout;       \n\n    assign {cout, diff} = A - B;\n\n    // A > B: if there's no borrow and the difference isn't zero\n    assign A_greater = (~cout && diff != 4'b0000);\n\n    assign A_equal = (A == B);\n\n    assign A_less = cout;\n\nendmodule\n", "corrupted_code": "module comparator_4bit(\n    input [3:0] A,   // First 4-bit input operand\n    input [3:0] B,   // Second 4-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [3:0] diff;  \n    wire cout;       \n\n    assign {cout, diff} = A - B;\n\n    // A > B: if there's no borrow and the difference isn't zero\n    assign A_greater = (~cout && diff != 4'b0000);\n\n    assign A_less = cout;\n\nendmodule\n", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 16, "original_snippet": "assign A_equal = (A == B);", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 16: Original: assign A_equal = (A == B);\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 16.\n   \u2022 Restore the original code: assign A_equal = (A == B);\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 7, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver"], "stacked_count": 1, "applied_modifications": ["remove_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.074595", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_pipe_8bit", "module_name": "multi_pipe_8bit", "description": "Please act as a professional verilog designer.\n\nImplement the design of unsigned 8bit multiplier based on pipelining processing. It utilizes a clock signal (clk), an active-low reset signal (rst_n), an input enable signal (mul_en_in), and provides an output enable signal (mul_en_out) and the product output (mul_out) of size 16 bits.\n\nModule name:  \n    multi_pipe_8bit \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    mul_en_in: Input enable signal that controls the multiplication operation.\n    mul_a: Input signal representing the multiplicand with a data width of 8 bits.\n    mul_b: Input signal representing the multiplier with a data width of 8 bits.\n\nOutput ports:\n    mul_en_out: Output enable signal indicating if the multiplication operation is enabled.\n    mul_out: Product output signal with a data width of 16 bits.\n\nImplementation:\nThe module utilizes a pipeline architecture to improve performance. It consists of several key components:\nInput Control:\nThe module includes an input enable signal, mul_en_in, which controls the multiplication operation.\nOn the positive edge of the clock signal, the module samples the input enable signal and stores it in a register, mul_en_out_reg.\nThe output enable signal, mul_en_out, is derived from the most significant bit of mul_en_out_reg, indicating whether the multiplication operation is enabled.\n\nInput Registers:\nThe module includes registers, mul_a_reg and mul_b_reg, to store the input multiplicand and multiplier, respectively.\nOn the positive edge of the clock signal, the module samples the input values and stores them in the corresponding registers.\nThe registers are only updated when the input enable signal is active.\n\nPartial Product Generation:\nThe module generates partial products by performing bitwise operations between the multiplicand and the individual bits of the multiplier.\nIt uses conditional assignments to select the appropriate bits from the multiplicand based on the multiplier bits.\nThe partial products are stored in a set of wires, temp, with each wire representing a different bit position.\n\nPartial Sum Calculation:\nThe module performs addition operations on the partial products to calculate partial sums.\nIt uses a set of registers, sum, to store the intermediate sum values.\nEach register corresponds to a group of partial products and is updated on the positive edge of the clock signal.\n\nFinal Product Calculation:\nThe module sums up all the partial sums to obtain the final product.\nIt uses a register, mul_out_reg, to store the accumulated sum.\nOn the positive edge of the clock signal, the register is updated with the sum of all partial sums.\n\nOutput Assignment:\nThe module assigns the output product value, mul_out, based on the output enable signal and the value in mul_out_reg.\nIf the output enable signal is active, indicating a valid product, the value in mul_out_reg is assigned to mul_out.\nOtherwise, mul_out is set to 0.\n\nGive me the complete code.\n"}, "clean_code": "module multi_pipe_8bit#(\n    parameter size = 8\n)(\n          clk,      \n          rst_n,       \n          mul_a,       \n          mul_b, \n          mul_en_in,\n \n          mul_en_out,      \n          mul_out    \n);\n \n   input clk;           \n   input rst_n; \n   input mul_en_in;      \n   input [size-1:0] mul_a;       \n   input [size-1:0] mul_b;       \n \n   output reg mul_en_out;  \n   output reg [size*2-1:0] mul_out;    \n \n            \n   reg [2:0] mul_en_out_reg;\n always@(posedge clk or negedge rst_n)\n       if(!rst_n)begin\n            mul_en_out_reg <= 'd0;             \n            mul_en_out     <= 'd0;                           \n       end\n       else begin\n            mul_en_out_reg <= {mul_en_out_reg[1:0],mul_en_in};            \n            mul_en_out     <= mul_en_out_reg[2];                  \n       end\n \n \n    reg [7:0] mul_a_reg;\n    reg [7:0] mul_b_reg;\n  always @(posedge clk or negedge rst_n)\n         if(!rst_n) begin\n              mul_a_reg <= 'd0;\n              mul_a_reg <= 'd0;\n         end\n         else begin\n              mul_a_reg <= mul_en_in ? mul_a :'d0;\n              mul_b_reg <= mul_en_in ? mul_b :'d0;\n         end\n \n  \n     wire [15:0] temp [size-1:0];\n  assign temp[0] = mul_b_reg[0]? {8'b0,mul_a_reg} : 'd0;\n  assign temp[1] = mul_b_reg[1]? {7'b0,mul_a_reg,1'b0} : 'd0;\n  assign temp[2] = mul_b_reg[2]? {6'b0,mul_a_reg,2'b0} : 'd0;\n  assign temp[3] = mul_b_reg[3]? {5'b0,mul_a_reg,3'b0} : 'd0;\n  assign temp[4] = mul_b_reg[4]? {4'b0,mul_a_reg,4'b0} : 'd0;\n  assign temp[5] = mul_b_reg[5]? {3'b0,mul_a_reg,5'b0} : 'd0;\n  assign temp[6] = mul_b_reg[6]? {2'b0,mul_a_reg,6'b0} : 'd0;\n  assign temp[7] = mul_b_reg[7]? {1'b0,mul_a_reg,7'b0} : 'd0; \n \n \n     reg [15:0] sum [3:0];//[size/2-1:1]\n always @(posedge clk or negedge rst_n) \n       if(!rst_n) begin\n          sum[0]  <= 'd0;\n          sum[1]  <= 'd0;\n          sum[2]  <= 'd0;\n          sum[3]  <= 'd0;\n       end \n       else begin\n          sum[0] <= temp[0] + temp[1];\n          sum[1] <= temp[2] + temp[3];\n          sum[2] <= temp[4] + temp[5];\n          sum[3] <= temp[6] + temp[7];\n       end\n \n     reg [15:0] mul_out_reg;\n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out_reg <= 'd0;\n       else \n          mul_out_reg <= sum[0] + sum[1] + sum[2] + sum[3];\n \n \n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out <= 'd0;\n       else if(mul_en_out_reg[2])\n          mul_out <= mul_out_reg;\n       else\n          mul_out <= 'd0;\n \n          \nendmodule", "corrupted_code": "module multi_pipe_8bit#(\n    parameter size = 8\n)(\n          clk,      \n          rst_n,       \n          mul_a,       \n          mul_b, \n          mul_en_in,\n \n          mul_en_out,      \n          mul_out    \n);\n \n   input clk;           \n   input rst_n; \n   input mul_en_in;      \n   input [size-1:0] mul_a;       \n   input [size-1:0] mul_b;       \n \n   output reg mul_en_out;  \n   output reg [size*2-1:0] mul_out;    \n \n            \n   reg [2:0] mul_en_out_reg;\n always@(posedge clk or negedge rst_n)\n       if(!rst_n)begin\n            mul_en_out_reg <= 'd0;             \n            mul_en_out     <= 'd0;                           \n       end\n       else begin\n            mul_en_out_reg <= {mul_en_out_reg[1:0],mul_en_in};            \n            mul_en_out     <= mul_en_out_reg[2];                  \n       end\n \n \n    reg [7:0] mul_a_reg;\n    reg [7:0] mul_b_reg;\n  always @(posedge clk or negedge rst_n)\n         if(!rst_n) begin\n              mul_a_reg <= 'd0;\n              mul_a_reg <= 'd0;\n         end\n         else begin\n              mul_a_reg <= mul_en_in ? mul_a :'d0;\n              mul_b_reg <= mul_en_in ? mul_b :'d0;\n         end\n \n  \n     wire [15:0] temp [size-1:0];\n  assign temp[0] = mul_b_reg[0]? {8'b0,mul_a_reg} : 'd0;\n  assign temp[1] = mul_b_reg[1]? {7'b0,mul_a_reg,1'b0} : 'd0;\n  assign temp[2] = mul_b_reg[2]? {6'b0,mul_a_reg,2'b0} : 'd0;\n  assign temp[3] = mul_b_reg[3]? {5'b0,mul_a_reg,3'b0} : 'd0;\n  assign temp[4] = mul_b_reg[4]? {4'b0,mul_a_reg,4'b0} : 'd0;\n  assign temp[5] = mul_b_reg[5]? {3'b0,mul_a_reg,5'b0} : 'd0;\n  assign temp[6] = mul_b_reg[6]? {2'b0,mul_a_reg,6'b0} : 'd0;\n  assign temp[7] = mul_b_reg[7]? {1'b0,mul_a_reg,7'b0} : 'd0; \n \n \n     reg [15:0] sum [3:0];//[size/2-1:1]\n always @(posedge clk or negedge rst_n) \n       if(!rst_n) begin\n          sum[0]  <= 'd0;\n          sum[1] = 'd0;\n          sum[2]  <= 'd0;\n          sum[3]  <= 'd0;\n       end \n       else begin\n          sum[0] <= temp[0] + temp[1];\n          sum[1] <= temp[2] + temp[3];\n          sum[2] <= temp[4] + temp[5];\n          sum[3] <= temp[6] + temp[7];\n       end\n \n     reg [15:0] mul_out_reg;\n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out_reg <= 'd0;\n       else \n          mul_out_reg <= sum[0] + sum[1] + sum[2] + sum[3];\n \n \n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out <= 'd0;\n       else if(mul_en_out_reg[2])\n          mul_out <= mul_out_reg;\n       else\n          mul_out <= 'd0;\n \n          \nendmodule", "corruption_explanation": "Changed non-blocking (<=) to blocking (=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 64, "original_snippet": "sum[1]  <= 'd0;", "modified_snippet": "sum[1] = 'd0;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 13, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "add_multiple_driver", "invert_condition", "invert_reset_polarity", "remove_async_reset"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.091344", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_pipe_8bit", "module_name": "multi_pipe_8bit", "description": "Please act as a professional verilog designer.\n\nImplement the design of unsigned 8bit multiplier based on pipelining processing. It utilizes a clock signal (clk), an active-low reset signal (rst_n), an input enable signal (mul_en_in), and provides an output enable signal (mul_en_out) and the product output (mul_out) of size 16 bits.\n\nModule name:  \n    multi_pipe_8bit \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    mul_en_in: Input enable signal that controls the multiplication operation.\n    mul_a: Input signal representing the multiplicand with a data width of 8 bits.\n    mul_b: Input signal representing the multiplier with a data width of 8 bits.\n\nOutput ports:\n    mul_en_out: Output enable signal indicating if the multiplication operation is enabled.\n    mul_out: Product output signal with a data width of 16 bits.\n\nImplementation:\nThe module utilizes a pipeline architecture to improve performance. It consists of several key components:\nInput Control:\nThe module includes an input enable signal, mul_en_in, which controls the multiplication operation.\nOn the positive edge of the clock signal, the module samples the input enable signal and stores it in a register, mul_en_out_reg.\nThe output enable signal, mul_en_out, is derived from the most significant bit of mul_en_out_reg, indicating whether the multiplication operation is enabled.\n\nInput Registers:\nThe module includes registers, mul_a_reg and mul_b_reg, to store the input multiplicand and multiplier, respectively.\nOn the positive edge of the clock signal, the module samples the input values and stores them in the corresponding registers.\nThe registers are only updated when the input enable signal is active.\n\nPartial Product Generation:\nThe module generates partial products by performing bitwise operations between the multiplicand and the individual bits of the multiplier.\nIt uses conditional assignments to select the appropriate bits from the multiplicand based on the multiplier bits.\nThe partial products are stored in a set of wires, temp, with each wire representing a different bit position.\n\nPartial Sum Calculation:\nThe module performs addition operations on the partial products to calculate partial sums.\nIt uses a set of registers, sum, to store the intermediate sum values.\nEach register corresponds to a group of partial products and is updated on the positive edge of the clock signal.\n\nFinal Product Calculation:\nThe module sums up all the partial sums to obtain the final product.\nIt uses a register, mul_out_reg, to store the accumulated sum.\nOn the positive edge of the clock signal, the register is updated with the sum of all partial sums.\n\nOutput Assignment:\nThe module assigns the output product value, mul_out, based on the output enable signal and the value in mul_out_reg.\nIf the output enable signal is active, indicating a valid product, the value in mul_out_reg is assigned to mul_out.\nOtherwise, mul_out is set to 0.\n\nGive me the complete code.\n"}, "clean_code": "module multi_pipe_8bit#(\n    parameter size = 8\n)(\n          clk,      \n          rst_n,       \n          mul_a,       \n          mul_b, \n          mul_en_in,\n \n          mul_en_out,      \n          mul_out    \n);\n \n   input clk;           \n   input rst_n; \n   input mul_en_in;      \n   input [size-1:0] mul_a;       \n   input [size-1:0] mul_b;       \n \n   output reg mul_en_out;  \n   output reg [size*2-1:0] mul_out;    \n \n            \n   reg [2:0] mul_en_out_reg;\n always@(posedge clk or negedge rst_n)\n       if(!rst_n)begin\n            mul_en_out_reg <= 'd0;             \n            mul_en_out     <= 'd0;                           \n       end\n       else begin\n            mul_en_out_reg <= {mul_en_out_reg[1:0],mul_en_in};            \n            mul_en_out     <= mul_en_out_reg[2];                  \n       end\n \n \n    reg [7:0] mul_a_reg;\n    reg [7:0] mul_b_reg;\n  always @(posedge clk or negedge rst_n)\n         if(!rst_n) begin\n              mul_a_reg <= 'd0;\n              mul_a_reg <= 'd0;\n         end\n         else begin\n              mul_a_reg <= mul_en_in ? mul_a :'d0;\n              mul_b_reg <= mul_en_in ? mul_b :'d0;\n         end\n \n  \n     wire [15:0] temp [size-1:0];\n  assign temp[0] = mul_b_reg[0]? {8'b0,mul_a_reg} : 'd0;\n  assign temp[1] = mul_b_reg[1]? {7'b0,mul_a_reg,1'b0} : 'd0;\n  assign temp[2] = mul_b_reg[2]? {6'b0,mul_a_reg,2'b0} : 'd0;\n  assign temp[3] = mul_b_reg[3]? {5'b0,mul_a_reg,3'b0} : 'd0;\n  assign temp[4] = mul_b_reg[4]? {4'b0,mul_a_reg,4'b0} : 'd0;\n  assign temp[5] = mul_b_reg[5]? {3'b0,mul_a_reg,5'b0} : 'd0;\n  assign temp[6] = mul_b_reg[6]? {2'b0,mul_a_reg,6'b0} : 'd0;\n  assign temp[7] = mul_b_reg[7]? {1'b0,mul_a_reg,7'b0} : 'd0; \n \n \n     reg [15:0] sum [3:0];//[size/2-1:1]\n always @(posedge clk or negedge rst_n) \n       if(!rst_n) begin\n          sum[0]  <= 'd0;\n          sum[1]  <= 'd0;\n          sum[2]  <= 'd0;\n          sum[3]  <= 'd0;\n       end \n       else begin\n          sum[0] <= temp[0] + temp[1];\n          sum[1] <= temp[2] + temp[3];\n          sum[2] <= temp[4] + temp[5];\n          sum[3] <= temp[6] + temp[7];\n       end\n \n     reg [15:0] mul_out_reg;\n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out_reg <= 'd0;\n       else \n          mul_out_reg <= sum[0] + sum[1] + sum[2] + sum[3];\n \n \n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out <= 'd0;\n       else if(mul_en_out_reg[2])\n          mul_out <= mul_out_reg;\n       else\n          mul_out <= 'd0;\n \n          \nendmodule", "corrupted_code": "module multi_pipe_8bit#(\n    parameter size = 8\n)(\n          clk,      \n          rst_n,       \n          mul_a,       \n          mul_b, \n          mul_en_in,\n \n          mul_en_out,      \n          mul_out    \n);\n \n   input clk;           \n   input rst_n; \n   input mul_en_in;      \n   input [size-1:0] mul_a;       \n   input [size-1:0] mul_b;       \n \n   output reg mul_en_out;  \n   output reg [size*2-1:0] mul_out;    \n \n            \n   reg [2:0] mul_en_out_reg;\n always@(posedge clk or negedge rst_n)\n       if(!rst_n)begin\n            mul_en_out_reg <= 'd0;             \n            mul_en_out     <= 'd0;                           \n       end\n       else begin\n            mul_en_out_reg <= {mul_en_out_reg[1:0],mul_en_in};            \n            mul_en_out     <= mul_en_out_reg[2];                  \n       end\n \n \n    reg [7:0] mul_a_reg;\n    reg [7:0] mul_b_reg;\n  always @(posedge clk or negedge rst_n)\n         if(!rst_n) begin\n              mul_a_reg <= 'd0;\n              mul_a_reg <= 'd0;\n         end\n         else begin\n              mul_a_reg <= mul_en_in ? mul_a :'d0;\n              mul_b_reg <= mul_en_in ? mul_b :'d0;\n         end\n \n  \n     wire [15:0] temp [size-1:0];\n  assign temp[0] = mul_b_reg[0]? {8'b0,mul_a_reg} : 'd0;\n  assign temp[1] = mul_b_reg[1]? {7'b0,mul_a_reg,1'b0} : 'd0;\n  assign temp[2] = mul_b_reg[2]? {6'b0,mul_a_reg,2'b0} : 'd0;\n  assign temp[3] = mul_b_reg[3]? {5'b0,mul_a_reg,3'b0} : 'd0;\n  assign temp[4] = mul_b_reg[4]? {4'b0,mul_a_reg,4'b0} : 'd0;\n  assign temp[5] = mul_b_reg[5]? {3'b0,mul_a_reg,5'b0} : 'd0;\n  assign temp[6] = mul_b_reg[6]? {2'b0,mul_a_reg,6'b0} : 'd0;\n  assign temp[7] = mul_b_reg[7]? {1'b0,mul_a_reg,7'b0} : 'd0; \n \n \n     reg [15:0] sum [3:0];//[size/2-1:1]\n always @(posedge clk or negedge rst_n) \n       if(!rst_n) begin\n          sum[0]  <= 'd0;\n          sum[1]  <= 'd0;\n          sum[2]  <= 'd0;\n          sum[3]  <= 'd0;\n       end \n       else begin\n          sum[0] <= temp[0] + temp[1];\n          sum[1] <= temp[2] + temp[3];\n          sum[2] <= temp[4] + temp[5];\n          sum[3] <= temp[6] + temp[7];\n       end\n \n     reg [15:0] mul_out_reg;\n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out_reg <= 'd0;\n       else \n          mul_out_reg <= sum[0] + sum[1] + sum[2] + sum[3];\n \n \n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out <= 'd0;\n       else if(mul_en_out_reg[2])\n          mul_out >= mul_out_reg;\n       else\n          mul_out <= 'd0;\n \n          \nendmodule", "corruption_explanation": "Changed operator from '<=' to '>='", "modification_type": "change_operator", "modification_line": 87, "original_snippet": "t <= m", "modified_snippet": "t >= m", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '<=' to '>='\n   \u2022 Line 87: Original: t <= m\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 87.\n   \u2022 Restore the original code: t <= m\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 13, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "add_multiple_driver", "invert_condition", "invert_reset_polarity", "remove_async_reset"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.094507", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_pipe_8bit", "module_name": "multi_pipe_8bit", "description": "Please act as a professional verilog designer.\n\nImplement the design of unsigned 8bit multiplier based on pipelining processing. It utilizes a clock signal (clk), an active-low reset signal (rst_n), an input enable signal (mul_en_in), and provides an output enable signal (mul_en_out) and the product output (mul_out) of size 16 bits.\n\nModule name:  \n    multi_pipe_8bit \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    mul_en_in: Input enable signal that controls the multiplication operation.\n    mul_a: Input signal representing the multiplicand with a data width of 8 bits.\n    mul_b: Input signal representing the multiplier with a data width of 8 bits.\n\nOutput ports:\n    mul_en_out: Output enable signal indicating if the multiplication operation is enabled.\n    mul_out: Product output signal with a data width of 16 bits.\n\nImplementation:\nThe module utilizes a pipeline architecture to improve performance. It consists of several key components:\nInput Control:\nThe module includes an input enable signal, mul_en_in, which controls the multiplication operation.\nOn the positive edge of the clock signal, the module samples the input enable signal and stores it in a register, mul_en_out_reg.\nThe output enable signal, mul_en_out, is derived from the most significant bit of mul_en_out_reg, indicating whether the multiplication operation is enabled.\n\nInput Registers:\nThe module includes registers, mul_a_reg and mul_b_reg, to store the input multiplicand and multiplier, respectively.\nOn the positive edge of the clock signal, the module samples the input values and stores them in the corresponding registers.\nThe registers are only updated when the input enable signal is active.\n\nPartial Product Generation:\nThe module generates partial products by performing bitwise operations between the multiplicand and the individual bits of the multiplier.\nIt uses conditional assignments to select the appropriate bits from the multiplicand based on the multiplier bits.\nThe partial products are stored in a set of wires, temp, with each wire representing a different bit position.\n\nPartial Sum Calculation:\nThe module performs addition operations on the partial products to calculate partial sums.\nIt uses a set of registers, sum, to store the intermediate sum values.\nEach register corresponds to a group of partial products and is updated on the positive edge of the clock signal.\n\nFinal Product Calculation:\nThe module sums up all the partial sums to obtain the final product.\nIt uses a register, mul_out_reg, to store the accumulated sum.\nOn the positive edge of the clock signal, the register is updated with the sum of all partial sums.\n\nOutput Assignment:\nThe module assigns the output product value, mul_out, based on the output enable signal and the value in mul_out_reg.\nIf the output enable signal is active, indicating a valid product, the value in mul_out_reg is assigned to mul_out.\nOtherwise, mul_out is set to 0.\n\nGive me the complete code.\n"}, "clean_code": "module multi_pipe_8bit#(\n    parameter size = 8\n)(\n          clk,      \n          rst_n,       \n          mul_a,       \n          mul_b, \n          mul_en_in,\n \n          mul_en_out,      \n          mul_out    \n);\n \n   input clk;           \n   input rst_n; \n   input mul_en_in;      \n   input [size-1:0] mul_a;       \n   input [size-1:0] mul_b;       \n \n   output reg mul_en_out;  \n   output reg [size*2-1:0] mul_out;    \n \n            \n   reg [2:0] mul_en_out_reg;\n always@(posedge clk or negedge rst_n)\n       if(!rst_n)begin\n            mul_en_out_reg <= 'd0;             \n            mul_en_out     <= 'd0;                           \n       end\n       else begin\n            mul_en_out_reg <= {mul_en_out_reg[1:0],mul_en_in};            \n            mul_en_out     <= mul_en_out_reg[2];                  \n       end\n \n \n    reg [7:0] mul_a_reg;\n    reg [7:0] mul_b_reg;\n  always @(posedge clk or negedge rst_n)\n         if(!rst_n) begin\n              mul_a_reg <= 'd0;\n              mul_a_reg <= 'd0;\n         end\n         else begin\n              mul_a_reg <= mul_en_in ? mul_a :'d0;\n              mul_b_reg <= mul_en_in ? mul_b :'d0;\n         end\n \n  \n     wire [15:0] temp [size-1:0];\n  assign temp[0] = mul_b_reg[0]? {8'b0,mul_a_reg} : 'd0;\n  assign temp[1] = mul_b_reg[1]? {7'b0,mul_a_reg,1'b0} : 'd0;\n  assign temp[2] = mul_b_reg[2]? {6'b0,mul_a_reg,2'b0} : 'd0;\n  assign temp[3] = mul_b_reg[3]? {5'b0,mul_a_reg,3'b0} : 'd0;\n  assign temp[4] = mul_b_reg[4]? {4'b0,mul_a_reg,4'b0} : 'd0;\n  assign temp[5] = mul_b_reg[5]? {3'b0,mul_a_reg,5'b0} : 'd0;\n  assign temp[6] = mul_b_reg[6]? {2'b0,mul_a_reg,6'b0} : 'd0;\n  assign temp[7] = mul_b_reg[7]? {1'b0,mul_a_reg,7'b0} : 'd0; \n \n \n     reg [15:0] sum [3:0];//[size/2-1:1]\n always @(posedge clk or negedge rst_n) \n       if(!rst_n) begin\n          sum[0]  <= 'd0;\n          sum[1]  <= 'd0;\n          sum[2]  <= 'd0;\n          sum[3]  <= 'd0;\n       end \n       else begin\n          sum[0] <= temp[0] + temp[1];\n          sum[1] <= temp[2] + temp[3];\n          sum[2] <= temp[4] + temp[5];\n          sum[3] <= temp[6] + temp[7];\n       end\n \n     reg [15:0] mul_out_reg;\n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out_reg <= 'd0;\n       else \n          mul_out_reg <= sum[0] + sum[1] + sum[2] + sum[3];\n \n \n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out <= 'd0;\n       else if(mul_en_out_reg[2])\n          mul_out <= mul_out_reg;\n       else\n          mul_out <= 'd0;\n \n          \nendmodule", "corrupted_code": "module multi_pipe_8bit#(\n    parameter size = 8\n)(\n          clk,      \n          rst_n,       \n          mul_a,       \n          mul_b, \n          mul_en_in,\n \n          mul_en_out,      \n          mul_out    \n);\n \n   input clk;           \n   input rst_n; \n   input mul_en_in;      \n   input [size-1:0] mul_a;       \n   input [size-1:0] mul_b;       \n \n   output reg mul_en_out;  \n   output reg [size*2-1:0] mul_out;    \n \n            \n   reg [2:0] mul_en_out_reg;\n always@(posedge clk or negedge rst_n)\n       if(!rst_n)begin\n            mul_en_out_reg <= 'd0;             \n            mul_en_out     <= 'd0;                           \n       end\n       else begin\n            mul_en_out_reg <= {mul_en_out_reg[1:0],mul_en_in};            \n            mul_en_out     <= mul_en_out_reg[2];                  \n       end\n \n \n    reg [7:0] mul_a_reg;\n    reg [7:0] mul_b_reg;\n  always @(posedge clk or negedge rst_n)\n         if(!rst_n) begin\n              mul_a_reg <= 'd0;\n              mul_a_reg <= 'd0;\n         end\n         else begin\n              mul_a_reg <= mul_en_in ? mul_a :'d0;\n              mul_b_reg <= mul_en_in ? mul_b :'d0;\n         end\n \n  \n     wire [15:0] temp [size-1:0];\n  assign temp[0] = mul_b_reg[0]? {8'b0,mul_a_reg} : 'd0;\n  assign temp[1] = mul_b_reg[1]? {7'b0,mul_a_reg,1'b0} : 'd0;\n  assign temp[2] = mul_b_reg[2]? {6'b0,mul_a_reg,2'b0} : 'd0;\n  assign temp[3] = mul_b_reg[3]? {5'b0,mul_a_reg,3'b0} : 'd0;\n  assign temp[4] = mul_b_reg[4]? {4'b0,mul_a_reg,4'b0} : 'd0;\n  assign temp[5] = mul_b_reg[5]? {3'b0,mul_a_reg,5'b0} : 'd0;\nassign temp = 1'b0;  // Conflicting assignment\n  assign temp[6] = mul_b_reg[6]? {2'b0,mul_a_reg,6'b0} : 'd0;\n  assign temp[7] = mul_b_reg[7]? {1'b0,mul_a_reg,7'b0} : 'd0; \n \n \n     reg [15:0] sum [3:0];//[size/2-1:1]\n always @(posedge clk or negedge rst_n) \n       if(!rst_n) begin\n          sum[0]  <= 'd0;\n          sum[1]  <= 'd0;\n          sum[2]  <= 'd0;\n          sum[3]  <= 'd0;\n       end \n       else begin\n          sum[0] <= temp[0] + temp[1];\n          sum[1] <= temp[2] + temp[3];\n          sum[2] <= temp[4] + temp[5];\n          sum[3] <= temp[6] + temp[7];\n       end\n \n     reg [15:0] mul_out_reg;\n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out_reg <= 'd0;\n       else \n          mul_out_reg <= sum[0] + sum[1] + sum[2] + sum[3];\n \n \n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out <= 'd0;\n       else if(mul_en_out_reg[2])\n          mul_out <= mul_out_reg;\n       else\n          mul_out <= 'd0;\n \n          \nendmodule", "corruption_explanation": "Added conflicting driver for signal 'temp'", "modification_type": "add_multiple_driver", "modification_line": 55, "original_snippet": "assign temp[5] = mul_b_reg[5]? {3'b0,mul_a_reg,5'b0} : 'd0;", "modified_snippet": "assign temp[5] = mul_b_reg[5]? {3'b0,mul_a_reg,5'b0} : 'd0;\nassign temp = 1'b0;  // Conflicting assignment", "issue_description": "The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_multiple_driver modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added conflicting driver for signal 'temp'\n   \u2022 Line 55: Original: assign temp[5] = mul_b_reg[5]? {3'b0,mul_a_reg,5'b0} : 'd0;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 55.\n   \u2022 Restore the original code: assign temp[5] = mul_b_reg[5]? {3'b0,mul_a_reg,5'b0} : 'd0;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add multiple driver.", "complexity": 13, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "add_multiple_driver", "invert_condition", "invert_reset_polarity", "remove_async_reset"], "stacked_count": 1, "applied_modifications": ["add_multiple_driver"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.097352", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_pipe_8bit", "module_name": "multi_pipe_8bit", "description": "Please act as a professional verilog designer.\n\nImplement the design of unsigned 8bit multiplier based on pipelining processing. It utilizes a clock signal (clk), an active-low reset signal (rst_n), an input enable signal (mul_en_in), and provides an output enable signal (mul_en_out) and the product output (mul_out) of size 16 bits.\n\nModule name:  \n    multi_pipe_8bit \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    mul_en_in: Input enable signal that controls the multiplication operation.\n    mul_a: Input signal representing the multiplicand with a data width of 8 bits.\n    mul_b: Input signal representing the multiplier with a data width of 8 bits.\n\nOutput ports:\n    mul_en_out: Output enable signal indicating if the multiplication operation is enabled.\n    mul_out: Product output signal with a data width of 16 bits.\n\nImplementation:\nThe module utilizes a pipeline architecture to improve performance. It consists of several key components:\nInput Control:\nThe module includes an input enable signal, mul_en_in, which controls the multiplication operation.\nOn the positive edge of the clock signal, the module samples the input enable signal and stores it in a register, mul_en_out_reg.\nThe output enable signal, mul_en_out, is derived from the most significant bit of mul_en_out_reg, indicating whether the multiplication operation is enabled.\n\nInput Registers:\nThe module includes registers, mul_a_reg and mul_b_reg, to store the input multiplicand and multiplier, respectively.\nOn the positive edge of the clock signal, the module samples the input values and stores them in the corresponding registers.\nThe registers are only updated when the input enable signal is active.\n\nPartial Product Generation:\nThe module generates partial products by performing bitwise operations between the multiplicand and the individual bits of the multiplier.\nIt uses conditional assignments to select the appropriate bits from the multiplicand based on the multiplier bits.\nThe partial products are stored in a set of wires, temp, with each wire representing a different bit position.\n\nPartial Sum Calculation:\nThe module performs addition operations on the partial products to calculate partial sums.\nIt uses a set of registers, sum, to store the intermediate sum values.\nEach register corresponds to a group of partial products and is updated on the positive edge of the clock signal.\n\nFinal Product Calculation:\nThe module sums up all the partial sums to obtain the final product.\nIt uses a register, mul_out_reg, to store the accumulated sum.\nOn the positive edge of the clock signal, the register is updated with the sum of all partial sums.\n\nOutput Assignment:\nThe module assigns the output product value, mul_out, based on the output enable signal and the value in mul_out_reg.\nIf the output enable signal is active, indicating a valid product, the value in mul_out_reg is assigned to mul_out.\nOtherwise, mul_out is set to 0.\n\nGive me the complete code.\n"}, "clean_code": "module multi_pipe_8bit#(\n    parameter size = 8\n)(\n          clk,      \n          rst_n,       \n          mul_a,       \n          mul_b, \n          mul_en_in,\n \n          mul_en_out,      \n          mul_out    \n);\n \n   input clk;           \n   input rst_n; \n   input mul_en_in;      \n   input [size-1:0] mul_a;       \n   input [size-1:0] mul_b;       \n \n   output reg mul_en_out;  \n   output reg [size*2-1:0] mul_out;    \n \n            \n   reg [2:0] mul_en_out_reg;\n always@(posedge clk or negedge rst_n)\n       if(!rst_n)begin\n            mul_en_out_reg <= 'd0;             \n            mul_en_out     <= 'd0;                           \n       end\n       else begin\n            mul_en_out_reg <= {mul_en_out_reg[1:0],mul_en_in};            \n            mul_en_out     <= mul_en_out_reg[2];                  \n       end\n \n \n    reg [7:0] mul_a_reg;\n    reg [7:0] mul_b_reg;\n  always @(posedge clk or negedge rst_n)\n         if(!rst_n) begin\n              mul_a_reg <= 'd0;\n              mul_a_reg <= 'd0;\n         end\n         else begin\n              mul_a_reg <= mul_en_in ? mul_a :'d0;\n              mul_b_reg <= mul_en_in ? mul_b :'d0;\n         end\n \n  \n     wire [15:0] temp [size-1:0];\n  assign temp[0] = mul_b_reg[0]? {8'b0,mul_a_reg} : 'd0;\n  assign temp[1] = mul_b_reg[1]? {7'b0,mul_a_reg,1'b0} : 'd0;\n  assign temp[2] = mul_b_reg[2]? {6'b0,mul_a_reg,2'b0} : 'd0;\n  assign temp[3] = mul_b_reg[3]? {5'b0,mul_a_reg,3'b0} : 'd0;\n  assign temp[4] = mul_b_reg[4]? {4'b0,mul_a_reg,4'b0} : 'd0;\n  assign temp[5] = mul_b_reg[5]? {3'b0,mul_a_reg,5'b0} : 'd0;\n  assign temp[6] = mul_b_reg[6]? {2'b0,mul_a_reg,6'b0} : 'd0;\n  assign temp[7] = mul_b_reg[7]? {1'b0,mul_a_reg,7'b0} : 'd0; \n \n \n     reg [15:0] sum [3:0];//[size/2-1:1]\n always @(posedge clk or negedge rst_n) \n       if(!rst_n) begin\n          sum[0]  <= 'd0;\n          sum[1]  <= 'd0;\n          sum[2]  <= 'd0;\n          sum[3]  <= 'd0;\n       end \n       else begin\n          sum[0] <= temp[0] + temp[1];\n          sum[1] <= temp[2] + temp[3];\n          sum[2] <= temp[4] + temp[5];\n          sum[3] <= temp[6] + temp[7];\n       end\n \n     reg [15:0] mul_out_reg;\n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out_reg <= 'd0;\n       else \n          mul_out_reg <= sum[0] + sum[1] + sum[2] + sum[3];\n \n \n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out <= 'd0;\n       else if(mul_en_out_reg[2])\n          mul_out <= mul_out_reg;\n       else\n          mul_out <= 'd0;\n \n          \nendmodule", "corrupted_code": "module multi_pipe_8bit#(\n    parameter size = 8\n)(\n          clk,      \n          rst_n,       \n          mul_a,       \n          mul_b, \n          mul_en_in,\n \n          mul_en_out,      \n          mul_out    \n);\n \n   input clk;           \n   input rst_n; \n   input mul_en_in;      \n   input [size-1:0] mul_a;       \n   input [size-1:0] mul_b;       \n \n   output reg mul_en_out;  \n   output reg [size*2-1:0] mul_out;    \n \n            \n   reg [2:0] mul_en_out_reg;\n always@(posedge clk or negedge rst_n)\n       if(!rst_n)begin\n            mul_en_out_reg <= 'd0;             \n            mul_en_out = 'd0;                           \n       end\n       else begin\n            mul_en_out_reg <= {mul_en_out_reg[1:0],mul_en_in};            \n            mul_en_out     <= mul_en_out_reg[2];                  \n       end\n \n \n    reg [7:0] mul_a_reg;\n    reg [7:0] mul_b_reg;\n  always @(posedge clk or negedge rst_n)\n         if(!rst_n) begin\n              mul_a_reg <= 'd0;\n              mul_a_reg <= 'd0;\n         end\n         else begin\n              mul_a_reg <= mul_en_in ? mul_a :'d0;\n              mul_b_reg <= mul_en_in ? mul_b :'d0;\n         end\n \n  \n     wire [15:0] temp [size-1:0];\n  assign temp[0] = mul_b_reg[0]? {8'b0,mul_a_reg} : 'd0;\n  assign temp[1] = mul_b_reg[1]? {7'b0,mul_a_reg,1'b0} : 'd0;\n  assign temp[2] = mul_b_reg[2]? {6'b0,mul_a_reg,2'b0} : 'd0;\n  assign temp[3] = mul_b_reg[3]? {5'b0,mul_a_reg,3'b0} : 'd0;\n  assign temp[4] = mul_b_reg[4]? {4'b0,mul_a_reg,4'b0} : 'd0;\n  assign temp[5] = mul_b_reg[5]? {3'b0,mul_a_reg,5'b0} : 'd0;\n  assign temp[6] = mul_b_reg[6]? {2'b0,mul_a_reg,6'b0} : 'd0;\n  assign temp[7] = mul_b_reg[7]? {1'b0,mul_a_reg,7'b0} : 'd0; \n \n \n     reg [15:0] sum [3:0];//[size/2-1:1]\n always @(posedge clk or negedge rst_n) \n       if(!rst_n) begin\n          sum[0]  <= 'd0;\n          sum[1]  <= 'd0;\n          sum[2]  <= 'd0;\n          sum[3]  <= 'd0;\n       end \n       else begin\n          sum[0] <= temp[0] + temp[1];\n          sum[1] <= temp[2] + temp[3];\n          sum[2] <= temp[4] + temp[5];\n          sum[3] <= temp[6] + temp[7];\n       end\n \n     reg [15:0] mul_out_reg;\n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out_reg <= 'd0;\n       else \n          mul_out_reg <= sum[0] + sum[1] + sum[2] + sum[3];\n \n \n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out <= 'd0;\n       else if(mul_en_out_reg[2])\n          mul_out <= mul_out_reg;\n       else\n          mul_out <= 'd0;\n \n          \nendmodule", "corruption_explanation": "Changed non-blocking (<=) to blocking (=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 28, "original_snippet": "mul_en_out     <= 'd0;", "modified_snippet": "mul_en_out = 'd0;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 13, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "add_multiple_driver", "invert_condition", "invert_reset_polarity", "remove_async_reset"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.100582", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_pipe_8bit", "module_name": "multi_pipe_8bit", "description": "Please act as a professional verilog designer.\n\nImplement the design of unsigned 8bit multiplier based on pipelining processing. It utilizes a clock signal (clk), an active-low reset signal (rst_n), an input enable signal (mul_en_in), and provides an output enable signal (mul_en_out) and the product output (mul_out) of size 16 bits.\n\nModule name:  \n    multi_pipe_8bit \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    mul_en_in: Input enable signal that controls the multiplication operation.\n    mul_a: Input signal representing the multiplicand with a data width of 8 bits.\n    mul_b: Input signal representing the multiplier with a data width of 8 bits.\n\nOutput ports:\n    mul_en_out: Output enable signal indicating if the multiplication operation is enabled.\n    mul_out: Product output signal with a data width of 16 bits.\n\nImplementation:\nThe module utilizes a pipeline architecture to improve performance. It consists of several key components:\nInput Control:\nThe module includes an input enable signal, mul_en_in, which controls the multiplication operation.\nOn the positive edge of the clock signal, the module samples the input enable signal and stores it in a register, mul_en_out_reg.\nThe output enable signal, mul_en_out, is derived from the most significant bit of mul_en_out_reg, indicating whether the multiplication operation is enabled.\n\nInput Registers:\nThe module includes registers, mul_a_reg and mul_b_reg, to store the input multiplicand and multiplier, respectively.\nOn the positive edge of the clock signal, the module samples the input values and stores them in the corresponding registers.\nThe registers are only updated when the input enable signal is active.\n\nPartial Product Generation:\nThe module generates partial products by performing bitwise operations between the multiplicand and the individual bits of the multiplier.\nIt uses conditional assignments to select the appropriate bits from the multiplicand based on the multiplier bits.\nThe partial products are stored in a set of wires, temp, with each wire representing a different bit position.\n\nPartial Sum Calculation:\nThe module performs addition operations on the partial products to calculate partial sums.\nIt uses a set of registers, sum, to store the intermediate sum values.\nEach register corresponds to a group of partial products and is updated on the positive edge of the clock signal.\n\nFinal Product Calculation:\nThe module sums up all the partial sums to obtain the final product.\nIt uses a register, mul_out_reg, to store the accumulated sum.\nOn the positive edge of the clock signal, the register is updated with the sum of all partial sums.\n\nOutput Assignment:\nThe module assigns the output product value, mul_out, based on the output enable signal and the value in mul_out_reg.\nIf the output enable signal is active, indicating a valid product, the value in mul_out_reg is assigned to mul_out.\nOtherwise, mul_out is set to 0.\n\nGive me the complete code.\n"}, "clean_code": "module multi_pipe_8bit#(\n    parameter size = 8\n)(\n          clk,      \n          rst_n,       \n          mul_a,       \n          mul_b, \n          mul_en_in,\n \n          mul_en_out,      \n          mul_out    \n);\n \n   input clk;           \n   input rst_n; \n   input mul_en_in;      \n   input [size-1:0] mul_a;       \n   input [size-1:0] mul_b;       \n \n   output reg mul_en_out;  \n   output reg [size*2-1:0] mul_out;    \n \n            \n   reg [2:0] mul_en_out_reg;\n always@(posedge clk or negedge rst_n)\n       if(!rst_n)begin\n            mul_en_out_reg <= 'd0;             \n            mul_en_out     <= 'd0;                           \n       end\n       else begin\n            mul_en_out_reg <= {mul_en_out_reg[1:0],mul_en_in};            \n            mul_en_out     <= mul_en_out_reg[2];                  \n       end\n \n \n    reg [7:0] mul_a_reg;\n    reg [7:0] mul_b_reg;\n  always @(posedge clk or negedge rst_n)\n         if(!rst_n) begin\n              mul_a_reg <= 'd0;\n              mul_a_reg <= 'd0;\n         end\n         else begin\n              mul_a_reg <= mul_en_in ? mul_a :'d0;\n              mul_b_reg <= mul_en_in ? mul_b :'d0;\n         end\n \n  \n     wire [15:0] temp [size-1:0];\n  assign temp[0] = mul_b_reg[0]? {8'b0,mul_a_reg} : 'd0;\n  assign temp[1] = mul_b_reg[1]? {7'b0,mul_a_reg,1'b0} : 'd0;\n  assign temp[2] = mul_b_reg[2]? {6'b0,mul_a_reg,2'b0} : 'd0;\n  assign temp[3] = mul_b_reg[3]? {5'b0,mul_a_reg,3'b0} : 'd0;\n  assign temp[4] = mul_b_reg[4]? {4'b0,mul_a_reg,4'b0} : 'd0;\n  assign temp[5] = mul_b_reg[5]? {3'b0,mul_a_reg,5'b0} : 'd0;\n  assign temp[6] = mul_b_reg[6]? {2'b0,mul_a_reg,6'b0} : 'd0;\n  assign temp[7] = mul_b_reg[7]? {1'b0,mul_a_reg,7'b0} : 'd0; \n \n \n     reg [15:0] sum [3:0];//[size/2-1:1]\n always @(posedge clk or negedge rst_n) \n       if(!rst_n) begin\n          sum[0]  <= 'd0;\n          sum[1]  <= 'd0;\n          sum[2]  <= 'd0;\n          sum[3]  <= 'd0;\n       end \n       else begin\n          sum[0] <= temp[0] + temp[1];\n          sum[1] <= temp[2] + temp[3];\n          sum[2] <= temp[4] + temp[5];\n          sum[3] <= temp[6] + temp[7];\n       end\n \n     reg [15:0] mul_out_reg;\n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out_reg <= 'd0;\n       else \n          mul_out_reg <= sum[0] + sum[1] + sum[2] + sum[3];\n \n \n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out <= 'd0;\n       else if(mul_en_out_reg[2])\n          mul_out <= mul_out_reg;\n       else\n          mul_out <= 'd0;\n \n          \nendmodule", "corrupted_code": "module multi_pipe_8bit#(\n    parameter size = 8\n)(\n          clk,      \n          rst_n,       \n          mul_a,       \n          mul_b, \n          mul_en_in,\n \n          mul_en_out,      \n          mul_out    \n);\n \n   input clk;           \n   input rst_n; \n   input mul_en_in;      \n   input [size-1:0] mul_a;       \n   input [size-1:0] mul_b;       \n \n   output reg mul_en_out;  \n   output reg [size*2-1:0] mul_out;    \n \n            \n   reg [2:0] mul_en_out_reg;\n always@(posedge clk or negedge rst_n)\n       if(!rst_n)begin\n            mul_en_out_reg <= 'd0;             \n            mul_en_out     <= 'd0;                           \n       end\n       else begin\n            mul_en_out_reg <= {mul_en_out_reg[1:0],mul_en_in};            \n            mul_en_out     <= mul_en_out_reg[2];                  \n       end\n \n \n    reg [7:0] mul_a_reg;\n    reg [7:0] mul_b_reg;\n  always @(posedge clk or negedge rst_n)\n         if(!rst_n) begin\n\n              mul_a_reg <= 'd0;\n         end\n         else begin\n              mul_a_reg <= mul_en_in ? mul_a :'d0;\n              mul_b_reg <= mul_en_in ? mul_b :'d0;\n         end\n \n  \n     wire [15:0] temp [size-1:0];\n  assign temp[0] = mul_b_reg[0]? {8'b0,mul_a_reg} : 'd0;\n  assign temp[1] = mul_b_reg[1]? {7'b0,mul_a_reg,1'b0} : 'd0;\n  assign temp[2] = mul_b_reg[2]? {6'b0,mul_a_reg,2'b0} : 'd0;\n  assign temp[3] = mul_b_reg[3]? {5'b0,mul_a_reg,3'b0} : 'd0;\n  assign temp[4] = mul_b_reg[4]? {4'b0,mul_a_reg,4'b0} : 'd0;\n  assign temp[5] = mul_b_reg[5]? {3'b0,mul_a_reg,5'b0} : 'd0;\n  assign temp[6] = mul_b_reg[6]? {2'b0,mul_a_reg,6'b0} : 'd0;\n  assign temp[7] = mul_b_reg[7]? {1'b0,mul_a_reg,7'b0} : 'd0; \n \n \n     reg [15:0] sum [3:0];//[size/2-1:1]\n always @(posedge clk or negedge rst_n) \n       if(!rst_n) begin\n          sum[0]  <= 'd0;\n          sum[1]  <= 'd0;\n          sum[2]  <= 'd0;\n          sum[3]  <= 'd0;\n       end \n       else begin\n          sum[0] <= temp[0] + temp[1];\n          sum[1] <= temp[2] + temp[3];\n          sum[2] <= temp[4] + temp[5];\n          sum[3] <= temp[6] + temp[7];\n       end\n \n     reg [15:0] mul_out_reg;\n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out_reg <= 'd0;\n       else \n          mul_out_reg <= sum[0] + sum[1] + sum[2] + sum[3];\n \n \n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out <= 'd0;\n       else if(mul_en_out_reg[2])\n          mul_out <= mul_out_reg;\n       else\n          mul_out <= 'd0;\n \n          \nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 40, "original_snippet": "mul_a_reg <= 'd0;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 40: Original: mul_a_reg <= 'd0;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 40.\n   \u2022 Restore the original code: mul_a_reg <= 'd0;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 13, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "add_multiple_driver", "invert_condition", "invert_reset_polarity", "remove_async_reset"], "stacked_count": 1, "applied_modifications": ["remove_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.103465", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_pipe_8bit", "module_name": "multi_pipe_8bit", "description": "Please act as a professional verilog designer.\n\nImplement the design of unsigned 8bit multiplier based on pipelining processing. It utilizes a clock signal (clk), an active-low reset signal (rst_n), an input enable signal (mul_en_in), and provides an output enable signal (mul_en_out) and the product output (mul_out) of size 16 bits.\n\nModule name:  \n    multi_pipe_8bit \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    mul_en_in: Input enable signal that controls the multiplication operation.\n    mul_a: Input signal representing the multiplicand with a data width of 8 bits.\n    mul_b: Input signal representing the multiplier with a data width of 8 bits.\n\nOutput ports:\n    mul_en_out: Output enable signal indicating if the multiplication operation is enabled.\n    mul_out: Product output signal with a data width of 16 bits.\n\nImplementation:\nThe module utilizes a pipeline architecture to improve performance. It consists of several key components:\nInput Control:\nThe module includes an input enable signal, mul_en_in, which controls the multiplication operation.\nOn the positive edge of the clock signal, the module samples the input enable signal and stores it in a register, mul_en_out_reg.\nThe output enable signal, mul_en_out, is derived from the most significant bit of mul_en_out_reg, indicating whether the multiplication operation is enabled.\n\nInput Registers:\nThe module includes registers, mul_a_reg and mul_b_reg, to store the input multiplicand and multiplier, respectively.\nOn the positive edge of the clock signal, the module samples the input values and stores them in the corresponding registers.\nThe registers are only updated when the input enable signal is active.\n\nPartial Product Generation:\nThe module generates partial products by performing bitwise operations between the multiplicand and the individual bits of the multiplier.\nIt uses conditional assignments to select the appropriate bits from the multiplicand based on the multiplier bits.\nThe partial products are stored in a set of wires, temp, with each wire representing a different bit position.\n\nPartial Sum Calculation:\nThe module performs addition operations on the partial products to calculate partial sums.\nIt uses a set of registers, sum, to store the intermediate sum values.\nEach register corresponds to a group of partial products and is updated on the positive edge of the clock signal.\n\nFinal Product Calculation:\nThe module sums up all the partial sums to obtain the final product.\nIt uses a register, mul_out_reg, to store the accumulated sum.\nOn the positive edge of the clock signal, the register is updated with the sum of all partial sums.\n\nOutput Assignment:\nThe module assigns the output product value, mul_out, based on the output enable signal and the value in mul_out_reg.\nIf the output enable signal is active, indicating a valid product, the value in mul_out_reg is assigned to mul_out.\nOtherwise, mul_out is set to 0.\n\nGive me the complete code.\n"}, "clean_code": "module multi_pipe_8bit#(\n    parameter size = 8\n)(\n          clk,      \n          rst_n,       \n          mul_a,       \n          mul_b, \n          mul_en_in,\n \n          mul_en_out,      \n          mul_out    \n);\n \n   input clk;           \n   input rst_n; \n   input mul_en_in;      \n   input [size-1:0] mul_a;       \n   input [size-1:0] mul_b;       \n \n   output reg mul_en_out;  \n   output reg [size*2-1:0] mul_out;    \n \n            \n   reg [2:0] mul_en_out_reg;\n always@(posedge clk or negedge rst_n)\n       if(!rst_n)begin\n            mul_en_out_reg <= 'd0;             \n            mul_en_out     <= 'd0;                           \n       end\n       else begin\n            mul_en_out_reg <= {mul_en_out_reg[1:0],mul_en_in};            \n            mul_en_out     <= mul_en_out_reg[2];                  \n       end\n \n \n    reg [7:0] mul_a_reg;\n    reg [7:0] mul_b_reg;\n  always @(posedge clk or negedge rst_n)\n         if(!rst_n) begin\n              mul_a_reg <= 'd0;\n              mul_a_reg <= 'd0;\n         end\n         else begin\n              mul_a_reg <= mul_en_in ? mul_a :'d0;\n              mul_b_reg <= mul_en_in ? mul_b :'d0;\n         end\n \n  \n     wire [15:0] temp [size-1:0];\n  assign temp[0] = mul_b_reg[0]? {8'b0,mul_a_reg} : 'd0;\n  assign temp[1] = mul_b_reg[1]? {7'b0,mul_a_reg,1'b0} : 'd0;\n  assign temp[2] = mul_b_reg[2]? {6'b0,mul_a_reg,2'b0} : 'd0;\n  assign temp[3] = mul_b_reg[3]? {5'b0,mul_a_reg,3'b0} : 'd0;\n  assign temp[4] = mul_b_reg[4]? {4'b0,mul_a_reg,4'b0} : 'd0;\n  assign temp[5] = mul_b_reg[5]? {3'b0,mul_a_reg,5'b0} : 'd0;\n  assign temp[6] = mul_b_reg[6]? {2'b0,mul_a_reg,6'b0} : 'd0;\n  assign temp[7] = mul_b_reg[7]? {1'b0,mul_a_reg,7'b0} : 'd0; \n \n \n     reg [15:0] sum [3:0];//[size/2-1:1]\n always @(posedge clk or negedge rst_n) \n       if(!rst_n) begin\n          sum[0]  <= 'd0;\n          sum[1]  <= 'd0;\n          sum[2]  <= 'd0;\n          sum[3]  <= 'd0;\n       end \n       else begin\n          sum[0] <= temp[0] + temp[1];\n          sum[1] <= temp[2] + temp[3];\n          sum[2] <= temp[4] + temp[5];\n          sum[3] <= temp[6] + temp[7];\n       end\n \n     reg [15:0] mul_out_reg;\n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out_reg <= 'd0;\n       else \n          mul_out_reg <= sum[0] + sum[1] + sum[2] + sum[3];\n \n \n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out <= 'd0;\n       else if(mul_en_out_reg[2])\n          mul_out <= mul_out_reg;\n       else\n          mul_out <= 'd0;\n \n          \nendmodule", "corrupted_code": "module multi_pipe_8bit#(\n    parameter size = 8\n)(\n          clk,      \n          rst_n,       \n          mul_a,       \n          mul_b, \n          mul_en_in,\n \n          mul_en_out,      \n          mul_out    \n);\n \n   input clk;           \n   input rst_n; \n   input mul_en_in;      \n   input [size-1:0] mul_a;       \n   input [size-1:0] mul_b;       \n \n   output reg mul_en_out;  \n   output reg [size*2-1:0] mul_out;    \n \n            \n   reg [2:0] mul_en_out_reg;\n always@(posedge clk or negedge rst_n)\n       if(!rst_n)begin\n            mul_en_out_reg <= 'd0;             \n            mul_en_out     <= 'd0;                           \n       end\n       else begin\n            mul_en_out_reg <= {mul_en_out_reg[1:0],mul_en_in};            \n            mul_en_out     <= mul_en_out_reg[2];                  \n       end\n \n \n    reg [7:0] mul_a_reg;\n    reg [7:0] mul_b_reg;\n  always @(posedge clk or negedge rst_n)\n         if(!rst_n) begin\n              mul_a_reg <= mul_en_in ? mul_a :'d0;\n              mul_b_reg <= mul_en_in ? mul_b :'d0;\n         end\n         else begin\n              mul_a_reg <= 'd0;\n              mul_a_reg <= 'd0;\n         end\n \n  \n     wire [15:0] temp [size-1:0];\n  assign temp[0] = mul_b_reg[0]? {8'b0,mul_a_reg} : 'd0;\n  assign temp[1] = mul_b_reg[1]? {7'b0,mul_a_reg,1'b0} : 'd0;\n  assign temp[2] = mul_b_reg[2]? {6'b0,mul_a_reg,2'b0} : 'd0;\n  assign temp[3] = mul_b_reg[3]? {5'b0,mul_a_reg,3'b0} : 'd0;\n  assign temp[4] = mul_b_reg[4]? {4'b0,mul_a_reg,4'b0} : 'd0;\n  assign temp[5] = mul_b_reg[5]? {3'b0,mul_a_reg,5'b0} : 'd0;\n  assign temp[6] = mul_b_reg[6]? {2'b0,mul_a_reg,6'b0} : 'd0;\n  assign temp[7] = mul_b_reg[7]? {1'b0,mul_a_reg,7'b0} : 'd0; \n \n \n     reg [15:0] sum [3:0];//[size/2-1:1]\n always @(posedge clk or negedge rst_n) \n       if(!rst_n) begin\n          sum[0]  <= 'd0;\n          sum[1]  <= 'd0;\n          sum[2]  <= 'd0;\n          sum[3]  <= 'd0;\n       end \n       else begin\n          sum[0] <= temp[0] + temp[1];\n          sum[1] <= temp[2] + temp[3];\n          sum[2] <= temp[4] + temp[5];\n          sum[3] <= temp[6] + temp[7];\n       end\n \n     reg [15:0] mul_out_reg;\n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out_reg <= 'd0;\n       else \n          mul_out_reg <= sum[0] + sum[1] + sum[2] + sum[3];\n \n \n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out <= 'd0;\n       else if(mul_en_out_reg[2])\n          mul_out <= mul_out_reg;\n       else\n          mul_out <= 'd0;\n \n          \nendmodule", "corruption_explanation": "Swapped if and else bodies", "modification_type": "invert_if_else", "modification_line": 39, "original_snippet": "if(!rst_n) begin\n              mul_a_reg <= 'd0;\n              mul_a_reg <= 'd0;\n         end\n         else begin\n              mul_a_reg <= mul_en_in ? mul_a :'d0;\n              mul_b_reg <= mul_en_i", "modified_snippet": "if(!rst_n) begin\n              mul_a_reg <= mul_en_in ? mul_a :'d0;\n              mul_b_reg <= mul_en_in ? mul_b :'d0;\n         end\n         else begin\n              mul_a_reg <= 'd0;\n              mu", "issue_description": "The buggy code has swapped if and else bodies in a conditional block. This causes the logic to execute the opposite branch for each condition, leading to incorrect behavior when the condition is true vs false. Test cases that depend on the conditional logic will fail because the intended branch is not executed.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module contains conditional logic that should execute different code paths based on a condition.\n   \u2022 The if branch should handle the true case, and the else branch should handle the false case.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Identified a conditional block with both if and else branches.\n   \u2022 The branches contain different assignments or logic operations.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The if and else bodies have been swapped.\n   \u2022 Logic that should execute when condition is true now executes when false, and vice versa.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The conditional bodies are inverted.\n   \u2022 Impact: All conditional behavior is reversed, causing incorrect outputs for all test cases.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Swap the if and else bodies back to their correct positions.\n   \u2022 Verify that the condition evaluates correctly and executes the intended branch.\n\n6. RTL Design Principle Violated:\n   \u2022 Correct conditional logic requires matching the intended behavior with the branch bodies.", "complexity": 13, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "add_multiple_driver", "invert_condition", "invert_reset_polarity", "remove_async_reset"], "stacked_count": 1, "applied_modifications": ["invert_if_else"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.106780", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_pipe_8bit", "module_name": "multi_pipe_8bit", "description": "Please act as a professional verilog designer.\n\nImplement the design of unsigned 8bit multiplier based on pipelining processing. It utilizes a clock signal (clk), an active-low reset signal (rst_n), an input enable signal (mul_en_in), and provides an output enable signal (mul_en_out) and the product output (mul_out) of size 16 bits.\n\nModule name:  \n    multi_pipe_8bit \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    mul_en_in: Input enable signal that controls the multiplication operation.\n    mul_a: Input signal representing the multiplicand with a data width of 8 bits.\n    mul_b: Input signal representing the multiplier with a data width of 8 bits.\n\nOutput ports:\n    mul_en_out: Output enable signal indicating if the multiplication operation is enabled.\n    mul_out: Product output signal with a data width of 16 bits.\n\nImplementation:\nThe module utilizes a pipeline architecture to improve performance. It consists of several key components:\nInput Control:\nThe module includes an input enable signal, mul_en_in, which controls the multiplication operation.\nOn the positive edge of the clock signal, the module samples the input enable signal and stores it in a register, mul_en_out_reg.\nThe output enable signal, mul_en_out, is derived from the most significant bit of mul_en_out_reg, indicating whether the multiplication operation is enabled.\n\nInput Registers:\nThe module includes registers, mul_a_reg and mul_b_reg, to store the input multiplicand and multiplier, respectively.\nOn the positive edge of the clock signal, the module samples the input values and stores them in the corresponding registers.\nThe registers are only updated when the input enable signal is active.\n\nPartial Product Generation:\nThe module generates partial products by performing bitwise operations between the multiplicand and the individual bits of the multiplier.\nIt uses conditional assignments to select the appropriate bits from the multiplicand based on the multiplier bits.\nThe partial products are stored in a set of wires, temp, with each wire representing a different bit position.\n\nPartial Sum Calculation:\nThe module performs addition operations on the partial products to calculate partial sums.\nIt uses a set of registers, sum, to store the intermediate sum values.\nEach register corresponds to a group of partial products and is updated on the positive edge of the clock signal.\n\nFinal Product Calculation:\nThe module sums up all the partial sums to obtain the final product.\nIt uses a register, mul_out_reg, to store the accumulated sum.\nOn the positive edge of the clock signal, the register is updated with the sum of all partial sums.\n\nOutput Assignment:\nThe module assigns the output product value, mul_out, based on the output enable signal and the value in mul_out_reg.\nIf the output enable signal is active, indicating a valid product, the value in mul_out_reg is assigned to mul_out.\nOtherwise, mul_out is set to 0.\n\nGive me the complete code.\n"}, "clean_code": "module multi_pipe_8bit#(\n    parameter size = 8\n)(\n          clk,      \n          rst_n,       \n          mul_a,       \n          mul_b, \n          mul_en_in,\n \n          mul_en_out,      \n          mul_out    \n);\n \n   input clk;           \n   input rst_n; \n   input mul_en_in;      \n   input [size-1:0] mul_a;       \n   input [size-1:0] mul_b;       \n \n   output reg mul_en_out;  \n   output reg [size*2-1:0] mul_out;    \n \n            \n   reg [2:0] mul_en_out_reg;\n always@(posedge clk or negedge rst_n)\n       if(!rst_n)begin\n            mul_en_out_reg <= 'd0;             \n            mul_en_out     <= 'd0;                           \n       end\n       else begin\n            mul_en_out_reg <= {mul_en_out_reg[1:0],mul_en_in};            \n            mul_en_out     <= mul_en_out_reg[2];                  \n       end\n \n \n    reg [7:0] mul_a_reg;\n    reg [7:0] mul_b_reg;\n  always @(posedge clk or negedge rst_n)\n         if(!rst_n) begin\n              mul_a_reg <= 'd0;\n              mul_a_reg <= 'd0;\n         end\n         else begin\n              mul_a_reg <= mul_en_in ? mul_a :'d0;\n              mul_b_reg <= mul_en_in ? mul_b :'d0;\n         end\n \n  \n     wire [15:0] temp [size-1:0];\n  assign temp[0] = mul_b_reg[0]? {8'b0,mul_a_reg} : 'd0;\n  assign temp[1] = mul_b_reg[1]? {7'b0,mul_a_reg,1'b0} : 'd0;\n  assign temp[2] = mul_b_reg[2]? {6'b0,mul_a_reg,2'b0} : 'd0;\n  assign temp[3] = mul_b_reg[3]? {5'b0,mul_a_reg,3'b0} : 'd0;\n  assign temp[4] = mul_b_reg[4]? {4'b0,mul_a_reg,4'b0} : 'd0;\n  assign temp[5] = mul_b_reg[5]? {3'b0,mul_a_reg,5'b0} : 'd0;\n  assign temp[6] = mul_b_reg[6]? {2'b0,mul_a_reg,6'b0} : 'd0;\n  assign temp[7] = mul_b_reg[7]? {1'b0,mul_a_reg,7'b0} : 'd0; \n \n \n     reg [15:0] sum [3:0];//[size/2-1:1]\n always @(posedge clk or negedge rst_n) \n       if(!rst_n) begin\n          sum[0]  <= 'd0;\n          sum[1]  <= 'd0;\n          sum[2]  <= 'd0;\n          sum[3]  <= 'd0;\n       end \n       else begin\n          sum[0] <= temp[0] + temp[1];\n          sum[1] <= temp[2] + temp[3];\n          sum[2] <= temp[4] + temp[5];\n          sum[3] <= temp[6] + temp[7];\n       end\n \n     reg [15:0] mul_out_reg;\n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out_reg <= 'd0;\n       else \n          mul_out_reg <= sum[0] + sum[1] + sum[2] + sum[3];\n \n \n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out <= 'd0;\n       else if(mul_en_out_reg[2])\n          mul_out <= mul_out_reg;\n       else\n          mul_out <= 'd0;\n \n          \nendmodule", "corrupted_code": "module multi_pipe_8bit#(\n    parameter size = 8\n)(\n          clk,      \n          rst_n,       \n          mul_a,       \n          mul_b, \n          mul_en_in,\n \n          mul_en_out,      \n          mul_out    \n);\n \n   input clk;           \n   input rst_n; \n   input mul_en_in;      \n   input [size-1:0] mul_a;       \n   input [size-1:0] mul_b;       \n \n   output reg mul_en_out;  \n   output reg [size*2-1:0] mul_out;    \n \n            \n   reg [2:0] mul_en_out_reg;\n always@(posedge clk or negedge rst_n)\n       if(!rst_n)begin\n            mul_en_out_reg <= 'd0;             \n            mul_en_out     <= 'd0;                           \n       end\n       else begin\n            mul_en_out_reg <= {mul_en_out_reg[1:0],mul_en_in};            \n            mul_en_out     <= mul_en_out_reg[2];                  \n       end\n \n \n    reg [7:0] mul_a_reg;\n    reg [7:0] mul_b_reg;\n  always @(posedge clk or negedge rst_n)\n         if(!rst_n) begin\n              mul_a_reg <= 'd0;\n              mul_a_reg <= 'd0;\n         end\n         else begin\n              mul_a_reg <= mul_en_in ? mul_a :'d0;\n              mul_b_reg <= mul_en_in ? mul_b :'d0;\n         end\n \n  \n     wire [15:0] temp [1 - size:0];\n  assign temp[0] = mul_b_reg[0]? {8'b0,mul_a_reg} : 'd0;\n  assign temp[1] = mul_b_reg[1]? {7'b0,mul_a_reg,1'b0} : 'd0;\n  assign temp[2] = mul_b_reg[2]? {6'b0,mul_a_reg,2'b0} : 'd0;\n  assign temp[3] = mul_b_reg[3]? {5'b0,mul_a_reg,3'b0} : 'd0;\n  assign temp[4] = mul_b_reg[4]? {4'b0,mul_a_reg,4'b0} : 'd0;\n  assign temp[5] = mul_b_reg[5]? {3'b0,mul_a_reg,5'b0} : 'd0;\n  assign temp[6] = mul_b_reg[6]? {2'b0,mul_a_reg,6'b0} : 'd0;\n  assign temp[7] = mul_b_reg[7]? {1'b0,mul_a_reg,7'b0} : 'd0; \n \n \n     reg [15:0] sum [3:0];//[size/2-1:1]\n always @(posedge clk or negedge rst_n) \n       if(!rst_n) begin\n          sum[0]  <= 'd0;\n          sum[1]  <= 'd0;\n          sum[2]  <= 'd0;\n          sum[3]  <= 'd0;\n       end \n       else begin\n          sum[0] <= temp[0] + temp[1];\n          sum[1] <= temp[2] + temp[3];\n          sum[2] <= temp[4] + temp[5];\n          sum[3] <= temp[6] + temp[7];\n       end\n \n     reg [15:0] mul_out_reg;\n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out_reg <= 'd0;\n       else \n          mul_out_reg <= sum[0] + sum[1] + sum[2] + sum[3];\n \n \n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out <= 'd0;\n       else if(mul_en_out_reg[2])\n          mul_out <= mul_out_reg;\n       else\n          mul_out <= 'd0;\n \n          \nendmodule", "corruption_explanation": "Swapped operands: 'size - 1' -> '1 - size'", "modification_type": "swap_operands", "modification_line": 49, "original_snippet": "size-1", "modified_snippet": "1 - size", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'size - 1' -> '1 - size'\n   \u2022 Line 49: Original: size-1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 49.\n   \u2022 Restore the original code: size-1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 13, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "add_multiple_driver", "invert_condition", "invert_reset_polarity", "remove_async_reset"], "stacked_count": 1, "applied_modifications": ["swap_operands"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.109903", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_pipe_8bit", "module_name": "multi_pipe_8bit", "description": "Please act as a professional verilog designer.\n\nImplement the design of unsigned 8bit multiplier based on pipelining processing. It utilizes a clock signal (clk), an active-low reset signal (rst_n), an input enable signal (mul_en_in), and provides an output enable signal (mul_en_out) and the product output (mul_out) of size 16 bits.\n\nModule name:  \n    multi_pipe_8bit \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    mul_en_in: Input enable signal that controls the multiplication operation.\n    mul_a: Input signal representing the multiplicand with a data width of 8 bits.\n    mul_b: Input signal representing the multiplier with a data width of 8 bits.\n\nOutput ports:\n    mul_en_out: Output enable signal indicating if the multiplication operation is enabled.\n    mul_out: Product output signal with a data width of 16 bits.\n\nImplementation:\nThe module utilizes a pipeline architecture to improve performance. It consists of several key components:\nInput Control:\nThe module includes an input enable signal, mul_en_in, which controls the multiplication operation.\nOn the positive edge of the clock signal, the module samples the input enable signal and stores it in a register, mul_en_out_reg.\nThe output enable signal, mul_en_out, is derived from the most significant bit of mul_en_out_reg, indicating whether the multiplication operation is enabled.\n\nInput Registers:\nThe module includes registers, mul_a_reg and mul_b_reg, to store the input multiplicand and multiplier, respectively.\nOn the positive edge of the clock signal, the module samples the input values and stores them in the corresponding registers.\nThe registers are only updated when the input enable signal is active.\n\nPartial Product Generation:\nThe module generates partial products by performing bitwise operations between the multiplicand and the individual bits of the multiplier.\nIt uses conditional assignments to select the appropriate bits from the multiplicand based on the multiplier bits.\nThe partial products are stored in a set of wires, temp, with each wire representing a different bit position.\n\nPartial Sum Calculation:\nThe module performs addition operations on the partial products to calculate partial sums.\nIt uses a set of registers, sum, to store the intermediate sum values.\nEach register corresponds to a group of partial products and is updated on the positive edge of the clock signal.\n\nFinal Product Calculation:\nThe module sums up all the partial sums to obtain the final product.\nIt uses a register, mul_out_reg, to store the accumulated sum.\nOn the positive edge of the clock signal, the register is updated with the sum of all partial sums.\n\nOutput Assignment:\nThe module assigns the output product value, mul_out, based on the output enable signal and the value in mul_out_reg.\nIf the output enable signal is active, indicating a valid product, the value in mul_out_reg is assigned to mul_out.\nOtherwise, mul_out is set to 0.\n\nGive me the complete code.\n"}, "clean_code": "module multi_pipe_8bit#(\n    parameter size = 8\n)(\n          clk,      \n          rst_n,       \n          mul_a,       \n          mul_b, \n          mul_en_in,\n \n          mul_en_out,      \n          mul_out    \n);\n \n   input clk;           \n   input rst_n; \n   input mul_en_in;      \n   input [size-1:0] mul_a;       \n   input [size-1:0] mul_b;       \n \n   output reg mul_en_out;  \n   output reg [size*2-1:0] mul_out;    \n \n            \n   reg [2:0] mul_en_out_reg;\n always@(posedge clk or negedge rst_n)\n       if(!rst_n)begin\n            mul_en_out_reg <= 'd0;             \n            mul_en_out     <= 'd0;                           \n       end\n       else begin\n            mul_en_out_reg <= {mul_en_out_reg[1:0],mul_en_in};            \n            mul_en_out     <= mul_en_out_reg[2];                  \n       end\n \n \n    reg [7:0] mul_a_reg;\n    reg [7:0] mul_b_reg;\n  always @(posedge clk or negedge rst_n)\n         if(!rst_n) begin\n              mul_a_reg <= 'd0;\n              mul_a_reg <= 'd0;\n         end\n         else begin\n              mul_a_reg <= mul_en_in ? mul_a :'d0;\n              mul_b_reg <= mul_en_in ? mul_b :'d0;\n         end\n \n  \n     wire [15:0] temp [size-1:0];\n  assign temp[0] = mul_b_reg[0]? {8'b0,mul_a_reg} : 'd0;\n  assign temp[1] = mul_b_reg[1]? {7'b0,mul_a_reg,1'b0} : 'd0;\n  assign temp[2] = mul_b_reg[2]? {6'b0,mul_a_reg,2'b0} : 'd0;\n  assign temp[3] = mul_b_reg[3]? {5'b0,mul_a_reg,3'b0} : 'd0;\n  assign temp[4] = mul_b_reg[4]? {4'b0,mul_a_reg,4'b0} : 'd0;\n  assign temp[5] = mul_b_reg[5]? {3'b0,mul_a_reg,5'b0} : 'd0;\n  assign temp[6] = mul_b_reg[6]? {2'b0,mul_a_reg,6'b0} : 'd0;\n  assign temp[7] = mul_b_reg[7]? {1'b0,mul_a_reg,7'b0} : 'd0; \n \n \n     reg [15:0] sum [3:0];//[size/2-1:1]\n always @(posedge clk or negedge rst_n) \n       if(!rst_n) begin\n          sum[0]  <= 'd0;\n          sum[1]  <= 'd0;\n          sum[2]  <= 'd0;\n          sum[3]  <= 'd0;\n       end \n       else begin\n          sum[0] <= temp[0] + temp[1];\n          sum[1] <= temp[2] + temp[3];\n          sum[2] <= temp[4] + temp[5];\n          sum[3] <= temp[6] + temp[7];\n       end\n \n     reg [15:0] mul_out_reg;\n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out_reg <= 'd0;\n       else \n          mul_out_reg <= sum[0] + sum[1] + sum[2] + sum[3];\n \n \n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out <= 'd0;\n       else if(mul_en_out_reg[2])\n          mul_out <= mul_out_reg;\n       else\n          mul_out <= 'd0;\n \n          \nendmodule", "corrupted_code": "module multi_pipe_8bit#(\n    parameter size = 8\n)(\n          clk,      \n          rst_n,       \n          mul_a,       \n          mul_b, \n          mul_en_in,\n \n          mul_en_out,      \n          mul_out    \n);\n \n   input clk;           \n   input rst_n; \n   input mul_en_in;      \n   input [size-1:0] mul_a;       \n   input [size-1:0] mul_b;       \n \n   output reg mul_en_out;  \n   output reg [size*2-1:0] mul_out;    \n \n            \n   reg [2:0] mul_en_out_reg;\n always@(posedge clk or negedge rst_n)\n       if(!rst_n)begin\n            mul_en_out_reg <= 'd0;             \n            mul_en_out     <= 'd0;                           \n       end\n       else begin\n            mul_en_out_reg <= {mul_en_out_reg[1:0],mul_en_in};            \n            mul_en_out     <= mul_en_out_reg[2];                  \n       end\n \n \n    reg [7:0] mul_a_reg;\n    reg [7:0] mul_b_reg;\n  always @(posedge clk or negedge rst_n)\n         if(!rst_n) begin\n              mul_a_reg <= 'd0;\n              mul_a_reg <= 'd0;\n         end\n         else begin\n              mul_a_reg <= mul_en_in ? mul_a :'d0;\n              mul_b_reg <= mul_en_in ? mul_b :'d0;\n         end\n \n  \n     wire [15:0] temp [size-1:0];\n  assign temp[0] = mul_b_reg[0]? {8'b0,mul_a_reg} : 'd0;\n  assign temp[1] = mul_b_reg[1]? {7'b0,mul_a_reg,1'b0} : 'd0;\n\n  assign temp[3] = mul_b_reg[3]? {5'b0,mul_a_reg,3'b0} : 'd0;\n  assign temp[4] = mul_b_reg[4]? {4'b0,mul_a_reg,4'b0} : 'd0;\n  assign temp[5] = mul_b_reg[5]? {3'b0,mul_a_reg,5'b0} : 'd0;\n  assign temp[6] = mul_b_reg[6]? {2'b0,mul_a_reg,6'b0} : 'd0;\n  assign temp[7] = mul_b_reg[7]? {1'b0,mul_a_reg,7'b0} : 'd0; \n \n \n     reg [15:0] sum [3:0];//[size/2-1:1]\n always @(posedge clk or negedge rst_n) \n       if(!rst_n) begin\n          sum[0]  <= 'd0;\n          sum[1]  <= 'd0;\n          sum[2]  <= 'd0;\n          sum[3]  <= 'd0;\n       end \n       else begin\n          sum[0] <= temp[0] + temp[1];\n          sum[1] <= temp[2] + temp[3];\n          sum[2] <= temp[4] + temp[5];\n          sum[3] <= temp[6] + temp[7];\n       end\n \n     reg [15:0] mul_out_reg;\n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out_reg <= 'd0;\n       else \n          mul_out_reg <= sum[0] + sum[1] + sum[2] + sum[3];\n \n \n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out <= 'd0;\n       else if(mul_en_out_reg[2])\n          mul_out <= mul_out_reg;\n       else\n          mul_out <= 'd0;\n \n          \nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 52, "original_snippet": "assign temp[2] = mul_b_reg[2]? {6'b0,mul_a_reg,2'b0} : 'd0;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 52: Original: assign temp[2] = mul_b_reg[2]? {6'b0,mul_a_reg,2'b0} : 'd0;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 52.\n   \u2022 Restore the original code: assign temp[2] = mul_b_reg[2]? {6'b0,mul_a_reg,2'b0} : 'd0;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 13, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "add_multiple_driver", "invert_condition", "invert_reset_polarity", "remove_async_reset"], "stacked_count": 1, "applied_modifications": ["remove_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.115067", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_pipe_8bit", "module_name": "multi_pipe_8bit", "description": "Please act as a professional verilog designer.\n\nImplement the design of unsigned 8bit multiplier based on pipelining processing. It utilizes a clock signal (clk), an active-low reset signal (rst_n), an input enable signal (mul_en_in), and provides an output enable signal (mul_en_out) and the product output (mul_out) of size 16 bits.\n\nModule name:  \n    multi_pipe_8bit \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    mul_en_in: Input enable signal that controls the multiplication operation.\n    mul_a: Input signal representing the multiplicand with a data width of 8 bits.\n    mul_b: Input signal representing the multiplier with a data width of 8 bits.\n\nOutput ports:\n    mul_en_out: Output enable signal indicating if the multiplication operation is enabled.\n    mul_out: Product output signal with a data width of 16 bits.\n\nImplementation:\nThe module utilizes a pipeline architecture to improve performance. It consists of several key components:\nInput Control:\nThe module includes an input enable signal, mul_en_in, which controls the multiplication operation.\nOn the positive edge of the clock signal, the module samples the input enable signal and stores it in a register, mul_en_out_reg.\nThe output enable signal, mul_en_out, is derived from the most significant bit of mul_en_out_reg, indicating whether the multiplication operation is enabled.\n\nInput Registers:\nThe module includes registers, mul_a_reg and mul_b_reg, to store the input multiplicand and multiplier, respectively.\nOn the positive edge of the clock signal, the module samples the input values and stores them in the corresponding registers.\nThe registers are only updated when the input enable signal is active.\n\nPartial Product Generation:\nThe module generates partial products by performing bitwise operations between the multiplicand and the individual bits of the multiplier.\nIt uses conditional assignments to select the appropriate bits from the multiplicand based on the multiplier bits.\nThe partial products are stored in a set of wires, temp, with each wire representing a different bit position.\n\nPartial Sum Calculation:\nThe module performs addition operations on the partial products to calculate partial sums.\nIt uses a set of registers, sum, to store the intermediate sum values.\nEach register corresponds to a group of partial products and is updated on the positive edge of the clock signal.\n\nFinal Product Calculation:\nThe module sums up all the partial sums to obtain the final product.\nIt uses a register, mul_out_reg, to store the accumulated sum.\nOn the positive edge of the clock signal, the register is updated with the sum of all partial sums.\n\nOutput Assignment:\nThe module assigns the output product value, mul_out, based on the output enable signal and the value in mul_out_reg.\nIf the output enable signal is active, indicating a valid product, the value in mul_out_reg is assigned to mul_out.\nOtherwise, mul_out is set to 0.\n\nGive me the complete code.\n"}, "clean_code": "module multi_pipe_8bit#(\n    parameter size = 8\n)(\n          clk,      \n          rst_n,       \n          mul_a,       \n          mul_b, \n          mul_en_in,\n \n          mul_en_out,      \n          mul_out    \n);\n \n   input clk;           \n   input rst_n; \n   input mul_en_in;      \n   input [size-1:0] mul_a;       \n   input [size-1:0] mul_b;       \n \n   output reg mul_en_out;  \n   output reg [size*2-1:0] mul_out;    \n \n            \n   reg [2:0] mul_en_out_reg;\n always@(posedge clk or negedge rst_n)\n       if(!rst_n)begin\n            mul_en_out_reg <= 'd0;             \n            mul_en_out     <= 'd0;                           \n       end\n       else begin\n            mul_en_out_reg <= {mul_en_out_reg[1:0],mul_en_in};            \n            mul_en_out     <= mul_en_out_reg[2];                  \n       end\n \n \n    reg [7:0] mul_a_reg;\n    reg [7:0] mul_b_reg;\n  always @(posedge clk or negedge rst_n)\n         if(!rst_n) begin\n              mul_a_reg <= 'd0;\n              mul_a_reg <= 'd0;\n         end\n         else begin\n              mul_a_reg <= mul_en_in ? mul_a :'d0;\n              mul_b_reg <= mul_en_in ? mul_b :'d0;\n         end\n \n  \n     wire [15:0] temp [size-1:0];\n  assign temp[0] = mul_b_reg[0]? {8'b0,mul_a_reg} : 'd0;\n  assign temp[1] = mul_b_reg[1]? {7'b0,mul_a_reg,1'b0} : 'd0;\n  assign temp[2] = mul_b_reg[2]? {6'b0,mul_a_reg,2'b0} : 'd0;\n  assign temp[3] = mul_b_reg[3]? {5'b0,mul_a_reg,3'b0} : 'd0;\n  assign temp[4] = mul_b_reg[4]? {4'b0,mul_a_reg,4'b0} : 'd0;\n  assign temp[5] = mul_b_reg[5]? {3'b0,mul_a_reg,5'b0} : 'd0;\n  assign temp[6] = mul_b_reg[6]? {2'b0,mul_a_reg,6'b0} : 'd0;\n  assign temp[7] = mul_b_reg[7]? {1'b0,mul_a_reg,7'b0} : 'd0; \n \n \n     reg [15:0] sum [3:0];//[size/2-1:1]\n always @(posedge clk or negedge rst_n) \n       if(!rst_n) begin\n          sum[0]  <= 'd0;\n          sum[1]  <= 'd0;\n          sum[2]  <= 'd0;\n          sum[3]  <= 'd0;\n       end \n       else begin\n          sum[0] <= temp[0] + temp[1];\n          sum[1] <= temp[2] + temp[3];\n          sum[2] <= temp[4] + temp[5];\n          sum[3] <= temp[6] + temp[7];\n       end\n \n     reg [15:0] mul_out_reg;\n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out_reg <= 'd0;\n       else \n          mul_out_reg <= sum[0] + sum[1] + sum[2] + sum[3];\n \n \n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out <= 'd0;\n       else if(mul_en_out_reg[2])\n          mul_out <= mul_out_reg;\n       else\n          mul_out <= 'd0;\n \n          \nendmodule", "corrupted_code": "module multi_pipe_8bit#(\n    parameter size = 8\n)(\n          clk,      \n          rst_n,       \n          mul_a,       \n          mul_b, \n          mul_en_in,\n \n          mul_en_out,      \n          mul_out    \n);\n \n   input clk;           \n   input rst_n; \n   input mul_en_in;      \n   input [size-1:0] mul_a;       \n   input [size-1:0] mul_b;       \n \n   output reg mul_en_out;  \n   output reg [size*2-1:0] mul_out;    \n \n            \n   reg [2:0] mul_en_out_reg;\n always@(posedge clk or negedge rst_n)\n       if(!rst_n)begin\n            mul_en_out_reg <= 'd0;             \n            mul_en_out = 'd0;                           \n       end\n       else begin\n            mul_en_out_reg <= {mul_en_out_reg[1:0],mul_en_in};            \n            mul_en_out     <= mul_en_out_reg[2];                  \n       end\n \n \n    reg [7:0] mul_a_reg;\n    reg [7:0] mul_b_reg;\n  always @(posedge clk or negedge rst_n)\n         if(!rst_n) begin\n              mul_a_reg <= 'd0;\n              mul_a_reg <= 'd0;\n         end\n         else begin\n              mul_a_reg <= mul_en_in ? mul_a :'d0;\n              mul_b_reg <= mul_en_in ? mul_b :'d0;\n         end\n \n  \n     wire [15:0] temp [size-1:0];\n  assign temp[0] = mul_b_reg[0]? {8'b0,mul_a_reg} : 'd0;\n  assign temp[1] = mul_b_reg[1]? {7'b0,mul_a_reg,1'b0} : 'd0;\n  assign temp[2] = mul_b_reg[2]? {6'b0,mul_a_reg,2'b0} : 'd0;\n  assign temp[3] = mul_b_reg[3]? {5'b0,mul_a_reg,3'b0} : 'd0;\n  assign temp[4] = mul_b_reg[4]? {4'b0,mul_a_reg,4'b0} : 'd0;\n  assign temp[5] = mul_b_reg[5]? {3'b0,mul_a_reg,5'b0} : 'd0;\n  assign temp[6] = mul_b_reg[6]? {2'b0,mul_a_reg,6'b0} : 'd0;\n  assign temp[7] = mul_b_reg[7]? {1'b0,mul_a_reg,7'b0} : 'd0; \n \n \n     reg [15:0] sum [3:0];//[size/2-1:1]\n always @(posedge clk or negedge rst_n) \n       if(!rst_n) begin\n          sum[0]  <= 'd0;\n          sum[1]  <= 'd0;\n          sum[2]  <= 'd0;\n          sum[3]  <= 'd0;\n       end \n       else begin\n          sum[0] <= temp[0] + temp[1];\n          sum[1] <= temp[2] + temp[3];\n          sum[2] <= temp[4] + temp[5];\n          sum[3] <= temp[6] + temp[7];\n       end\n \n     reg [15:0] mul_out_reg;\n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out_reg <= 'd0;\n       else \n          mul_out_reg <= sum[0] + sum[1] + sum[2] + sum[3];\n \n \n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out <= 'd0;\n       else if(mul_en_out_reg[2])\n          mul_out <= mul_out_reg;\n       else\n          mul_out <= 'd0;\n \n          \nendmodule", "corruption_explanation": "Changed non-blocking (<=) to blocking (=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 28, "original_snippet": "mul_en_out     <= 'd0;", "modified_snippet": "mul_en_out = 'd0;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 13, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "add_multiple_driver", "invert_condition", "invert_reset_polarity", "remove_async_reset"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.118297", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_booth_8bit", "module_name": "booth4_mul", "description": "Please act as a professional verilog designer.\n\nImplement an 8-bit Radix-4 booth multiplier that performs the multiplication of two 8-bit inputs (a and b) using the Booth algorithm. It utilizes a clock signal (clk), and a reset signal (reset), and provides the product output (p) and a ready signal (rdy). The ready signal (rdy) is set to 1 to indicate the completion of the multiplication process.\n\nModule name:  \n   multi_booth_8bit  \n\nInput ports:\n   clk: Clock signal used for synchronous operation.\n   reset: Reset signal used to initialize the multiplier module.\n   a: 8-bit input representing the multiplicand.\n   b: 8-bit input representing the multiplier.\n\nOutput ports:\n   p: 16-bit output representing the product of the multiplication.\n   rdy: Ready signal indicating the completion of the multiplication operation.\n\nImplementation:\nOn the positive edge of the clock signal (clk) or the positive edge of the reset signal (reset), the module performs the multiplication process.\nIf the reset signal (reset) is high, two 16-bit registers multiplier <= {{8{a[7]}}, a} and multiplicand <= {{8{b[7]}}, b}. \nIf the reset signal (reset) is low, indicating normal operation, the module checks if the counter (5bit ctr) is less than 16.\nIf the counter (ctr) is less than 16, the multiplicand register (multiplicand) is left-shifted by 1 to simulate the Booth algorithm's shifting operation.\nIf the current bit of the multiplier register (multiplier[ctr]) is 1, indicating a positive Booth encoding, the product register (p) accumulates the value of the multiplicand register (multiplicand).\nThe counter (ctr) is incremented by 1. Once the counter (ctr) reaches 16, indicating the completion of the multiplication process, the ready signal (rdy) is set to 1.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns / 1ps\n\nmodule verified_multi_booth_8bit (p, rdy, clk, reset, a, b);\n   input clk, reset;\n   input [7:0] a, b;\n   output [15:0] p;\n   output rdy;\n   \n   reg [15:0] p;\n   reg [15:0] multiplier;\n   reg [15:0] multiplicand;\n   reg rdy;\n   reg [4:0] ctr;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) \n    begin\n    rdy     <= 0;\n    p   <= 0;\n    ctr     <= 0;\n    multiplier <= {{8{a[7]}}, a};\n    multiplicand <= {{8{b[7]}}, b};\n    end \n    else \n    begin \n      if(ctr < 16) \n          begin\n          multiplicand <= multiplicand << 1;\n            if (multiplier[ctr] == 1)\n            begin\n                p <= p + multiplicand;\n            end\n            ctr <= ctr + 1;\n          end\n       else \n           begin\n           rdy <= 1;\n           end\n    end\n  end //End of always block\n    \nendmodule", "corrupted_code": "`timescale 1ns / 1ps\n\nmodule verified_multi_booth_8bit (p, rdy, clk, reset, a, b);\n   input clk, reset;\n   input [7:0] a, b;\n   output [15:0] p;\n   output rdy;\n   \n   reg [15:0] p;\n   reg [15:0] multiplier;\n   reg [15:0] multiplicand;\n   reg rdy;\n   reg [4:0] ctr;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) \n    begin\n    rdy     <= 0;\n    p   <= 0;\n    ctr     <= 0;\n    multiplier <= {{8{a[7]}}, a};\n    multiplicand <= {{8{b[7]}}, b};\n    end \n    else \n    begin \n      if(ctr < 16) \n          begin\n          multiplicand <= multiplicand << 1;\n            if (multiplier[ctr] == 1)\n            begin\n                p <= p + multiplicand;\n            end\n            ctr <= ctr + 1;\n          end\n       else \n           begin\n           rdy = 1;\n           end\n    end\n  end //End of always block\n    \nendmodule", "corruption_explanation": "Changed non-blocking (<=) to blocking (=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 37, "original_snippet": "rdy <= 1;", "modified_snippet": "rdy = 1;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 16, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.122136", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_booth_8bit", "module_name": "booth4_mul", "description": "Please act as a professional verilog designer.\n\nImplement an 8-bit Radix-4 booth multiplier that performs the multiplication of two 8-bit inputs (a and b) using the Booth algorithm. It utilizes a clock signal (clk), and a reset signal (reset), and provides the product output (p) and a ready signal (rdy). The ready signal (rdy) is set to 1 to indicate the completion of the multiplication process.\n\nModule name:  \n   multi_booth_8bit  \n\nInput ports:\n   clk: Clock signal used for synchronous operation.\n   reset: Reset signal used to initialize the multiplier module.\n   a: 8-bit input representing the multiplicand.\n   b: 8-bit input representing the multiplier.\n\nOutput ports:\n   p: 16-bit output representing the product of the multiplication.\n   rdy: Ready signal indicating the completion of the multiplication operation.\n\nImplementation:\nOn the positive edge of the clock signal (clk) or the positive edge of the reset signal (reset), the module performs the multiplication process.\nIf the reset signal (reset) is high, two 16-bit registers multiplier <= {{8{a[7]}}, a} and multiplicand <= {{8{b[7]}}, b}. \nIf the reset signal (reset) is low, indicating normal operation, the module checks if the counter (5bit ctr) is less than 16.\nIf the counter (ctr) is less than 16, the multiplicand register (multiplicand) is left-shifted by 1 to simulate the Booth algorithm's shifting operation.\nIf the current bit of the multiplier register (multiplier[ctr]) is 1, indicating a positive Booth encoding, the product register (p) accumulates the value of the multiplicand register (multiplicand).\nThe counter (ctr) is incremented by 1. Once the counter (ctr) reaches 16, indicating the completion of the multiplication process, the ready signal (rdy) is set to 1.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns / 1ps\n\nmodule verified_multi_booth_8bit (p, rdy, clk, reset, a, b);\n   input clk, reset;\n   input [7:0] a, b;\n   output [15:0] p;\n   output rdy;\n   \n   reg [15:0] p;\n   reg [15:0] multiplier;\n   reg [15:0] multiplicand;\n   reg rdy;\n   reg [4:0] ctr;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) \n    begin\n    rdy     <= 0;\n    p   <= 0;\n    ctr     <= 0;\n    multiplier <= {{8{a[7]}}, a};\n    multiplicand <= {{8{b[7]}}, b};\n    end \n    else \n    begin \n      if(ctr < 16) \n          begin\n          multiplicand <= multiplicand << 1;\n            if (multiplier[ctr] == 1)\n            begin\n                p <= p + multiplicand;\n            end\n            ctr <= ctr + 1;\n          end\n       else \n           begin\n           rdy <= 1;\n           end\n    end\n  end //End of always block\n    \nendmodule", "corrupted_code": "`timescale 1ns / 1ps\n\nmodule verified_multi_booth_8bit (p, rdy, clk, reset, a, b);\n   input clk, reset;\n   input [7:0] a, b;\n   output [15:0] p;\n   output rdy;\n   \n   reg [15:0] p;\n   reg [15:0] multiplier;\n   reg [15:0] multiplicand;\n   reg rdy;\n   reg [4:0] ctr;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) \n    begin\n    rdy     <= 0;\n    p   <= 0;\n    ctr     <= 0;\n    multiplier <= {{8{a[7]}}, a};\n    multiplicand <= {{8{b[7]}}, b};\n    end \n    else \n    begin \n      if(16 < ctr) \n          begin\n          multiplicand <= multiplicand << 1;\n            if (multiplier[ctr] == 1)\n            begin\n                p <= p + multiplicand;\n            end\n            ctr <= ctr + 1;\n          end\n       else \n           begin\n           rdy <= 1;\n           end\n    end\n  end //End of always block\n    \nendmodule", "corruption_explanation": "Swapped operands: 'ctr < 16' -> '16 < ctr'", "modification_type": "swap_operands", "modification_line": 26, "original_snippet": "ctr < 16", "modified_snippet": "16 < ctr", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'ctr < 16' -> '16 < ctr'\n   \u2022 Line 26: Original: ctr < 16\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 26.\n   \u2022 Restore the original code: ctr < 16\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 16, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_operands"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.123318", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_booth_8bit", "module_name": "booth4_mul", "description": "Please act as a professional verilog designer.\n\nImplement an 8-bit Radix-4 booth multiplier that performs the multiplication of two 8-bit inputs (a and b) using the Booth algorithm. It utilizes a clock signal (clk), and a reset signal (reset), and provides the product output (p) and a ready signal (rdy). The ready signal (rdy) is set to 1 to indicate the completion of the multiplication process.\n\nModule name:  \n   multi_booth_8bit  \n\nInput ports:\n   clk: Clock signal used for synchronous operation.\n   reset: Reset signal used to initialize the multiplier module.\n   a: 8-bit input representing the multiplicand.\n   b: 8-bit input representing the multiplier.\n\nOutput ports:\n   p: 16-bit output representing the product of the multiplication.\n   rdy: Ready signal indicating the completion of the multiplication operation.\n\nImplementation:\nOn the positive edge of the clock signal (clk) or the positive edge of the reset signal (reset), the module performs the multiplication process.\nIf the reset signal (reset) is high, two 16-bit registers multiplier <= {{8{a[7]}}, a} and multiplicand <= {{8{b[7]}}, b}. \nIf the reset signal (reset) is low, indicating normal operation, the module checks if the counter (5bit ctr) is less than 16.\nIf the counter (ctr) is less than 16, the multiplicand register (multiplicand) is left-shifted by 1 to simulate the Booth algorithm's shifting operation.\nIf the current bit of the multiplier register (multiplier[ctr]) is 1, indicating a positive Booth encoding, the product register (p) accumulates the value of the multiplicand register (multiplicand).\nThe counter (ctr) is incremented by 1. Once the counter (ctr) reaches 16, indicating the completion of the multiplication process, the ready signal (rdy) is set to 1.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns / 1ps\n\nmodule verified_multi_booth_8bit (p, rdy, clk, reset, a, b);\n   input clk, reset;\n   input [7:0] a, b;\n   output [15:0] p;\n   output rdy;\n   \n   reg [15:0] p;\n   reg [15:0] multiplier;\n   reg [15:0] multiplicand;\n   reg rdy;\n   reg [4:0] ctr;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) \n    begin\n    rdy     <= 0;\n    p   <= 0;\n    ctr     <= 0;\n    multiplier <= {{8{a[7]}}, a};\n    multiplicand <= {{8{b[7]}}, b};\n    end \n    else \n    begin \n      if(ctr < 16) \n          begin\n          multiplicand <= multiplicand << 1;\n            if (multiplier[ctr] == 1)\n            begin\n                p <= p + multiplicand;\n            end\n            ctr <= ctr + 1;\n          end\n       else \n           begin\n           rdy <= 1;\n           end\n    end\n  end //End of always block\n    \nendmodule", "corrupted_code": "`timescale 1ns / 1ps\n\nmodule verified_multi_booth_8bit (p, rdy, clk, reset, a, b);\n   input clk, reset;\n   input [7:0] a, b;\n   output [15:0] p;\n   output rdy;\n   \n   reg [15:0] p;\n   reg [15:0] multiplier;\n   reg [15:0] multiplicand;\n   reg rdy;\n   reg [4:0] ctr;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) \n    begin\n    rdy     <= 0;\n    p   <= 0;\n\n    multiplier <= {{8{a[7]}}, a};\n    multiplicand <= {{8{b[7]}}, b};\n    end \n    else \n    begin \n      if(ctr < 16) \n          begin\n          multiplicand <= multiplicand << 1;\n            if (multiplier[ctr] == 1)\n            begin\n                p <= p + multiplicand;\n            end\n            ctr <= ctr + 1;\n          end\n       else \n           begin\n           rdy <= 1;\n           end\n    end\n  end //End of always block\n    \nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 20, "original_snippet": "ctr     <= 0;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 20: Original: ctr     <= 0;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 20.\n   \u2022 Restore the original code: ctr     <= 0;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 16, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.124436", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_booth_8bit", "module_name": "booth4_mul", "description": "Please act as a professional verilog designer.\n\nImplement an 8-bit Radix-4 booth multiplier that performs the multiplication of two 8-bit inputs (a and b) using the Booth algorithm. It utilizes a clock signal (clk), and a reset signal (reset), and provides the product output (p) and a ready signal (rdy). The ready signal (rdy) is set to 1 to indicate the completion of the multiplication process.\n\nModule name:  \n   multi_booth_8bit  \n\nInput ports:\n   clk: Clock signal used for synchronous operation.\n   reset: Reset signal used to initialize the multiplier module.\n   a: 8-bit input representing the multiplicand.\n   b: 8-bit input representing the multiplier.\n\nOutput ports:\n   p: 16-bit output representing the product of the multiplication.\n   rdy: Ready signal indicating the completion of the multiplication operation.\n\nImplementation:\nOn the positive edge of the clock signal (clk) or the positive edge of the reset signal (reset), the module performs the multiplication process.\nIf the reset signal (reset) is high, two 16-bit registers multiplier <= {{8{a[7]}}, a} and multiplicand <= {{8{b[7]}}, b}. \nIf the reset signal (reset) is low, indicating normal operation, the module checks if the counter (5bit ctr) is less than 16.\nIf the counter (ctr) is less than 16, the multiplicand register (multiplicand) is left-shifted by 1 to simulate the Booth algorithm's shifting operation.\nIf the current bit of the multiplier register (multiplier[ctr]) is 1, indicating a positive Booth encoding, the product register (p) accumulates the value of the multiplicand register (multiplicand).\nThe counter (ctr) is incremented by 1. Once the counter (ctr) reaches 16, indicating the completion of the multiplication process, the ready signal (rdy) is set to 1.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns / 1ps\n\nmodule verified_multi_booth_8bit (p, rdy, clk, reset, a, b);\n   input clk, reset;\n   input [7:0] a, b;\n   output [15:0] p;\n   output rdy;\n   \n   reg [15:0] p;\n   reg [15:0] multiplier;\n   reg [15:0] multiplicand;\n   reg rdy;\n   reg [4:0] ctr;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) \n    begin\n    rdy     <= 0;\n    p   <= 0;\n    ctr     <= 0;\n    multiplier <= {{8{a[7]}}, a};\n    multiplicand <= {{8{b[7]}}, b};\n    end \n    else \n    begin \n      if(ctr < 16) \n          begin\n          multiplicand <= multiplicand << 1;\n            if (multiplier[ctr] == 1)\n            begin\n                p <= p + multiplicand;\n            end\n            ctr <= ctr + 1;\n          end\n       else \n           begin\n           rdy <= 1;\n           end\n    end\n  end //End of always block\n    \nendmodule", "corrupted_code": "`timescale 1ns / 1ps\n\nmodule verified_multi_booth_8bit (p, rdy, clk, reset, a, b);\n   input clk, reset;\n   input [7:0] a, b;\n   output [14:0] p;\n   output rdy;\n   \n   reg [15:0] p;\n   reg [15:0] multiplier;\n   reg [15:0] multiplicand;\n   reg rdy;\n   reg [4:0] ctr;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) \n    begin\n    rdy     <= 0;\n    p   <= 0;\n    ctr     <= 0;\n    multiplier <= {{8{a[7]}}, a};\n    multiplicand <= {{8{b[7]}}, b};\n    end \n    else \n    begin \n      if(ctr < 16) \n          begin\n          multiplicand <= multiplicand << 1;\n            if (multiplier[ctr] == 1)\n            begin\n                p <= p + multiplicand;\n            end\n            ctr <= ctr + 1;\n          end\n       else \n           begin\n           rdy <= 1;\n           end\n    end\n  end //End of always block\n    \nendmodule", "corruption_explanation": "Changed bit width from [15:0] to [14:0]", "modification_type": "change_bit_width", "modification_line": 6, "original_snippet": "[15:0]", "modified_snippet": "[14:0]", "issue_description": "The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_bit_width modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed bit width from [15:0] to [14:0]\n   \u2022 Line 6: Original: [15:0]\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 6.\n   \u2022 Restore the original code: [15:0]\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change bit width.", "complexity": 16, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_bit_width"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.125521", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_booth_8bit", "module_name": "booth4_mul", "description": "Please act as a professional verilog designer.\n\nImplement an 8-bit Radix-4 booth multiplier that performs the multiplication of two 8-bit inputs (a and b) using the Booth algorithm. It utilizes a clock signal (clk), and a reset signal (reset), and provides the product output (p) and a ready signal (rdy). The ready signal (rdy) is set to 1 to indicate the completion of the multiplication process.\n\nModule name:  \n   multi_booth_8bit  \n\nInput ports:\n   clk: Clock signal used for synchronous operation.\n   reset: Reset signal used to initialize the multiplier module.\n   a: 8-bit input representing the multiplicand.\n   b: 8-bit input representing the multiplier.\n\nOutput ports:\n   p: 16-bit output representing the product of the multiplication.\n   rdy: Ready signal indicating the completion of the multiplication operation.\n\nImplementation:\nOn the positive edge of the clock signal (clk) or the positive edge of the reset signal (reset), the module performs the multiplication process.\nIf the reset signal (reset) is high, two 16-bit registers multiplier <= {{8{a[7]}}, a} and multiplicand <= {{8{b[7]}}, b}. \nIf the reset signal (reset) is low, indicating normal operation, the module checks if the counter (5bit ctr) is less than 16.\nIf the counter (ctr) is less than 16, the multiplicand register (multiplicand) is left-shifted by 1 to simulate the Booth algorithm's shifting operation.\nIf the current bit of the multiplier register (multiplier[ctr]) is 1, indicating a positive Booth encoding, the product register (p) accumulates the value of the multiplicand register (multiplicand).\nThe counter (ctr) is incremented by 1. Once the counter (ctr) reaches 16, indicating the completion of the multiplication process, the ready signal (rdy) is set to 1.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns / 1ps\n\nmodule verified_multi_booth_8bit (p, rdy, clk, reset, a, b);\n   input clk, reset;\n   input [7:0] a, b;\n   output [15:0] p;\n   output rdy;\n   \n   reg [15:0] p;\n   reg [15:0] multiplier;\n   reg [15:0] multiplicand;\n   reg rdy;\n   reg [4:0] ctr;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) \n    begin\n    rdy     <= 0;\n    p   <= 0;\n    ctr     <= 0;\n    multiplier <= {{8{a[7]}}, a};\n    multiplicand <= {{8{b[7]}}, b};\n    end \n    else \n    begin \n      if(ctr < 16) \n          begin\n          multiplicand <= multiplicand << 1;\n            if (multiplier[ctr] == 1)\n            begin\n                p <= p + multiplicand;\n            end\n            ctr <= ctr + 1;\n          end\n       else \n           begin\n           rdy <= 1;\n           end\n    end\n  end //End of always block\n    \nendmodule", "corrupted_code": "`timescale 1ns / 1ps\n\nmodule verified_multi_booth_8bit (p, rdy, clk, reset, a, b);\n   input clk, reset;\n   input [7:0] a, b;\n   output [15:0] p;\n   output rdy;\n   \n   reg [15:0] p;\n   reg [15:0] multiplier;\n   reg [15:0] multiplicand;\n   reg rdy;\n   reg [4:0] ctr;\n\n \n    else \n    begin \n      if(ctr < 16) \n          begin\n          multiplicand <= multiplicand << 1;\n            if (multiplier[ctr] == 1)\n            begin\n                p <= p + multiplicand;\n            end\n            ctr <= ctr + 1;\n          end\n       else \n           begin\n           rdy <= 1;\n           end\n    end\n  end //End of always block\n    \nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 15, "original_snippet": "always @(posedge clk or posedge reset) begin\n    if (reset) \n    begin\n    rdy     <= 0;\n    p   <= 0;\n    ctr     <= 0;\n    multiplier <= {{8{a[7]}}, a};\n    multiplicand <= {{8{b[7]}}, b};\n    end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 15: Original: always @(posedge clk or posedge reset) begin\n    if (reset) \n    begin\n    rdy     <= 0;\n    p   <= 0;\n    ctr     <= 0;\n    multiplier <= {{8{a[7]}}, a};\n    multiplicand <= {{8{b[7]}}, b};\n    end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 15.\n   \u2022 Restore the original code: always @(posedge clk or posedge reset) begin\n    if (reset) \n    begin\n    rdy     <= 0;\n    p   <= 0;\n    ctr     <= 0;\n    multiplier <= {{8{a[7]}}, a};\n    multiplicand <= {{8{b[7]}}, b};\n    end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 16, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.126806", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_booth_8bit", "module_name": "booth4_mul", "description": "Please act as a professional verilog designer.\n\nImplement an 8-bit Radix-4 booth multiplier that performs the multiplication of two 8-bit inputs (a and b) using the Booth algorithm. It utilizes a clock signal (clk), and a reset signal (reset), and provides the product output (p) and a ready signal (rdy). The ready signal (rdy) is set to 1 to indicate the completion of the multiplication process.\n\nModule name:  \n   multi_booth_8bit  \n\nInput ports:\n   clk: Clock signal used for synchronous operation.\n   reset: Reset signal used to initialize the multiplier module.\n   a: 8-bit input representing the multiplicand.\n   b: 8-bit input representing the multiplier.\n\nOutput ports:\n   p: 16-bit output representing the product of the multiplication.\n   rdy: Ready signal indicating the completion of the multiplication operation.\n\nImplementation:\nOn the positive edge of the clock signal (clk) or the positive edge of the reset signal (reset), the module performs the multiplication process.\nIf the reset signal (reset) is high, two 16-bit registers multiplier <= {{8{a[7]}}, a} and multiplicand <= {{8{b[7]}}, b}. \nIf the reset signal (reset) is low, indicating normal operation, the module checks if the counter (5bit ctr) is less than 16.\nIf the counter (ctr) is less than 16, the multiplicand register (multiplicand) is left-shifted by 1 to simulate the Booth algorithm's shifting operation.\nIf the current bit of the multiplier register (multiplier[ctr]) is 1, indicating a positive Booth encoding, the product register (p) accumulates the value of the multiplicand register (multiplicand).\nThe counter (ctr) is incremented by 1. Once the counter (ctr) reaches 16, indicating the completion of the multiplication process, the ready signal (rdy) is set to 1.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns / 1ps\n\nmodule verified_multi_booth_8bit (p, rdy, clk, reset, a, b);\n   input clk, reset;\n   input [7:0] a, b;\n   output [15:0] p;\n   output rdy;\n   \n   reg [15:0] p;\n   reg [15:0] multiplier;\n   reg [15:0] multiplicand;\n   reg rdy;\n   reg [4:0] ctr;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) \n    begin\n    rdy     <= 0;\n    p   <= 0;\n    ctr     <= 0;\n    multiplier <= {{8{a[7]}}, a};\n    multiplicand <= {{8{b[7]}}, b};\n    end \n    else \n    begin \n      if(ctr < 16) \n          begin\n          multiplicand <= multiplicand << 1;\n            if (multiplier[ctr] == 1)\n            begin\n                p <= p + multiplicand;\n            end\n            ctr <= ctr + 1;\n          end\n       else \n           begin\n           rdy <= 1;\n           end\n    end\n  end //End of always block\n    \nendmodule", "corrupted_code": "`timescale 1ns / 1ps\n\nmodule verified_multi_booth_8bit (p, rdy, clk, reset, a, b);\n   input clk, reset;\n   input [7:0] a, b;\n   output [15:0] p;\n   output rdy;\n   \n   reg [15:0] p;\n   reg [15:0] multiplier;\n   reg [15:0] multiplicand;\n   reg rdy;\n   reg [4:0] ctr;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) \n    begin\n    rdy     <= 0;\n    p   <= 0;\n    ctr     <= 0;\n    multiplier <= {{8{a[7]}}, a};\n\n    end \n    else \n    begin \n      if(ctr < 16) \n          begin\n          multiplicand <= multiplicand << 1;\n            if (multiplier[ctr] == 1)\n            begin\n                p <= p + multiplicand;\n            end\n            ctr <= ctr + 1;\n          end\n       else \n           begin\n           rdy <= 1;\n           end\n    end\n  end //End of always block\n    \nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 22, "original_snippet": "multiplicand <= {{8{b[7]}}, b};", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 22: Original: multiplicand <= {{8{b[7]}}, b};\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 22.\n   \u2022 Restore the original code: multiplicand <= {{8{b[7]}}, b};\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 16, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.127952", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_booth_8bit", "module_name": "booth4_mul", "description": "Please act as a professional verilog designer.\n\nImplement an 8-bit Radix-4 booth multiplier that performs the multiplication of two 8-bit inputs (a and b) using the Booth algorithm. It utilizes a clock signal (clk), and a reset signal (reset), and provides the product output (p) and a ready signal (rdy). The ready signal (rdy) is set to 1 to indicate the completion of the multiplication process.\n\nModule name:  \n   multi_booth_8bit  \n\nInput ports:\n   clk: Clock signal used for synchronous operation.\n   reset: Reset signal used to initialize the multiplier module.\n   a: 8-bit input representing the multiplicand.\n   b: 8-bit input representing the multiplier.\n\nOutput ports:\n   p: 16-bit output representing the product of the multiplication.\n   rdy: Ready signal indicating the completion of the multiplication operation.\n\nImplementation:\nOn the positive edge of the clock signal (clk) or the positive edge of the reset signal (reset), the module performs the multiplication process.\nIf the reset signal (reset) is high, two 16-bit registers multiplier <= {{8{a[7]}}, a} and multiplicand <= {{8{b[7]}}, b}. \nIf the reset signal (reset) is low, indicating normal operation, the module checks if the counter (5bit ctr) is less than 16.\nIf the counter (ctr) is less than 16, the multiplicand register (multiplicand) is left-shifted by 1 to simulate the Booth algorithm's shifting operation.\nIf the current bit of the multiplier register (multiplier[ctr]) is 1, indicating a positive Booth encoding, the product register (p) accumulates the value of the multiplicand register (multiplicand).\nThe counter (ctr) is incremented by 1. Once the counter (ctr) reaches 16, indicating the completion of the multiplication process, the ready signal (rdy) is set to 1.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns / 1ps\n\nmodule verified_multi_booth_8bit (p, rdy, clk, reset, a, b);\n   input clk, reset;\n   input [7:0] a, b;\n   output [15:0] p;\n   output rdy;\n   \n   reg [15:0] p;\n   reg [15:0] multiplier;\n   reg [15:0] multiplicand;\n   reg rdy;\n   reg [4:0] ctr;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) \n    begin\n    rdy     <= 0;\n    p   <= 0;\n    ctr     <= 0;\n    multiplier <= {{8{a[7]}}, a};\n    multiplicand <= {{8{b[7]}}, b};\n    end \n    else \n    begin \n      if(ctr < 16) \n          begin\n          multiplicand <= multiplicand << 1;\n            if (multiplier[ctr] == 1)\n            begin\n                p <= p + multiplicand;\n            end\n            ctr <= ctr + 1;\n          end\n       else \n           begin\n           rdy <= 1;\n           end\n    end\n  end //End of always block\n    \nendmodule", "corrupted_code": "`timescale 1ns / 1ps\n\nmodule verified_multi_booth_8bit (p, rdy, clk, reset, a, b);\n   input clk, reset;\n   input [7:0] a, b;\n   output [15:0] p;\n   output rdy;\n   \n   reg [15:0] p;\n   reg [15:0] multiplier;\n   reg [15:0] multiplicand;\n   reg rdy;\n   reg [4:0] ctr;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) \n    begin\n    rdy     <= 0;\n    p   <= 0;\n    ctr     <= 0;\n    multiplier <= {{8{a[7]}}, a};\n    multiplicand <= {{8{b[7]}}, b};\n    end \n    else \n    begin \n      if(!(ctr < 16)) \n          begin\n          multiplicand <= multiplicand << 1;\n            if (multiplier[ctr] == 1)\n            begin\n                p <= p + multiplicand;\n            end\n            ctr <= ctr + 1;\n          end\n       else \n           begin\n           rdy <= 1;\n           end\n    end\n  end //End of always block\n    \nendmodule", "corruption_explanation": "Inverted condition: 'ctr < 16' -> '!(ctr < 16)'", "modification_type": "invert_condition", "modification_line": 26, "original_snippet": "if(ctr < 16) \n          begin", "modified_snippet": "if(!(ctr < 16)) \n          begin", "issue_description": "The buggy code has an inverted condition in an if statement. Instead of checking if(x), it checks if(!x), causing the logic to execute when it shouldn't and skip execution when it should. All conditional behavior is reversed from intended functionality.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_condition modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted condition: 'ctr < 16' -> '!(ctr < 16)'\n   \u2022 Line 26: Original: if(ctr < 16) \n          begin\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 26.\n   \u2022 Restore the original code: if(ctr < 16) \n          begin\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert condition.", "complexity": 16, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_condition"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.129117", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_booth_8bit", "module_name": "booth4_mul", "description": "Please act as a professional verilog designer.\n\nImplement an 8-bit Radix-4 booth multiplier that performs the multiplication of two 8-bit inputs (a and b) using the Booth algorithm. It utilizes a clock signal (clk), and a reset signal (reset), and provides the product output (p) and a ready signal (rdy). The ready signal (rdy) is set to 1 to indicate the completion of the multiplication process.\n\nModule name:  \n   multi_booth_8bit  \n\nInput ports:\n   clk: Clock signal used for synchronous operation.\n   reset: Reset signal used to initialize the multiplier module.\n   a: 8-bit input representing the multiplicand.\n   b: 8-bit input representing the multiplier.\n\nOutput ports:\n   p: 16-bit output representing the product of the multiplication.\n   rdy: Ready signal indicating the completion of the multiplication operation.\n\nImplementation:\nOn the positive edge of the clock signal (clk) or the positive edge of the reset signal (reset), the module performs the multiplication process.\nIf the reset signal (reset) is high, two 16-bit registers multiplier <= {{8{a[7]}}, a} and multiplicand <= {{8{b[7]}}, b}. \nIf the reset signal (reset) is low, indicating normal operation, the module checks if the counter (5bit ctr) is less than 16.\nIf the counter (ctr) is less than 16, the multiplicand register (multiplicand) is left-shifted by 1 to simulate the Booth algorithm's shifting operation.\nIf the current bit of the multiplier register (multiplier[ctr]) is 1, indicating a positive Booth encoding, the product register (p) accumulates the value of the multiplicand register (multiplicand).\nThe counter (ctr) is incremented by 1. Once the counter (ctr) reaches 16, indicating the completion of the multiplication process, the ready signal (rdy) is set to 1.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns / 1ps\n\nmodule verified_multi_booth_8bit (p, rdy, clk, reset, a, b);\n   input clk, reset;\n   input [7:0] a, b;\n   output [15:0] p;\n   output rdy;\n   \n   reg [15:0] p;\n   reg [15:0] multiplier;\n   reg [15:0] multiplicand;\n   reg rdy;\n   reg [4:0] ctr;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) \n    begin\n    rdy     <= 0;\n    p   <= 0;\n    ctr     <= 0;\n    multiplier <= {{8{a[7]}}, a};\n    multiplicand <= {{8{b[7]}}, b};\n    end \n    else \n    begin \n      if(ctr < 16) \n          begin\n          multiplicand <= multiplicand << 1;\n            if (multiplier[ctr] == 1)\n            begin\n                p <= p + multiplicand;\n            end\n            ctr <= ctr + 1;\n          end\n       else \n           begin\n           rdy <= 1;\n           end\n    end\n  end //End of always block\n    \nendmodule", "corrupted_code": "`timescale 1ns / 1ps\n\nmodule verified_multi_booth_8bit (p, rdy, clk, reset, a, b);\n   input clk, reset;\n   input [7:0] a, b;\n   output [15:0] p;\n   output rdy;\n   \n   reg [15:0] p;\n   reg [15:0] multiplier;\n   reg [15:0] multiplicand;\n   reg rdy;\n   reg [4:0] ctr;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) \n    begin \n      if(ctr < 16) \n          begin\n          multiplicand <= multiplicand << 1;\n            if (multiplier[ctr] == 1)\n            begin\n                p <= p + multiplicand;\n            end \n    else \n    begin\n    rdy     <= 0;\n    p   <= 0;\n    ctr     <= 0;\n    multiplier <= {{8{a[7]}}, a};\n    multiplicand <= {{8{b[7]}}, b};\n    end\n            ctr <= ctr + 1;\n          end\n       else \n           begin\n           rdy <= 1;\n           end\n    end\n  end //End of always block\n    \nendmodule", "corruption_explanation": "Swapped if and else bodies", "modification_type": "invert_if_else", "modification_line": 16, "original_snippet": "if (reset) \n    begin\n    rdy     <= 0;\n    p   <= 0;\n    ctr     <= 0;\n    multiplier <= {{8{a[7]}}, a};\n    multiplicand <= {{8{b[7]}}, b};\n    end \n    else \n    begin \n      if(ctr < 16) \n        ", "modified_snippet": "if (reset) \n    begin \n      if(ctr < 16) \n          begin\n          multiplicand <= multiplicand << 1;\n            if (multiplier[ctr] == 1)\n            begin\n                p <= p + multiplicand;\n ", "issue_description": "The buggy code has swapped if and else bodies in a conditional block. This causes the logic to execute the opposite branch for each condition, leading to incorrect behavior when the condition is true vs false. Test cases that depend on the conditional logic will fail because the intended branch is not executed.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module contains conditional logic that should execute different code paths based on a condition.\n   \u2022 The if branch should handle the true case, and the else branch should handle the false case.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Identified a conditional block with both if and else branches.\n   \u2022 The branches contain different assignments or logic operations.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The if and else bodies have been swapped.\n   \u2022 Logic that should execute when condition is true now executes when false, and vice versa.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The conditional bodies are inverted.\n   \u2022 Impact: All conditional behavior is reversed, causing incorrect outputs for all test cases.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Swap the if and else bodies back to their correct positions.\n   \u2022 Verify that the condition evaluates correctly and executes the intended branch.\n\n6. RTL Design Principle Violated:\n   \u2022 Correct conditional logic requires matching the intended behavior with the branch bodies.", "complexity": 16, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_if_else"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.130277", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_8bit", "module_name": "multi_8bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of an 8-bit multiplier based on shifting and adding operations.\n\nModule name:  \n    multi_8bit               \nInput ports:\n    A [7:0]: First 8-bit input operand (representing a multiplicand).\n    B [7:0]: Second 8-bit input operand (representing a multiplier).\nOutput ports:\n    product [15:0]: 16-bit output representing the product of the two 8-bit inputs (A * B).\n\nImplementation:\nMultiplication: The module performs multiplication of A and B using the shift-and-add method.\n- The algorithm iterates through each bit of the multiplier (B). For each bit that is set (1), the multiplicand (A) is added to the product at the corresponding shifted position.\n- The process continues until all bits of the multiplier have been processed.\n\nShifting: After each addition, the multiplicand is logically shifted left by one bit to prepare for the next addition, simulating the traditional multiplication process.\n\nThe final product is stored in the output port, which is 16 bits wide to accommodate the maximum possible product of two 8-bit numbers.\n\nGive me the complete code.\n"}, "clean_code": "module multi_8bit (\n  input [7:0] A,\n  input [7:0] B,\n  output reg [15:0] product\n);\n\n  reg [7:0] multiplicand;\n  reg [3:0] shift_count;\n\n  always @* begin\n    product = 16'b0; \n    multiplicand = A; \n    shift_count = 0;  \n\n    for (int i = 0; i < 8; i = i + 1) begin\n      if (B[i] == 1) begin\n        product = product + (multiplicand << shift_count);\n      end\n      shift_count = shift_count + 1;\n    end\n  end\n\nendmodule", "corrupted_code": "module multi_8bit (\n  input [7:0] A,\n  input [7:0] B,\n  output reg [15:0] product\n);\n\n  reg [7:0] multiplicand;\n  reg [3:0] shift_count;\n\n  always @* begin\n    product = 16'b0; \n    multiplicand = A; \n    shift_count = 0;  \n\n    \n      shift_count = shift_count + 1;\n    end\n  end\n\nendmodule", "corruption_explanation": "Removed a loop block", "modification_type": "remove_loop", "modification_line": 15, "original_snippet": "for (int i = 0; i < 8; i = i + 1) begin\n      if (B[i] == 1) begin\n        product = product + (multiplicand << shift_count);\n      end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing a loop construct. This removes iterative logic that may be essential for initialization, array operations, or repetitive computations. Functionality that depends on the loop will be broken.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_loop modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed a loop block\n   \u2022 Line 15: Original: for (int i = 0; i < 8; i = i + 1) begin\n      if (B[i] == 1) begin\n        product = product + (multiplicand << shift_count);\n      end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 15.\n   \u2022 Restore the original code: for (int i = 0; i < 8; i = i + 1) begin\n      if (B[i] == 1) begin\n        product = product + (multiplicand << shift_count);\n      end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove loop.", "complexity": 7, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["remove_loop"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.133205", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_8bit", "module_name": "multi_8bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of an 8-bit multiplier based on shifting and adding operations.\n\nModule name:  \n    multi_8bit               \nInput ports:\n    A [7:0]: First 8-bit input operand (representing a multiplicand).\n    B [7:0]: Second 8-bit input operand (representing a multiplier).\nOutput ports:\n    product [15:0]: 16-bit output representing the product of the two 8-bit inputs (A * B).\n\nImplementation:\nMultiplication: The module performs multiplication of A and B using the shift-and-add method.\n- The algorithm iterates through each bit of the multiplier (B). For each bit that is set (1), the multiplicand (A) is added to the product at the corresponding shifted position.\n- The process continues until all bits of the multiplier have been processed.\n\nShifting: After each addition, the multiplicand is logically shifted left by one bit to prepare for the next addition, simulating the traditional multiplication process.\n\nThe final product is stored in the output port, which is 16 bits wide to accommodate the maximum possible product of two 8-bit numbers.\n\nGive me the complete code.\n"}, "clean_code": "module multi_8bit (\n  input [7:0] A,\n  input [7:0] B,\n  output reg [15:0] product\n);\n\n  reg [7:0] multiplicand;\n  reg [3:0] shift_count;\n\n  always @* begin\n    product = 16'b0; \n    multiplicand = A; \n    shift_count = 0;  \n\n    for (int i = 0; i < 8; i = i + 1) begin\n      if (B[i] == 1) begin\n        product = product + (multiplicand << shift_count);\n      end\n      shift_count = shift_count + 1;\n    end\n  end\n\nendmodule", "corrupted_code": "module multi_8bit (\n  input [7:0] A,\n  input [7:0] B,\n  output reg [15:0] product\n);\n\n  reg [7:0] multiplicand;\n  reg [3:0] shift_count;\n\n  always @* begin\n    product = 16'b0; \n    multiplicand = A; \n    shift_count = 1;  \n\n    for (int i = 0; i < 8; i = i + 1) begin\n      if (B[i] == 1) begin\n        product = product + (multiplicand << shift_count);\n      end\n      shift_count = shift_count + 1;\n    end\n  end\n\nendmodule", "corruption_explanation": "Changed constant from 0 to 1", "modification_type": "change_constant", "modification_line": 13, "original_snippet": "0", "modified_snippet": "1", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 0 to 1\n   \u2022 Line 13: Original: 0\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 13.\n   \u2022 Restore the original code: 0\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 7, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["change_constant"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.133904", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_8bit", "module_name": "multi_8bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of an 8-bit multiplier based on shifting and adding operations.\n\nModule name:  \n    multi_8bit               \nInput ports:\n    A [7:0]: First 8-bit input operand (representing a multiplicand).\n    B [7:0]: Second 8-bit input operand (representing a multiplier).\nOutput ports:\n    product [15:0]: 16-bit output representing the product of the two 8-bit inputs (A * B).\n\nImplementation:\nMultiplication: The module performs multiplication of A and B using the shift-and-add method.\n- The algorithm iterates through each bit of the multiplier (B). For each bit that is set (1), the multiplicand (A) is added to the product at the corresponding shifted position.\n- The process continues until all bits of the multiplier have been processed.\n\nShifting: After each addition, the multiplicand is logically shifted left by one bit to prepare for the next addition, simulating the traditional multiplication process.\n\nThe final product is stored in the output port, which is 16 bits wide to accommodate the maximum possible product of two 8-bit numbers.\n\nGive me the complete code.\n"}, "clean_code": "module multi_8bit (\n  input [7:0] A,\n  input [7:0] B,\n  output reg [15:0] product\n);\n\n  reg [7:0] multiplicand;\n  reg [3:0] shift_count;\n\n  always @* begin\n    product = 16'b0; \n    multiplicand = A; \n    shift_count = 0;  \n\n    for (int i = 0; i < 8; i = i + 1) begin\n      if (B[i] == 1) begin\n        product = product + (multiplicand << shift_count);\n      end\n      shift_count = shift_count + 1;\n    end\n  end\n\nendmodule", "corrupted_code": "module multi_8bit (\n  input [7:0] A,\n  input [7:0] B,\n  output reg [15:0] product\n);\n\n  reg [7:0] multiplicand;\n  reg [3:0] shift_count;\n\n  always @* begin\n    product = 16'b0; \n    multiplicand = A; \n    shift_count = 0;  \n\n    for (int i = 0; i > 8; i = i + 1) begin\n      if (B[i] == 1) begin\n        product = product + (multiplicand << shift_count);\n      end\n      shift_count = shift_count + 1;\n    end\n  end\n\nendmodule", "corruption_explanation": "Changed operator from '<' to '>'", "modification_type": "change_operator", "modification_line": 15, "original_snippet": "<", "modified_snippet": ">", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '<' to '>'\n   \u2022 Line 15: Original: <\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 15.\n   \u2022 Restore the original code: <\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 7, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.134682", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_8bit", "module_name": "multi_8bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of an 8-bit multiplier based on shifting and adding operations.\n\nModule name:  \n    multi_8bit               \nInput ports:\n    A [7:0]: First 8-bit input operand (representing a multiplicand).\n    B [7:0]: Second 8-bit input operand (representing a multiplier).\nOutput ports:\n    product [15:0]: 16-bit output representing the product of the two 8-bit inputs (A * B).\n\nImplementation:\nMultiplication: The module performs multiplication of A and B using the shift-and-add method.\n- The algorithm iterates through each bit of the multiplier (B). For each bit that is set (1), the multiplicand (A) is added to the product at the corresponding shifted position.\n- The process continues until all bits of the multiplier have been processed.\n\nShifting: After each addition, the multiplicand is logically shifted left by one bit to prepare for the next addition, simulating the traditional multiplication process.\n\nThe final product is stored in the output port, which is 16 bits wide to accommodate the maximum possible product of two 8-bit numbers.\n\nGive me the complete code.\n"}, "clean_code": "module multi_8bit (\n  input [7:0] A,\n  input [7:0] B,\n  output reg [15:0] product\n);\n\n  reg [7:0] multiplicand;\n  reg [3:0] shift_count;\n\n  always @* begin\n    product = 16'b0; \n    multiplicand = A; \n    shift_count = 0;  \n\n    for (int i = 0; i < 8; i = i + 1) begin\n      if (B[i] == 1) begin\n        product = product + (multiplicand << shift_count);\n      end\n      shift_count = shift_count + 1;\n    end\n  end\n\nendmodule", "corrupted_code": "module multi_8bit (\n  input [7:0] A,\n  input [7:0] B,\n  output reg [15:0] product\n);\n\n  reg [7:0] multiplicand;\n  reg [3:0] shift_count;\n\n  \n      shift_count = shift_count + 1;\n    end\n  end\n\nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 10, "original_snippet": "always @* begin\n    product = 16'b0; \n    multiplicand = A; \n    shift_count = 0;  \n\n    for (int i = 0; i < 8; i = i + 1) begin\n      if (B[i] == 1) begin\n        product = product + (multiplicand <<", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 10: Original: always @* begin\n    product = 16'b0; \n    multiplicand = A; \n    shift_count = 0;  \n\n    for (int i = 0; i < 8; i = i + 1) begin\n      if (B[i] == 1) begin\n        product = product + (multiplicand <<\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 10.\n   \u2022 Restore the original code: always @* begin\n    product = 16'b0; \n    multiplicand = A; \n    shift_count = 0;  \n\n    for (int i = 0; i < 8; i = i + 1) begin\n      if (B[i] == 1) begin\n        product = product + (multiplicand <<\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 7, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.135363", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_8bit", "module_name": "multi_8bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of an 8-bit multiplier based on shifting and adding operations.\n\nModule name:  \n    multi_8bit               \nInput ports:\n    A [7:0]: First 8-bit input operand (representing a multiplicand).\n    B [7:0]: Second 8-bit input operand (representing a multiplier).\nOutput ports:\n    product [15:0]: 16-bit output representing the product of the two 8-bit inputs (A * B).\n\nImplementation:\nMultiplication: The module performs multiplication of A and B using the shift-and-add method.\n- The algorithm iterates through each bit of the multiplier (B). For each bit that is set (1), the multiplicand (A) is added to the product at the corresponding shifted position.\n- The process continues until all bits of the multiplier have been processed.\n\nShifting: After each addition, the multiplicand is logically shifted left by one bit to prepare for the next addition, simulating the traditional multiplication process.\n\nThe final product is stored in the output port, which is 16 bits wide to accommodate the maximum possible product of two 8-bit numbers.\n\nGive me the complete code.\n"}, "clean_code": "module multi_8bit (\n  input [7:0] A,\n  input [7:0] B,\n  output reg [15:0] product\n);\n\n  reg [7:0] multiplicand;\n  reg [3:0] shift_count;\n\n  always @* begin\n    product = 16'b0; \n    multiplicand = A; \n    shift_count = 0;  \n\n    for (int i = 0; i < 8; i = i + 1) begin\n      if (B[i] == 1) begin\n        product = product + (multiplicand << shift_count);\n      end\n      shift_count = shift_count + 1;\n    end\n  end\n\nendmodule", "corrupted_code": "module multi_8bit (\n  input [7:0] A,\n  input [7:0] B,\n  output reg [15:0] product\n);\n\n  reg [7:0] multiplicand;\n  reg [3:0] shift_count;\n\n  always @* begin\n    product = 16'b0; \n\n    shift_count = 0;  \n\n    for (int i = 0; i < 8; i = i + 1) begin\n      if (B[i] == 1) begin\n        product = product + (multiplicand << shift_count);\n      end\n      shift_count = shift_count + 1;\n    end\n  end\n\nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 12, "original_snippet": "multiplicand = A;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 12: Original: multiplicand = A;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 12.\n   \u2022 Restore the original code: multiplicand = A;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 7, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["remove_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.157266", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_8bit", "module_name": "multi_8bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of an 8-bit multiplier based on shifting and adding operations.\n\nModule name:  \n    multi_8bit               \nInput ports:\n    A [7:0]: First 8-bit input operand (representing a multiplicand).\n    B [7:0]: Second 8-bit input operand (representing a multiplier).\nOutput ports:\n    product [15:0]: 16-bit output representing the product of the two 8-bit inputs (A * B).\n\nImplementation:\nMultiplication: The module performs multiplication of A and B using the shift-and-add method.\n- The algorithm iterates through each bit of the multiplier (B). For each bit that is set (1), the multiplicand (A) is added to the product at the corresponding shifted position.\n- The process continues until all bits of the multiplier have been processed.\n\nShifting: After each addition, the multiplicand is logically shifted left by one bit to prepare for the next addition, simulating the traditional multiplication process.\n\nThe final product is stored in the output port, which is 16 bits wide to accommodate the maximum possible product of two 8-bit numbers.\n\nGive me the complete code.\n"}, "clean_code": "module multi_8bit (\n  input [7:0] A,\n  input [7:0] B,\n  output reg [15:0] product\n);\n\n  reg [7:0] multiplicand;\n  reg [3:0] shift_count;\n\n  always @* begin\n    product = 16'b0; \n    multiplicand = A; \n    shift_count = 0;  \n\n    for (int i = 0; i < 8; i = i + 1) begin\n      if (B[i] == 1) begin\n        product = product + (multiplicand << shift_count);\n      end\n      shift_count = shift_count + 1;\n    end\n  end\n\nendmodule", "corrupted_code": "module multi_8bit (\n  input [7:0] A,\n  input [7:0] B,\n  output reg [15:0] product\n);\n\n  reg [7:0] multiplicand;\n  reg [3:0] shift_count;\n\n  always @* begin\n    product = 16'b0; \n    multiplicand = A; \n    shift_count = 0;  \n\n    for (int i = 0; i < 8; i = i + 1) begin\n      if (!(B[i] == 1)) begin\n        product = product + (multiplicand << shift_count);\n      end\n      shift_count = shift_count + 1;\n    end\n  end\n\nendmodule", "corruption_explanation": "Inverted condition: 'B[i] == 1' -> '!(B[i] == 1)'", "modification_type": "invert_condition", "modification_line": 16, "original_snippet": "if (B[i] == 1) begin", "modified_snippet": "if (!(B[i] == 1)) begin", "issue_description": "The buggy code has an inverted condition in an if statement. Instead of checking if(x), it checks if(!x), causing the logic to execute when it shouldn't and skip execution when it should. All conditional behavior is reversed from intended functionality.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_condition modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted condition: 'B[i] == 1' -> '!(B[i] == 1)'\n   \u2022 Line 16: Original: if (B[i] == 1) begin\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 16.\n   \u2022 Restore the original code: if (B[i] == 1) begin\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert condition.", "complexity": 7, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["invert_condition"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.158091", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_8bit", "module_name": "multi_8bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of an 8-bit multiplier based on shifting and adding operations.\n\nModule name:  \n    multi_8bit               \nInput ports:\n    A [7:0]: First 8-bit input operand (representing a multiplicand).\n    B [7:0]: Second 8-bit input operand (representing a multiplier).\nOutput ports:\n    product [15:0]: 16-bit output representing the product of the two 8-bit inputs (A * B).\n\nImplementation:\nMultiplication: The module performs multiplication of A and B using the shift-and-add method.\n- The algorithm iterates through each bit of the multiplier (B). For each bit that is set (1), the multiplicand (A) is added to the product at the corresponding shifted position.\n- The process continues until all bits of the multiplier have been processed.\n\nShifting: After each addition, the multiplicand is logically shifted left by one bit to prepare for the next addition, simulating the traditional multiplication process.\n\nThe final product is stored in the output port, which is 16 bits wide to accommodate the maximum possible product of two 8-bit numbers.\n\nGive me the complete code.\n"}, "clean_code": "module multi_8bit (\n  input [7:0] A,\n  input [7:0] B,\n  output reg [15:0] product\n);\n\n  reg [7:0] multiplicand;\n  reg [3:0] shift_count;\n\n  always @* begin\n    product = 16'b0; \n    multiplicand = A; \n    shift_count = 0;  \n\n    for (int i = 0; i < 8; i = i + 1) begin\n      if (B[i] == 1) begin\n        product = product + (multiplicand << shift_count);\n      end\n      shift_count = shift_count + 1;\n    end\n  end\n\nendmodule", "corrupted_code": "module multi_8bit (\n  input [7:0] A,\n  input [7:0] B,\n  output reg [15:0] product\n);\n\n  reg [7:0] multiplicand;\n  reg [3:0] shift_count;\n\n  always @* begin\n    product = 16'b0; \n\n    shift_count = 0;  \n\n    for (int i = 0; i < 8; i = i + 1) begin\n      if (B[i] == 1) begin\n        product = product + (multiplicand << shift_count);\n      end\n      shift_count = shift_count + 1;\n    end\n  end\n\nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 12, "original_snippet": "multiplicand = A;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 12: Original: multiplicand = A;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 12.\n   \u2022 Restore the original code: multiplicand = A;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 7, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["remove_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.158840", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_8bit", "module_name": "multi_8bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of an 8-bit multiplier based on shifting and adding operations.\n\nModule name:  \n    multi_8bit               \nInput ports:\n    A [7:0]: First 8-bit input operand (representing a multiplicand).\n    B [7:0]: Second 8-bit input operand (representing a multiplier).\nOutput ports:\n    product [15:0]: 16-bit output representing the product of the two 8-bit inputs (A * B).\n\nImplementation:\nMultiplication: The module performs multiplication of A and B using the shift-and-add method.\n- The algorithm iterates through each bit of the multiplier (B). For each bit that is set (1), the multiplicand (A) is added to the product at the corresponding shifted position.\n- The process continues until all bits of the multiplier have been processed.\n\nShifting: After each addition, the multiplicand is logically shifted left by one bit to prepare for the next addition, simulating the traditional multiplication process.\n\nThe final product is stored in the output port, which is 16 bits wide to accommodate the maximum possible product of two 8-bit numbers.\n\nGive me the complete code.\n"}, "clean_code": "module multi_8bit (\n  input [7:0] A,\n  input [7:0] B,\n  output reg [15:0] product\n);\n\n  reg [7:0] multiplicand;\n  reg [3:0] shift_count;\n\n  always @* begin\n    product = 16'b0; \n    multiplicand = A; \n    shift_count = 0;  \n\n    for (int i = 0; i < 8; i = i + 1) begin\n      if (B[i] == 1) begin\n        product = product + (multiplicand << shift_count);\n      end\n      shift_count = shift_count + 1;\n    end\n  end\n\nendmodule", "corrupted_code": "module multi_8bit (\n  input [7:0] A,\n  input [7:0] B,\n  output reg [15:0] product\n);\n\n  reg [7:0] multiplicand;\n  reg [3:0] shift_count;\n\n  \n      shift_count = shift_count + 1;\n    end\n  end\n\nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 10, "original_snippet": "always @* begin\n    product = 16'b0; \n    multiplicand = A; \n    shift_count = 0;  \n\n    for (int i = 0; i < 8; i = i + 1) begin\n      if (B[i] == 1) begin\n        product = product + (multiplicand <<", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 10: Original: always @* begin\n    product = 16'b0; \n    multiplicand = A; \n    shift_count = 0;  \n\n    for (int i = 0; i < 8; i = i + 1) begin\n      if (B[i] == 1) begin\n        product = product + (multiplicand <<\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 10.\n   \u2022 Restore the original code: always @* begin\n    product = 16'b0; \n    multiplicand = A; \n    shift_count = 0;  \n\n    for (int i = 0; i < 8; i = i + 1) begin\n      if (B[i] == 1) begin\n        product = product + (multiplicand <<\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 7, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.159552", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_8bit", "module_name": "multi_8bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of an 8-bit multiplier based on shifting and adding operations.\n\nModule name:  \n    multi_8bit               \nInput ports:\n    A [7:0]: First 8-bit input operand (representing a multiplicand).\n    B [7:0]: Second 8-bit input operand (representing a multiplier).\nOutput ports:\n    product [15:0]: 16-bit output representing the product of the two 8-bit inputs (A * B).\n\nImplementation:\nMultiplication: The module performs multiplication of A and B using the shift-and-add method.\n- The algorithm iterates through each bit of the multiplier (B). For each bit that is set (1), the multiplicand (A) is added to the product at the corresponding shifted position.\n- The process continues until all bits of the multiplier have been processed.\n\nShifting: After each addition, the multiplicand is logically shifted left by one bit to prepare for the next addition, simulating the traditional multiplication process.\n\nThe final product is stored in the output port, which is 16 bits wide to accommodate the maximum possible product of two 8-bit numbers.\n\nGive me the complete code.\n"}, "clean_code": "module multi_8bit (\n  input [7:0] A,\n  input [7:0] B,\n  output reg [15:0] product\n);\n\n  reg [7:0] multiplicand;\n  reg [3:0] shift_count;\n\n  always @* begin\n    product = 16'b0; \n    multiplicand = A; \n    shift_count = 0;  \n\n    for (int i = 0; i < 8; i = i + 1) begin\n      if (B[i] == 1) begin\n        product = product + (multiplicand << shift_count);\n      end\n      shift_count = shift_count + 1;\n    end\n  end\n\nendmodule", "corrupted_code": "module multi_8bit (\n  input [7:0] A,\n  input [7:0] B,\n  output reg [15:0] product\n);\n\n  reg [7:0] multiplicand;\n  reg [3:0] shift_count;\n\n  always @* begin\n    product = 16'b0; \n    multiplicand = A; \n    shift_count = 0;  \n\n    for (int i = 0; i < 8; i = i + 1) begin\n      if (B[i] == 1) begin\n        product = product + (shift_count << multiplicand);\n      end\n      shift_count = shift_count + 1;\n    end\n  end\n\nendmodule", "corruption_explanation": "Swapped operands: 'multiplicand << shift_count' -> 'shift_count << multiplicand'", "modification_type": "swap_operands", "modification_line": 17, "original_snippet": "multiplicand << shift_count", "modified_snippet": "shift_count << multiplicand", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'multiplicand << shift_count' -> 'shift_count << multiplicand'\n   \u2022 Line 17: Original: multiplicand << shift_count\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 17.\n   \u2022 Restore the original code: multiplicand << shift_count\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 7, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["swap_operands"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.160257", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_8bit", "module_name": "multi_8bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of an 8-bit multiplier based on shifting and adding operations.\n\nModule name:  \n    multi_8bit               \nInput ports:\n    A [7:0]: First 8-bit input operand (representing a multiplicand).\n    B [7:0]: Second 8-bit input operand (representing a multiplier).\nOutput ports:\n    product [15:0]: 16-bit output representing the product of the two 8-bit inputs (A * B).\n\nImplementation:\nMultiplication: The module performs multiplication of A and B using the shift-and-add method.\n- The algorithm iterates through each bit of the multiplier (B). For each bit that is set (1), the multiplicand (A) is added to the product at the corresponding shifted position.\n- The process continues until all bits of the multiplier have been processed.\n\nShifting: After each addition, the multiplicand is logically shifted left by one bit to prepare for the next addition, simulating the traditional multiplication process.\n\nThe final product is stored in the output port, which is 16 bits wide to accommodate the maximum possible product of two 8-bit numbers.\n\nGive me the complete code.\n"}, "clean_code": "module multi_8bit (\n  input [7:0] A,\n  input [7:0] B,\n  output reg [15:0] product\n);\n\n  reg [7:0] multiplicand;\n  reg [3:0] shift_count;\n\n  always @* begin\n    product = 16'b0; \n    multiplicand = A; \n    shift_count = 0;  \n\n    for (int i = 0; i < 8; i = i + 1) begin\n      if (B[i] == 1) begin\n        product = product + (multiplicand << shift_count);\n      end\n      shift_count = shift_count + 1;\n    end\n  end\n\nendmodule", "corrupted_code": "module multi_8bit (\n  input [7:0] A,\n  input [7:0] B,\n  output reg [15:0] product\n);\n\n  reg [7:0] multiplicand;\n  reg [3:0] shift_count;\n\n  always @* begin\n    product = 16'b0; \n    multiplicand = A; \n    shift_count = 0;  \n\n    for (int i = 0; i < 8; i = i + 1) begin\n      if (B[i] != 1) begin\n        product = product + (multiplicand << shift_count);\n      end\n      shift_count = shift_count + 1;\n    end\n  end\n\nendmodule", "corruption_explanation": "Changed operator from '==' to '!='", "modification_type": "change_operator", "modification_line": 16, "original_snippet": "==", "modified_snippet": "!=", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '==' to '!='\n   \u2022 Line 16: Original: ==\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 16.\n   \u2022 Restore the original code: ==\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 7, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.160996", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_pipe_4bit", "module_name": "multi_pipe_4bit", "description": "Please act as a professional verilog designer.\n\nImplement the design of 4bit unsigned number pipeline multiplier. It consists of two levels of registers to store intermediate values and control the multiplication process.\n\nModule name:  \n    multi_pipe_4bit \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    mul_a: Input signal representing the multiplicand with a data width of \"size\" bits.\n    mul_b: Input signal representing the multiplier with a data width of \"size\" bits.\t\n\nOutput ports:\n    mul_out: Product output signal with a data width of 2*size bits.\n\nParameter:\n    size = 4\n\nImplementation:\nExtension of input signals:\nThe input signals (mul_a and mul_b) are extended by adding \"size\" number of zero bits at the most significant bit positions.\nMultiplication operation:\nThe module uses a generate block to perform multiplication for each bit position of the multiplier (mul_b) and generate the partial products.\nFor each bit position i from 0 to size-1, the partial product is calculated as follows:\nIf the corresponding bit in the multiplier is 1, the multiplicand is left-shifted by i positions.\nIf the corresponding bit in the multiplier is 0, the partial product is set to 0 ('d0).\nAdd of partial products:\nThe module uses registers to store the intermediate sum values.\nOn the positive edge of the clock signal (clk) or the falling edge of the reset signal (rst_n), the module performs add operations.\nIf the reset signal (rst_n) is low, indicating a reset condition, the registers are set to 0.\nIf the reset signal (rst_n) is high, the registers are updated with the sum of the corresponding partial products.\nFinal product calculation:\nOn the positive edge of the clock signal (clk) or the falling edge of the reset signal (rst_n), the module calculates the final product.\nIf the reset signal (rst_n) is low, indicating a reset condition, the product output (mul_out) is set to 0.\nIf the reset signal (rst_n) is high, the product output (mul_out) is updated with the sum of registers.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule verified_multi_pipe#(\n\tparameter size = 4\n)(\n\tinput \t\t\t\t\t\tclk \t\t,   \n\tinput \t\t\t\t\t\trst_n\t\t,\n\tinput\t[size-1:0]\t\t\tmul_a\t\t,\n\tinput\t[size-1:0]\t\t\tmul_b\t\t,\n \n \toutput\treg\t[size*2-1:0]\tmul_out\t\t\n);\n\nparameter N = 2 * size;\n\nreg     [N-1:0]     sum_tmp1                ;\nreg     [N-1:0]     sum_tmp2                ;\nwire    [N-1:0]     mul_a_extend            ;\nwire    [N-1:0]     mul_b_extend            ;\n\nwire    [N-1:0]     mul_result[size-1:0]    ;\n\ngenvar i;\ngenerate\n    for(i = 0; i < size; i = i + 1) begin:add\n        assign mul_result[i] = mul_b[i] ? mul_a_extend << i : 'd0;\n    end\nendgenerate\n\nassign mul_a_extend = {{size{1'b0}}, mul_a};\nassign mul_b_extend = {{size{1'b0}}, mul_b};\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        sum_tmp1 <= 'd0;\n        sum_tmp2 <= 'd0;\n    end\n    else begin\n        sum_tmp1 <= mul_result[0] + mul_result[1];\n        sum_tmp2 <= mul_result[2] + mul_result[3];\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        mul_out <= 'd0;\n    end\n    else begin\n        mul_out <= sum_tmp1 + sum_tmp2;\n    end\nend\n\nendmodule\n\n", "corrupted_code": "`timescale 1ns/1ns\nmodule verified_multi_pipe#(\n\tparameter size = 4\n)(\n\tinput \t\t\t\t\t\tclk \t\t,   \n\tinput \t\t\t\t\t\trst_n\t\t,\n\tinput\t[size-1:0]\t\t\tmul_a\t\t,\n\tinput\t[size-1:0]\t\t\tmul_b\t\t,\n \n \toutput\treg\t[size*2-1:0]\tmul_out\t\t\n);\n\nparameter N = 2 * size;\n\nreg     [N-1:0]     sum_tmp1                ;\nreg     [N-1:0]     sum_tmp2                ;\nwire    [N-1:0]     mul_a_extend            ;\nwire    [N-1:0]     mul_b_extend            ;\n\nwire    [N-1:0]     mul_result[size-1:0]    ;\n\ngenvar i;\ngenerate\n    for(i = 0; i < size; i = i + 1) begin:add\n        assign mul_result[i] = mul_b[i] ? mul_a_extend << i : 'd0;\n    end\nendgenerate\n\nassign mul_a_extend = {{size{1'b0}}, mul_a};\nassign mul_b_extend = {{size{1'b0}}, mul_b};\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        sum_tmp1 <= 'd0;\n        sum_tmp2 <= 'd0;\n    end\n    else begin\n        sum_tmp1 <= mul_result[0] + mul_result[1];\n        sum_tmp2 <= mul_result[2] + mul_result[3];\n    end\nend\n\nalways @(posedge clk) begin\n    if(!rst_n) begin\n        mul_out <= 'd0;\n    end\n    else begin\n        mul_out <= sum_tmp1 + sum_tmp2;\n    end\nend\n\nendmodule\n\n", "corruption_explanation": "Removed async reset from sensitivity list", "modification_type": "remove_async_reset", "modification_line": 43, "original_snippet": "always @(posedge clk or negedge rst_n)", "modified_snippet": "always @(posedge clk)", "issue_description": "The buggy code has removed async reset from the sensitivity list. The always block only triggers on clock edges, not reset. This causes metastability on power-up and removes the ability to asynchronously reset the design.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_async_reset modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed async reset from sensitivity list\n   \u2022 Line 43: Original: always @(posedge clk or negedge rst_n)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 43.\n   \u2022 Restore the original code: always @(posedge clk or negedge rst_n)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove async reset.", "complexity": 23, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_async_reset"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.164083", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_pipe_4bit", "module_name": "multi_pipe_4bit", "description": "Please act as a professional verilog designer.\n\nImplement the design of 4bit unsigned number pipeline multiplier. It consists of two levels of registers to store intermediate values and control the multiplication process.\n\nModule name:  \n    multi_pipe_4bit \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    mul_a: Input signal representing the multiplicand with a data width of \"size\" bits.\n    mul_b: Input signal representing the multiplier with a data width of \"size\" bits.\t\n\nOutput ports:\n    mul_out: Product output signal with a data width of 2*size bits.\n\nParameter:\n    size = 4\n\nImplementation:\nExtension of input signals:\nThe input signals (mul_a and mul_b) are extended by adding \"size\" number of zero bits at the most significant bit positions.\nMultiplication operation:\nThe module uses a generate block to perform multiplication for each bit position of the multiplier (mul_b) and generate the partial products.\nFor each bit position i from 0 to size-1, the partial product is calculated as follows:\nIf the corresponding bit in the multiplier is 1, the multiplicand is left-shifted by i positions.\nIf the corresponding bit in the multiplier is 0, the partial product is set to 0 ('d0).\nAdd of partial products:\nThe module uses registers to store the intermediate sum values.\nOn the positive edge of the clock signal (clk) or the falling edge of the reset signal (rst_n), the module performs add operations.\nIf the reset signal (rst_n) is low, indicating a reset condition, the registers are set to 0.\nIf the reset signal (rst_n) is high, the registers are updated with the sum of the corresponding partial products.\nFinal product calculation:\nOn the positive edge of the clock signal (clk) or the falling edge of the reset signal (rst_n), the module calculates the final product.\nIf the reset signal (rst_n) is low, indicating a reset condition, the product output (mul_out) is set to 0.\nIf the reset signal (rst_n) is high, the product output (mul_out) is updated with the sum of registers.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule verified_multi_pipe#(\n\tparameter size = 4\n)(\n\tinput \t\t\t\t\t\tclk \t\t,   \n\tinput \t\t\t\t\t\trst_n\t\t,\n\tinput\t[size-1:0]\t\t\tmul_a\t\t,\n\tinput\t[size-1:0]\t\t\tmul_b\t\t,\n \n \toutput\treg\t[size*2-1:0]\tmul_out\t\t\n);\n\nparameter N = 2 * size;\n\nreg     [N-1:0]     sum_tmp1                ;\nreg     [N-1:0]     sum_tmp2                ;\nwire    [N-1:0]     mul_a_extend            ;\nwire    [N-1:0]     mul_b_extend            ;\n\nwire    [N-1:0]     mul_result[size-1:0]    ;\n\ngenvar i;\ngenerate\n    for(i = 0; i < size; i = i + 1) begin:add\n        assign mul_result[i] = mul_b[i] ? mul_a_extend << i : 'd0;\n    end\nendgenerate\n\nassign mul_a_extend = {{size{1'b0}}, mul_a};\nassign mul_b_extend = {{size{1'b0}}, mul_b};\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        sum_tmp1 <= 'd0;\n        sum_tmp2 <= 'd0;\n    end\n    else begin\n        sum_tmp1 <= mul_result[0] + mul_result[1];\n        sum_tmp2 <= mul_result[2] + mul_result[3];\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        mul_out <= 'd0;\n    end\n    else begin\n        mul_out <= sum_tmp1 + sum_tmp2;\n    end\nend\n\nendmodule\n\n", "corrupted_code": "`timescale 1ns/1ns\nmodule verified_multi_pipe#(\n\tparameter size = 4\n)(\n\tinput \t\t\t\t\t\tclk \t\t,   \n\tinput \t\t\t\t\t\trst_n\t\t,\n\tinput\t[size-1:0]\t\t\tmul_a\t\t,\n\tinput\t[size-1:0]\t\t\tmul_b\t\t,\n \n \toutput\treg\t[size*2-1:0]\tmul_out\t\t\n);\n\nparameter N = 2 * size;\n\nreg     [N-1:0]     sum_tmp1                ;\nreg     [N-1:0]     sum_tmp2                ;\nwire    [N-1:0]     mul_a_extend            ;\nwire    [N-1:0]     mul_b_extend            ;\n\nwire    [N-1:0]     mul_result[size-1:0]    ;\n\ngenvar i;\ngenerate\n    for(i = 0; i < size; i = i + 1) begin:add\n        assign mul_result[i] = mul_b[i] ? mul_a_extend << i : 'd0;\n    end\nendgenerate\n\nassign mul_a_extend = {{size{1'b0}}, mul_a};\nassign mul_b_extend = {{size{1'b0}}, mul_b};\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        sum_tmp1 <= 'd0;\n        sum_tmp2 <= 'd0;\n    end\n    else begin\n        sum_tmp1 <= mul_result[0] + mul_result[1];\n        sum_tmp2 <= mul_result[2] + mul_result[3];\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    \nend\n\nendmodule\n\n", "corruption_explanation": "Removed a conditional block", "modification_type": "remove_conditional", "modification_line": 44, "original_snippet": "if(!rst_n) begin\n        mul_out <= 'd0;\n    end\n    else begin\n        mul_out <= sum_tmp1 + sum_tmp2;\n    end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing a conditional block. This removes important control logic, causing the design to skip necessary state transitions or data processing. Test cases that depend on the conditional behavior will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_conditional modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed a conditional block\n   \u2022 Line 44: Original: if(!rst_n) begin\n        mul_out <= 'd0;\n    end\n    else begin\n        mul_out <= sum_tmp1 + sum_tmp2;\n    end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 44.\n   \u2022 Restore the original code: if(!rst_n) begin\n        mul_out <= 'd0;\n    end\n    else begin\n        mul_out <= sum_tmp1 + sum_tmp2;\n    end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove conditional.", "complexity": 23, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_conditional"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.165745", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_pipe_4bit", "module_name": "multi_pipe_4bit", "description": "Please act as a professional verilog designer.\n\nImplement the design of 4bit unsigned number pipeline multiplier. It consists of two levels of registers to store intermediate values and control the multiplication process.\n\nModule name:  \n    multi_pipe_4bit \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    mul_a: Input signal representing the multiplicand with a data width of \"size\" bits.\n    mul_b: Input signal representing the multiplier with a data width of \"size\" bits.\t\n\nOutput ports:\n    mul_out: Product output signal with a data width of 2*size bits.\n\nParameter:\n    size = 4\n\nImplementation:\nExtension of input signals:\nThe input signals (mul_a and mul_b) are extended by adding \"size\" number of zero bits at the most significant bit positions.\nMultiplication operation:\nThe module uses a generate block to perform multiplication for each bit position of the multiplier (mul_b) and generate the partial products.\nFor each bit position i from 0 to size-1, the partial product is calculated as follows:\nIf the corresponding bit in the multiplier is 1, the multiplicand is left-shifted by i positions.\nIf the corresponding bit in the multiplier is 0, the partial product is set to 0 ('d0).\nAdd of partial products:\nThe module uses registers to store the intermediate sum values.\nOn the positive edge of the clock signal (clk) or the falling edge of the reset signal (rst_n), the module performs add operations.\nIf the reset signal (rst_n) is low, indicating a reset condition, the registers are set to 0.\nIf the reset signal (rst_n) is high, the registers are updated with the sum of the corresponding partial products.\nFinal product calculation:\nOn the positive edge of the clock signal (clk) or the falling edge of the reset signal (rst_n), the module calculates the final product.\nIf the reset signal (rst_n) is low, indicating a reset condition, the product output (mul_out) is set to 0.\nIf the reset signal (rst_n) is high, the product output (mul_out) is updated with the sum of registers.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule verified_multi_pipe#(\n\tparameter size = 4\n)(\n\tinput \t\t\t\t\t\tclk \t\t,   \n\tinput \t\t\t\t\t\trst_n\t\t,\n\tinput\t[size-1:0]\t\t\tmul_a\t\t,\n\tinput\t[size-1:0]\t\t\tmul_b\t\t,\n \n \toutput\treg\t[size*2-1:0]\tmul_out\t\t\n);\n\nparameter N = 2 * size;\n\nreg     [N-1:0]     sum_tmp1                ;\nreg     [N-1:0]     sum_tmp2                ;\nwire    [N-1:0]     mul_a_extend            ;\nwire    [N-1:0]     mul_b_extend            ;\n\nwire    [N-1:0]     mul_result[size-1:0]    ;\n\ngenvar i;\ngenerate\n    for(i = 0; i < size; i = i + 1) begin:add\n        assign mul_result[i] = mul_b[i] ? mul_a_extend << i : 'd0;\n    end\nendgenerate\n\nassign mul_a_extend = {{size{1'b0}}, mul_a};\nassign mul_b_extend = {{size{1'b0}}, mul_b};\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        sum_tmp1 <= 'd0;\n        sum_tmp2 <= 'd0;\n    end\n    else begin\n        sum_tmp1 <= mul_result[0] + mul_result[1];\n        sum_tmp2 <= mul_result[2] + mul_result[3];\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        mul_out <= 'd0;\n    end\n    else begin\n        mul_out <= sum_tmp1 + sum_tmp2;\n    end\nend\n\nendmodule\n\n", "corrupted_code": "`timescale 1ns/1ns\nmodule verified_multi_pipe#(\n\tparameter size = 4\n)(\n\tinput \t\t\t\t\t\tclk \t\t,   \n\tinput \t\t\t\t\t\trst_n\t\t,\n\tinput\t[size-1:0]\t\t\tmul_a\t\t,\n\tinput\t[size-1:0]\t\t\tmul_b\t\t,\n \n \toutput\treg\t[size*2-1:0]\tmul_out\t\t\n);\n\nparameter N = 2 * size;\n\nreg     [N-1:0]     sum_tmp1                ;\nreg     [N-1:0]     sum_tmp2                ;\nwire    [N-1:0]     mul_a_extend            ;\nwire    [N-1:0]     mul_b_extend            ;\n\nwire    [N-1:0]     mul_result[size-1:0]    ;\n\ngenvar i;\ngenerate\n    \nendgenerate\n\nassign mul_a_extend = {{size{1'b0}}, mul_a};\nassign mul_b_extend = {{size{1'b0}}, mul_b};\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        sum_tmp1 <= 'd0;\n        sum_tmp2 <= 'd0;\n    end\n    else begin\n        sum_tmp1 <= mul_result[0] + mul_result[1];\n        sum_tmp2 <= mul_result[2] + mul_result[3];\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        mul_out <= 'd0;\n    end\n    else begin\n        mul_out <= sum_tmp1 + sum_tmp2;\n    end\nend\n\nendmodule\n\n", "corruption_explanation": "Removed a loop block", "modification_type": "remove_loop", "modification_line": 24, "original_snippet": "for(i = 0; i < size; i = i + 1) begin:add\n        assign mul_result[i] = mul_b[i] ? mul_a_extend << i : 'd0;\n    end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing a loop construct. This removes iterative logic that may be essential for initialization, array operations, or repetitive computations. Functionality that depends on the loop will be broken.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_loop modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed a loop block\n   \u2022 Line 24: Original: for(i = 0; i < size; i = i + 1) begin:add\n        assign mul_result[i] = mul_b[i] ? mul_a_extend << i : 'd0;\n    end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 24.\n   \u2022 Restore the original code: for(i = 0; i < size; i = i + 1) begin:add\n        assign mul_result[i] = mul_b[i] ? mul_a_extend << i : 'd0;\n    end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove loop.", "complexity": 23, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_loop"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.167429", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_pipe_4bit", "module_name": "multi_pipe_4bit", "description": "Please act as a professional verilog designer.\n\nImplement the design of 4bit unsigned number pipeline multiplier. It consists of two levels of registers to store intermediate values and control the multiplication process.\n\nModule name:  \n    multi_pipe_4bit \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    mul_a: Input signal representing the multiplicand with a data width of \"size\" bits.\n    mul_b: Input signal representing the multiplier with a data width of \"size\" bits.\t\n\nOutput ports:\n    mul_out: Product output signal with a data width of 2*size bits.\n\nParameter:\n    size = 4\n\nImplementation:\nExtension of input signals:\nThe input signals (mul_a and mul_b) are extended by adding \"size\" number of zero bits at the most significant bit positions.\nMultiplication operation:\nThe module uses a generate block to perform multiplication for each bit position of the multiplier (mul_b) and generate the partial products.\nFor each bit position i from 0 to size-1, the partial product is calculated as follows:\nIf the corresponding bit in the multiplier is 1, the multiplicand is left-shifted by i positions.\nIf the corresponding bit in the multiplier is 0, the partial product is set to 0 ('d0).\nAdd of partial products:\nThe module uses registers to store the intermediate sum values.\nOn the positive edge of the clock signal (clk) or the falling edge of the reset signal (rst_n), the module performs add operations.\nIf the reset signal (rst_n) is low, indicating a reset condition, the registers are set to 0.\nIf the reset signal (rst_n) is high, the registers are updated with the sum of the corresponding partial products.\nFinal product calculation:\nOn the positive edge of the clock signal (clk) or the falling edge of the reset signal (rst_n), the module calculates the final product.\nIf the reset signal (rst_n) is low, indicating a reset condition, the product output (mul_out) is set to 0.\nIf the reset signal (rst_n) is high, the product output (mul_out) is updated with the sum of registers.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule verified_multi_pipe#(\n\tparameter size = 4\n)(\n\tinput \t\t\t\t\t\tclk \t\t,   \n\tinput \t\t\t\t\t\trst_n\t\t,\n\tinput\t[size-1:0]\t\t\tmul_a\t\t,\n\tinput\t[size-1:0]\t\t\tmul_b\t\t,\n \n \toutput\treg\t[size*2-1:0]\tmul_out\t\t\n);\n\nparameter N = 2 * size;\n\nreg     [N-1:0]     sum_tmp1                ;\nreg     [N-1:0]     sum_tmp2                ;\nwire    [N-1:0]     mul_a_extend            ;\nwire    [N-1:0]     mul_b_extend            ;\n\nwire    [N-1:0]     mul_result[size-1:0]    ;\n\ngenvar i;\ngenerate\n    for(i = 0; i < size; i = i + 1) begin:add\n        assign mul_result[i] = mul_b[i] ? mul_a_extend << i : 'd0;\n    end\nendgenerate\n\nassign mul_a_extend = {{size{1'b0}}, mul_a};\nassign mul_b_extend = {{size{1'b0}}, mul_b};\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        sum_tmp1 <= 'd0;\n        sum_tmp2 <= 'd0;\n    end\n    else begin\n        sum_tmp1 <= mul_result[0] + mul_result[1];\n        sum_tmp2 <= mul_result[2] + mul_result[3];\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        mul_out <= 'd0;\n    end\n    else begin\n        mul_out <= sum_tmp1 + sum_tmp2;\n    end\nend\n\nendmodule\n\n", "corrupted_code": "`timescale 1ns/1ns\nmodule verified_multi_pipe#(\n\tparameter size = 4\n)(\n\tinput \t\t\t\t\t\tclk \t\t,   \n\tinput \t\t\t\t\t\trst_n\t\t,\n\tinput\t[size-1:0]\t\t\tmul_a\t\t,\n\tinput\t[size-1:0]\t\t\tmul_b\t\t,\n \n \toutput\treg\t[size*2-1:0]\tmul_out\t\t\n);\n\nparameter N = 2 * size;\n\nreg     [N-1:0]     sum_tmp1                ;\nreg     [N-1:0]     sum_tmp2                ;\nwire    [N-1:0]     mul_a_extend            ;\nwire    [N-1:0]     mul_b_extend            ;\n\nwire    [N-1:0]     mul_result[size-1:0]    ;\n\ngenvar i;\ngenerate\n    for(i = 0; i < size; i = i + 1) begin:add\n        assign mul_result[i] = mul_b[i] ? mul_a_extend >> i : 'd0;\n    end\nendgenerate\n\nassign mul_a_extend = {{size{1'b0}}, mul_a};\nassign mul_b_extend = {{size{1'b0}}, mul_b};\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        sum_tmp1 <= 'd0;\n        sum_tmp2 <= 'd0;\n    end\n    else begin\n        sum_tmp1 <= mul_result[0] + mul_result[1];\n        sum_tmp2 <= mul_result[2] + mul_result[3];\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        mul_out <= 'd0;\n    end\n    else begin\n        mul_out <= sum_tmp1 + sum_tmp2;\n    end\nend\n\nendmodule\n\n", "corruption_explanation": "Changed operator from '<<' to '>>'", "modification_type": "change_operator", "modification_line": 25, "original_snippet": "<<", "modified_snippet": ">>", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '<<' to '>>'\n   \u2022 Line 25: Original: <<\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 25.\n   \u2022 Restore the original code: <<\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 23, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.169444", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_pipe_4bit", "module_name": "multi_pipe_4bit", "description": "Please act as a professional verilog designer.\n\nImplement the design of 4bit unsigned number pipeline multiplier. It consists of two levels of registers to store intermediate values and control the multiplication process.\n\nModule name:  \n    multi_pipe_4bit \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    mul_a: Input signal representing the multiplicand with a data width of \"size\" bits.\n    mul_b: Input signal representing the multiplier with a data width of \"size\" bits.\t\n\nOutput ports:\n    mul_out: Product output signal with a data width of 2*size bits.\n\nParameter:\n    size = 4\n\nImplementation:\nExtension of input signals:\nThe input signals (mul_a and mul_b) are extended by adding \"size\" number of zero bits at the most significant bit positions.\nMultiplication operation:\nThe module uses a generate block to perform multiplication for each bit position of the multiplier (mul_b) and generate the partial products.\nFor each bit position i from 0 to size-1, the partial product is calculated as follows:\nIf the corresponding bit in the multiplier is 1, the multiplicand is left-shifted by i positions.\nIf the corresponding bit in the multiplier is 0, the partial product is set to 0 ('d0).\nAdd of partial products:\nThe module uses registers to store the intermediate sum values.\nOn the positive edge of the clock signal (clk) or the falling edge of the reset signal (rst_n), the module performs add operations.\nIf the reset signal (rst_n) is low, indicating a reset condition, the registers are set to 0.\nIf the reset signal (rst_n) is high, the registers are updated with the sum of the corresponding partial products.\nFinal product calculation:\nOn the positive edge of the clock signal (clk) or the falling edge of the reset signal (rst_n), the module calculates the final product.\nIf the reset signal (rst_n) is low, indicating a reset condition, the product output (mul_out) is set to 0.\nIf the reset signal (rst_n) is high, the product output (mul_out) is updated with the sum of registers.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule verified_multi_pipe#(\n\tparameter size = 4\n)(\n\tinput \t\t\t\t\t\tclk \t\t,   \n\tinput \t\t\t\t\t\trst_n\t\t,\n\tinput\t[size-1:0]\t\t\tmul_a\t\t,\n\tinput\t[size-1:0]\t\t\tmul_b\t\t,\n \n \toutput\treg\t[size*2-1:0]\tmul_out\t\t\n);\n\nparameter N = 2 * size;\n\nreg     [N-1:0]     sum_tmp1                ;\nreg     [N-1:0]     sum_tmp2                ;\nwire    [N-1:0]     mul_a_extend            ;\nwire    [N-1:0]     mul_b_extend            ;\n\nwire    [N-1:0]     mul_result[size-1:0]    ;\n\ngenvar i;\ngenerate\n    for(i = 0; i < size; i = i + 1) begin:add\n        assign mul_result[i] = mul_b[i] ? mul_a_extend << i : 'd0;\n    end\nendgenerate\n\nassign mul_a_extend = {{size{1'b0}}, mul_a};\nassign mul_b_extend = {{size{1'b0}}, mul_b};\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        sum_tmp1 <= 'd0;\n        sum_tmp2 <= 'd0;\n    end\n    else begin\n        sum_tmp1 <= mul_result[0] + mul_result[1];\n        sum_tmp2 <= mul_result[2] + mul_result[3];\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        mul_out <= 'd0;\n    end\n    else begin\n        mul_out <= sum_tmp1 + sum_tmp2;\n    end\nend\n\nendmodule\n\n", "corrupted_code": "`timescale 1ns/1ns\nmodule verified_multi_pipe#(\n\tparameter size = 4\n)(\n\tinput \t\t\t\t\t\tclk \t\t,   \n\tinput \t\t\t\t\t\trst_n\t\t,\n\tinput\t[size-1:0]\t\t\tmul_a\t\t,\n\tinput\t[size-1:0]\t\t\tmul_b\t\t,\n \n \toutput\treg\t[size*2-1:0]\tmul_out\t\t\n);\n\nparameter N = 2 * size;\n\nreg     [N-1:0]     sum_tmp1                ;\nreg     [N-1:0]     sum_tmp2                ;\nwire    [N-1:0]     mul_a_extend            ;\nwire    [N-1:0]     mul_b_extend            ;\n\nwire    [N-1:0]     mul_result[size-1:0]    ;\n\ngenvar i;\ngenerate\n    for(i = 0; i < size; i = i + 1) begin:add\n        assign mul_result[i] = mul_b[i] ? mul_a_extend << i : 'd0;\n    end\nendgenerate\n\nassign mul_a_extend = {{size{1'b0}}, mul_a};\nassign mul_b_extend = {{size{1'b0}}, mul_b};\nassign mul_b_extend = 1'b0;  // Conflicting assignment\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        sum_tmp1 <= 'd0;\n        sum_tmp2 <= 'd0;\n    end\n    else begin\n        sum_tmp1 <= mul_result[0] + mul_result[1];\n        sum_tmp2 <= mul_result[2] + mul_result[3];\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        mul_out <= 'd0;\n    end\n    else begin\n        mul_out <= sum_tmp1 + sum_tmp2;\n    end\nend\n\nendmodule\n\n", "corruption_explanation": "Added conflicting driver for signal 'mul_b_extend'", "modification_type": "add_multiple_driver", "modification_line": 30, "original_snippet": "assign mul_b_extend = {{size{1'b0}}, mul_b};", "modified_snippet": "assign mul_b_extend = {{size{1'b0}}, mul_b};\nassign mul_b_extend = 1'b0;  // Conflicting assignment", "issue_description": "The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_multiple_driver modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added conflicting driver for signal 'mul_b_extend'\n   \u2022 Line 30: Original: assign mul_b_extend = {{size{1'b0}}, mul_b};\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 30.\n   \u2022 Restore the original code: assign mul_b_extend = {{size{1'b0}}, mul_b};\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add multiple driver.", "complexity": 23, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["add_multiple_driver"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.173223", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_pipe_4bit", "module_name": "multi_pipe_4bit", "description": "Please act as a professional verilog designer.\n\nImplement the design of 4bit unsigned number pipeline multiplier. It consists of two levels of registers to store intermediate values and control the multiplication process.\n\nModule name:  \n    multi_pipe_4bit \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    mul_a: Input signal representing the multiplicand with a data width of \"size\" bits.\n    mul_b: Input signal representing the multiplier with a data width of \"size\" bits.\t\n\nOutput ports:\n    mul_out: Product output signal with a data width of 2*size bits.\n\nParameter:\n    size = 4\n\nImplementation:\nExtension of input signals:\nThe input signals (mul_a and mul_b) are extended by adding \"size\" number of zero bits at the most significant bit positions.\nMultiplication operation:\nThe module uses a generate block to perform multiplication for each bit position of the multiplier (mul_b) and generate the partial products.\nFor each bit position i from 0 to size-1, the partial product is calculated as follows:\nIf the corresponding bit in the multiplier is 1, the multiplicand is left-shifted by i positions.\nIf the corresponding bit in the multiplier is 0, the partial product is set to 0 ('d0).\nAdd of partial products:\nThe module uses registers to store the intermediate sum values.\nOn the positive edge of the clock signal (clk) or the falling edge of the reset signal (rst_n), the module performs add operations.\nIf the reset signal (rst_n) is low, indicating a reset condition, the registers are set to 0.\nIf the reset signal (rst_n) is high, the registers are updated with the sum of the corresponding partial products.\nFinal product calculation:\nOn the positive edge of the clock signal (clk) or the falling edge of the reset signal (rst_n), the module calculates the final product.\nIf the reset signal (rst_n) is low, indicating a reset condition, the product output (mul_out) is set to 0.\nIf the reset signal (rst_n) is high, the product output (mul_out) is updated with the sum of registers.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule verified_multi_pipe#(\n\tparameter size = 4\n)(\n\tinput \t\t\t\t\t\tclk \t\t,   \n\tinput \t\t\t\t\t\trst_n\t\t,\n\tinput\t[size-1:0]\t\t\tmul_a\t\t,\n\tinput\t[size-1:0]\t\t\tmul_b\t\t,\n \n \toutput\treg\t[size*2-1:0]\tmul_out\t\t\n);\n\nparameter N = 2 * size;\n\nreg     [N-1:0]     sum_tmp1                ;\nreg     [N-1:0]     sum_tmp2                ;\nwire    [N-1:0]     mul_a_extend            ;\nwire    [N-1:0]     mul_b_extend            ;\n\nwire    [N-1:0]     mul_result[size-1:0]    ;\n\ngenvar i;\ngenerate\n    for(i = 0; i < size; i = i + 1) begin:add\n        assign mul_result[i] = mul_b[i] ? mul_a_extend << i : 'd0;\n    end\nendgenerate\n\nassign mul_a_extend = {{size{1'b0}}, mul_a};\nassign mul_b_extend = {{size{1'b0}}, mul_b};\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        sum_tmp1 <= 'd0;\n        sum_tmp2 <= 'd0;\n    end\n    else begin\n        sum_tmp1 <= mul_result[0] + mul_result[1];\n        sum_tmp2 <= mul_result[2] + mul_result[3];\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        mul_out <= 'd0;\n    end\n    else begin\n        mul_out <= sum_tmp1 + sum_tmp2;\n    end\nend\n\nendmodule\n\n", "corrupted_code": "`timescale 1ns/1ns\nmodule verified_multi_pipe#(\n\tparameter size = 4\n)(\n\tinput \t\t\t\t\t\tclk \t\t,   \n\tinput \t\t\t\t\t\trst_n\t\t,\n\tinput\t[size-1:0]\t\t\tmul_a\t\t,\n\tinput\t[size-1:0]\t\t\tmul_b\t\t,\n \n \toutput\treg\t[size*2-1:0]\tmul_out\t\t\n);\n\nparameter N = 2 * size;\n\nreg     [N-1:0]     sum_tmp1                ;\nreg     [N-1:0]     sum_tmp2                ;\nwire    [N-1:0]     mul_a_extend            ;\nwire    [N-1:0]     mul_b_extend            ;\n\nwire    [N-1:0]     mul_result[size-1:0]    ;\n\ngenvar i;\ngenerate\n    for(i = 0; i < size; i = i + 1) begin:add\n        assign mul_result[i] = mul_b[i] ? mul_a_extend << i : 'd0;\n    end\nendgenerate\n\nassign mul_a_extend = {{size{1'b0}}, mul_a};\nassign mul_b_extend = {{size{1'b0}}, mul_b};\n\nalways @(posedge clk or negedge rst_n) begin\n    if (rst_n) begin\n        sum_tmp1 <= 'd0;\n        sum_tmp2 <= 'd0;\n    end\n    else begin\n        sum_tmp1 <= mul_result[0] + mul_result[1];\n        sum_tmp2 <= mul_result[2] + mul_result[3];\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        mul_out <= 'd0;\n    end\n    else begin\n        mul_out <= sum_tmp1 + sum_tmp2;\n    end\nend\n\nendmodule\n\n", "corruption_explanation": "Inverted reset polarity in condition", "modification_type": "invert_reset_polarity", "modification_line": 33, "original_snippet": "if(!rst_n)", "modified_snippet": "if (rst_n)", "issue_description": "The buggy code has inverted reset polarity. If the design expects active-low reset (!rst), it now uses active-high, or vice versa. This causes the reset logic to activate during normal operation and deactivate during actual reset, breaking initialization.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_reset_polarity modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted reset polarity in condition\n   \u2022 Line 33: Original: if(!rst_n)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 33.\n   \u2022 Restore the original code: if(!rst_n)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert reset polarity.", "complexity": 23, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_reset_polarity"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.176614", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_pipe_4bit", "module_name": "multi_pipe_4bit", "description": "Please act as a professional verilog designer.\n\nImplement the design of 4bit unsigned number pipeline multiplier. It consists of two levels of registers to store intermediate values and control the multiplication process.\n\nModule name:  \n    multi_pipe_4bit \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    mul_a: Input signal representing the multiplicand with a data width of \"size\" bits.\n    mul_b: Input signal representing the multiplier with a data width of \"size\" bits.\t\n\nOutput ports:\n    mul_out: Product output signal with a data width of 2*size bits.\n\nParameter:\n    size = 4\n\nImplementation:\nExtension of input signals:\nThe input signals (mul_a and mul_b) are extended by adding \"size\" number of zero bits at the most significant bit positions.\nMultiplication operation:\nThe module uses a generate block to perform multiplication for each bit position of the multiplier (mul_b) and generate the partial products.\nFor each bit position i from 0 to size-1, the partial product is calculated as follows:\nIf the corresponding bit in the multiplier is 1, the multiplicand is left-shifted by i positions.\nIf the corresponding bit in the multiplier is 0, the partial product is set to 0 ('d0).\nAdd of partial products:\nThe module uses registers to store the intermediate sum values.\nOn the positive edge of the clock signal (clk) or the falling edge of the reset signal (rst_n), the module performs add operations.\nIf the reset signal (rst_n) is low, indicating a reset condition, the registers are set to 0.\nIf the reset signal (rst_n) is high, the registers are updated with the sum of the corresponding partial products.\nFinal product calculation:\nOn the positive edge of the clock signal (clk) or the falling edge of the reset signal (rst_n), the module calculates the final product.\nIf the reset signal (rst_n) is low, indicating a reset condition, the product output (mul_out) is set to 0.\nIf the reset signal (rst_n) is high, the product output (mul_out) is updated with the sum of registers.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule verified_multi_pipe#(\n\tparameter size = 4\n)(\n\tinput \t\t\t\t\t\tclk \t\t,   \n\tinput \t\t\t\t\t\trst_n\t\t,\n\tinput\t[size-1:0]\t\t\tmul_a\t\t,\n\tinput\t[size-1:0]\t\t\tmul_b\t\t,\n \n \toutput\treg\t[size*2-1:0]\tmul_out\t\t\n);\n\nparameter N = 2 * size;\n\nreg     [N-1:0]     sum_tmp1                ;\nreg     [N-1:0]     sum_tmp2                ;\nwire    [N-1:0]     mul_a_extend            ;\nwire    [N-1:0]     mul_b_extend            ;\n\nwire    [N-1:0]     mul_result[size-1:0]    ;\n\ngenvar i;\ngenerate\n    for(i = 0; i < size; i = i + 1) begin:add\n        assign mul_result[i] = mul_b[i] ? mul_a_extend << i : 'd0;\n    end\nendgenerate\n\nassign mul_a_extend = {{size{1'b0}}, mul_a};\nassign mul_b_extend = {{size{1'b0}}, mul_b};\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        sum_tmp1 <= 'd0;\n        sum_tmp2 <= 'd0;\n    end\n    else begin\n        sum_tmp1 <= mul_result[0] + mul_result[1];\n        sum_tmp2 <= mul_result[2] + mul_result[3];\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        mul_out <= 'd0;\n    end\n    else begin\n        mul_out <= sum_tmp1 + sum_tmp2;\n    end\nend\n\nendmodule\n\n", "corrupted_code": "`timescale 1ns/1ns\nmodule verified_multi_pipe#(\n\tparameter size = 4\n)(\n\tinput \t\t\t\t\t\tclk \t\t,   \n\tinput \t\t\t\t\t\trst_n\t\t,\n\tinput\t[size-1:0]\t\t\tmul_a\t\t,\n\tinput\t[size-1:0]\t\t\tmul_b\t\t,\n \n \toutput\treg\t[size*2-1:0]\tmul_out\t\t\n);\n\nparameter N = 2 * size;\n\nreg     [N-1:0]     sum_tmp1                ;\nreg     [N-1:0]     sum_tmp2                ;\nwire    [N-1:0]     mul_a_extend            ;\nwire    [N-1:0]     mul_b_extend            ;\n\nwire    [N-1:0]     mul_result[size-1:0]    ;\n\ngenvar i;\ngenerate\n    for(i = 0; i < size; i = i + 1) begin:add\n        assign mul_result[i] = mul_b[i] ? mul_a_extend << i : 'd0;\n    end\nendgenerate\n\nassign mul_a_extend = {{size{1'b0}}, mul_a};\nassign mul_b_extend = {{size{1'b0}}, mul_b};\n\nalways @(posedge clk) begin\n    if(!rst_n) begin\n        sum_tmp1 <= 'd0;\n        sum_tmp2 <= 'd0;\n    end\n    else begin\n        sum_tmp1 <= mul_result[0] + mul_result[1];\n        sum_tmp2 <= mul_result[2] + mul_result[3];\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        mul_out <= 'd0;\n    end\n    else begin\n        mul_out <= sum_tmp1 + sum_tmp2;\n    end\nend\n\nendmodule\n\n", "corruption_explanation": "Removed async reset from sensitivity list", "modification_type": "remove_async_reset", "modification_line": 32, "original_snippet": "always @(posedge clk or negedge rst_n)", "modified_snippet": "always @(posedge clk)", "issue_description": "The buggy code has removed async reset from the sensitivity list. The always block only triggers on clock edges, not reset. This causes metastability on power-up and removes the ability to asynchronously reset the design.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_async_reset modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed async reset from sensitivity list\n   \u2022 Line 32: Original: always @(posedge clk or negedge rst_n)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 32.\n   \u2022 Restore the original code: always @(posedge clk or negedge rst_n)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove async reset.", "complexity": 23, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_async_reset"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.178278", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Multiplier", "design_name": "multi_pipe_4bit", "module_name": "multi_pipe_4bit", "description": "Please act as a professional verilog designer.\n\nImplement the design of 4bit unsigned number pipeline multiplier. It consists of two levels of registers to store intermediate values and control the multiplication process.\n\nModule name:  \n    multi_pipe_4bit \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    mul_a: Input signal representing the multiplicand with a data width of \"size\" bits.\n    mul_b: Input signal representing the multiplier with a data width of \"size\" bits.\t\n\nOutput ports:\n    mul_out: Product output signal with a data width of 2*size bits.\n\nParameter:\n    size = 4\n\nImplementation:\nExtension of input signals:\nThe input signals (mul_a and mul_b) are extended by adding \"size\" number of zero bits at the most significant bit positions.\nMultiplication operation:\nThe module uses a generate block to perform multiplication for each bit position of the multiplier (mul_b) and generate the partial products.\nFor each bit position i from 0 to size-1, the partial product is calculated as follows:\nIf the corresponding bit in the multiplier is 1, the multiplicand is left-shifted by i positions.\nIf the corresponding bit in the multiplier is 0, the partial product is set to 0 ('d0).\nAdd of partial products:\nThe module uses registers to store the intermediate sum values.\nOn the positive edge of the clock signal (clk) or the falling edge of the reset signal (rst_n), the module performs add operations.\nIf the reset signal (rst_n) is low, indicating a reset condition, the registers are set to 0.\nIf the reset signal (rst_n) is high, the registers are updated with the sum of the corresponding partial products.\nFinal product calculation:\nOn the positive edge of the clock signal (clk) or the falling edge of the reset signal (rst_n), the module calculates the final product.\nIf the reset signal (rst_n) is low, indicating a reset condition, the product output (mul_out) is set to 0.\nIf the reset signal (rst_n) is high, the product output (mul_out) is updated with the sum of registers.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule verified_multi_pipe#(\n\tparameter size = 4\n)(\n\tinput \t\t\t\t\t\tclk \t\t,   \n\tinput \t\t\t\t\t\trst_n\t\t,\n\tinput\t[size-1:0]\t\t\tmul_a\t\t,\n\tinput\t[size-1:0]\t\t\tmul_b\t\t,\n \n \toutput\treg\t[size*2-1:0]\tmul_out\t\t\n);\n\nparameter N = 2 * size;\n\nreg     [N-1:0]     sum_tmp1                ;\nreg     [N-1:0]     sum_tmp2                ;\nwire    [N-1:0]     mul_a_extend            ;\nwire    [N-1:0]     mul_b_extend            ;\n\nwire    [N-1:0]     mul_result[size-1:0]    ;\n\ngenvar i;\ngenerate\n    for(i = 0; i < size; i = i + 1) begin:add\n        assign mul_result[i] = mul_b[i] ? mul_a_extend << i : 'd0;\n    end\nendgenerate\n\nassign mul_a_extend = {{size{1'b0}}, mul_a};\nassign mul_b_extend = {{size{1'b0}}, mul_b};\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        sum_tmp1 <= 'd0;\n        sum_tmp2 <= 'd0;\n    end\n    else begin\n        sum_tmp1 <= mul_result[0] + mul_result[1];\n        sum_tmp2 <= mul_result[2] + mul_result[3];\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        mul_out <= 'd0;\n    end\n    else begin\n        mul_out <= sum_tmp1 + sum_tmp2;\n    end\nend\n\nendmodule\n\n", "corrupted_code": "`timescale 1ns/1ns\nmodule verified_multi_pipe#(\n\tparameter size = 4\n)(\n\tinput \t\t\t\t\t\tclk \t\t,   \n\tinput \t\t\t\t\t\trst_n\t\t,\n\tinput\t[size-1:0]\t\t\tmul_a\t\t,\n\tinput\t[size-1:0]\t\t\tmul_b\t\t,\n \n \toutput\treg\t[size*2-1:0]\tmul_out\t\t\n);\n\nparameter N = 2 * size;\n\nreg     [N-1:0]     sum_tmp1                ;\nreg     [N-1:0]     sum_tmp2                ;\nwire    [N-1:0]     mul_a_extend            ;\nwire    [N-1:0]     mul_b_extend            ;\n\nwire    [N-1:0]     mul_result[size-1:0]    ;\n\ngenvar i;\ngenerate\n    for(i = 0; i < size; i = i + 1) begin:add\n        assign mul_result[i] = mul_b[i] ? mul_a_extend << i : 'd0;\n    end\nendgenerate\n\nassign mul_a_extend = {{size{1'b0}}, mul_a};\nassign mul_b_extend = {{size{1'b0}}, mul_b};\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        sum_tmp1 <= 'd0;\n        sum_tmp2 <= 'd0;\n    end\n    else begin\n        sum_tmp1 <= mul_result[0] + mul_result[1];\n        sum_tmp2 <= mul_result[2] + mul_result[3];\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        mul_out <= 'd0;\n    end\n    else begin\n        mul_out <= sum_tmp1 + sum_tmp2;\n    end\nend\n\n\n    wire clk_dup;\n    assign clk_dup = clk;\nendmodule\n\n", "corruption_explanation": "Added duplicate clock signal clk_dup", "modification_type": "duplicate_clock_signal", "modification_line": 23, "original_snippet": "(none)", "modified_snippet": "wire clk_dup;\n    assign clk_dup = clk;", "issue_description": "The buggy code has a duplicate clock signal. A phantom clock domain is created, which may confuse CDC analysis tools and create subtle timing issues in synthesis. This violates clock domain design best practices.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a duplicate_clock_signal modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added duplicate clock signal clk_dup\n   \u2022 Line 23: Original: (none)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 23.\n   \u2022 Restore the original code: (none)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to duplicate clock signal.", "complexity": 23, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["duplicate_clock_signal"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.180071", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Other", "design_name": "fixed_point_substractor", "module_name": "fixed_point_substractor", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a fixed-point subtractor for precise arithmetic operations with fixed precision.\n\nModule name:\n    fixed_point_subtractor\n\nParameterized values:\n    Q: Represents the number of fractional bits in the fixed-point representation.\n    N: Represents the total number of bits (both integer and fractional) used for inputs and outputs.\n\nInput ports:\n    a [N-1:0]: First N-bit fixed-point input operand.\n    b [N-1:0]: Second N-bit fixed-point input operand.\n\nOutput ports:\n\n    c [N-1:0]: N-bit output representing the result of the fixed-point subtraction.\nInternal registers:\n    res [N-1:0]: N-bit register used to store the result of the subtraction operation.\n\nImplementation:\n    Same Sign Subtraction: When the signs of a and b are the same, their fractional and integer parts are subtracted. The sign of the result will be the same as the inputs.\n\nDifferent Sign Subtraction:\n    If a is positive and b is negative, the absolute values of a and b are added. The result will have a positive sign if a is greater than b, and a negative sign otherwise.\n    If a is negative and b is positive, the same logic applies, with the result's sign depending on the relative sizes of a and b.\n\nHandling Zero: \n    When the result is zero, the sign bit is explicitly set to 0 to handle this edge case.\n\nPrecision: \n    The fixed-point precision is defined by the parameters Q (fractional bits) and N (total bits). This ensures that the subtraction is performed accurately while maintaining the necessary precision for both integer and fractional parts.\n\nGive me the complete code."}, "clean_code": "module fixed_point_subtractor #(\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\n\t\tres[N-1] = a[N-1];\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corrupted_code": "module fixed_point_subtractor #(\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\n\t\tres[N-1] = a[N-1];\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\t\n\t\t\tres[N-1] <= 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 47, "original_snippet": "res[N-1] = 0;", "modified_snippet": "res[N-1] <= 0;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 43, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.183161", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Other", "design_name": "fixed_point_substractor", "module_name": "fixed_point_substractor", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a fixed-point subtractor for precise arithmetic operations with fixed precision.\n\nModule name:\n    fixed_point_subtractor\n\nParameterized values:\n    Q: Represents the number of fractional bits in the fixed-point representation.\n    N: Represents the total number of bits (both integer and fractional) used for inputs and outputs.\n\nInput ports:\n    a [N-1:0]: First N-bit fixed-point input operand.\n    b [N-1:0]: Second N-bit fixed-point input operand.\n\nOutput ports:\n\n    c [N-1:0]: N-bit output representing the result of the fixed-point subtraction.\nInternal registers:\n    res [N-1:0]: N-bit register used to store the result of the subtraction operation.\n\nImplementation:\n    Same Sign Subtraction: When the signs of a and b are the same, their fractional and integer parts are subtracted. The sign of the result will be the same as the inputs.\n\nDifferent Sign Subtraction:\n    If a is positive and b is negative, the absolute values of a and b are added. The result will have a positive sign if a is greater than b, and a negative sign otherwise.\n    If a is negative and b is positive, the same logic applies, with the result's sign depending on the relative sizes of a and b.\n\nHandling Zero: \n    When the result is zero, the sign bit is explicitly set to 0 to handle this edge case.\n\nPrecision: \n    The fixed-point precision is defined by the parameters Q (fractional bits) and N (total bits). This ensures that the subtraction is performed accurately while maintaining the necessary precision for both integer and fractional parts.\n\nGive me the complete code."}, "clean_code": "module fixed_point_subtractor #(\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\n\t\tres[N-1] = a[N-1];\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corrupted_code": "module fixed_point_subtractor #(\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\n\t\tres[N-1] = a[N-1];\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] <= a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 39, "original_snippet": "res[N-2:0] = a[N-2:0] + b[N-2:0];", "modified_snippet": "res[N-2:0] <= a[N-2:0] + b[N-2:0];", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 43, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.184857", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Other", "design_name": "fixed_point_substractor", "module_name": "fixed_point_substractor", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a fixed-point subtractor for precise arithmetic operations with fixed precision.\n\nModule name:\n    fixed_point_subtractor\n\nParameterized values:\n    Q: Represents the number of fractional bits in the fixed-point representation.\n    N: Represents the total number of bits (both integer and fractional) used for inputs and outputs.\n\nInput ports:\n    a [N-1:0]: First N-bit fixed-point input operand.\n    b [N-1:0]: Second N-bit fixed-point input operand.\n\nOutput ports:\n\n    c [N-1:0]: N-bit output representing the result of the fixed-point subtraction.\nInternal registers:\n    res [N-1:0]: N-bit register used to store the result of the subtraction operation.\n\nImplementation:\n    Same Sign Subtraction: When the signs of a and b are the same, their fractional and integer parts are subtracted. The sign of the result will be the same as the inputs.\n\nDifferent Sign Subtraction:\n    If a is positive and b is negative, the absolute values of a and b are added. The result will have a positive sign if a is greater than b, and a negative sign otherwise.\n    If a is negative and b is positive, the same logic applies, with the result's sign depending on the relative sizes of a and b.\n\nHandling Zero: \n    When the result is zero, the sign bit is explicitly set to 0 to handle this edge case.\n\nPrecision: \n    The fixed-point precision is defined by the parameters Q (fractional bits) and N (total bits). This ensures that the subtraction is performed accurately while maintaining the necessary precision for both integer and fractional parts.\n\nGive me the complete code."}, "clean_code": "module fixed_point_subtractor #(\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\n\t\tres[N-1] = a[N-1];\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corrupted_code": "module fixed_point_subtractor #(\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\n\t\tres[N-1] = a[N-1];\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corruption_explanation": "Changed operator from '+' to '-'", "modification_type": "change_operator", "modification_line": 26, "original_snippet": "+", "modified_snippet": "-", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '+' to '-'\n   \u2022 Line 26: Original: +\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 26.\n   \u2022 Restore the original code: +\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 43, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.187877", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Other", "design_name": "fixed_point_substractor", "module_name": "fixed_point_substractor", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a fixed-point subtractor for precise arithmetic operations with fixed precision.\n\nModule name:\n    fixed_point_subtractor\n\nParameterized values:\n    Q: Represents the number of fractional bits in the fixed-point representation.\n    N: Represents the total number of bits (both integer and fractional) used for inputs and outputs.\n\nInput ports:\n    a [N-1:0]: First N-bit fixed-point input operand.\n    b [N-1:0]: Second N-bit fixed-point input operand.\n\nOutput ports:\n\n    c [N-1:0]: N-bit output representing the result of the fixed-point subtraction.\nInternal registers:\n    res [N-1:0]: N-bit register used to store the result of the subtraction operation.\n\nImplementation:\n    Same Sign Subtraction: When the signs of a and b are the same, their fractional and integer parts are subtracted. The sign of the result will be the same as the inputs.\n\nDifferent Sign Subtraction:\n    If a is positive and b is negative, the absolute values of a and b are added. The result will have a positive sign if a is greater than b, and a negative sign otherwise.\n    If a is negative and b is positive, the same logic applies, with the result's sign depending on the relative sizes of a and b.\n\nHandling Zero: \n    When the result is zero, the sign bit is explicitly set to 0 to handle this edge case.\n\nPrecision: \n    The fixed-point precision is defined by the parameters Q (fractional bits) and N (total bits). This ensures that the subtraction is performed accurately while maintaining the necessary precision for both integer and fractional parts.\n\nGive me the complete code."}, "clean_code": "module fixed_point_subtractor #(\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\n\t\tres[N-1] = a[N-1];\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corrupted_code": "module fixed_point_subtractor #(\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\n\t\tres[N-1] = a[N-1];\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif(!(a[N-2:0] > b[N-2:0])) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corruption_explanation": "Inverted condition: 'a[N-2:0] > b[N-2:0]' -> '!(a[N-2:0] > b[N-2:0])'", "modification_type": "invert_condition", "modification_line": 25, "original_snippet": "if( a[N-2:0] > b[N-2:0] ) begin", "modified_snippet": "if(!(a[N-2:0] > b[N-2:0])) begin", "issue_description": "The buggy code has an inverted condition in an if statement. Instead of checking if(x), it checks if(!x), causing the logic to execute when it shouldn't and skip execution when it should. All conditional behavior is reversed from intended functionality.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_condition modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted condition: 'a[N-2:0] > b[N-2:0]' -> '!(a[N-2:0] > b[N-2:0])'\n   \u2022 Line 25: Original: if( a[N-2:0] > b[N-2:0] ) begin\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 25.\n   \u2022 Restore the original code: if( a[N-2:0] > b[N-2:0] ) begin\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert condition.", "complexity": 43, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["invert_condition"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.190091", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Other", "design_name": "fixed_point_substractor", "module_name": "fixed_point_substractor", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a fixed-point subtractor for precise arithmetic operations with fixed precision.\n\nModule name:\n    fixed_point_subtractor\n\nParameterized values:\n    Q: Represents the number of fractional bits in the fixed-point representation.\n    N: Represents the total number of bits (both integer and fractional) used for inputs and outputs.\n\nInput ports:\n    a [N-1:0]: First N-bit fixed-point input operand.\n    b [N-1:0]: Second N-bit fixed-point input operand.\n\nOutput ports:\n\n    c [N-1:0]: N-bit output representing the result of the fixed-point subtraction.\nInternal registers:\n    res [N-1:0]: N-bit register used to store the result of the subtraction operation.\n\nImplementation:\n    Same Sign Subtraction: When the signs of a and b are the same, their fractional and integer parts are subtracted. The sign of the result will be the same as the inputs.\n\nDifferent Sign Subtraction:\n    If a is positive and b is negative, the absolute values of a and b are added. The result will have a positive sign if a is greater than b, and a negative sign otherwise.\n    If a is negative and b is positive, the same logic applies, with the result's sign depending on the relative sizes of a and b.\n\nHandling Zero: \n    When the result is zero, the sign bit is explicitly set to 0 to handle this edge case.\n\nPrecision: \n    The fixed-point precision is defined by the parameters Q (fractional bits) and N (total bits). This ensures that the subtraction is performed accurately while maintaining the necessary precision for both integer and fractional parts.\n\nGive me the complete code."}, "clean_code": "module fixed_point_subtractor #(\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\n\t\tres[N-1] = a[N-1];\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corrupted_code": "module fixed_point_subtractor #(\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\n\t\tres[N-1] = a[N-1];\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corruption_explanation": "Changed operator from '+' to '-'", "modification_type": "change_operator", "modification_line": 26, "original_snippet": "+", "modified_snippet": "-", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '+' to '-'\n   \u2022 Line 26: Original: +\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 26.\n   \u2022 Restore the original code: +\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 43, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.192480", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Other", "design_name": "fixed_point_substractor", "module_name": "fixed_point_substractor", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a fixed-point subtractor for precise arithmetic operations with fixed precision.\n\nModule name:\n    fixed_point_subtractor\n\nParameterized values:\n    Q: Represents the number of fractional bits in the fixed-point representation.\n    N: Represents the total number of bits (both integer and fractional) used for inputs and outputs.\n\nInput ports:\n    a [N-1:0]: First N-bit fixed-point input operand.\n    b [N-1:0]: Second N-bit fixed-point input operand.\n\nOutput ports:\n\n    c [N-1:0]: N-bit output representing the result of the fixed-point subtraction.\nInternal registers:\n    res [N-1:0]: N-bit register used to store the result of the subtraction operation.\n\nImplementation:\n    Same Sign Subtraction: When the signs of a and b are the same, their fractional and integer parts are subtracted. The sign of the result will be the same as the inputs.\n\nDifferent Sign Subtraction:\n    If a is positive and b is negative, the absolute values of a and b are added. The result will have a positive sign if a is greater than b, and a negative sign otherwise.\n    If a is negative and b is positive, the same logic applies, with the result's sign depending on the relative sizes of a and b.\n\nHandling Zero: \n    When the result is zero, the sign bit is explicitly set to 0 to handle this edge case.\n\nPrecision: \n    The fixed-point precision is defined by the parameters Q (fractional bits) and N (total bits). This ensures that the subtraction is performed accurately while maintaining the necessary precision for both integer and fractional parts.\n\nGive me the complete code."}, "clean_code": "module fixed_point_subtractor #(\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\n\t\tres[N-1] = a[N-1];\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corrupted_code": "module fixed_point_subtractor #(\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\n\t\tres[N-1] = a[N-1];\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corruption_explanation": "Swapped if and else bodies", "modification_type": "invert_if_else", "modification_line": 38, "original_snippet": "if( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t", "modified_snippet": "if( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n", "issue_description": "The buggy code has swapped if and else bodies in a conditional block. This causes the logic to execute the opposite branch for each condition, leading to incorrect behavior when the condition is true vs false. Test cases that depend on the conditional logic will fail because the intended branch is not executed.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module contains conditional logic that should execute different code paths based on a condition.\n   \u2022 The if branch should handle the true case, and the else branch should handle the false case.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Identified a conditional block with both if and else branches.\n   \u2022 The branches contain different assignments or logic operations.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The if and else bodies have been swapped.\n   \u2022 Logic that should execute when condition is true now executes when false, and vice versa.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The conditional bodies are inverted.\n   \u2022 Impact: All conditional behavior is reversed, causing incorrect outputs for all test cases.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Swap the if and else bodies back to their correct positions.\n   \u2022 Verify that the condition evaluates correctly and executes the intended branch.\n\n6. RTL Design Principle Violated:\n   \u2022 Correct conditional logic requires matching the intended behavior with the branch bodies.", "complexity": 43, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["invert_if_else"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.194682", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Other", "design_name": "fixed_point_substractor", "module_name": "fixed_point_substractor", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a fixed-point subtractor for precise arithmetic operations with fixed precision.\n\nModule name:\n    fixed_point_subtractor\n\nParameterized values:\n    Q: Represents the number of fractional bits in the fixed-point representation.\n    N: Represents the total number of bits (both integer and fractional) used for inputs and outputs.\n\nInput ports:\n    a [N-1:0]: First N-bit fixed-point input operand.\n    b [N-1:0]: Second N-bit fixed-point input operand.\n\nOutput ports:\n\n    c [N-1:0]: N-bit output representing the result of the fixed-point subtraction.\nInternal registers:\n    res [N-1:0]: N-bit register used to store the result of the subtraction operation.\n\nImplementation:\n    Same Sign Subtraction: When the signs of a and b are the same, their fractional and integer parts are subtracted. The sign of the result will be the same as the inputs.\n\nDifferent Sign Subtraction:\n    If a is positive and b is negative, the absolute values of a and b are added. The result will have a positive sign if a is greater than b, and a negative sign otherwise.\n    If a is negative and b is positive, the same logic applies, with the result's sign depending on the relative sizes of a and b.\n\nHandling Zero: \n    When the result is zero, the sign bit is explicitly set to 0 to handle this edge case.\n\nPrecision: \n    The fixed-point precision is defined by the parameters Q (fractional bits) and N (total bits). This ensures that the subtraction is performed accurately while maintaining the necessary precision for both integer and fractional parts.\n\nGive me the complete code."}, "clean_code": "module fixed_point_subtractor #(\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\n\t\tres[N-1] = a[N-1];\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corrupted_code": "module fixed_point_subtractor #(\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\nassign c = 1'b0;  // Conflicting assignment\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\n\t\tres[N-1] = a[N-1];\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corruption_explanation": "Added conflicting driver for signal 'c'", "modification_type": "add_multiple_driver", "modification_line": 12, "original_snippet": "assign c = res;", "modified_snippet": "assign c = res;\nassign c = 1'b0;  // Conflicting assignment", "issue_description": "The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_multiple_driver modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added conflicting driver for signal 'c'\n   \u2022 Line 12: Original: assign c = res;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 12.\n   \u2022 Restore the original code: assign c = res;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add multiple driver.", "complexity": 43, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["add_multiple_driver"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.196891", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Other", "design_name": "fixed_point_substractor", "module_name": "fixed_point_substractor", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a fixed-point subtractor for precise arithmetic operations with fixed precision.\n\nModule name:\n    fixed_point_subtractor\n\nParameterized values:\n    Q: Represents the number of fractional bits in the fixed-point representation.\n    N: Represents the total number of bits (both integer and fractional) used for inputs and outputs.\n\nInput ports:\n    a [N-1:0]: First N-bit fixed-point input operand.\n    b [N-1:0]: Second N-bit fixed-point input operand.\n\nOutput ports:\n\n    c [N-1:0]: N-bit output representing the result of the fixed-point subtraction.\nInternal registers:\n    res [N-1:0]: N-bit register used to store the result of the subtraction operation.\n\nImplementation:\n    Same Sign Subtraction: When the signs of a and b are the same, their fractional and integer parts are subtracted. The sign of the result will be the same as the inputs.\n\nDifferent Sign Subtraction:\n    If a is positive and b is negative, the absolute values of a and b are added. The result will have a positive sign if a is greater than b, and a negative sign otherwise.\n    If a is negative and b is positive, the same logic applies, with the result's sign depending on the relative sizes of a and b.\n\nHandling Zero: \n    When the result is zero, the sign bit is explicitly set to 0 to handle this edge case.\n\nPrecision: \n    The fixed-point precision is defined by the parameters Q (fractional bits) and N (total bits). This ensures that the subtraction is performed accurately while maintaining the necessary precision for both integer and fractional parts.\n\nGive me the complete code."}, "clean_code": "module fixed_point_subtractor #(\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\n\t\tres[N-1] = a[N-1];\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corrupted_code": "module fixed_point_subtractor #(\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\n\t\tres[N-1] = a[N-1];\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] <= a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 39, "original_snippet": "res[N-2:0] = a[N-2:0] + b[N-2:0];", "modified_snippet": "res[N-2:0] <= a[N-2:0] + b[N-2:0];", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 43, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.199288", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Other", "design_name": "fixed_point_substractor", "module_name": "fixed_point_substractor", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a fixed-point subtractor for precise arithmetic operations with fixed precision.\n\nModule name:\n    fixed_point_subtractor\n\nParameterized values:\n    Q: Represents the number of fractional bits in the fixed-point representation.\n    N: Represents the total number of bits (both integer and fractional) used for inputs and outputs.\n\nInput ports:\n    a [N-1:0]: First N-bit fixed-point input operand.\n    b [N-1:0]: Second N-bit fixed-point input operand.\n\nOutput ports:\n\n    c [N-1:0]: N-bit output representing the result of the fixed-point subtraction.\nInternal registers:\n    res [N-1:0]: N-bit register used to store the result of the subtraction operation.\n\nImplementation:\n    Same Sign Subtraction: When the signs of a and b are the same, their fractional and integer parts are subtracted. The sign of the result will be the same as the inputs.\n\nDifferent Sign Subtraction:\n    If a is positive and b is negative, the absolute values of a and b are added. The result will have a positive sign if a is greater than b, and a negative sign otherwise.\n    If a is negative and b is positive, the same logic applies, with the result's sign depending on the relative sizes of a and b.\n\nHandling Zero: \n    When the result is zero, the sign bit is explicitly set to 0 to handle this edge case.\n\nPrecision: \n    The fixed-point precision is defined by the parameters Q (fractional bits) and N (total bits). This ensures that the subtraction is performed accurately while maintaining the necessary precision for both integer and fractional parts.\n\nGive me the complete code."}, "clean_code": "module fixed_point_subtractor #(\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\n\t\tres[N-1] = a[N-1];\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corrupted_code": "module fixed_point_subtractor #(\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\nassign c = 1'b0;  // Conflicting assignment\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\n\t\tres[N-1] = a[N-1];\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] + a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corruption_explanation": "Added conflicting driver for signal 'c'", "modification_type": "add_multiple_driver", "modification_line": 12, "original_snippet": "assign c = res;", "modified_snippet": "assign c = res;\nassign c = 1'b0;  // Conflicting assignment", "issue_description": "The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_multiple_driver modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added conflicting driver for signal 'c'\n   \u2022 Line 12: Original: assign c = res;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 12.\n   \u2022 Restore the original code: assign c = res;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add multiple driver.", "complexity": 43, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["add_multiple_driver"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.201511", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Other", "design_name": "float_multi", "module_name": "float_multi", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 32-bit floating-point multiplier for IEEE-754 standard single-precision arithmetic.\nThe float_multi module is designed to perform high-precision multiplication of 32-bit single-precision floating-point numbers, following the IEEE 754 standard. This module enables accurate arithmetic operations essential for various computational applications.\n\nModule name:\nfloat_multi\n\nInput ports:\n    clk (input): Clock signal for synchronization.\n    rst (input): Reset signal (active high).\n    a (input [31:0]): First operand in IEEE 754 format.\n    b (input [31:0]): Second operand in IEEE 754 format.\n\nOutput ports:\n    z (output reg [31:0]): Result of the multiplication in IEEE 754 format.\n\nInternal signals:\n    counter (reg [2:0]): Cycle counter for operation sequencing.\n    a_mantissa, b_mantissa, z_mantissa (reg [23:0]): Mantissas of input and output numbers.\n    a_exponent, b_exponent, z_exponent (reg [9:0]): Exponents of input and output numbers.\n    a_sign, b_sign, z_sign (reg): Sign bits for inputs and output.\n    product (reg [49:0]): Intermediate product of the mantissas.\n    guard_bit, round_bit, sticky (reg): Rounding control bits.\n\nImplementation:\n    -Initialization: The counter is reset to zero on the rst signal.\n    -Input Processing: The mantissas, exponents, and sign bits of inputs a and b are extracted during the first clock cycle.\n    -Special Cases Handling: The module identifies special cases like NaN (Not a Number) and infinity based on the inputs.\n    -Normalization: Mantissas are normalized if needed.\n    -Multiplication: The mantissas are multiplied, combining the signs and adjusting the exponents.\n    -Rounding and Adjustment: The module rounds the result and adjusts the exponent to ensure accurate representation.\n    -Output Generation: The final result is formatted in IEEE 754 standard, addressing overflow and underflow scenarios.\n\nGive me the complete code."}, "clean_code": "module float_multi(clk, rst, a, b, z);\n\ninput clk, rst;\ninput [31:0] a, b;\noutput reg [31:0] z;\n\nreg [2:0] counter;\n\nreg [23:0] a_mantissa, b_mantissa, z_mantissa; //Mantissa\nreg [9:0] a_exponent, b_exponent, z_exponent; //EXPONENTS\nreg a_sign, b_sign, z_sign; // Sign_Bit\n\nreg [49:0] product;\n\nreg guard_bit, round_bit, sticky;\n\nalways @(posedge clk or rst) begin\n\tif(rst)\n\t\tcounter <= 0;\n\telse\n\t\tcounter <= counter + 1;\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b001) begin \n\t//IEEE 754 Representation\n\t\ta_mantissa <= a[22:0];\n\t        b_mantissa <= b[22:0];\n\t        a_exponent <= a[30:23] - 127;\n        \tb_exponent <= b[30:23] - 127;\n\t        a_sign <= a[31];\n        \tb_sign <= b[31];\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b010) begin\n\t\tif ((a_exponent == 128 && a_mantissa != 0) || (b_exponent == 128 && b_mantissa != 0)) begin //Not a Number \n          \t\tz[31] <= 1;\n          \t\tz[30:23] <= 255;\n          \t\tz[22] <= 1;\n          \t\tz[21:0] <= 0;\n          \tend\n          \telse if (a_exponent == 128) begin //INF A\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //NAN IF B = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n          \telse if (b_exponent == 128) begin //INF B\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //NAN IF A = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n\t          else if (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //0 if A = 0\n       \t\t z[31] <= a_sign ^ b_sign; //Sign_Bit \n       \t\t z[30:23] <= 0; \n        \t \t z[22:0] <= 0;\n        \t  end\n        \t  else if (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //0 if B = 0\n        \t \t z[31] <= a_sign ^ b_sign;\n        \t  \t z[30:23] <= 0;\n        \t  \t z[22:0] <= 0;\n        \t  end\n        \t  else begin\n        \t  \tif ($signed(a_exponent) == -127) //DENORMALIZING A\n        \t    \t\ta_exponent <= -126;\n        \t  \telse\n        \t    \t\ta_mantissa[23] <= 1;\n            \t\t\n        \t    \tif ($signed(b_exponent) == -127) //DENORMALIZING B\n        \t    \t\tb_exponent <= -126;\n        \t  \telse\n        \t    \t\tb_mantissa[23] <= 1;\n        \t  end\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b011) begin\n\t\tif (~a_mantissa[23]) begin //NORMALIZE A\n\t        \ta_mantissa <= a_mantissa << 1;\n\t       \ta_exponent <= a_exponent - 1;\n\t        end\n\t        if (~b_mantissa[23]) begin //NORMALIZE B\n\t        \tb_mantissa <= b_mantissa << 1;\n\t       \tb_exponent <= b_exponent - 1;\n\t        end\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b100) begin //GET THE SIGNS XORED and EXPONENTS ADDED and GET THE INTERMEDIATE MANTISSA MULTIPLICATION\n\t\tz_sign <= a_sign ^ b_sign;\n\t        z_exponent <= a_exponent + b_exponent + 1 ;\n        \tproduct <= a_mantissa * b_mantissa * 4;\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b101) begin\n\t\tz_mantissa <= product[49:26];\n       \tguard_bit <= product[25];\n      \t\tround_bit <= product[24];\n      \t\tsticky <= (product[23:0] != 0);\n\tend\nend\n\nalways @(counter) begin\n\tif(counter == 3'b110) begin\n\t\tif ($signed(z_exponent) < -126) begin\n        \t\tz_exponent <= z_exponent + (-126 -$signed(z_exponent));\n    \t\t\tz_mantissa <= z_mantissa >> (-126 -$signed(z_exponent));\n     \t\t\tguard_bit <= z_mantissa[0];\n       \t\tround_bit <= guard_bit;\n       \t\tsticky <= sticky | round_bit;\n        \tend\n\t\telse if (z_mantissa[23] == 0) begin\n        \t\tz_exponent <= z_exponent - 1;\n        \t\tz_mantissa <= z_mantissa << 1;\n        \t\tz_mantissa[0] <= guard_bit;\n        \t\tguard_bit <= round_bit;\n        \t\tround_bit <= 0;\n        \tend\n\t        else if (guard_bit && (round_bit | sticky | z_mantissa[0])) begin\n        \t\tz_mantissa <= z_mantissa + 1;\n          \t\tif (z_mantissa == 24'hffffff)\n            \t\t\tz_exponent <=z_exponent + 1;\n        \tend\n        end\nend\n\nalways @(counter) begin\n\tif(counter == 3'b111) begin\n\t\tz[22:0] <= z_mantissa[22:0];\n        \tz[30:23] <= z_exponent[7:0] + 127;\n        \tz[31] <= z_sign;\n        \tif ($signed(z_exponent) == -126 && z_mantissa[23] == 0)\n          \t\tz[30:23] <= 0;\n        \tif ($signed(z_exponent) > 127) begin //IF OVERFLOW RETURN INF\n          \t\tz[22:0] <= 0;\n          \t\tz[30:23] <= 255;\n          \t\tz[31] <= z_sign;\n        \tend\n\tend\nend\n\n\nendmodule", "corrupted_code": "module float_multi(clk, rst, a, b, z);\n\ninput clk, rst;\ninput [31:0] a, b;\noutput reg [31:0] z;\n\nreg [2:0] counter;\n\nreg [23:0] a_mantissa, b_mantissa, z_mantissa; //Mantissa\nreg [9:0] a_exponent, b_exponent, z_exponent; //EXPONENTS\nreg a_sign, b_sign, z_sign; // Sign_Bit\n\nreg [49:0] product;\n\nreg guard_bit, round_bit, sticky;\n\nalways @(posedge clk or rst) begin\n\tif(rst)\n\t\tcounter <= 0;\n\telse\n\t\tcounter <= counter + 1;\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b001) begin \n\t//IEEE 754 Representation\n\t\ta_mantissa <= a[22:0];\n\t        b_mantissa <= b[22:0];\n\t        a_exponent <= a[30:23] - 127;\n        \tb_exponent <= b[30:23] - 127;\n\t        a_sign <= a[31];\n        \tb_sign <= b[31];\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b010) begin\n\t\tif ((a_exponent == 128 && a_mantissa != 0) || (b_exponent == 128 && b_mantissa != 0)) begin //Not a Number \n          \t\tz[31] <= 1;\n          \t\tz[30:23] <= 255;\n          \t\tz[22] <= 1;\n          \t\tz[21:0] <= 0;\n          \tend\n          \telse if (a_exponent == 128) begin //INF A\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //NAN IF B = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n          \telse if (b_exponent == 128) begin //INF B\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //NAN IF A = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n\t          else if (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //0 if A = 0\n       \t\t z[31] <= a_sign ^ b_sign; //Sign_Bit \n       \t\t z[30:23] <= 0; \n        \t \t z[22:0] <= 0;\n        \t  end\n        \t  else if (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //0 if B = 0\n        \t \t z[31] <= a_sign ^ b_sign;\n        \t  \t z[30:23] <= 0;\n        \t  \t z[22:0] <= 0;\n        \t  end\n        \t  else begin\n        \t  \tif ($signed(a_exponent) == -127) //DENORMALIZING A\n        \t    \t\ta_exponent <= -126;\n        \t  \telse\n        \t    \t\ta_mantissa[23] <= 1;\n            \t\t\n        \t    \tif ($signed(b_exponent) == -127) //DENORMALIZING B\n        \t    \t\tb_exponent <= -126;\n        \t  \telse\n        \t    \t\tb_mantissa[23] <= 1;\n        \t  end\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b011) begin\n\t\tif (~a_mantissa[23]) begin //NORMALIZE A\n\n\t       \ta_exponent <= a_exponent - 1;\n\t        end\n\t        if (~b_mantissa[23]) begin //NORMALIZE B\n\t        \tb_mantissa <= b_mantissa << 1;\n\t       \tb_exponent <= b_exponent - 1;\n\t        end\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b100) begin //GET THE SIGNS XORED and EXPONENTS ADDED and GET THE INTERMEDIATE MANTISSA MULTIPLICATION\n\t\tz_sign <= a_sign ^ b_sign;\n\t        z_exponent <= a_exponent + b_exponent + 1 ;\n        \tproduct <= a_mantissa * b_mantissa * 4;\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b101) begin\n\t\tz_mantissa <= product[49:26];\n       \tguard_bit <= product[25];\n      \t\tround_bit <= product[24];\n      \t\tsticky <= (product[23:0] != 0);\n\tend\nend\n\nalways @(counter) begin\n\tif(counter == 3'b110) begin\n\t\tif ($signed(z_exponent) < -126) begin\n        \t\tz_exponent <= z_exponent + (-126 -$signed(z_exponent));\n    \t\t\tz_mantissa <= z_mantissa >> (-126 -$signed(z_exponent));\n     \t\t\tguard_bit <= z_mantissa[0];\n       \t\tround_bit <= guard_bit;\n       \t\tsticky <= sticky | round_bit;\n        \tend\n\t\telse if (z_mantissa[23] == 0) begin\n        \t\tz_exponent <= z_exponent - 1;\n        \t\tz_mantissa <= z_mantissa << 1;\n        \t\tz_mantissa[0] <= guard_bit;\n        \t\tguard_bit <= round_bit;\n        \t\tround_bit <= 0;\n        \tend\n\t        else if (guard_bit && (round_bit | sticky | z_mantissa[0])) begin\n        \t\tz_mantissa <= z_mantissa + 1;\n          \t\tif (z_mantissa == 24'hffffff)\n            \t\t\tz_exponent <=z_exponent + 1;\n        \tend\n        end\nend\n\nalways @(counter) begin\n\tif(counter == 3'b111) begin\n\t\tz[22:0] <= z_mantissa[22:0];\n        \tz[30:23] <= z_exponent[7:0] + 127;\n        \tz[31] <= z_sign;\n        \tif ($signed(z_exponent) == -126 && z_mantissa[23] == 0)\n          \t\tz[30:23] <= 0;\n        \tif ($signed(z_exponent) > 127) begin //IF OVERFLOW RETURN INF\n          \t\tz[22:0] <= 0;\n          \t\tz[30:23] <= 255;\n          \t\tz[31] <= z_sign;\n        \tend\n\tend\nend\n\n\nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 96, "original_snippet": "a_mantissa <= a_mantissa << 1;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 96: Original: a_mantissa <= a_mantissa << 1;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 96.\n   \u2022 Restore the original code: a_mantissa <= a_mantissa << 1;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 88, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.212608", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Other", "design_name": "float_multi", "module_name": "float_multi", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 32-bit floating-point multiplier for IEEE-754 standard single-precision arithmetic.\nThe float_multi module is designed to perform high-precision multiplication of 32-bit single-precision floating-point numbers, following the IEEE 754 standard. This module enables accurate arithmetic operations essential for various computational applications.\n\nModule name:\nfloat_multi\n\nInput ports:\n    clk (input): Clock signal for synchronization.\n    rst (input): Reset signal (active high).\n    a (input [31:0]): First operand in IEEE 754 format.\n    b (input [31:0]): Second operand in IEEE 754 format.\n\nOutput ports:\n    z (output reg [31:0]): Result of the multiplication in IEEE 754 format.\n\nInternal signals:\n    counter (reg [2:0]): Cycle counter for operation sequencing.\n    a_mantissa, b_mantissa, z_mantissa (reg [23:0]): Mantissas of input and output numbers.\n    a_exponent, b_exponent, z_exponent (reg [9:0]): Exponents of input and output numbers.\n    a_sign, b_sign, z_sign (reg): Sign bits for inputs and output.\n    product (reg [49:0]): Intermediate product of the mantissas.\n    guard_bit, round_bit, sticky (reg): Rounding control bits.\n\nImplementation:\n    -Initialization: The counter is reset to zero on the rst signal.\n    -Input Processing: The mantissas, exponents, and sign bits of inputs a and b are extracted during the first clock cycle.\n    -Special Cases Handling: The module identifies special cases like NaN (Not a Number) and infinity based on the inputs.\n    -Normalization: Mantissas are normalized if needed.\n    -Multiplication: The mantissas are multiplied, combining the signs and adjusting the exponents.\n    -Rounding and Adjustment: The module rounds the result and adjusts the exponent to ensure accurate representation.\n    -Output Generation: The final result is formatted in IEEE 754 standard, addressing overflow and underflow scenarios.\n\nGive me the complete code."}, "clean_code": "module float_multi(clk, rst, a, b, z);\n\ninput clk, rst;\ninput [31:0] a, b;\noutput reg [31:0] z;\n\nreg [2:0] counter;\n\nreg [23:0] a_mantissa, b_mantissa, z_mantissa; //Mantissa\nreg [9:0] a_exponent, b_exponent, z_exponent; //EXPONENTS\nreg a_sign, b_sign, z_sign; // Sign_Bit\n\nreg [49:0] product;\n\nreg guard_bit, round_bit, sticky;\n\nalways @(posedge clk or rst) begin\n\tif(rst)\n\t\tcounter <= 0;\n\telse\n\t\tcounter <= counter + 1;\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b001) begin \n\t//IEEE 754 Representation\n\t\ta_mantissa <= a[22:0];\n\t        b_mantissa <= b[22:0];\n\t        a_exponent <= a[30:23] - 127;\n        \tb_exponent <= b[30:23] - 127;\n\t        a_sign <= a[31];\n        \tb_sign <= b[31];\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b010) begin\n\t\tif ((a_exponent == 128 && a_mantissa != 0) || (b_exponent == 128 && b_mantissa != 0)) begin //Not a Number \n          \t\tz[31] <= 1;\n          \t\tz[30:23] <= 255;\n          \t\tz[22] <= 1;\n          \t\tz[21:0] <= 0;\n          \tend\n          \telse if (a_exponent == 128) begin //INF A\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //NAN IF B = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n          \telse if (b_exponent == 128) begin //INF B\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //NAN IF A = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n\t          else if (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //0 if A = 0\n       \t\t z[31] <= a_sign ^ b_sign; //Sign_Bit \n       \t\t z[30:23] <= 0; \n        \t \t z[22:0] <= 0;\n        \t  end\n        \t  else if (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //0 if B = 0\n        \t \t z[31] <= a_sign ^ b_sign;\n        \t  \t z[30:23] <= 0;\n        \t  \t z[22:0] <= 0;\n        \t  end\n        \t  else begin\n        \t  \tif ($signed(a_exponent) == -127) //DENORMALIZING A\n        \t    \t\ta_exponent <= -126;\n        \t  \telse\n        \t    \t\ta_mantissa[23] <= 1;\n            \t\t\n        \t    \tif ($signed(b_exponent) == -127) //DENORMALIZING B\n        \t    \t\tb_exponent <= -126;\n        \t  \telse\n        \t    \t\tb_mantissa[23] <= 1;\n        \t  end\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b011) begin\n\t\tif (~a_mantissa[23]) begin //NORMALIZE A\n\t        \ta_mantissa <= a_mantissa << 1;\n\t       \ta_exponent <= a_exponent - 1;\n\t        end\n\t        if (~b_mantissa[23]) begin //NORMALIZE B\n\t        \tb_mantissa <= b_mantissa << 1;\n\t       \tb_exponent <= b_exponent - 1;\n\t        end\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b100) begin //GET THE SIGNS XORED and EXPONENTS ADDED and GET THE INTERMEDIATE MANTISSA MULTIPLICATION\n\t\tz_sign <= a_sign ^ b_sign;\n\t        z_exponent <= a_exponent + b_exponent + 1 ;\n        \tproduct <= a_mantissa * b_mantissa * 4;\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b101) begin\n\t\tz_mantissa <= product[49:26];\n       \tguard_bit <= product[25];\n      \t\tround_bit <= product[24];\n      \t\tsticky <= (product[23:0] != 0);\n\tend\nend\n\nalways @(counter) begin\n\tif(counter == 3'b110) begin\n\t\tif ($signed(z_exponent) < -126) begin\n        \t\tz_exponent <= z_exponent + (-126 -$signed(z_exponent));\n    \t\t\tz_mantissa <= z_mantissa >> (-126 -$signed(z_exponent));\n     \t\t\tguard_bit <= z_mantissa[0];\n       \t\tround_bit <= guard_bit;\n       \t\tsticky <= sticky | round_bit;\n        \tend\n\t\telse if (z_mantissa[23] == 0) begin\n        \t\tz_exponent <= z_exponent - 1;\n        \t\tz_mantissa <= z_mantissa << 1;\n        \t\tz_mantissa[0] <= guard_bit;\n        \t\tguard_bit <= round_bit;\n        \t\tround_bit <= 0;\n        \tend\n\t        else if (guard_bit && (round_bit | sticky | z_mantissa[0])) begin\n        \t\tz_mantissa <= z_mantissa + 1;\n          \t\tif (z_mantissa == 24'hffffff)\n            \t\t\tz_exponent <=z_exponent + 1;\n        \tend\n        end\nend\n\nalways @(counter) begin\n\tif(counter == 3'b111) begin\n\t\tz[22:0] <= z_mantissa[22:0];\n        \tz[30:23] <= z_exponent[7:0] + 127;\n        \tz[31] <= z_sign;\n        \tif ($signed(z_exponent) == -126 && z_mantissa[23] == 0)\n          \t\tz[30:23] <= 0;\n        \tif ($signed(z_exponent) > 127) begin //IF OVERFLOW RETURN INF\n          \t\tz[22:0] <= 0;\n          \t\tz[30:23] <= 255;\n          \t\tz[31] <= z_sign;\n        \tend\n\tend\nend\n\n\nendmodule", "corrupted_code": "module float_multi(clk, rst, a, b, z);\n\ninput clk, rst;\ninput [31:0] a, b;\noutput reg [31:0] z;\n\nreg [2:0] counter;\n\nreg [23:0] a_mantissa, b_mantissa, z_mantissa; //Mantissa\nreg [9:0] a_exponent, b_exponent, z_exponent; //EXPONENTS\nreg a_sign, b_sign, z_sign; // Sign_Bit\n\nreg [49:0] product;\n\nreg guard_bit, round_bit, sticky;\n\n\n\n\nalways @(counter) begin\n\tif(counter == 3'b001) begin \n\t//IEEE 754 Representation\n\t\ta_mantissa <= a[22:0];\n\t        b_mantissa <= b[22:0];\n\t        a_exponent <= a[30:23] - 127;\n        \tb_exponent <= b[30:23] - 127;\n\t        a_sign <= a[31];\n        \tb_sign <= b[31];\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b010) begin\n\t\tif ((a_exponent == 128 && a_mantissa != 0) || (b_exponent == 128 && b_mantissa != 0)) begin //Not a Number \n          \t\tz[31] <= 1;\n          \t\tz[30:23] <= 255;\n          \t\tz[22] <= 1;\n          \t\tz[21:0] <= 0;\n          \tend\n          \telse if (a_exponent == 128) begin //INF A\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //NAN IF B = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n          \telse if (b_exponent == 128) begin //INF B\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //NAN IF A = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n\t          else if (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //0 if A = 0\n       \t\t z[31] <= a_sign ^ b_sign; //Sign_Bit \n       \t\t z[30:23] <= 0; \n        \t \t z[22:0] <= 0;\n        \t  end\n        \t  else if (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //0 if B = 0\n        \t \t z[31] <= a_sign ^ b_sign;\n        \t  \t z[30:23] <= 0;\n        \t  \t z[22:0] <= 0;\n        \t  end\n        \t  else begin\n        \t  \tif ($signed(a_exponent) == -127) //DENORMALIZING A\n        \t    \t\ta_exponent <= -126;\n        \t  \telse\n        \t    \t\ta_mantissa[23] <= 1;\n            \t\t\n        \t    \tif ($signed(b_exponent) == -127) //DENORMALIZING B\n        \t    \t\tb_exponent <= -126;\n        \t  \telse\n        \t    \t\tb_mantissa[23] <= 1;\n        \t  end\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b011) begin\n\t\tif (~a_mantissa[23]) begin //NORMALIZE A\n\t        \ta_mantissa <= a_mantissa << 1;\n\t       \ta_exponent <= a_exponent - 1;\n\t        end\n\t        if (~b_mantissa[23]) begin //NORMALIZE B\n\t        \tb_mantissa <= b_mantissa << 1;\n\t       \tb_exponent <= b_exponent - 1;\n\t        end\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b100) begin //GET THE SIGNS XORED and EXPONENTS ADDED and GET THE INTERMEDIATE MANTISSA MULTIPLICATION\n\t\tz_sign <= a_sign ^ b_sign;\n\t        z_exponent <= a_exponent + b_exponent + 1 ;\n        \tproduct <= a_mantissa * b_mantissa * 4;\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b101) begin\n\t\tz_mantissa <= product[49:26];\n       \tguard_bit <= product[25];\n      \t\tround_bit <= product[24];\n      \t\tsticky <= (product[23:0] != 0);\n\tend\nend\n\nalways @(counter) begin\n\tif(counter == 3'b110) begin\n\t\tif ($signed(z_exponent) < -126) begin\n        \t\tz_exponent <= z_exponent + (-126 -$signed(z_exponent));\n    \t\t\tz_mantissa <= z_mantissa >> (-126 -$signed(z_exponent));\n     \t\t\tguard_bit <= z_mantissa[0];\n       \t\tround_bit <= guard_bit;\n       \t\tsticky <= sticky | round_bit;\n        \tend\n\t\telse if (z_mantissa[23] == 0) begin\n        \t\tz_exponent <= z_exponent - 1;\n        \t\tz_mantissa <= z_mantissa << 1;\n        \t\tz_mantissa[0] <= guard_bit;\n        \t\tguard_bit <= round_bit;\n        \t\tround_bit <= 0;\n        \tend\n\t        else if (guard_bit && (round_bit | sticky | z_mantissa[0])) begin\n        \t\tz_mantissa <= z_mantissa + 1;\n          \t\tif (z_mantissa == 24'hffffff)\n            \t\t\tz_exponent <=z_exponent + 1;\n        \tend\n        end\nend\n\nalways @(counter) begin\n\tif(counter == 3'b111) begin\n\t\tz[22:0] <= z_mantissa[22:0];\n        \tz[30:23] <= z_exponent[7:0] + 127;\n        \tz[31] <= z_sign;\n        \tif ($signed(z_exponent) == -126 && z_mantissa[23] == 0)\n          \t\tz[30:23] <= 0;\n        \tif ($signed(z_exponent) > 127) begin //IF OVERFLOW RETURN INF\n          \t\tz[22:0] <= 0;\n          \t\tz[30:23] <= 255;\n          \t\tz[31] <= z_sign;\n        \tend\n\tend\nend\n\n\nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 17, "original_snippet": "always @(posedge clk or rst) begin\n\tif(rst)\n\t\tcounter <= 0;\n\telse\n\t\tcounter <= counter + 1;\nend", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 17: Original: always @(posedge clk or rst) begin\n\tif(rst)\n\t\tcounter <= 0;\n\telse\n\t\tcounter <= counter + 1;\nend\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 17.\n   \u2022 Restore the original code: always @(posedge clk or rst) begin\n\tif(rst)\n\t\tcounter <= 0;\n\telse\n\t\tcounter <= counter + 1;\nend\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 88, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.229840", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Other", "design_name": "float_multi", "module_name": "float_multi", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 32-bit floating-point multiplier for IEEE-754 standard single-precision arithmetic.\nThe float_multi module is designed to perform high-precision multiplication of 32-bit single-precision floating-point numbers, following the IEEE 754 standard. This module enables accurate arithmetic operations essential for various computational applications.\n\nModule name:\nfloat_multi\n\nInput ports:\n    clk (input): Clock signal for synchronization.\n    rst (input): Reset signal (active high).\n    a (input [31:0]): First operand in IEEE 754 format.\n    b (input [31:0]): Second operand in IEEE 754 format.\n\nOutput ports:\n    z (output reg [31:0]): Result of the multiplication in IEEE 754 format.\n\nInternal signals:\n    counter (reg [2:0]): Cycle counter for operation sequencing.\n    a_mantissa, b_mantissa, z_mantissa (reg [23:0]): Mantissas of input and output numbers.\n    a_exponent, b_exponent, z_exponent (reg [9:0]): Exponents of input and output numbers.\n    a_sign, b_sign, z_sign (reg): Sign bits for inputs and output.\n    product (reg [49:0]): Intermediate product of the mantissas.\n    guard_bit, round_bit, sticky (reg): Rounding control bits.\n\nImplementation:\n    -Initialization: The counter is reset to zero on the rst signal.\n    -Input Processing: The mantissas, exponents, and sign bits of inputs a and b are extracted during the first clock cycle.\n    -Special Cases Handling: The module identifies special cases like NaN (Not a Number) and infinity based on the inputs.\n    -Normalization: Mantissas are normalized if needed.\n    -Multiplication: The mantissas are multiplied, combining the signs and adjusting the exponents.\n    -Rounding and Adjustment: The module rounds the result and adjusts the exponent to ensure accurate representation.\n    -Output Generation: The final result is formatted in IEEE 754 standard, addressing overflow and underflow scenarios.\n\nGive me the complete code."}, "clean_code": "module float_multi(clk, rst, a, b, z);\n\ninput clk, rst;\ninput [31:0] a, b;\noutput reg [31:0] z;\n\nreg [2:0] counter;\n\nreg [23:0] a_mantissa, b_mantissa, z_mantissa; //Mantissa\nreg [9:0] a_exponent, b_exponent, z_exponent; //EXPONENTS\nreg a_sign, b_sign, z_sign; // Sign_Bit\n\nreg [49:0] product;\n\nreg guard_bit, round_bit, sticky;\n\nalways @(posedge clk or rst) begin\n\tif(rst)\n\t\tcounter <= 0;\n\telse\n\t\tcounter <= counter + 1;\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b001) begin \n\t//IEEE 754 Representation\n\t\ta_mantissa <= a[22:0];\n\t        b_mantissa <= b[22:0];\n\t        a_exponent <= a[30:23] - 127;\n        \tb_exponent <= b[30:23] - 127;\n\t        a_sign <= a[31];\n        \tb_sign <= b[31];\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b010) begin\n\t\tif ((a_exponent == 128 && a_mantissa != 0) || (b_exponent == 128 && b_mantissa != 0)) begin //Not a Number \n          \t\tz[31] <= 1;\n          \t\tz[30:23] <= 255;\n          \t\tz[22] <= 1;\n          \t\tz[21:0] <= 0;\n          \tend\n          \telse if (a_exponent == 128) begin //INF A\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //NAN IF B = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n          \telse if (b_exponent == 128) begin //INF B\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //NAN IF A = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n\t          else if (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //0 if A = 0\n       \t\t z[31] <= a_sign ^ b_sign; //Sign_Bit \n       \t\t z[30:23] <= 0; \n        \t \t z[22:0] <= 0;\n        \t  end\n        \t  else if (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //0 if B = 0\n        \t \t z[31] <= a_sign ^ b_sign;\n        \t  \t z[30:23] <= 0;\n        \t  \t z[22:0] <= 0;\n        \t  end\n        \t  else begin\n        \t  \tif ($signed(a_exponent) == -127) //DENORMALIZING A\n        \t    \t\ta_exponent <= -126;\n        \t  \telse\n        \t    \t\ta_mantissa[23] <= 1;\n            \t\t\n        \t    \tif ($signed(b_exponent) == -127) //DENORMALIZING B\n        \t    \t\tb_exponent <= -126;\n        \t  \telse\n        \t    \t\tb_mantissa[23] <= 1;\n        \t  end\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b011) begin\n\t\tif (~a_mantissa[23]) begin //NORMALIZE A\n\t        \ta_mantissa <= a_mantissa << 1;\n\t       \ta_exponent <= a_exponent - 1;\n\t        end\n\t        if (~b_mantissa[23]) begin //NORMALIZE B\n\t        \tb_mantissa <= b_mantissa << 1;\n\t       \tb_exponent <= b_exponent - 1;\n\t        end\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b100) begin //GET THE SIGNS XORED and EXPONENTS ADDED and GET THE INTERMEDIATE MANTISSA MULTIPLICATION\n\t\tz_sign <= a_sign ^ b_sign;\n\t        z_exponent <= a_exponent + b_exponent + 1 ;\n        \tproduct <= a_mantissa * b_mantissa * 4;\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b101) begin\n\t\tz_mantissa <= product[49:26];\n       \tguard_bit <= product[25];\n      \t\tround_bit <= product[24];\n      \t\tsticky <= (product[23:0] != 0);\n\tend\nend\n\nalways @(counter) begin\n\tif(counter == 3'b110) begin\n\t\tif ($signed(z_exponent) < -126) begin\n        \t\tz_exponent <= z_exponent + (-126 -$signed(z_exponent));\n    \t\t\tz_mantissa <= z_mantissa >> (-126 -$signed(z_exponent));\n     \t\t\tguard_bit <= z_mantissa[0];\n       \t\tround_bit <= guard_bit;\n       \t\tsticky <= sticky | round_bit;\n        \tend\n\t\telse if (z_mantissa[23] == 0) begin\n        \t\tz_exponent <= z_exponent - 1;\n        \t\tz_mantissa <= z_mantissa << 1;\n        \t\tz_mantissa[0] <= guard_bit;\n        \t\tguard_bit <= round_bit;\n        \t\tround_bit <= 0;\n        \tend\n\t        else if (guard_bit && (round_bit | sticky | z_mantissa[0])) begin\n        \t\tz_mantissa <= z_mantissa + 1;\n          \t\tif (z_mantissa == 24'hffffff)\n            \t\t\tz_exponent <=z_exponent + 1;\n        \tend\n        end\nend\n\nalways @(counter) begin\n\tif(counter == 3'b111) begin\n\t\tz[22:0] <= z_mantissa[22:0];\n        \tz[30:23] <= z_exponent[7:0] + 127;\n        \tz[31] <= z_sign;\n        \tif ($signed(z_exponent) == -126 && z_mantissa[23] == 0)\n          \t\tz[30:23] <= 0;\n        \tif ($signed(z_exponent) > 127) begin //IF OVERFLOW RETURN INF\n          \t\tz[22:0] <= 0;\n          \t\tz[30:23] <= 255;\n          \t\tz[31] <= z_sign;\n        \tend\n\tend\nend\n\n\nendmodule", "corrupted_code": "module float_multi(clk, rst, a, b, z);\n\ninput clk, rst;\ninput [31:0] a, b;\noutput reg [31:0] z;\n\nreg [2:0] counter;\n\nreg [23:0] a_mantissa, b_mantissa, z_mantissa; //Mantissa\nreg [9:0] a_exponent, b_exponent, z_exponent; //EXPONENTS\nreg a_sign, b_sign, z_sign; // Sign_Bit\n\nreg [49:0] product;\n\nreg guard_bit, round_bit, sticky;\n\nalways @(posedge clk or rst) begin\n\tif(rst)\n\t\tcounter <= 0;\n\telse\n\t\tcounter <= counter + 1;\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b001) begin \n\t//IEEE 754 Representation\n\t\ta_mantissa <= a[22:0];\n\t        b_mantissa <= b[22:0];\n\t        a_exponent <= a[30:23] - 127;\n        \tb_exponent <= b[30:23] - 127;\n\t        a_sign <= a[31];\n        \tb_sign <= b[31];\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b010) begin\n\t\tif ((a_exponent == 128 && a_mantissa != 0) || (b_exponent == 128 && b_mantissa != 0)) begin //Not a Number \n          \t\tz[31] <= 1;\n          \t\tz[30:23] <= 255;\n          \t\tz[22] <= 1;\n          \t\tz[21:0] <= 0;\n          \tend\n          \telse if (a_exponent == 128) begin //INF A\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //NAN IF B = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n          \telse if (b_exponent == 128) begin //INF B\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //NAN IF A = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n\t          else if (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //0 if A = 0\n       \t\t z[31] <= a_sign ^ b_sign; //Sign_Bit \n       \t\t z[30:23] <= 0; \n        \t \t z[22:0] <= 0;\n        \t  end\n        \t  else if (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //0 if B = 0\n        \t \t z[31] <= a_sign ^ b_sign;\n        \t  \t z[30:23] <= 0;\n        \t  \t z[22:0] <= 0;\n        \t  end\n        \t  else begin\n        \t  \tif ($signed(a_exponent) == -127) //DENORMALIZING A\n        \t    \t\ta_exponent <= -126;\n        \t  \telse\n        \t    \t\ta_mantissa[23] <= 1;\n            \t\t\n        \t    \tif ($signed(b_exponent) == -127) //DENORMALIZING B\n        \t    \t\tb_exponent <= -126;\n        \t  \telse\n        \t    \t\tb_mantissa[23] <= 1;\n        \t  end\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b011) begin\n\t\tif (~a_mantissa[23]) begin //NORMALIZE A\n\t        \ta_mantissa <= a_mantissa << 1;\n\t       \ta_exponent <= a_exponent - 1;\n\t        end\n\t        if (~b_mantissa[23]) begin //NORMALIZE B\n\t        \tb_mantissa <= b_mantissa << 1;\n\t       \tb_exponent <= b_exponent - 1;\n\t        end\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b100) begin //GET THE SIGNS XORED and EXPONENTS ADDED and GET THE INTERMEDIATE MANTISSA MULTIPLICATION\n\t\tz_sign <= a_sign ^ b_sign;\n\t        z_exponent <= a_exponent + b_exponent + 1 ;\n        \tproduct <= a_mantissa * b_mantissa * 4;\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b101) begin\n\t\tz_mantissa <= product[49:26];\n\n      \t\tround_bit <= product[24];\n      \t\tsticky <= (product[23:0] != 0);\n\tend\nend\n\nalways @(counter) begin\n\tif(counter == 3'b110) begin\n\t\tif ($signed(z_exponent) < -126) begin\n        \t\tz_exponent <= z_exponent + (-126 -$signed(z_exponent));\n    \t\t\tz_mantissa <= z_mantissa >> (-126 -$signed(z_exponent));\n     \t\t\tguard_bit <= z_mantissa[0];\n       \t\tround_bit <= guard_bit;\n       \t\tsticky <= sticky | round_bit;\n        \tend\n\t\telse if (z_mantissa[23] == 0) begin\n        \t\tz_exponent <= z_exponent - 1;\n        \t\tz_mantissa <= z_mantissa << 1;\n        \t\tz_mantissa[0] <= guard_bit;\n        \t\tguard_bit <= round_bit;\n        \t\tround_bit <= 0;\n        \tend\n\t        else if (guard_bit && (round_bit | sticky | z_mantissa[0])) begin\n        \t\tz_mantissa <= z_mantissa + 1;\n          \t\tif (z_mantissa == 24'hffffff)\n            \t\t\tz_exponent <=z_exponent + 1;\n        \tend\n        end\nend\n\nalways @(counter) begin\n\tif(counter == 3'b111) begin\n\t\tz[22:0] <= z_mantissa[22:0];\n        \tz[30:23] <= z_exponent[7:0] + 127;\n        \tz[31] <= z_sign;\n        \tif ($signed(z_exponent) == -126 && z_mantissa[23] == 0)\n          \t\tz[30:23] <= 0;\n        \tif ($signed(z_exponent) > 127) begin //IF OVERFLOW RETURN INF\n          \t\tz[22:0] <= 0;\n          \t\tz[30:23] <= 255;\n          \t\tz[31] <= z_sign;\n        \tend\n\tend\nend\n\n\nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 119, "original_snippet": "guard_bit <= product[25];", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 119: Original: guard_bit <= product[25];\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 119.\n   \u2022 Restore the original code: guard_bit <= product[25];\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 88, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.260484", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Other", "design_name": "float_multi", "module_name": "float_multi", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 32-bit floating-point multiplier for IEEE-754 standard single-precision arithmetic.\nThe float_multi module is designed to perform high-precision multiplication of 32-bit single-precision floating-point numbers, following the IEEE 754 standard. This module enables accurate arithmetic operations essential for various computational applications.\n\nModule name:\nfloat_multi\n\nInput ports:\n    clk (input): Clock signal for synchronization.\n    rst (input): Reset signal (active high).\n    a (input [31:0]): First operand in IEEE 754 format.\n    b (input [31:0]): Second operand in IEEE 754 format.\n\nOutput ports:\n    z (output reg [31:0]): Result of the multiplication in IEEE 754 format.\n\nInternal signals:\n    counter (reg [2:0]): Cycle counter for operation sequencing.\n    a_mantissa, b_mantissa, z_mantissa (reg [23:0]): Mantissas of input and output numbers.\n    a_exponent, b_exponent, z_exponent (reg [9:0]): Exponents of input and output numbers.\n    a_sign, b_sign, z_sign (reg): Sign bits for inputs and output.\n    product (reg [49:0]): Intermediate product of the mantissas.\n    guard_bit, round_bit, sticky (reg): Rounding control bits.\n\nImplementation:\n    -Initialization: The counter is reset to zero on the rst signal.\n    -Input Processing: The mantissas, exponents, and sign bits of inputs a and b are extracted during the first clock cycle.\n    -Special Cases Handling: The module identifies special cases like NaN (Not a Number) and infinity based on the inputs.\n    -Normalization: Mantissas are normalized if needed.\n    -Multiplication: The mantissas are multiplied, combining the signs and adjusting the exponents.\n    -Rounding and Adjustment: The module rounds the result and adjusts the exponent to ensure accurate representation.\n    -Output Generation: The final result is formatted in IEEE 754 standard, addressing overflow and underflow scenarios.\n\nGive me the complete code."}, "clean_code": "module float_multi(clk, rst, a, b, z);\n\ninput clk, rst;\ninput [31:0] a, b;\noutput reg [31:0] z;\n\nreg [2:0] counter;\n\nreg [23:0] a_mantissa, b_mantissa, z_mantissa; //Mantissa\nreg [9:0] a_exponent, b_exponent, z_exponent; //EXPONENTS\nreg a_sign, b_sign, z_sign; // Sign_Bit\n\nreg [49:0] product;\n\nreg guard_bit, round_bit, sticky;\n\nalways @(posedge clk or rst) begin\n\tif(rst)\n\t\tcounter <= 0;\n\telse\n\t\tcounter <= counter + 1;\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b001) begin \n\t//IEEE 754 Representation\n\t\ta_mantissa <= a[22:0];\n\t        b_mantissa <= b[22:0];\n\t        a_exponent <= a[30:23] - 127;\n        \tb_exponent <= b[30:23] - 127;\n\t        a_sign <= a[31];\n        \tb_sign <= b[31];\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b010) begin\n\t\tif ((a_exponent == 128 && a_mantissa != 0) || (b_exponent == 128 && b_mantissa != 0)) begin //Not a Number \n          \t\tz[31] <= 1;\n          \t\tz[30:23] <= 255;\n          \t\tz[22] <= 1;\n          \t\tz[21:0] <= 0;\n          \tend\n          \telse if (a_exponent == 128) begin //INF A\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //NAN IF B = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n          \telse if (b_exponent == 128) begin //INF B\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //NAN IF A = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n\t          else if (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //0 if A = 0\n       \t\t z[31] <= a_sign ^ b_sign; //Sign_Bit \n       \t\t z[30:23] <= 0; \n        \t \t z[22:0] <= 0;\n        \t  end\n        \t  else if (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //0 if B = 0\n        \t \t z[31] <= a_sign ^ b_sign;\n        \t  \t z[30:23] <= 0;\n        \t  \t z[22:0] <= 0;\n        \t  end\n        \t  else begin\n        \t  \tif ($signed(a_exponent) == -127) //DENORMALIZING A\n        \t    \t\ta_exponent <= -126;\n        \t  \telse\n        \t    \t\ta_mantissa[23] <= 1;\n            \t\t\n        \t    \tif ($signed(b_exponent) == -127) //DENORMALIZING B\n        \t    \t\tb_exponent <= -126;\n        \t  \telse\n        \t    \t\tb_mantissa[23] <= 1;\n        \t  end\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b011) begin\n\t\tif (~a_mantissa[23]) begin //NORMALIZE A\n\t        \ta_mantissa <= a_mantissa << 1;\n\t       \ta_exponent <= a_exponent - 1;\n\t        end\n\t        if (~b_mantissa[23]) begin //NORMALIZE B\n\t        \tb_mantissa <= b_mantissa << 1;\n\t       \tb_exponent <= b_exponent - 1;\n\t        end\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b100) begin //GET THE SIGNS XORED and EXPONENTS ADDED and GET THE INTERMEDIATE MANTISSA MULTIPLICATION\n\t\tz_sign <= a_sign ^ b_sign;\n\t        z_exponent <= a_exponent + b_exponent + 1 ;\n        \tproduct <= a_mantissa * b_mantissa * 4;\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b101) begin\n\t\tz_mantissa <= product[49:26];\n       \tguard_bit <= product[25];\n      \t\tround_bit <= product[24];\n      \t\tsticky <= (product[23:0] != 0);\n\tend\nend\n\nalways @(counter) begin\n\tif(counter == 3'b110) begin\n\t\tif ($signed(z_exponent) < -126) begin\n        \t\tz_exponent <= z_exponent + (-126 -$signed(z_exponent));\n    \t\t\tz_mantissa <= z_mantissa >> (-126 -$signed(z_exponent));\n     \t\t\tguard_bit <= z_mantissa[0];\n       \t\tround_bit <= guard_bit;\n       \t\tsticky <= sticky | round_bit;\n        \tend\n\t\telse if (z_mantissa[23] == 0) begin\n        \t\tz_exponent <= z_exponent - 1;\n        \t\tz_mantissa <= z_mantissa << 1;\n        \t\tz_mantissa[0] <= guard_bit;\n        \t\tguard_bit <= round_bit;\n        \t\tround_bit <= 0;\n        \tend\n\t        else if (guard_bit && (round_bit | sticky | z_mantissa[0])) begin\n        \t\tz_mantissa <= z_mantissa + 1;\n          \t\tif (z_mantissa == 24'hffffff)\n            \t\t\tz_exponent <=z_exponent + 1;\n        \tend\n        end\nend\n\nalways @(counter) begin\n\tif(counter == 3'b111) begin\n\t\tz[22:0] <= z_mantissa[22:0];\n        \tz[30:23] <= z_exponent[7:0] + 127;\n        \tz[31] <= z_sign;\n        \tif ($signed(z_exponent) == -126 && z_mantissa[23] == 0)\n          \t\tz[30:23] <= 0;\n        \tif ($signed(z_exponent) > 127) begin //IF OVERFLOW RETURN INF\n          \t\tz[22:0] <= 0;\n          \t\tz[30:23] <= 255;\n          \t\tz[31] <= z_sign;\n        \tend\n\tend\nend\n\n\nendmodule", "corrupted_code": "module float_multi(clk, rst, a, b, z);\n\ninput clk, rst;\ninput [31:0] a, b;\noutput reg [31:0] z;\n\nreg [2:0] counter;\n\nreg [23:0] a_mantissa, b_mantissa, z_mantissa; //Mantissa\nreg [9:0] a_exponent, b_exponent, z_exponent; //EXPONENTS\nreg a_sign, b_sign, z_sign; // Sign_Bit\n\nreg [49:0] product;\n\nreg guard_bit, round_bit, sticky;\n\nalways @(posedge clk or rst) begin\n\tif(rst)\n\t\tcounter <= 0;\n\telse\n\t\tcounter <= counter + 1;\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b001) begin \n\t//IEEE 754 Representation\n\t\ta_mantissa <= a[22:0];\n\t        b_mantissa <= b[22:0];\n\t        a_exponent = a[30:23] - 127;\n        \tb_exponent <= b[30:23] - 127;\n\t        a_sign <= a[31];\n        \tb_sign <= b[31];\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b010) begin\n\t\tif ((a_exponent == 128 && a_mantissa != 0) || (b_exponent == 128 && b_mantissa != 0)) begin //Not a Number \n          \t\tz[31] <= 1;\n          \t\tz[30:23] <= 255;\n          \t\tz[22] <= 1;\n          \t\tz[21:0] <= 0;\n          \tend\n          \telse if (a_exponent == 128) begin //INF A\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //NAN IF B = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n          \telse if (b_exponent == 128) begin //INF B\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //NAN IF A = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n\t          else if (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //0 if A = 0\n       \t\t z[31] <= a_sign ^ b_sign; //Sign_Bit \n       \t\t z[30:23] <= 0; \n        \t \t z[22:0] <= 0;\n        \t  end\n        \t  else if (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //0 if B = 0\n        \t \t z[31] <= a_sign ^ b_sign;\n        \t  \t z[30:23] <= 0;\n        \t  \t z[22:0] <= 0;\n        \t  end\n        \t  else begin\n        \t  \tif ($signed(a_exponent) == -127) //DENORMALIZING A\n        \t    \t\ta_exponent <= -126;\n        \t  \telse\n        \t    \t\ta_mantissa[23] <= 1;\n            \t\t\n        \t    \tif ($signed(b_exponent) == -127) //DENORMALIZING B\n        \t    \t\tb_exponent <= -126;\n        \t  \telse\n        \t    \t\tb_mantissa[23] <= 1;\n        \t  end\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b011) begin\n\t\tif (~a_mantissa[23]) begin //NORMALIZE A\n\t        \ta_mantissa <= a_mantissa << 1;\n\t       \ta_exponent <= a_exponent - 1;\n\t        end\n\t        if (~b_mantissa[23]) begin //NORMALIZE B\n\t        \tb_mantissa <= b_mantissa << 1;\n\t       \tb_exponent <= b_exponent - 1;\n\t        end\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b100) begin //GET THE SIGNS XORED and EXPONENTS ADDED and GET THE INTERMEDIATE MANTISSA MULTIPLICATION\n\t\tz_sign <= a_sign ^ b_sign;\n\t        z_exponent <= a_exponent + b_exponent + 1 ;\n        \tproduct <= a_mantissa * b_mantissa * 4;\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b101) begin\n\t\tz_mantissa <= product[49:26];\n       \tguard_bit <= product[25];\n      \t\tround_bit <= product[24];\n      \t\tsticky <= (product[23:0] != 0);\n\tend\nend\n\nalways @(counter) begin\n\tif(counter == 3'b110) begin\n\t\tif ($signed(z_exponent) < -126) begin\n        \t\tz_exponent <= z_exponent + (-126 -$signed(z_exponent));\n    \t\t\tz_mantissa <= z_mantissa >> (-126 -$signed(z_exponent));\n     \t\t\tguard_bit <= z_mantissa[0];\n       \t\tround_bit <= guard_bit;\n       \t\tsticky <= sticky | round_bit;\n        \tend\n\t\telse if (z_mantissa[23] == 0) begin\n        \t\tz_exponent <= z_exponent - 1;\n        \t\tz_mantissa <= z_mantissa << 1;\n        \t\tz_mantissa[0] <= guard_bit;\n        \t\tguard_bit <= round_bit;\n        \t\tround_bit <= 0;\n        \tend\n\t        else if (guard_bit && (round_bit | sticky | z_mantissa[0])) begin\n        \t\tz_mantissa <= z_mantissa + 1;\n          \t\tif (z_mantissa == 24'hffffff)\n            \t\t\tz_exponent <=z_exponent + 1;\n        \tend\n        end\nend\n\nalways @(counter) begin\n\tif(counter == 3'b111) begin\n\t\tz[22:0] <= z_mantissa[22:0];\n        \tz[30:23] <= z_exponent[7:0] + 127;\n        \tz[31] <= z_sign;\n        \tif ($signed(z_exponent) == -126 && z_mantissa[23] == 0)\n          \t\tz[30:23] <= 0;\n        \tif ($signed(z_exponent) > 127) begin //IF OVERFLOW RETURN INF\n          \t\tz[22:0] <= 0;\n          \t\tz[30:23] <= 255;\n          \t\tz[31] <= z_sign;\n        \tend\n\tend\nend\n\n\nendmodule", "corruption_explanation": "Changed non-blocking (<=) to blocking (=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 30, "original_snippet": "a_exponent <= a[30:23] - 127;", "modified_snippet": "a_exponent = a[30:23] - 127;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 88, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.267466", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Other", "design_name": "float_multi", "module_name": "float_multi", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 32-bit floating-point multiplier for IEEE-754 standard single-precision arithmetic.\nThe float_multi module is designed to perform high-precision multiplication of 32-bit single-precision floating-point numbers, following the IEEE 754 standard. This module enables accurate arithmetic operations essential for various computational applications.\n\nModule name:\nfloat_multi\n\nInput ports:\n    clk (input): Clock signal for synchronization.\n    rst (input): Reset signal (active high).\n    a (input [31:0]): First operand in IEEE 754 format.\n    b (input [31:0]): Second operand in IEEE 754 format.\n\nOutput ports:\n    z (output reg [31:0]): Result of the multiplication in IEEE 754 format.\n\nInternal signals:\n    counter (reg [2:0]): Cycle counter for operation sequencing.\n    a_mantissa, b_mantissa, z_mantissa (reg [23:0]): Mantissas of input and output numbers.\n    a_exponent, b_exponent, z_exponent (reg [9:0]): Exponents of input and output numbers.\n    a_sign, b_sign, z_sign (reg): Sign bits for inputs and output.\n    product (reg [49:0]): Intermediate product of the mantissas.\n    guard_bit, round_bit, sticky (reg): Rounding control bits.\n\nImplementation:\n    -Initialization: The counter is reset to zero on the rst signal.\n    -Input Processing: The mantissas, exponents, and sign bits of inputs a and b are extracted during the first clock cycle.\n    -Special Cases Handling: The module identifies special cases like NaN (Not a Number) and infinity based on the inputs.\n    -Normalization: Mantissas are normalized if needed.\n    -Multiplication: The mantissas are multiplied, combining the signs and adjusting the exponents.\n    -Rounding and Adjustment: The module rounds the result and adjusts the exponent to ensure accurate representation.\n    -Output Generation: The final result is formatted in IEEE 754 standard, addressing overflow and underflow scenarios.\n\nGive me the complete code."}, "clean_code": "module float_multi(clk, rst, a, b, z);\n\ninput clk, rst;\ninput [31:0] a, b;\noutput reg [31:0] z;\n\nreg [2:0] counter;\n\nreg [23:0] a_mantissa, b_mantissa, z_mantissa; //Mantissa\nreg [9:0] a_exponent, b_exponent, z_exponent; //EXPONENTS\nreg a_sign, b_sign, z_sign; // Sign_Bit\n\nreg [49:0] product;\n\nreg guard_bit, round_bit, sticky;\n\nalways @(posedge clk or rst) begin\n\tif(rst)\n\t\tcounter <= 0;\n\telse\n\t\tcounter <= counter + 1;\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b001) begin \n\t//IEEE 754 Representation\n\t\ta_mantissa <= a[22:0];\n\t        b_mantissa <= b[22:0];\n\t        a_exponent <= a[30:23] - 127;\n        \tb_exponent <= b[30:23] - 127;\n\t        a_sign <= a[31];\n        \tb_sign <= b[31];\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b010) begin\n\t\tif ((a_exponent == 128 && a_mantissa != 0) || (b_exponent == 128 && b_mantissa != 0)) begin //Not a Number \n          \t\tz[31] <= 1;\n          \t\tz[30:23] <= 255;\n          \t\tz[22] <= 1;\n          \t\tz[21:0] <= 0;\n          \tend\n          \telse if (a_exponent == 128) begin //INF A\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //NAN IF B = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n          \telse if (b_exponent == 128) begin //INF B\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //NAN IF A = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n\t          else if (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //0 if A = 0\n       \t\t z[31] <= a_sign ^ b_sign; //Sign_Bit \n       \t\t z[30:23] <= 0; \n        \t \t z[22:0] <= 0;\n        \t  end\n        \t  else if (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //0 if B = 0\n        \t \t z[31] <= a_sign ^ b_sign;\n        \t  \t z[30:23] <= 0;\n        \t  \t z[22:0] <= 0;\n        \t  end\n        \t  else begin\n        \t  \tif ($signed(a_exponent) == -127) //DENORMALIZING A\n        \t    \t\ta_exponent <= -126;\n        \t  \telse\n        \t    \t\ta_mantissa[23] <= 1;\n            \t\t\n        \t    \tif ($signed(b_exponent) == -127) //DENORMALIZING B\n        \t    \t\tb_exponent <= -126;\n        \t  \telse\n        \t    \t\tb_mantissa[23] <= 1;\n        \t  end\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b011) begin\n\t\tif (~a_mantissa[23]) begin //NORMALIZE A\n\t        \ta_mantissa <= a_mantissa << 1;\n\t       \ta_exponent <= a_exponent - 1;\n\t        end\n\t        if (~b_mantissa[23]) begin //NORMALIZE B\n\t        \tb_mantissa <= b_mantissa << 1;\n\t       \tb_exponent <= b_exponent - 1;\n\t        end\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b100) begin //GET THE SIGNS XORED and EXPONENTS ADDED and GET THE INTERMEDIATE MANTISSA MULTIPLICATION\n\t\tz_sign <= a_sign ^ b_sign;\n\t        z_exponent <= a_exponent + b_exponent + 1 ;\n        \tproduct <= a_mantissa * b_mantissa * 4;\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b101) begin\n\t\tz_mantissa <= product[49:26];\n       \tguard_bit <= product[25];\n      \t\tround_bit <= product[24];\n      \t\tsticky <= (product[23:0] != 0);\n\tend\nend\n\nalways @(counter) begin\n\tif(counter == 3'b110) begin\n\t\tif ($signed(z_exponent) < -126) begin\n        \t\tz_exponent <= z_exponent + (-126 -$signed(z_exponent));\n    \t\t\tz_mantissa <= z_mantissa >> (-126 -$signed(z_exponent));\n     \t\t\tguard_bit <= z_mantissa[0];\n       \t\tround_bit <= guard_bit;\n       \t\tsticky <= sticky | round_bit;\n        \tend\n\t\telse if (z_mantissa[23] == 0) begin\n        \t\tz_exponent <= z_exponent - 1;\n        \t\tz_mantissa <= z_mantissa << 1;\n        \t\tz_mantissa[0] <= guard_bit;\n        \t\tguard_bit <= round_bit;\n        \t\tround_bit <= 0;\n        \tend\n\t        else if (guard_bit && (round_bit | sticky | z_mantissa[0])) begin\n        \t\tz_mantissa <= z_mantissa + 1;\n          \t\tif (z_mantissa == 24'hffffff)\n            \t\t\tz_exponent <=z_exponent + 1;\n        \tend\n        end\nend\n\nalways @(counter) begin\n\tif(counter == 3'b111) begin\n\t\tz[22:0] <= z_mantissa[22:0];\n        \tz[30:23] <= z_exponent[7:0] + 127;\n        \tz[31] <= z_sign;\n        \tif ($signed(z_exponent) == -126 && z_mantissa[23] == 0)\n          \t\tz[30:23] <= 0;\n        \tif ($signed(z_exponent) > 127) begin //IF OVERFLOW RETURN INF\n          \t\tz[22:0] <= 0;\n          \t\tz[30:23] <= 255;\n          \t\tz[31] <= z_sign;\n        \tend\n\tend\nend\n\n\nendmodule", "corrupted_code": "module float_multi(clk, rst, a, b, z);\n\ninput clk, rst;\ninput [31:0] a, b;\noutput reg [31:0] z;\n\nreg [2:0] counter;\n\nreg [23:0] a_mantissa, b_mantissa, z_mantissa; //Mantissa\nreg [9:0] a_exponent, b_exponent, z_exponent; //EXPONENTS\nreg a_sign, b_sign, z_sign; // Sign_Bit\n\nreg [49:0] product;\n\nreg guard_bit, round_bit, sticky;\n\nalways @(posedge clk or rst) begin\n\tif(rst)\n\t\tcounter <= 0;\n\telse\n\t\tcounter <= counter + 1;\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b001) begin \n\t//IEEE 754 Representation\n\t\ta_mantissa <= a[22:0];\n\t        b_mantissa <= b[22:0];\n\t        a_exponent <= a[30:23] - 127;\n        \tb_exponent <= b[30:23] - 127;\n\t        a_sign <= a[31];\n        \tb_sign <= b[31];\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b010) begin\n\t\tif ((a_exponent == 128 && a_mantissa != 0) || (b_exponent == 128 && b_mantissa != 0)) begin //Not a Number \n          \t\tz[31] <= 1;\n          \t\tz[30:23] <= 255;\n          \t\tz[22] <= 1;\n          \t\tz[21:0] <= 0;\n          \tend\n          \telse if (a_exponent == 128) begin //INF A\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //NAN IF B = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n          \telse if (b_exponent == 128) begin //INF B\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //NAN IF A = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n\t          else if (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //0 if A = 0\n       \t\t z[31] <= a_sign ^ b_sign; //Sign_Bit \n       \t\t z[30:23] <= 0; \n        \t \t z[22:0] <= 0;\n        \t  end\n        \t  else if (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //0 if B = 0\n        \t \t z[31] <= a_sign ^ b_sign;\n        \t  \t z[30:23] <= 0;\n        \t  \t z[22:0] <= 0;\n        \t  end\n        \t  else begin\n        \t  \tif ($signed(a_exponent) == -127) //DENORMALIZING A\n        \t    \t\ta_exponent <= -126;\n        \t  \telse\n        \t    \t\ta_mantissa[23] <= 1;\n            \t\t\n        \t    \tif ($signed(b_exponent) == -127) //DENORMALIZING B\n        \t    \t\tb_exponent <= -126;\n        \t  \telse\n        \t    \t\tb_mantissa[23] <= 1;\n        \t  end\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b011) begin\n\t\tif (~a_mantissa[23]) begin //NORMALIZE A\n\t        \ta_mantissa <= a_mantissa << 1;\n\t       \ta_exponent <= a_exponent - 1;\n\t        end\n\t        if (~b_mantissa[23]) begin //NORMALIZE B\n\t        \tb_mantissa <= b_mantissa << 1;\n\t       \tb_exponent <= b_exponent - 1;\n\t        end\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b100) begin //GET THE SIGNS XORED and EXPONENTS ADDED and GET THE INTERMEDIATE MANTISSA MULTIPLICATION\n\t\tz_sign <= a_sign ^ b_sign;\n\t        z_exponent <= a_exponent + b_exponent + 1 ;\n        \tproduct <= a_mantissa * b_mantissa * 4;\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b101) begin\n\t\tz_mantissa <= product[49:26];\n       \tguard_bit <= product[25];\n      \t\tround_bit <= product[24];\n      \t\tsticky <= (product[23:0] != 0);\n\tend\nend\n\nalways @(counter) begin\n\tif(counter == 3'b110) begin\n\t\tif ($signed(z_exponent) < -126) begin\n        \t\tz_exponent <= z_exponent + (-126 -$signed(z_exponent));\n    \t\t\tz_mantissa <= z_mantissa >> (-126 -$signed(z_exponent));\n     \t\t\tz_mantissa <= guard_bit[0];\n       \t\tround_bit <= guard_bit;\n       \t\tsticky <= sticky | round_bit;\n        \tend\n\t\telse if (z_mantissa[23] == 0) begin\n        \t\tz_exponent <= z_exponent - 1;\n        \t\tz_mantissa <= z_mantissa << 1;\n        \t\tz_mantissa[0] <= guard_bit;\n        \t\tguard_bit <= round_bit;\n        \t\tround_bit <= 0;\n        \tend\n\t        else if (guard_bit && (round_bit | sticky | z_mantissa[0])) begin\n        \t\tz_mantissa <= z_mantissa + 1;\n          \t\tif (z_mantissa == 24'hffffff)\n            \t\t\tz_exponent <=z_exponent + 1;\n        \tend\n        end\nend\n\nalways @(counter) begin\n\tif(counter == 3'b111) begin\n\t\tz[22:0] <= z_mantissa[22:0];\n        \tz[30:23] <= z_exponent[7:0] + 127;\n        \tz[31] <= z_sign;\n        \tif ($signed(z_exponent) == -126 && z_mantissa[23] == 0)\n          \t\tz[30:23] <= 0;\n        \tif ($signed(z_exponent) > 127) begin //IF OVERFLOW RETURN INF\n          \t\tz[22:0] <= 0;\n          \t\tz[30:23] <= 255;\n          \t\tz[31] <= z_sign;\n        \tend\n\tend\nend\n\n\nendmodule", "corruption_explanation": "Swapped operands: 'guard_bit <= z_mantissa' -> 'z_mantissa <= guard_bit'", "modification_type": "swap_operands", "modification_line": 130, "original_snippet": "guard_bit <= z_mantissa", "modified_snippet": "z_mantissa <= guard_bit", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'guard_bit <= z_mantissa' -> 'z_mantissa <= guard_bit'\n   \u2022 Line 130: Original: guard_bit <= z_mantissa\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 130.\n   \u2022 Restore the original code: guard_bit <= z_mantissa\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 88, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_operands"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.273930", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Other", "design_name": "float_multi", "module_name": "float_multi", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 32-bit floating-point multiplier for IEEE-754 standard single-precision arithmetic.\nThe float_multi module is designed to perform high-precision multiplication of 32-bit single-precision floating-point numbers, following the IEEE 754 standard. This module enables accurate arithmetic operations essential for various computational applications.\n\nModule name:\nfloat_multi\n\nInput ports:\n    clk (input): Clock signal for synchronization.\n    rst (input): Reset signal (active high).\n    a (input [31:0]): First operand in IEEE 754 format.\n    b (input [31:0]): Second operand in IEEE 754 format.\n\nOutput ports:\n    z (output reg [31:0]): Result of the multiplication in IEEE 754 format.\n\nInternal signals:\n    counter (reg [2:0]): Cycle counter for operation sequencing.\n    a_mantissa, b_mantissa, z_mantissa (reg [23:0]): Mantissas of input and output numbers.\n    a_exponent, b_exponent, z_exponent (reg [9:0]): Exponents of input and output numbers.\n    a_sign, b_sign, z_sign (reg): Sign bits for inputs and output.\n    product (reg [49:0]): Intermediate product of the mantissas.\n    guard_bit, round_bit, sticky (reg): Rounding control bits.\n\nImplementation:\n    -Initialization: The counter is reset to zero on the rst signal.\n    -Input Processing: The mantissas, exponents, and sign bits of inputs a and b are extracted during the first clock cycle.\n    -Special Cases Handling: The module identifies special cases like NaN (Not a Number) and infinity based on the inputs.\n    -Normalization: Mantissas are normalized if needed.\n    -Multiplication: The mantissas are multiplied, combining the signs and adjusting the exponents.\n    -Rounding and Adjustment: The module rounds the result and adjusts the exponent to ensure accurate representation.\n    -Output Generation: The final result is formatted in IEEE 754 standard, addressing overflow and underflow scenarios.\n\nGive me the complete code."}, "clean_code": "module float_multi(clk, rst, a, b, z);\n\ninput clk, rst;\ninput [31:0] a, b;\noutput reg [31:0] z;\n\nreg [2:0] counter;\n\nreg [23:0] a_mantissa, b_mantissa, z_mantissa; //Mantissa\nreg [9:0] a_exponent, b_exponent, z_exponent; //EXPONENTS\nreg a_sign, b_sign, z_sign; // Sign_Bit\n\nreg [49:0] product;\n\nreg guard_bit, round_bit, sticky;\n\nalways @(posedge clk or rst) begin\n\tif(rst)\n\t\tcounter <= 0;\n\telse\n\t\tcounter <= counter + 1;\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b001) begin \n\t//IEEE 754 Representation\n\t\ta_mantissa <= a[22:0];\n\t        b_mantissa <= b[22:0];\n\t        a_exponent <= a[30:23] - 127;\n        \tb_exponent <= b[30:23] - 127;\n\t        a_sign <= a[31];\n        \tb_sign <= b[31];\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b010) begin\n\t\tif ((a_exponent == 128 && a_mantissa != 0) || (b_exponent == 128 && b_mantissa != 0)) begin //Not a Number \n          \t\tz[31] <= 1;\n          \t\tz[30:23] <= 255;\n          \t\tz[22] <= 1;\n          \t\tz[21:0] <= 0;\n          \tend\n          \telse if (a_exponent == 128) begin //INF A\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //NAN IF B = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n          \telse if (b_exponent == 128) begin //INF B\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //NAN IF A = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n\t          else if (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //0 if A = 0\n       \t\t z[31] <= a_sign ^ b_sign; //Sign_Bit \n       \t\t z[30:23] <= 0; \n        \t \t z[22:0] <= 0;\n        \t  end\n        \t  else if (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //0 if B = 0\n        \t \t z[31] <= a_sign ^ b_sign;\n        \t  \t z[30:23] <= 0;\n        \t  \t z[22:0] <= 0;\n        \t  end\n        \t  else begin\n        \t  \tif ($signed(a_exponent) == -127) //DENORMALIZING A\n        \t    \t\ta_exponent <= -126;\n        \t  \telse\n        \t    \t\ta_mantissa[23] <= 1;\n            \t\t\n        \t    \tif ($signed(b_exponent) == -127) //DENORMALIZING B\n        \t    \t\tb_exponent <= -126;\n        \t  \telse\n        \t    \t\tb_mantissa[23] <= 1;\n        \t  end\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b011) begin\n\t\tif (~a_mantissa[23]) begin //NORMALIZE A\n\t        \ta_mantissa <= a_mantissa << 1;\n\t       \ta_exponent <= a_exponent - 1;\n\t        end\n\t        if (~b_mantissa[23]) begin //NORMALIZE B\n\t        \tb_mantissa <= b_mantissa << 1;\n\t       \tb_exponent <= b_exponent - 1;\n\t        end\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b100) begin //GET THE SIGNS XORED and EXPONENTS ADDED and GET THE INTERMEDIATE MANTISSA MULTIPLICATION\n\t\tz_sign <= a_sign ^ b_sign;\n\t        z_exponent <= a_exponent + b_exponent + 1 ;\n        \tproduct <= a_mantissa * b_mantissa * 4;\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b101) begin\n\t\tz_mantissa <= product[49:26];\n       \tguard_bit <= product[25];\n      \t\tround_bit <= product[24];\n      \t\tsticky <= (product[23:0] != 0);\n\tend\nend\n\nalways @(counter) begin\n\tif(counter == 3'b110) begin\n\t\tif ($signed(z_exponent) < -126) begin\n        \t\tz_exponent <= z_exponent + (-126 -$signed(z_exponent));\n    \t\t\tz_mantissa <= z_mantissa >> (-126 -$signed(z_exponent));\n     \t\t\tguard_bit <= z_mantissa[0];\n       \t\tround_bit <= guard_bit;\n       \t\tsticky <= sticky | round_bit;\n        \tend\n\t\telse if (z_mantissa[23] == 0) begin\n        \t\tz_exponent <= z_exponent - 1;\n        \t\tz_mantissa <= z_mantissa << 1;\n        \t\tz_mantissa[0] <= guard_bit;\n        \t\tguard_bit <= round_bit;\n        \t\tround_bit <= 0;\n        \tend\n\t        else if (guard_bit && (round_bit | sticky | z_mantissa[0])) begin\n        \t\tz_mantissa <= z_mantissa + 1;\n          \t\tif (z_mantissa == 24'hffffff)\n            \t\t\tz_exponent <=z_exponent + 1;\n        \tend\n        end\nend\n\nalways @(counter) begin\n\tif(counter == 3'b111) begin\n\t\tz[22:0] <= z_mantissa[22:0];\n        \tz[30:23] <= z_exponent[7:0] + 127;\n        \tz[31] <= z_sign;\n        \tif ($signed(z_exponent) == -126 && z_mantissa[23] == 0)\n          \t\tz[30:23] <= 0;\n        \tif ($signed(z_exponent) > 127) begin //IF OVERFLOW RETURN INF\n          \t\tz[22:0] <= 0;\n          \t\tz[30:23] <= 255;\n          \t\tz[31] <= z_sign;\n        \tend\n\tend\nend\n\n\nendmodule", "corrupted_code": "module float_multi(clk, rst, a, b, z);\n\ninput clk, rst;\ninput [31:0] a, b;\noutput reg [31:0] z;\n\nreg [2:0] counter;\n\nreg [23:0] a_mantissa, b_mantissa, z_mantissa; //Mantissa\nreg [9:0] a_exponent, b_exponent, z_exponent; //EXPONENTS\nreg a_sign, b_sign, z_sign; // Sign_Bit\n\nreg [49:0] product;\n\nreg guard_bit, round_bit, sticky;\n\nalways @(posedge clk or rst) begin\n\tif(rst)\n\t\tcounter <= 0;\n\telse\n\t\tcounter <= counter + 1;\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b001) begin \n\t//IEEE 754 Representation\n\t\ta_mantissa <= a[22:0];\n\t        b_mantissa <= b[22:0];\n\t        a_exponent <= a[30:23] - 127;\n        \tb_exponent <= b[30:23] - 127;\n\t        a_sign <= a[31];\n        \tb_sign <= b[31];\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b010) begin\n\t\tif ((a_exponent == 128 && a_mantissa != 0) || (b_exponent == 128 && b_mantissa != 0)) begin //Not a Number \n          \t\tz[31] <= 1;\n          \t\tz[30:23] <= 255;\n          \t\tz[22] <= 1;\n          \t\tz[21:0] <= 0;\n          \tend\n          \telse if (a_exponent == 128) begin //INF A\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //NAN IF B = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n          \telse if (b_exponent == 128) begin //INF B\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //NAN IF A = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n\t          else if (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //0 if A = 0\n       \t\t z[31] <= a_sign ^ b_sign; //Sign_Bit \n       \t\t z[30:23] <= 0; \n        \t \t z[22:0] <= 0;\n        \t  end\n        \t  else if (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //0 if B = 0\n        \t \t z[31] <= a_sign ^ b_sign;\n        \t  \t z[30:23] <= 0;\n        \t  \t z[22:0] <= 0;\n        \t  end\n        \t  else begin\n        \t  \tif ($signed(a_exponent) == -127) //DENORMALIZING A\n        \t    \t\ta_exponent <= -126;\n        \t  \telse\n        \t    \t\ta_mantissa[23] <= 1;\n            \t\t\n        \t    \tif ($signed(b_exponent) == -127) //DENORMALIZING B\n        \t    \t\tb_exponent <= -126;\n        \t  \telse\n        \t    \t\tb_mantissa[23] <= 1;\n        \t  end\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b011) begin\n\t\tif (~a_mantissa[23]) begin //NORMALIZE A\n\t        \ta_mantissa <= a_mantissa << 1;\n\t       \ta_exponent <= a_exponent - 1;\n\t        end\n\t        if (~b_mantissa[23]) begin //NORMALIZE B\n\t        \tb_mantissa <= b_mantissa << 1;\n\t       \tb_exponent <= b_exponent - 1;\n\t        end\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b100) begin //GET THE SIGNS XORED and EXPONENTS ADDED and GET THE INTERMEDIATE MANTISSA MULTIPLICATION\n\t\tz_sign <= a_sign ^ b_sign;\n\t        z_exponent <= a_exponent + b_exponent + 1 ;\n        \tproduct <= a_mantissa * b_mantissa * 4;\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b101) begin\n\t\tz_mantissa <= product[49:26];\n       \tguard_bit <= product[25];\n      \t\tround_bit <= product[24];\n      \t\tsticky <= (product[23:0] != 0);\n\tend\nend\n\nalways @(counter) begin\n\tif(counter == 3'b110) begin\n\t\tif ($signed(z_exponent) < -126) begin\n        \t\tz_exponent <= z_exponent + (-126 -$signed(z_exponent));\n    \t\t\tz_mantissa <= z_mantissa >> (-126 -$signed(z_exponent));\n     \t\t\tguard_bit <= z_mantissa[0];\n       \t\tround_bit <= guard_bit;\n       \t\tsticky <= sticky | round_bit;\n        \tend\n\t\telse if (z_mantissa[23] == 0) begin\n        \t\tz_exponent <= z_exponent - 1;\n        \t\tz_mantissa <= z_mantissa << 1;\n        \t\tz_mantissa[0] <= guard_bit;\n        \t\tguard_bit <= round_bit;\n        \t\tround_bit <= 0;\n        \tend\n\t        else if (guard_bit && (round_bit | sticky | z_mantissa[0])) begin\n        \t\tz_mantissa <= z_mantissa + 1;\n          \t\tif (z_mantissa == 24'hffffff)\n\n        \tend\n        end\nend\n\nalways @(counter) begin\n\tif(counter == 3'b111) begin\n\t\tz[22:0] <= z_mantissa[22:0];\n        \tz[30:23] <= z_exponent[7:0] + 127;\n        \tz[31] <= z_sign;\n        \tif ($signed(z_exponent) == -126 && z_mantissa[23] == 0)\n          \t\tz[30:23] <= 0;\n        \tif ($signed(z_exponent) > 127) begin //IF OVERFLOW RETURN INF\n          \t\tz[22:0] <= 0;\n          \t\tz[30:23] <= 255;\n          \t\tz[31] <= z_sign;\n        \tend\n\tend\nend\n\n\nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 144, "original_snippet": "z_exponent <=z_exponent + 1;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 144: Original: z_exponent <=z_exponent + 1;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 144.\n   \u2022 Restore the original code: z_exponent <=z_exponent + 1;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 88, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.285534", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Other", "design_name": "float_multi", "module_name": "float_multi", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 32-bit floating-point multiplier for IEEE-754 standard single-precision arithmetic.\nThe float_multi module is designed to perform high-precision multiplication of 32-bit single-precision floating-point numbers, following the IEEE 754 standard. This module enables accurate arithmetic operations essential for various computational applications.\n\nModule name:\nfloat_multi\n\nInput ports:\n    clk (input): Clock signal for synchronization.\n    rst (input): Reset signal (active high).\n    a (input [31:0]): First operand in IEEE 754 format.\n    b (input [31:0]): Second operand in IEEE 754 format.\n\nOutput ports:\n    z (output reg [31:0]): Result of the multiplication in IEEE 754 format.\n\nInternal signals:\n    counter (reg [2:0]): Cycle counter for operation sequencing.\n    a_mantissa, b_mantissa, z_mantissa (reg [23:0]): Mantissas of input and output numbers.\n    a_exponent, b_exponent, z_exponent (reg [9:0]): Exponents of input and output numbers.\n    a_sign, b_sign, z_sign (reg): Sign bits for inputs and output.\n    product (reg [49:0]): Intermediate product of the mantissas.\n    guard_bit, round_bit, sticky (reg): Rounding control bits.\n\nImplementation:\n    -Initialization: The counter is reset to zero on the rst signal.\n    -Input Processing: The mantissas, exponents, and sign bits of inputs a and b are extracted during the first clock cycle.\n    -Special Cases Handling: The module identifies special cases like NaN (Not a Number) and infinity based on the inputs.\n    -Normalization: Mantissas are normalized if needed.\n    -Multiplication: The mantissas are multiplied, combining the signs and adjusting the exponents.\n    -Rounding and Adjustment: The module rounds the result and adjusts the exponent to ensure accurate representation.\n    -Output Generation: The final result is formatted in IEEE 754 standard, addressing overflow and underflow scenarios.\n\nGive me the complete code."}, "clean_code": "module float_multi(clk, rst, a, b, z);\n\ninput clk, rst;\ninput [31:0] a, b;\noutput reg [31:0] z;\n\nreg [2:0] counter;\n\nreg [23:0] a_mantissa, b_mantissa, z_mantissa; //Mantissa\nreg [9:0] a_exponent, b_exponent, z_exponent; //EXPONENTS\nreg a_sign, b_sign, z_sign; // Sign_Bit\n\nreg [49:0] product;\n\nreg guard_bit, round_bit, sticky;\n\nalways @(posedge clk or rst) begin\n\tif(rst)\n\t\tcounter <= 0;\n\telse\n\t\tcounter <= counter + 1;\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b001) begin \n\t//IEEE 754 Representation\n\t\ta_mantissa <= a[22:0];\n\t        b_mantissa <= b[22:0];\n\t        a_exponent <= a[30:23] - 127;\n        \tb_exponent <= b[30:23] - 127;\n\t        a_sign <= a[31];\n        \tb_sign <= b[31];\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b010) begin\n\t\tif ((a_exponent == 128 && a_mantissa != 0) || (b_exponent == 128 && b_mantissa != 0)) begin //Not a Number \n          \t\tz[31] <= 1;\n          \t\tz[30:23] <= 255;\n          \t\tz[22] <= 1;\n          \t\tz[21:0] <= 0;\n          \tend\n          \telse if (a_exponent == 128) begin //INF A\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //NAN IF B = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n          \telse if (b_exponent == 128) begin //INF B\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //NAN IF A = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n\t          else if (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //0 if A = 0\n       \t\t z[31] <= a_sign ^ b_sign; //Sign_Bit \n       \t\t z[30:23] <= 0; \n        \t \t z[22:0] <= 0;\n        \t  end\n        \t  else if (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //0 if B = 0\n        \t \t z[31] <= a_sign ^ b_sign;\n        \t  \t z[30:23] <= 0;\n        \t  \t z[22:0] <= 0;\n        \t  end\n        \t  else begin\n        \t  \tif ($signed(a_exponent) == -127) //DENORMALIZING A\n        \t    \t\ta_exponent <= -126;\n        \t  \telse\n        \t    \t\ta_mantissa[23] <= 1;\n            \t\t\n        \t    \tif ($signed(b_exponent) == -127) //DENORMALIZING B\n        \t    \t\tb_exponent <= -126;\n        \t  \telse\n        \t    \t\tb_mantissa[23] <= 1;\n        \t  end\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b011) begin\n\t\tif (~a_mantissa[23]) begin //NORMALIZE A\n\t        \ta_mantissa <= a_mantissa << 1;\n\t       \ta_exponent <= a_exponent - 1;\n\t        end\n\t        if (~b_mantissa[23]) begin //NORMALIZE B\n\t        \tb_mantissa <= b_mantissa << 1;\n\t       \tb_exponent <= b_exponent - 1;\n\t        end\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b100) begin //GET THE SIGNS XORED and EXPONENTS ADDED and GET THE INTERMEDIATE MANTISSA MULTIPLICATION\n\t\tz_sign <= a_sign ^ b_sign;\n\t        z_exponent <= a_exponent + b_exponent + 1 ;\n        \tproduct <= a_mantissa * b_mantissa * 4;\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b101) begin\n\t\tz_mantissa <= product[49:26];\n       \tguard_bit <= product[25];\n      \t\tround_bit <= product[24];\n      \t\tsticky <= (product[23:0] != 0);\n\tend\nend\n\nalways @(counter) begin\n\tif(counter == 3'b110) begin\n\t\tif ($signed(z_exponent) < -126) begin\n        \t\tz_exponent <= z_exponent + (-126 -$signed(z_exponent));\n    \t\t\tz_mantissa <= z_mantissa >> (-126 -$signed(z_exponent));\n     \t\t\tguard_bit <= z_mantissa[0];\n       \t\tround_bit <= guard_bit;\n       \t\tsticky <= sticky | round_bit;\n        \tend\n\t\telse if (z_mantissa[23] == 0) begin\n        \t\tz_exponent <= z_exponent - 1;\n        \t\tz_mantissa <= z_mantissa << 1;\n        \t\tz_mantissa[0] <= guard_bit;\n        \t\tguard_bit <= round_bit;\n        \t\tround_bit <= 0;\n        \tend\n\t        else if (guard_bit && (round_bit | sticky | z_mantissa[0])) begin\n        \t\tz_mantissa <= z_mantissa + 1;\n          \t\tif (z_mantissa == 24'hffffff)\n            \t\t\tz_exponent <=z_exponent + 1;\n        \tend\n        end\nend\n\nalways @(counter) begin\n\tif(counter == 3'b111) begin\n\t\tz[22:0] <= z_mantissa[22:0];\n        \tz[30:23] <= z_exponent[7:0] + 127;\n        \tz[31] <= z_sign;\n        \tif ($signed(z_exponent) == -126 && z_mantissa[23] == 0)\n          \t\tz[30:23] <= 0;\n        \tif ($signed(z_exponent) > 127) begin //IF OVERFLOW RETURN INF\n          \t\tz[22:0] <= 0;\n          \t\tz[30:23] <= 255;\n          \t\tz[31] <= z_sign;\n        \tend\n\tend\nend\n\n\nendmodule", "corrupted_code": "module float_multi(clk, rst, a, b, z);\n\ninput clk, rst;\ninput [31:0] a, b;\noutput reg [31:0] z;\n\nreg [2:0] counter;\n\nreg [23:0] a_mantissa, b_mantissa, z_mantissa; //Mantissa\nreg [9:0] a_exponent, b_exponent, z_exponent; //EXPONENTS\nreg a_sign, b_sign, z_sign; // Sign_Bit\n\nreg [49:0] product;\n\nreg guard_bit, round_bit, sticky;\n\nalways @(posedge clk or rst) begin\n\tif(rst)\n\t\tcounter <= 0;\n\telse\n\t\tcounter <= counter + 1;\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b001) begin \n\t//IEEE 754 Representation\n\t\ta_mantissa <= a[22:0];\n\t        b_mantissa <= b[22:0];\n\t        a_exponent <= a[30:23] - 127;\n        \tb_exponent <= b[30:23] - 127;\n\t        a_sign <= a[31];\n        \tb_sign <= b[31];\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b010) begin\n\t\tif ((a_exponent == 128 && a_mantissa != 0) || (b_exponent == 128 && b_mantissa != 0)) begin //Not a Number \n          \t\tz[31] <= 1;\n          \t\tz[30:23] <= 255;\n          \t\tz[22] <= 1;\n          \t\tz[21:0] <= 0;\n          \tend\n          \telse if (a_exponent == 128) begin //INF A\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //NAN IF B = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n          \telse if (b_exponent == 128) begin //INF B\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //NAN IF A = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n\t          else if (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //0 if A = 0\n       \t\t z[31] <= a_sign ^ b_sign; //Sign_Bit \n       \t\t z[30:23] <= 0; \n        \t \t z[22:0] <= 0;\n        \t  end\n        \t  else if (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //0 if B = 0\n        \t \t z[31] <= a_sign ^ b_sign;\n        \t  \t z[30:23] <= 0;\n        \t  \t z[22:0] <= 0;\n        \t  end\n        \t  else begin\n        \t  \tif ($signed(a_exponent) == -127) //DENORMALIZING A\n        \t    \t\ta_exponent <= -126;\n        \t  \telse\n        \t    \t\ta_mantissa[23] <= 1;\n            \t\t\n        \t    \tif ($signed(b_exponent) == -127) //DENORMALIZING B\n        \t    \t\tb_exponent <= -126;\n        \t  \telse\n        \t    \t\tb_mantissa[23] <= 1;\n        \t  end\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b011) begin\n\t\tif (~a_mantissa[23]) begin //NORMALIZE A\n\t        \ta_mantissa <= a_mantissa << 1;\n\t       \ta_exponent <= a_exponent - 1;\n\t        end\n\t        if (~b_mantissa[23]) begin //NORMALIZE B\n\t        \tb_mantissa <= b_mantissa << 1;\n\t       \tb_exponent <= b_exponent - 1;\n\t        end\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b100) begin //GET THE SIGNS XORED and EXPONENTS ADDED and GET THE INTERMEDIATE MANTISSA MULTIPLICATION\n\t\tz_sign <= a_sign ^ b_sign;\n\t        z_exponent <= a_exponent + b_exponent + 1 ;\n        \tproduct <= a_mantissa * b_mantissa * 4;\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b101) begin\n\t\tz_mantissa <= product[49:26];\n       \tguard_bit <= product[25];\n      \t\tround_bit <= product[24];\n      \t\tsticky <= (product[23:0] != 0);\n\tend\nend\n\n\n\t\telse if (z_mantissa[23] == 0) begin\n        \t\tz_exponent <= z_exponent - 1;\n        \t\tz_mantissa <= z_mantissa << 1;\n        \t\tz_mantissa[0] <= guard_bit;\n        \t\tguard_bit <= round_bit;\n        \t\tround_bit <= 0;\n        \tend\n\t        else if (guard_bit && (round_bit | sticky | z_mantissa[0])) begin\n        \t\tz_mantissa <= z_mantissa + 1;\n          \t\tif (z_mantissa == 24'hffffff)\n            \t\t\tz_exponent <=z_exponent + 1;\n        \tend\n        end\nend\n\nalways @(counter) begin\n\tif(counter == 3'b111) begin\n\t\tz[22:0] <= z_mantissa[22:0];\n        \tz[30:23] <= z_exponent[7:0] + 127;\n        \tz[31] <= z_sign;\n        \tif ($signed(z_exponent) == -126 && z_mantissa[23] == 0)\n          \t\tz[30:23] <= 0;\n        \tif ($signed(z_exponent) > 127) begin //IF OVERFLOW RETURN INF\n          \t\tz[22:0] <= 0;\n          \t\tz[30:23] <= 255;\n          \t\tz[31] <= z_sign;\n        \tend\n\tend\nend\n\n\nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 125, "original_snippet": "always @(counter) begin\n\tif(counter == 3'b110) begin\n\t\tif ($signed(z_exponent) < -126) begin\n        \t\tz_exponent <= z_exponent + (-126 -$signed(z_exponent));\n    \t\t\tz_mantissa <= z_mantissa >> (-126 ", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 125: Original: always @(counter) begin\n\tif(counter == 3'b110) begin\n\t\tif ($signed(z_exponent) < -126) begin\n        \t\tz_exponent <= z_exponent + (-126 -$signed(z_exponent));\n    \t\t\tz_mantissa <= z_mantissa >> (-126 \n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 125.\n   \u2022 Restore the original code: always @(counter) begin\n\tif(counter == 3'b110) begin\n\t\tif ($signed(z_exponent) < -126) begin\n        \t\tz_exponent <= z_exponent + (-126 -$signed(z_exponent));\n    \t\t\tz_mantissa <= z_mantissa >> (-126 \n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 88, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.291730", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Other", "design_name": "float_multi", "module_name": "float_multi", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 32-bit floating-point multiplier for IEEE-754 standard single-precision arithmetic.\nThe float_multi module is designed to perform high-precision multiplication of 32-bit single-precision floating-point numbers, following the IEEE 754 standard. This module enables accurate arithmetic operations essential for various computational applications.\n\nModule name:\nfloat_multi\n\nInput ports:\n    clk (input): Clock signal for synchronization.\n    rst (input): Reset signal (active high).\n    a (input [31:0]): First operand in IEEE 754 format.\n    b (input [31:0]): Second operand in IEEE 754 format.\n\nOutput ports:\n    z (output reg [31:0]): Result of the multiplication in IEEE 754 format.\n\nInternal signals:\n    counter (reg [2:0]): Cycle counter for operation sequencing.\n    a_mantissa, b_mantissa, z_mantissa (reg [23:0]): Mantissas of input and output numbers.\n    a_exponent, b_exponent, z_exponent (reg [9:0]): Exponents of input and output numbers.\n    a_sign, b_sign, z_sign (reg): Sign bits for inputs and output.\n    product (reg [49:0]): Intermediate product of the mantissas.\n    guard_bit, round_bit, sticky (reg): Rounding control bits.\n\nImplementation:\n    -Initialization: The counter is reset to zero on the rst signal.\n    -Input Processing: The mantissas, exponents, and sign bits of inputs a and b are extracted during the first clock cycle.\n    -Special Cases Handling: The module identifies special cases like NaN (Not a Number) and infinity based on the inputs.\n    -Normalization: Mantissas are normalized if needed.\n    -Multiplication: The mantissas are multiplied, combining the signs and adjusting the exponents.\n    -Rounding and Adjustment: The module rounds the result and adjusts the exponent to ensure accurate representation.\n    -Output Generation: The final result is formatted in IEEE 754 standard, addressing overflow and underflow scenarios.\n\nGive me the complete code."}, "clean_code": "module float_multi(clk, rst, a, b, z);\n\ninput clk, rst;\ninput [31:0] a, b;\noutput reg [31:0] z;\n\nreg [2:0] counter;\n\nreg [23:0] a_mantissa, b_mantissa, z_mantissa; //Mantissa\nreg [9:0] a_exponent, b_exponent, z_exponent; //EXPONENTS\nreg a_sign, b_sign, z_sign; // Sign_Bit\n\nreg [49:0] product;\n\nreg guard_bit, round_bit, sticky;\n\nalways @(posedge clk or rst) begin\n\tif(rst)\n\t\tcounter <= 0;\n\telse\n\t\tcounter <= counter + 1;\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b001) begin \n\t//IEEE 754 Representation\n\t\ta_mantissa <= a[22:0];\n\t        b_mantissa <= b[22:0];\n\t        a_exponent <= a[30:23] - 127;\n        \tb_exponent <= b[30:23] - 127;\n\t        a_sign <= a[31];\n        \tb_sign <= b[31];\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b010) begin\n\t\tif ((a_exponent == 128 && a_mantissa != 0) || (b_exponent == 128 && b_mantissa != 0)) begin //Not a Number \n          \t\tz[31] <= 1;\n          \t\tz[30:23] <= 255;\n          \t\tz[22] <= 1;\n          \t\tz[21:0] <= 0;\n          \tend\n          \telse if (a_exponent == 128) begin //INF A\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //NAN IF B = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n          \telse if (b_exponent == 128) begin //INF B\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //NAN IF A = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n\t          else if (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //0 if A = 0\n       \t\t z[31] <= a_sign ^ b_sign; //Sign_Bit \n       \t\t z[30:23] <= 0; \n        \t \t z[22:0] <= 0;\n        \t  end\n        \t  else if (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //0 if B = 0\n        \t \t z[31] <= a_sign ^ b_sign;\n        \t  \t z[30:23] <= 0;\n        \t  \t z[22:0] <= 0;\n        \t  end\n        \t  else begin\n        \t  \tif ($signed(a_exponent) == -127) //DENORMALIZING A\n        \t    \t\ta_exponent <= -126;\n        \t  \telse\n        \t    \t\ta_mantissa[23] <= 1;\n            \t\t\n        \t    \tif ($signed(b_exponent) == -127) //DENORMALIZING B\n        \t    \t\tb_exponent <= -126;\n        \t  \telse\n        \t    \t\tb_mantissa[23] <= 1;\n        \t  end\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b011) begin\n\t\tif (~a_mantissa[23]) begin //NORMALIZE A\n\t        \ta_mantissa <= a_mantissa << 1;\n\t       \ta_exponent <= a_exponent - 1;\n\t        end\n\t        if (~b_mantissa[23]) begin //NORMALIZE B\n\t        \tb_mantissa <= b_mantissa << 1;\n\t       \tb_exponent <= b_exponent - 1;\n\t        end\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b100) begin //GET THE SIGNS XORED and EXPONENTS ADDED and GET THE INTERMEDIATE MANTISSA MULTIPLICATION\n\t\tz_sign <= a_sign ^ b_sign;\n\t        z_exponent <= a_exponent + b_exponent + 1 ;\n        \tproduct <= a_mantissa * b_mantissa * 4;\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b101) begin\n\t\tz_mantissa <= product[49:26];\n       \tguard_bit <= product[25];\n      \t\tround_bit <= product[24];\n      \t\tsticky <= (product[23:0] != 0);\n\tend\nend\n\nalways @(counter) begin\n\tif(counter == 3'b110) begin\n\t\tif ($signed(z_exponent) < -126) begin\n        \t\tz_exponent <= z_exponent + (-126 -$signed(z_exponent));\n    \t\t\tz_mantissa <= z_mantissa >> (-126 -$signed(z_exponent));\n     \t\t\tguard_bit <= z_mantissa[0];\n       \t\tround_bit <= guard_bit;\n       \t\tsticky <= sticky | round_bit;\n        \tend\n\t\telse if (z_mantissa[23] == 0) begin\n        \t\tz_exponent <= z_exponent - 1;\n        \t\tz_mantissa <= z_mantissa << 1;\n        \t\tz_mantissa[0] <= guard_bit;\n        \t\tguard_bit <= round_bit;\n        \t\tround_bit <= 0;\n        \tend\n\t        else if (guard_bit && (round_bit | sticky | z_mantissa[0])) begin\n        \t\tz_mantissa <= z_mantissa + 1;\n          \t\tif (z_mantissa == 24'hffffff)\n            \t\t\tz_exponent <=z_exponent + 1;\n        \tend\n        end\nend\n\nalways @(counter) begin\n\tif(counter == 3'b111) begin\n\t\tz[22:0] <= z_mantissa[22:0];\n        \tz[30:23] <= z_exponent[7:0] + 127;\n        \tz[31] <= z_sign;\n        \tif ($signed(z_exponent) == -126 && z_mantissa[23] == 0)\n          \t\tz[30:23] <= 0;\n        \tif ($signed(z_exponent) > 127) begin //IF OVERFLOW RETURN INF\n          \t\tz[22:0] <= 0;\n          \t\tz[30:23] <= 255;\n          \t\tz[31] <= z_sign;\n        \tend\n\tend\nend\n\n\nendmodule", "corrupted_code": "module float_multi(clk, rst, a, b, z);\n\ninput clk, rst;\ninput [31:0] a, b;\noutput reg [31:0] z;\n\nreg [2:0] counter;\n\nreg [23:0] a_mantissa, b_mantissa, z_mantissa; //Mantissa\nreg [9:0] a_exponent, b_exponent, z_exponent; //EXPONENTS\nreg a_sign, b_sign, z_sign; // Sign_Bit\n\nreg [49:0] product;\n\nreg guard_bit, round_bit, sticky;\n\nalways @(posedge clk or rst) begin\n\tif(rst)\n\t\tcounter <= 0;\n\telse\n\t\tcounter <= counter + 1;\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b001) begin \n\t//IEEE 754 Representation\n\t\ta_mantissa <= a[22:0];\n\t        b_mantissa <= b[22:0];\n\t        a_exponent <= a[30:23] - 127;\n        \tb_exponent <= b[30:23] - 127;\n\t        a_sign <= a[31];\n        \tb_sign <= b[31];\n        end\nend\n\n\nalways @(counter) begin\n\t\n          \tend\n          \telse if (b_exponent == 128) begin //INF B\n          \t\tz[31] <= a_sign ^ b_sign;\n          \t\tz[30:23] <= 255;\n          \t\tz[22:0] <= 0;\n          \t\tif (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //NAN IF A = 0\n            \t\t\tz[31] <= 1;\n            \t\t\tz[30:23] <= 255;\n\t        \t    \tz[22] <= 1;\n        \t\t    \tz[21:0] <= 0;\n          \t\tend\n          \tend\n\t          else if (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin //0 if A = 0\n       \t\t z[31] <= a_sign ^ b_sign; //Sign_Bit \n       \t\t z[30:23] <= 0; \n        \t \t z[22:0] <= 0;\n        \t  end\n        \t  else if (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin //0 if B = 0\n        \t \t z[31] <= a_sign ^ b_sign;\n        \t  \t z[30:23] <= 0;\n        \t  \t z[22:0] <= 0;\n        \t  end\n        \t  else begin\n        \t  \tif ($signed(a_exponent) == -127) //DENORMALIZING A\n        \t    \t\ta_exponent <= -126;\n        \t  \telse\n        \t    \t\ta_mantissa[23] <= 1;\n            \t\t\n        \t    \tif ($signed(b_exponent) == -127) //DENORMALIZING B\n        \t    \t\tb_exponent <= -126;\n        \t  \telse\n        \t    \t\tb_mantissa[23] <= 1;\n        \t  end\n        end\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b011) begin\n\t\tif (~a_mantissa[23]) begin //NORMALIZE A\n\t        \ta_mantissa <= a_mantissa << 1;\n\t       \ta_exponent <= a_exponent - 1;\n\t        end\n\t        if (~b_mantissa[23]) begin //NORMALIZE B\n\t        \tb_mantissa <= b_mantissa << 1;\n\t       \tb_exponent <= b_exponent - 1;\n\t        end\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b100) begin //GET THE SIGNS XORED and EXPONENTS ADDED and GET THE INTERMEDIATE MANTISSA MULTIPLICATION\n\t\tz_sign <= a_sign ^ b_sign;\n\t        z_exponent <= a_exponent + b_exponent + 1 ;\n        \tproduct <= a_mantissa * b_mantissa * 4;\n\tend\nend\n\n\nalways @(counter) begin\n\tif(counter == 3'b101) begin\n\t\tz_mantissa <= product[49:26];\n       \tguard_bit <= product[25];\n      \t\tround_bit <= product[24];\n      \t\tsticky <= (product[23:0] != 0);\n\tend\nend\n\nalways @(counter) begin\n\tif(counter == 3'b110) begin\n\t\tif ($signed(z_exponent) < -126) begin\n        \t\tz_exponent <= z_exponent + (-126 -$signed(z_exponent));\n    \t\t\tz_mantissa <= z_mantissa >> (-126 -$signed(z_exponent));\n     \t\t\tguard_bit <= z_mantissa[0];\n       \t\tround_bit <= guard_bit;\n       \t\tsticky <= sticky | round_bit;\n        \tend\n\t\telse if (z_mantissa[23] == 0) begin\n        \t\tz_exponent <= z_exponent - 1;\n        \t\tz_mantissa <= z_mantissa << 1;\n        \t\tz_mantissa[0] <= guard_bit;\n        \t\tguard_bit <= round_bit;\n        \t\tround_bit <= 0;\n        \tend\n\t        else if (guard_bit && (round_bit | sticky | z_mantissa[0])) begin\n        \t\tz_mantissa <= z_mantissa + 1;\n          \t\tif (z_mantissa == 24'hffffff)\n            \t\t\tz_exponent <=z_exponent + 1;\n        \tend\n        end\nend\n\nalways @(counter) begin\n\tif(counter == 3'b111) begin\n\t\tz[22:0] <= z_mantissa[22:0];\n        \tz[30:23] <= z_exponent[7:0] + 127;\n        \tz[31] <= z_sign;\n        \tif ($signed(z_exponent) == -126 && z_mantissa[23] == 0)\n          \t\tz[30:23] <= 0;\n        \tif ($signed(z_exponent) > 127) begin //IF OVERFLOW RETURN INF\n          \t\tz[22:0] <= 0;\n          \t\tz[30:23] <= 255;\n          \t\tz[31] <= z_sign;\n        \tend\n\tend\nend\n\n\nendmodule", "corruption_explanation": "Removed a conditional block", "modification_type": "remove_conditional", "modification_line": 39, "original_snippet": "if(counter == 3'b010) begin\n\t\tif ((a_exponent == 128 && a_mantissa != 0) || (b_exponent == 128 && b_mantissa != 0)) begin //Not a Number \n          \t\tz[31] <= 1;\n          \t\tz[30:23] <= 255;\n         ", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing a conditional block. This removes important control logic, causing the design to skip necessary state transitions or data processing. Test cases that depend on the conditional behavior will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_conditional modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed a conditional block\n   \u2022 Line 39: Original: if(counter == 3'b010) begin\n\t\tif ((a_exponent == 128 && a_mantissa != 0) || (b_exponent == 128 && b_mantissa != 0)) begin //Not a Number \n          \t\tz[31] <= 1;\n          \t\tz[30:23] <= 255;\n         \n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 39.\n   \u2022 Restore the original code: if(counter == 3'b010) begin\n\t\tif ((a_exponent == 128 && a_mantissa != 0) || (b_exponent == 128 && b_mantissa != 0)) begin //Not a Number \n          \t\tz[31] <= 1;\n          \t\tz[30:23] <= 255;\n         \n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove conditional.", "complexity": 88, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_conditional"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.297908", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Other", "design_name": "fixed_point_adder", "module_name": "fixed_point_adder", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a parameterized fixed-point adder for arithmetic operations with fixed precision.\n\nModule name:  \n    fixed_point_adder               \nInput parameters:\n    Q: Number of fractional bits (precision).\n    N: Total number of bits, including integer and fractional parts.\nInput ports:\n    a [N-1:0]: First N-bit fixed-point input operand.\n    b [N-1:0]: Second N-bit fixed-point input operand.\nOutput ports:\n    c [N-1:0]: N-bit output representing the result of the fixed-point addition.\n\nInternal Registers:\n    res [N-1:0]: N-bit register used to store the result of the addition or subtraction.\n\nImplementation:\n1. Absolute Value Addition:\n    - If the most significant bits (MSBs) of `a` and `b` are the same (both positive or both negative), their absolute values are added.\n    - The MSB of the result is set to match the MSBs of `a` and `b` (sign bit remains consistent).\n\n2. Absolute Value Subtraction:\n    - If the MSBs of `a` and `b` are different (one is positive, the other negative), the larger absolute value is determined.\n    - If `a` is greater than `b`, the result is `a - b` and the MSB of the result is set to 0 (positive).\n    - If `b` is greater than `a`, the result is `b - a`. The MSB of the result is set according to whether the result is zero or negative.\n\n3. Precision:\n    - The operands `a` and `b` consist of integer and fractional parts, with the fractional part determined by parameter `Q`.\n    - The precision is consistent across both inputs and the output to ensure accurate fixed-point arithmetic.\n\n4. Overflow Handling:\n    - Overflow is managed internally by observing the MSB to ensure the result fits within the N-bit range.\n\nGive me the complete code.\n"}, "clean_code": "module fixed_point_adder #(\n\t//Parameterized values\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t \t\n\t\tres[N-1] = a[N-1];\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative...\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corrupted_code": "module fixed_point_adder #(\n\t//Parameterized values\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t \t\n\t\tres[N-1] = a[N-1];\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative...\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[2 - N:0] - a[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corruption_explanation": "Swapped operands: 'N - 2' -> '2 - N'", "modification_type": "swap_operands", "modification_line": 31, "original_snippet": "N-2", "modified_snippet": "2 - N", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'N - 2' -> '2 - N'\n   \u2022 Line 31: Original: N-2\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 31.\n   \u2022 Restore the original code: N-2\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 43, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["swap_operands"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.301154", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Other", "design_name": "fixed_point_adder", "module_name": "fixed_point_adder", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a parameterized fixed-point adder for arithmetic operations with fixed precision.\n\nModule name:  \n    fixed_point_adder               \nInput parameters:\n    Q: Number of fractional bits (precision).\n    N: Total number of bits, including integer and fractional parts.\nInput ports:\n    a [N-1:0]: First N-bit fixed-point input operand.\n    b [N-1:0]: Second N-bit fixed-point input operand.\nOutput ports:\n    c [N-1:0]: N-bit output representing the result of the fixed-point addition.\n\nInternal Registers:\n    res [N-1:0]: N-bit register used to store the result of the addition or subtraction.\n\nImplementation:\n1. Absolute Value Addition:\n    - If the most significant bits (MSBs) of `a` and `b` are the same (both positive or both negative), their absolute values are added.\n    - The MSB of the result is set to match the MSBs of `a` and `b` (sign bit remains consistent).\n\n2. Absolute Value Subtraction:\n    - If the MSBs of `a` and `b` are different (one is positive, the other negative), the larger absolute value is determined.\n    - If `a` is greater than `b`, the result is `a - b` and the MSB of the result is set to 0 (positive).\n    - If `b` is greater than `a`, the result is `b - a`. The MSB of the result is set according to whether the result is zero or negative.\n\n3. Precision:\n    - The operands `a` and `b` consist of integer and fractional parts, with the fractional part determined by parameter `Q`.\n    - The precision is consistent across both inputs and the output to ensure accurate fixed-point arithmetic.\n\n4. Overflow Handling:\n    - Overflow is managed internally by observing the MSB to ensure the result fits within the N-bit range.\n\nGive me the complete code.\n"}, "clean_code": "module fixed_point_adder #(\n\t//Parameterized values\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t \t\n\t\tres[N-1] = a[N-1];\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative...\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corrupted_code": "module fixed_point_adder #(\n\t//Parameterized values\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t \t\n\t\tres[N-1] = a[N-1];\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative...\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[1 - N] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corruption_explanation": "Swapped operands: 'N - 1' -> '1 - N'", "modification_type": "swap_operands", "modification_line": 33, "original_snippet": "N-1", "modified_snippet": "1 - N", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'N - 1' -> '1 - N'\n   \u2022 Line 33: Original: N-1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 33.\n   \u2022 Restore the original code: N-1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 43, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["swap_operands"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.302769", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Other", "design_name": "fixed_point_adder", "module_name": "fixed_point_adder", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a parameterized fixed-point adder for arithmetic operations with fixed precision.\n\nModule name:  \n    fixed_point_adder               \nInput parameters:\n    Q: Number of fractional bits (precision).\n    N: Total number of bits, including integer and fractional parts.\nInput ports:\n    a [N-1:0]: First N-bit fixed-point input operand.\n    b [N-1:0]: Second N-bit fixed-point input operand.\nOutput ports:\n    c [N-1:0]: N-bit output representing the result of the fixed-point addition.\n\nInternal Registers:\n    res [N-1:0]: N-bit register used to store the result of the addition or subtraction.\n\nImplementation:\n1. Absolute Value Addition:\n    - If the most significant bits (MSBs) of `a` and `b` are the same (both positive or both negative), their absolute values are added.\n    - The MSB of the result is set to match the MSBs of `a` and `b` (sign bit remains consistent).\n\n2. Absolute Value Subtraction:\n    - If the MSBs of `a` and `b` are different (one is positive, the other negative), the larger absolute value is determined.\n    - If `a` is greater than `b`, the result is `a - b` and the MSB of the result is set to 0 (positive).\n    - If `b` is greater than `a`, the result is `b - a`. The MSB of the result is set according to whether the result is zero or negative.\n\n3. Precision:\n    - The operands `a` and `b` consist of integer and fractional parts, with the fractional part determined by parameter `Q`.\n    - The precision is consistent across both inputs and the output to ensure accurate fixed-point arithmetic.\n\n4. Overflow Handling:\n    - Overflow is managed internally by observing the MSB to ensure the result fits within the N-bit range.\n\nGive me the complete code.\n"}, "clean_code": "module fixed_point_adder #(\n\t//Parameterized values\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t \t\n\t\tres[N-1] = a[N-1];\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative...\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corrupted_code": "module fixed_point_adder #(\n\t//Parameterized values\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative...\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 16, "original_snippet": "always @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t \t\n\t\tres[N-1] = a[N-1];\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\t\tend", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 16: Original: always @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t \t\n\t\tres[N-1] = a[N-1];\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\t\tend\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 16.\n   \u2022 Restore the original code: always @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t \t\n\t\tres[N-1] = a[N-1];\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\t\tend\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 43, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.304316", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Other", "design_name": "fixed_point_adder", "module_name": "fixed_point_adder", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a parameterized fixed-point adder for arithmetic operations with fixed precision.\n\nModule name:  \n    fixed_point_adder               \nInput parameters:\n    Q: Number of fractional bits (precision).\n    N: Total number of bits, including integer and fractional parts.\nInput ports:\n    a [N-1:0]: First N-bit fixed-point input operand.\n    b [N-1:0]: Second N-bit fixed-point input operand.\nOutput ports:\n    c [N-1:0]: N-bit output representing the result of the fixed-point addition.\n\nInternal Registers:\n    res [N-1:0]: N-bit register used to store the result of the addition or subtraction.\n\nImplementation:\n1. Absolute Value Addition:\n    - If the most significant bits (MSBs) of `a` and `b` are the same (both positive or both negative), their absolute values are added.\n    - The MSB of the result is set to match the MSBs of `a` and `b` (sign bit remains consistent).\n\n2. Absolute Value Subtraction:\n    - If the MSBs of `a` and `b` are different (one is positive, the other negative), the larger absolute value is determined.\n    - If `a` is greater than `b`, the result is `a - b` and the MSB of the result is set to 0 (positive).\n    - If `b` is greater than `a`, the result is `b - a`. The MSB of the result is set according to whether the result is zero or negative.\n\n3. Precision:\n    - The operands `a` and `b` consist of integer and fractional parts, with the fractional part determined by parameter `Q`.\n    - The precision is consistent across both inputs and the output to ensure accurate fixed-point arithmetic.\n\n4. Overflow Handling:\n    - Overflow is managed internally by observing the MSB to ensure the result fits within the N-bit range.\n\nGive me the complete code.\n"}, "clean_code": "module fixed_point_adder #(\n\t//Parameterized values\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t \t\n\t\tres[N-1] = a[N-1];\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative...\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corrupted_code": "module fixed_point_adder #(\n\t//Parameterized values\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t \t\n\t\tres[N-1] = a[N-1];\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative...\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corruption_explanation": "Removed else branch (may cause latch inference)", "modification_type": "remove_else_branch", "modification_line": 18, "original_snippet": "if(a[N-1] == b[N-1]) begin\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t \t\n\t\tres[N-1] = a[N-1];\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative...\n\telse if(a[N-1] == 0 &", "modified_snippet": "if(a[N-1] == b[N-1]) begin\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t \t\n\t\tres[N-1] = a[N-1];\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative...\n\telse if(a[N-1] == 0 &", "issue_description": "The buggy code is missing an else branch in a conditional statement. In combinational logic (always_comb or always @*), this can cause latch inference because the output is not defined for all input conditions. In sequential logic, signals may retain old values unexpectedly. This violates RTL design best practices requiring complete conditional assignments.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module should provide a complete conditional assignment to avoid latch inference.\n   \u2022 Combinational logic must define outputs for all input conditions.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an if statement without an else branch.\n   \u2022 The assigned signal is not defined when the condition is false.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The else branch has been removed from the conditional.\n   \u2022 This creates an incomplete conditional assignment.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Missing else branch leaves the signal undefined in some cases.\n   \u2022 Impact: Latch inference in combinational blocks, or stale values in sequential blocks.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Add an else branch with appropriate default or alternative assignment.\n   \u2022 Ensure all signals are assigned in all branches of the conditional.\n\n6. RTL Design Principle Violated:\n   \u2022 Combinational logic must have complete assignments to avoid latch inference.\n   \u2022 All conditional blocks should have else clauses or default values.", "complexity": 43, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["remove_else_branch"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.305960", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Other", "design_name": "fixed_point_adder", "module_name": "fixed_point_adder", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a parameterized fixed-point adder for arithmetic operations with fixed precision.\n\nModule name:  \n    fixed_point_adder               \nInput parameters:\n    Q: Number of fractional bits (precision).\n    N: Total number of bits, including integer and fractional parts.\nInput ports:\n    a [N-1:0]: First N-bit fixed-point input operand.\n    b [N-1:0]: Second N-bit fixed-point input operand.\nOutput ports:\n    c [N-1:0]: N-bit output representing the result of the fixed-point addition.\n\nInternal Registers:\n    res [N-1:0]: N-bit register used to store the result of the addition or subtraction.\n\nImplementation:\n1. Absolute Value Addition:\n    - If the most significant bits (MSBs) of `a` and `b` are the same (both positive or both negative), their absolute values are added.\n    - The MSB of the result is set to match the MSBs of `a` and `b` (sign bit remains consistent).\n\n2. Absolute Value Subtraction:\n    - If the MSBs of `a` and `b` are different (one is positive, the other negative), the larger absolute value is determined.\n    - If `a` is greater than `b`, the result is `a - b` and the MSB of the result is set to 0 (positive).\n    - If `b` is greater than `a`, the result is `b - a`. The MSB of the result is set according to whether the result is zero or negative.\n\n3. Precision:\n    - The operands `a` and `b` consist of integer and fractional parts, with the fractional part determined by parameter `Q`.\n    - The precision is consistent across both inputs and the output to ensure accurate fixed-point arithmetic.\n\n4. Overflow Handling:\n    - Overflow is managed internally by observing the MSB to ensure the result fits within the N-bit range.\n\nGive me the complete code.\n"}, "clean_code": "module fixed_point_adder #(\n\t//Parameterized values\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t \t\n\t\tres[N-1] = a[N-1];\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative...\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corrupted_code": "module fixed_point_adder #(\n\t//Parameterized values\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t \t\n\t\tres[N-1] = a[N-1];\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative...\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corruption_explanation": "Swapped if and else bodies", "modification_type": "invert_if_else", "modification_line": 39, "original_snippet": "if( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t", "modified_snippet": "if( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n", "issue_description": "The buggy code has swapped if and else bodies in a conditional block. This causes the logic to execute the opposite branch for each condition, leading to incorrect behavior when the condition is true vs false. Test cases that depend on the conditional logic will fail because the intended branch is not executed.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module contains conditional logic that should execute different code paths based on a condition.\n   \u2022 The if branch should handle the true case, and the else branch should handle the false case.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Identified a conditional block with both if and else branches.\n   \u2022 The branches contain different assignments or logic operations.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The if and else bodies have been swapped.\n   \u2022 Logic that should execute when condition is true now executes when false, and vice versa.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The conditional bodies are inverted.\n   \u2022 Impact: All conditional behavior is reversed, causing incorrect outputs for all test cases.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Swap the if and else bodies back to their correct positions.\n   \u2022 Verify that the condition evaluates correctly and executes the intended branch.\n\n6. RTL Design Principle Violated:\n   \u2022 Correct conditional logic requires matching the intended behavior with the branch bodies.", "complexity": 43, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["invert_if_else"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.308748", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Other", "design_name": "fixed_point_adder", "module_name": "fixed_point_adder", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a parameterized fixed-point adder for arithmetic operations with fixed precision.\n\nModule name:  \n    fixed_point_adder               \nInput parameters:\n    Q: Number of fractional bits (precision).\n    N: Total number of bits, including integer and fractional parts.\nInput ports:\n    a [N-1:0]: First N-bit fixed-point input operand.\n    b [N-1:0]: Second N-bit fixed-point input operand.\nOutput ports:\n    c [N-1:0]: N-bit output representing the result of the fixed-point addition.\n\nInternal Registers:\n    res [N-1:0]: N-bit register used to store the result of the addition or subtraction.\n\nImplementation:\n1. Absolute Value Addition:\n    - If the most significant bits (MSBs) of `a` and `b` are the same (both positive or both negative), their absolute values are added.\n    - The MSB of the result is set to match the MSBs of `a` and `b` (sign bit remains consistent).\n\n2. Absolute Value Subtraction:\n    - If the MSBs of `a` and `b` are different (one is positive, the other negative), the larger absolute value is determined.\n    - If `a` is greater than `b`, the result is `a - b` and the MSB of the result is set to 0 (positive).\n    - If `b` is greater than `a`, the result is `b - a`. The MSB of the result is set according to whether the result is zero or negative.\n\n3. Precision:\n    - The operands `a` and `b` consist of integer and fractional parts, with the fractional part determined by parameter `Q`.\n    - The precision is consistent across both inputs and the output to ensure accurate fixed-point arithmetic.\n\n4. Overflow Handling:\n    - Overflow is managed internally by observing the MSB to ensure the result fits within the N-bit range.\n\nGive me the complete code.\n"}, "clean_code": "module fixed_point_adder #(\n\t//Parameterized values\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t \t\n\t\tres[N-1] = a[N-1];\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative...\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corrupted_code": "module fixed_point_adder #(\n\t//Parameterized values\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t \t\n\t\tres[N-1] = a[N-1];\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative...\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif(!(a[N-2:0] > b[N-2:0])) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corruption_explanation": "Inverted condition: 'a[N-2:0] > b[N-2:0]' -> '!(a[N-2:0] > b[N-2:0])'", "modification_type": "invert_condition", "modification_line": 26, "original_snippet": "if( a[N-2:0] > b[N-2:0] ) begin", "modified_snippet": "if(!(a[N-2:0] > b[N-2:0])) begin", "issue_description": "The buggy code has an inverted condition in an if statement. Instead of checking if(x), it checks if(!x), causing the logic to execute when it shouldn't and skip execution when it should. All conditional behavior is reversed from intended functionality.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_condition modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted condition: 'a[N-2:0] > b[N-2:0]' -> '!(a[N-2:0] > b[N-2:0])'\n   \u2022 Line 26: Original: if( a[N-2:0] > b[N-2:0] ) begin\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 26.\n   \u2022 Restore the original code: if( a[N-2:0] > b[N-2:0] ) begin\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert condition.", "complexity": 43, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["invert_condition"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.310288", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Other", "design_name": "fixed_point_adder", "module_name": "fixed_point_adder", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a parameterized fixed-point adder for arithmetic operations with fixed precision.\n\nModule name:  \n    fixed_point_adder               \nInput parameters:\n    Q: Number of fractional bits (precision).\n    N: Total number of bits, including integer and fractional parts.\nInput ports:\n    a [N-1:0]: First N-bit fixed-point input operand.\n    b [N-1:0]: Second N-bit fixed-point input operand.\nOutput ports:\n    c [N-1:0]: N-bit output representing the result of the fixed-point addition.\n\nInternal Registers:\n    res [N-1:0]: N-bit register used to store the result of the addition or subtraction.\n\nImplementation:\n1. Absolute Value Addition:\n    - If the most significant bits (MSBs) of `a` and `b` are the same (both positive or both negative), their absolute values are added.\n    - The MSB of the result is set to match the MSBs of `a` and `b` (sign bit remains consistent).\n\n2. Absolute Value Subtraction:\n    - If the MSBs of `a` and `b` are different (one is positive, the other negative), the larger absolute value is determined.\n    - If `a` is greater than `b`, the result is `a - b` and the MSB of the result is set to 0 (positive).\n    - If `b` is greater than `a`, the result is `b - a`. The MSB of the result is set according to whether the result is zero or negative.\n\n3. Precision:\n    - The operands `a` and `b` consist of integer and fractional parts, with the fractional part determined by parameter `Q`.\n    - The precision is consistent across both inputs and the output to ensure accurate fixed-point arithmetic.\n\n4. Overflow Handling:\n    - Overflow is managed internally by observing the MSB to ensure the result fits within the N-bit range.\n\nGive me the complete code.\n"}, "clean_code": "module fixed_point_adder #(\n\t//Parameterized values\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t \t\n\t\tres[N-1] = a[N-1];\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative...\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corrupted_code": "module fixed_point_adder #(\n\t//Parameterized values\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t \t\n\t\tres[N-1] = a[N-1];\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative...\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corruption_explanation": "Removed else branch (may cause latch inference)", "modification_type": "remove_else_branch", "modification_line": 39, "original_snippet": "if( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t", "modified_snippet": "if( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend", "issue_description": "The buggy code is missing an else branch in a conditional statement. In combinational logic (always_comb or always @*), this can cause latch inference because the output is not defined for all input conditions. In sequential logic, signals may retain old values unexpectedly. This violates RTL design best practices requiring complete conditional assignments.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module should provide a complete conditional assignment to avoid latch inference.\n   \u2022 Combinational logic must define outputs for all input conditions.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an if statement without an else branch.\n   \u2022 The assigned signal is not defined when the condition is false.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The else branch has been removed from the conditional.\n   \u2022 This creates an incomplete conditional assignment.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Missing else branch leaves the signal undefined in some cases.\n   \u2022 Impact: Latch inference in combinational blocks, or stale values in sequential blocks.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Add an else branch with appropriate default or alternative assignment.\n   \u2022 Ensure all signals are assigned in all branches of the conditional.\n\n6. RTL Design Principle Violated:\n   \u2022 Combinational logic must have complete assignments to avoid latch inference.\n   \u2022 All conditional blocks should have else clauses or default values.", "complexity": 43, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["remove_else_branch"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.311857", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Other", "design_name": "fixed_point_adder", "module_name": "fixed_point_adder", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a parameterized fixed-point adder for arithmetic operations with fixed precision.\n\nModule name:  \n    fixed_point_adder               \nInput parameters:\n    Q: Number of fractional bits (precision).\n    N: Total number of bits, including integer and fractional parts.\nInput ports:\n    a [N-1:0]: First N-bit fixed-point input operand.\n    b [N-1:0]: Second N-bit fixed-point input operand.\nOutput ports:\n    c [N-1:0]: N-bit output representing the result of the fixed-point addition.\n\nInternal Registers:\n    res [N-1:0]: N-bit register used to store the result of the addition or subtraction.\n\nImplementation:\n1. Absolute Value Addition:\n    - If the most significant bits (MSBs) of `a` and `b` are the same (both positive or both negative), their absolute values are added.\n    - The MSB of the result is set to match the MSBs of `a` and `b` (sign bit remains consistent).\n\n2. Absolute Value Subtraction:\n    - If the MSBs of `a` and `b` are different (one is positive, the other negative), the larger absolute value is determined.\n    - If `a` is greater than `b`, the result is `a - b` and the MSB of the result is set to 0 (positive).\n    - If `b` is greater than `a`, the result is `b - a`. The MSB of the result is set according to whether the result is zero or negative.\n\n3. Precision:\n    - The operands `a` and `b` consist of integer and fractional parts, with the fractional part determined by parameter `Q`.\n    - The precision is consistent across both inputs and the output to ensure accurate fixed-point arithmetic.\n\n4. Overflow Handling:\n    - Overflow is managed internally by observing the MSB to ensure the result fits within the N-bit range.\n\nGive me the complete code.\n"}, "clean_code": "module fixed_point_adder #(\n\t//Parameterized values\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t \t\n\t\tres[N-1] = a[N-1];\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative...\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corrupted_code": "module fixed_point_adder #(\n\t//Parameterized values\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\nassign c = 1'b0;  // Conflicting assignment\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t \t\n\t\tres[N-1] = a[N-1];\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative...\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corruption_explanation": "Added conflicting driver for signal 'c'", "modification_type": "add_multiple_driver", "modification_line": 13, "original_snippet": "assign c = res;", "modified_snippet": "assign c = res;\nassign c = 1'b0;  // Conflicting assignment", "issue_description": "The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_multiple_driver modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added conflicting driver for signal 'c'\n   \u2022 Line 13: Original: assign c = res;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 13.\n   \u2022 Restore the original code: assign c = res;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add multiple driver.", "complexity": 43, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["add_multiple_driver"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.313398", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Other", "design_name": "fixed_point_adder", "module_name": "fixed_point_adder", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a parameterized fixed-point adder for arithmetic operations with fixed precision.\n\nModule name:  \n    fixed_point_adder               \nInput parameters:\n    Q: Number of fractional bits (precision).\n    N: Total number of bits, including integer and fractional parts.\nInput ports:\n    a [N-1:0]: First N-bit fixed-point input operand.\n    b [N-1:0]: Second N-bit fixed-point input operand.\nOutput ports:\n    c [N-1:0]: N-bit output representing the result of the fixed-point addition.\n\nInternal Registers:\n    res [N-1:0]: N-bit register used to store the result of the addition or subtraction.\n\nImplementation:\n1. Absolute Value Addition:\n    - If the most significant bits (MSBs) of `a` and `b` are the same (both positive or both negative), their absolute values are added.\n    - The MSB of the result is set to match the MSBs of `a` and `b` (sign bit remains consistent).\n\n2. Absolute Value Subtraction:\n    - If the MSBs of `a` and `b` are different (one is positive, the other negative), the larger absolute value is determined.\n    - If `a` is greater than `b`, the result is `a - b` and the MSB of the result is set to 0 (positive).\n    - If `b` is greater than `a`, the result is `b - a`. The MSB of the result is set according to whether the result is zero or negative.\n\n3. Precision:\n    - The operands `a` and `b` consist of integer and fractional parts, with the fractional part determined by parameter `Q`.\n    - The precision is consistent across both inputs and the output to ensure accurate fixed-point arithmetic.\n\n4. Overflow Handling:\n    - Overflow is managed internally by observing the MSB to ensure the result fits within the N-bit range.\n\nGive me the complete code.\n"}, "clean_code": "module fixed_point_adder #(\n\t//Parameterized values\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t \t\n\t\tres[N-1] = a[N-1];\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative...\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corrupted_code": "module fixed_point_adder #(\n\t//Parameterized values\n\tparameter Q = 15,\n\tparameter N = 32\n\t)\n\t(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n    );\n\nreg [N-1:0] res;\n\nassign c = res;\n\nalways @(a,b) begin\n\t// both negative or both positive\n\tif(a[N-1] == b[N-1]) begin\t\t\t\t\n\t\tres[N-2:0] = a[N-2:0] + b[N-2:0];\t \t\n\t\tres[N-1] = a[N-1];\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\n\t//\tone of them is negative...\n\telse if(a[N-1] == 0 && b[N-1] == 1) begin\t\t\n\t\tif(!(a[N-2:0] > b[N-2:0])) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif( a[N-2:0] > b[N-2:0] ) begin\t\t\t\t\t\n\t\t\tres[N-2:0] = a[N-2:0] - b[N-2:0];\t\t\t\n\t\t\tif (res[N-2:0] == 0)\n\t\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\telse\n\t\t\t\tres[N-1] = 1;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tres[N-2:0] = b[N-2:0] - a[N-2:0];\t\t\t\n\t\t\tres[N-1] = 0;\t\t\t\t\t\t\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendmodule", "corruption_explanation": "Inverted condition: 'a[N-2:0] > b[N-2:0]' -> '!(a[N-2:0] > b[N-2:0])'", "modification_type": "invert_condition", "modification_line": 26, "original_snippet": "if( a[N-2:0] > b[N-2:0] ) begin", "modified_snippet": "if(!(a[N-2:0] > b[N-2:0])) begin", "issue_description": "The buggy code has an inverted condition in an if statement. Instead of checking if(x), it checks if(!x), causing the logic to execute when it shouldn't and skip execution when it should. All conditional behavior is reversed from intended functionality.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_condition modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted condition: 'a[N-2:0] > b[N-2:0]' -> '!(a[N-2:0] > b[N-2:0])'\n   \u2022 Line 26: Original: if( a[N-2:0] > b[N-2:0] ) begin\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 26.\n   \u2022 Restore the original code: if( a[N-2:0] > b[N-2:0] ) begin\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert condition.", "complexity": 43, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["invert_condition"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.314953", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Divider", "design_name": "div_16bit", "module_name": "div_16bit", "description": "Please act as a professional verilog designer.\n\nImplement a 16-bit divider module, the dividend is 16-bit and the divider is 8-bit in combinational logic. Extract the higher bits of the dividend, matching the bit width of the divisor. Compare these bits with the divisor: if the dividend bits are greater, set the quotient to 1, otherwise set it to 0, and use the difference as the remainder. Concatenate the remainder with the highest remaining 1-bit of the dividend, and repeat the process until all dividend bits are processed.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n\nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe module uses two always blocks to perform the division operation.\nThe first always block is a combinational block triggered by any change in the input values A and B. It updates the values of two registers, a_reg and b_reg, with the values of A and B, respectively.\nThe second always block is also a combinational block triggered by any change in the input values A and B.\n\nGive me the complete code.\n"}, "clean_code": "module div_16bit(\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output wire [15:0] result,\n    output wire [15:0] odd\n    );\n\nreg [15:0] a_reg;\nreg [15:0] b_reg;\nreg [31:0] tmp_a;\nreg [31:0] tmp_b;\ninteger i;\n\nalways@(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways@(*) begin\n    begin\n        tmp_a = {16'b0, a_reg};\n        tmp_b = {b_reg, 16'b0};\n        for(i = 0;i < 16;i = i+1) begin\n            tmp_a = tmp_a << 1;\n            if (tmp_a >= tmp_b) begin\n                tmp_a = tmp_a - tmp_b + 1;\n            end\n            else begin\n                tmp_a = tmp_a;\n            end\n        end\n    end\nend\n\nassign odd = tmp_a[31:16];\nassign result = tmp_a[15:0];\n\nendmodule", "corrupted_code": "module div_16bit(\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output wire [15:0] result,\n    output wire [15:0] odd\n    );\n\nreg [15:0] a_reg;\nreg [15:0] b_reg;\nreg [31:0] tmp_a;\nreg [31:0] tmp_b;\ninteger i;\n\nalways@(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways@(*) begin\n    begin\n        tmp_a = {16'b0, a_reg};\n        tmp_b = {b_reg, 16'b0};\n        for(i = 0;i < 16;i = i+1) begin\n            tmp_a = tmp_a << 1;\n            if (tmp_a >= tmp_b) begin\n                tmp_a = tmp_a;\n            end\n            else begin\n                tmp_a = tmp_a - tmp_b + 1;\n            end\n        end\n    end\nend\n\nassign odd = tmp_a[31:16];\nassign result = tmp_a[15:0];\n\nendmodule", "corruption_explanation": "Swapped if and else bodies", "modification_type": "invert_if_else", "modification_line": 25, "original_snippet": "if (tmp_a >= tmp_b) begin\n                tmp_a = tmp_a - tmp_b + 1;\n            end\n            else begin\n                tmp_a = tmp_a;\n            end", "modified_snippet": "if (tmp_a >= tmp_b) begin\n                tmp_a = tmp_a;\n            end\n            else begin\n                tmp_a = tmp_a - tmp_b + 1;\n            end", "issue_description": "The buggy code has swapped if and else bodies in a conditional block. This causes the logic to execute the opposite branch for each condition, leading to incorrect behavior when the condition is true vs false. Test cases that depend on the conditional logic will fail because the intended branch is not executed.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module contains conditional logic that should execute different code paths based on a condition.\n   \u2022 The if branch should handle the true case, and the else branch should handle the false case.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Identified a conditional block with both if and else branches.\n   \u2022 The branches contain different assignments or logic operations.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The if and else bodies have been swapped.\n   \u2022 Logic that should execute when condition is true now executes when false, and vice versa.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The conditional bodies are inverted.\n   \u2022 Impact: All conditional behavior is reversed, causing incorrect outputs for all test cases.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Swap the if and else bodies back to their correct positions.\n   \u2022 Verify that the condition evaluates correctly and executes the intended branch.\n\n6. RTL Design Principle Violated:\n   \u2022 Correct conditional logic requires matching the intended behavior with the branch bodies.", "complexity": 9, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["invert_if_else"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.317094", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Divider", "design_name": "div_16bit", "module_name": "div_16bit", "description": "Please act as a professional verilog designer.\n\nImplement a 16-bit divider module, the dividend is 16-bit and the divider is 8-bit in combinational logic. Extract the higher bits of the dividend, matching the bit width of the divisor. Compare these bits with the divisor: if the dividend bits are greater, set the quotient to 1, otherwise set it to 0, and use the difference as the remainder. Concatenate the remainder with the highest remaining 1-bit of the dividend, and repeat the process until all dividend bits are processed.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n\nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe module uses two always blocks to perform the division operation.\nThe first always block is a combinational block triggered by any change in the input values A and B. It updates the values of two registers, a_reg and b_reg, with the values of A and B, respectively.\nThe second always block is also a combinational block triggered by any change in the input values A and B.\n\nGive me the complete code.\n"}, "clean_code": "module div_16bit(\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output wire [15:0] result,\n    output wire [15:0] odd\n    );\n\nreg [15:0] a_reg;\nreg [15:0] b_reg;\nreg [31:0] tmp_a;\nreg [31:0] tmp_b;\ninteger i;\n\nalways@(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways@(*) begin\n    begin\n        tmp_a = {16'b0, a_reg};\n        tmp_b = {b_reg, 16'b0};\n        for(i = 0;i < 16;i = i+1) begin\n            tmp_a = tmp_a << 1;\n            if (tmp_a >= tmp_b) begin\n                tmp_a = tmp_a - tmp_b + 1;\n            end\n            else begin\n                tmp_a = tmp_a;\n            end\n        end\n    end\nend\n\nassign odd = tmp_a[31:16];\nassign result = tmp_a[15:0];\n\nendmodule", "corrupted_code": "module div_16bit(\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output wire [15:0] result,\n    output wire [15:0] odd\n    );\n\nreg [15:0] a_reg;\nreg [15:0] b_reg;\nreg [31:0] tmp_a;\nreg [31:0] tmp_b;\ninteger i;\n\nalways@(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways@(*) begin\n    begin\n        tmp_a = {16'b0, a_reg};\n        tmp_b = {b_reg, 16'b0};\n        for(i = 0;i < 16;i = i+1) begin\n            tmp_a = tmp_a << 1;\n            if (tmp_a >= tmp_b) begin\n                tmp_a = tmp_a - tmp_b + 1;\n            end\n        end\n    end\nend\n\nassign odd = tmp_a[31:16];\nassign result = tmp_a[15:0];\n\nendmodule", "corruption_explanation": "Removed else branch (may cause latch inference)", "modification_type": "remove_else_branch", "modification_line": 25, "original_snippet": "if (tmp_a >= tmp_b) begin\n                tmp_a = tmp_a - tmp_b + 1;\n            end\n            else begin\n                tmp_a = tmp_a;\n            end", "modified_snippet": "if (tmp_a >= tmp_b) begin\n                tmp_a = tmp_a - tmp_b + 1;\n            end", "issue_description": "The buggy code is missing an else branch in a conditional statement. In combinational logic (always_comb or always @*), this can cause latch inference because the output is not defined for all input conditions. In sequential logic, signals may retain old values unexpectedly. This violates RTL design best practices requiring complete conditional assignments.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module should provide a complete conditional assignment to avoid latch inference.\n   \u2022 Combinational logic must define outputs for all input conditions.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an if statement without an else branch.\n   \u2022 The assigned signal is not defined when the condition is false.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The else branch has been removed from the conditional.\n   \u2022 This creates an incomplete conditional assignment.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Missing else branch leaves the signal undefined in some cases.\n   \u2022 Impact: Latch inference in combinational blocks, or stale values in sequential blocks.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Add an else branch with appropriate default or alternative assignment.\n   \u2022 Ensure all signals are assigned in all branches of the conditional.\n\n6. RTL Design Principle Violated:\n   \u2022 Combinational logic must have complete assignments to avoid latch inference.\n   \u2022 All conditional blocks should have else clauses or default values.", "complexity": 9, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["remove_else_branch"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.318071", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Divider", "design_name": "div_16bit", "module_name": "div_16bit", "description": "Please act as a professional verilog designer.\n\nImplement a 16-bit divider module, the dividend is 16-bit and the divider is 8-bit in combinational logic. Extract the higher bits of the dividend, matching the bit width of the divisor. Compare these bits with the divisor: if the dividend bits are greater, set the quotient to 1, otherwise set it to 0, and use the difference as the remainder. Concatenate the remainder with the highest remaining 1-bit of the dividend, and repeat the process until all dividend bits are processed.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n\nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe module uses two always blocks to perform the division operation.\nThe first always block is a combinational block triggered by any change in the input values A and B. It updates the values of two registers, a_reg and b_reg, with the values of A and B, respectively.\nThe second always block is also a combinational block triggered by any change in the input values A and B.\n\nGive me the complete code.\n"}, "clean_code": "module div_16bit(\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output wire [15:0] result,\n    output wire [15:0] odd\n    );\n\nreg [15:0] a_reg;\nreg [15:0] b_reg;\nreg [31:0] tmp_a;\nreg [31:0] tmp_b;\ninteger i;\n\nalways@(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways@(*) begin\n    begin\n        tmp_a = {16'b0, a_reg};\n        tmp_b = {b_reg, 16'b0};\n        for(i = 0;i < 16;i = i+1) begin\n            tmp_a = tmp_a << 1;\n            if (tmp_a >= tmp_b) begin\n                tmp_a = tmp_a - tmp_b + 1;\n            end\n            else begin\n                tmp_a = tmp_a;\n            end\n        end\n    end\nend\n\nassign odd = tmp_a[31:16];\nassign result = tmp_a[15:0];\n\nendmodule", "corrupted_code": "module div_16bit(\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output wire [15:0] result,\n    output wire [15:0] odd\n    );\n\nreg [15:0] a_reg;\nreg [15:0] b_reg;\nreg [31:0] tmp_a;\nreg [31:0] tmp_b;\ninteger i;\n\nalways@(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways@(*) begin\n    begin\n        tmp_a = {16'b0, a_reg};\n        tmp_b = {b_reg, 16'b0};\n        for(i = 0;i < 16;i = i+1) begin\n            tmp_a = tmp_a << 1;\n            if (tmp_a >= tmp_b) begin\n\n            end\n            else begin\n                tmp_a = tmp_a;\n            end\n        end\n    end\nend\n\nassign odd = tmp_a[31:16];\nassign result = tmp_a[15:0];\n\nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 26, "original_snippet": "tmp_a = tmp_a - tmp_b + 1;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 26: Original: tmp_a = tmp_a - tmp_b + 1;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 26.\n   \u2022 Restore the original code: tmp_a = tmp_a - tmp_b + 1;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 9, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["remove_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.319070", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Divider", "design_name": "div_16bit", "module_name": "div_16bit", "description": "Please act as a professional verilog designer.\n\nImplement a 16-bit divider module, the dividend is 16-bit and the divider is 8-bit in combinational logic. Extract the higher bits of the dividend, matching the bit width of the divisor. Compare these bits with the divisor: if the dividend bits are greater, set the quotient to 1, otherwise set it to 0, and use the difference as the remainder. Concatenate the remainder with the highest remaining 1-bit of the dividend, and repeat the process until all dividend bits are processed.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n\nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe module uses two always blocks to perform the division operation.\nThe first always block is a combinational block triggered by any change in the input values A and B. It updates the values of two registers, a_reg and b_reg, with the values of A and B, respectively.\nThe second always block is also a combinational block triggered by any change in the input values A and B.\n\nGive me the complete code.\n"}, "clean_code": "module div_16bit(\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output wire [15:0] result,\n    output wire [15:0] odd\n    );\n\nreg [15:0] a_reg;\nreg [15:0] b_reg;\nreg [31:0] tmp_a;\nreg [31:0] tmp_b;\ninteger i;\n\nalways@(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways@(*) begin\n    begin\n        tmp_a = {16'b0, a_reg};\n        tmp_b = {b_reg, 16'b0};\n        for(i = 0;i < 16;i = i+1) begin\n            tmp_a = tmp_a << 1;\n            if (tmp_a >= tmp_b) begin\n                tmp_a = tmp_a - tmp_b + 1;\n            end\n            else begin\n                tmp_a = tmp_a;\n            end\n        end\n    end\nend\n\nassign odd = tmp_a[31:16];\nassign result = tmp_a[15:0];\n\nendmodule", "corrupted_code": "module div_16bit(\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output wire [15:0] result,\n    output wire [15:0] odd\n    );\n\nreg [15:0] a_reg;\nreg [15:0] b_reg;\nreg [31:0] tmp_a;\nreg [31:0] tmp_b;\ninteger i;\n\nalways@(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways@(*) begin\n    begin\n        tmp_a = {16'b0, a_reg};\n        tmp_b = {b_reg, 16'b0};\n        for(i = 0;i < 16;i = i+1) begin\n            tmp_a = tmp_a << 1;\n            if (tmp_a >= tmp_b) begin\n                tmp_a = tmp_a - tmp_b + 1;\n            end\n            else begin\n                tmp_a = tmp_a;\n            end\n        end\n    end\nend\n\nassign odd <= tmp_a[31:16];\nassign result = tmp_a[15:0];\n\nendmodule", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 35, "original_snippet": "dd = tmp_a[31:16];", "modified_snippet": "dd <= tmp_a[31:16];", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 9, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.320153", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Divider", "design_name": "div_16bit", "module_name": "div_16bit", "description": "Please act as a professional verilog designer.\n\nImplement a 16-bit divider module, the dividend is 16-bit and the divider is 8-bit in combinational logic. Extract the higher bits of the dividend, matching the bit width of the divisor. Compare these bits with the divisor: if the dividend bits are greater, set the quotient to 1, otherwise set it to 0, and use the difference as the remainder. Concatenate the remainder with the highest remaining 1-bit of the dividend, and repeat the process until all dividend bits are processed.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n\nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe module uses two always blocks to perform the division operation.\nThe first always block is a combinational block triggered by any change in the input values A and B. It updates the values of two registers, a_reg and b_reg, with the values of A and B, respectively.\nThe second always block is also a combinational block triggered by any change in the input values A and B.\n\nGive me the complete code.\n"}, "clean_code": "module div_16bit(\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output wire [15:0] result,\n    output wire [15:0] odd\n    );\n\nreg [15:0] a_reg;\nreg [15:0] b_reg;\nreg [31:0] tmp_a;\nreg [31:0] tmp_b;\ninteger i;\n\nalways@(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways@(*) begin\n    begin\n        tmp_a = {16'b0, a_reg};\n        tmp_b = {b_reg, 16'b0};\n        for(i = 0;i < 16;i = i+1) begin\n            tmp_a = tmp_a << 1;\n            if (tmp_a >= tmp_b) begin\n                tmp_a = tmp_a - tmp_b + 1;\n            end\n            else begin\n                tmp_a = tmp_a;\n            end\n        end\n    end\nend\n\nassign odd = tmp_a[31:16];\nassign result = tmp_a[15:0];\n\nendmodule", "corrupted_code": "module div_16bit(\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output wire [15:0] result,\n    output wire [15:0] odd\n    );\n\nreg [15:0] a_reg;\nreg [15:0] b_reg;\nreg [31:0] tmp_a;\nreg [31:0] tmp_b;\ninteger i;\n\nalways @(a) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways@(*) begin\n    begin\n        tmp_a = {16'b0, a_reg};\n        tmp_b = {b_reg, 16'b0};\n        for(i = 0;i < 16;i = i+1) begin\n            tmp_a = tmp_a << 1;\n            if (tmp_a >= tmp_b) begin\n                tmp_a = tmp_a - tmp_b + 1;\n            end\n            else begin\n                tmp_a = tmp_a;\n            end\n        end\n    end\nend\n\nassign odd = tmp_a[31:16];\nassign result = tmp_a[15:0];\n\nendmodule", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 14, "original_snippet": "always@(*)", "modified_snippet": "always @(a)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 14: Original: always@(*)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 14.\n   \u2022 Restore the original code: always@(*)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 9, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["change_sensitivity_list"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.321124", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Divider", "design_name": "div_16bit", "module_name": "div_16bit", "description": "Please act as a professional verilog designer.\n\nImplement a 16-bit divider module, the dividend is 16-bit and the divider is 8-bit in combinational logic. Extract the higher bits of the dividend, matching the bit width of the divisor. Compare these bits with the divisor: if the dividend bits are greater, set the quotient to 1, otherwise set it to 0, and use the difference as the remainder. Concatenate the remainder with the highest remaining 1-bit of the dividend, and repeat the process until all dividend bits are processed.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n\nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe module uses two always blocks to perform the division operation.\nThe first always block is a combinational block triggered by any change in the input values A and B. It updates the values of two registers, a_reg and b_reg, with the values of A and B, respectively.\nThe second always block is also a combinational block triggered by any change in the input values A and B.\n\nGive me the complete code.\n"}, "clean_code": "module div_16bit(\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output wire [15:0] result,\n    output wire [15:0] odd\n    );\n\nreg [15:0] a_reg;\nreg [15:0] b_reg;\nreg [31:0] tmp_a;\nreg [31:0] tmp_b;\ninteger i;\n\nalways@(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways@(*) begin\n    begin\n        tmp_a = {16'b0, a_reg};\n        tmp_b = {b_reg, 16'b0};\n        for(i = 0;i < 16;i = i+1) begin\n            tmp_a = tmp_a << 1;\n            if (tmp_a >= tmp_b) begin\n                tmp_a = tmp_a - tmp_b + 1;\n            end\n            else begin\n                tmp_a = tmp_a;\n            end\n        end\n    end\nend\n\nassign odd = tmp_a[31:16];\nassign result = tmp_a[15:0];\n\nendmodule", "corrupted_code": "module div_16bit(\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output wire [15:0] result,\n    output wire [15:0] odd\n    );\n\nreg [15:0] a_reg;\nreg [15:0] b_reg;\nreg [31:0] tmp_a;\nreg [31:0] tmp_b;\ninteger i;\n\nalways@(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\n\n            else begin\n                tmp_a = tmp_a;\n            end\n        end\n    end\nend\n\nassign odd = tmp_a[31:16];\nassign result = tmp_a[15:0];\n\nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 19, "original_snippet": "always@(*) begin\n    begin\n        tmp_a = {16'b0, a_reg};\n        tmp_b = {b_reg, 16'b0};\n        for(i = 0;i < 16;i = i+1) begin\n            tmp_a = tmp_a << 1;\n            if (tmp_a >= tmp_b) begin", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 19: Original: always@(*) begin\n    begin\n        tmp_a = {16'b0, a_reg};\n        tmp_b = {b_reg, 16'b0};\n        for(i = 0;i < 16;i = i+1) begin\n            tmp_a = tmp_a << 1;\n            if (tmp_a >= tmp_b) begin\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 19.\n   \u2022 Restore the original code: always@(*) begin\n    begin\n        tmp_a = {16'b0, a_reg};\n        tmp_b = {b_reg, 16'b0};\n        for(i = 0;i < 16;i = i+1) begin\n            tmp_a = tmp_a << 1;\n            if (tmp_a >= tmp_b) begin\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 9, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.322089", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Divider", "design_name": "div_16bit", "module_name": "div_16bit", "description": "Please act as a professional verilog designer.\n\nImplement a 16-bit divider module, the dividend is 16-bit and the divider is 8-bit in combinational logic. Extract the higher bits of the dividend, matching the bit width of the divisor. Compare these bits with the divisor: if the dividend bits are greater, set the quotient to 1, otherwise set it to 0, and use the difference as the remainder. Concatenate the remainder with the highest remaining 1-bit of the dividend, and repeat the process until all dividend bits are processed.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n\nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe module uses two always blocks to perform the division operation.\nThe first always block is a combinational block triggered by any change in the input values A and B. It updates the values of two registers, a_reg and b_reg, with the values of A and B, respectively.\nThe second always block is also a combinational block triggered by any change in the input values A and B.\n\nGive me the complete code.\n"}, "clean_code": "module div_16bit(\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output wire [15:0] result,\n    output wire [15:0] odd\n    );\n\nreg [15:0] a_reg;\nreg [15:0] b_reg;\nreg [31:0] tmp_a;\nreg [31:0] tmp_b;\ninteger i;\n\nalways@(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways@(*) begin\n    begin\n        tmp_a = {16'b0, a_reg};\n        tmp_b = {b_reg, 16'b0};\n        for(i = 0;i < 16;i = i+1) begin\n            tmp_a = tmp_a << 1;\n            if (tmp_a >= tmp_b) begin\n                tmp_a = tmp_a - tmp_b + 1;\n            end\n            else begin\n                tmp_a = tmp_a;\n            end\n        end\n    end\nend\n\nassign odd = tmp_a[31:16];\nassign result = tmp_a[15:0];\n\nendmodule", "corrupted_code": "module div_16bit(\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output wire [15:0] result,\n    output wire [15:0] odd\n    );\n\nreg [15:0] a_reg;\nreg [15:0] b_reg;\nreg [31:0] tmp_a;\nreg [31:0] tmp_b;\ninteger i;\n\nalways @(a) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways@(*) begin\n    begin\n        tmp_a = {16'b0, a_reg};\n        tmp_b = {b_reg, 16'b0};\n        for(i = 0;i < 16;i = i+1) begin\n            tmp_a = tmp_a << 1;\n            if (tmp_a >= tmp_b) begin\n                tmp_a = tmp_a - tmp_b + 1;\n            end\n            else begin\n                tmp_a = tmp_a;\n            end\n        end\n    end\nend\n\nassign odd = tmp_a[31:16];\nassign result = tmp_a[15:0];\n\nendmodule", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 14, "original_snippet": "always@(*)", "modified_snippet": "always @(a)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 14: Original: always@(*)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 14.\n   \u2022 Restore the original code: always@(*)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 9, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["change_sensitivity_list"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.323054", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Divider", "design_name": "div_16bit", "module_name": "div_16bit", "description": "Please act as a professional verilog designer.\n\nImplement a 16-bit divider module, the dividend is 16-bit and the divider is 8-bit in combinational logic. Extract the higher bits of the dividend, matching the bit width of the divisor. Compare these bits with the divisor: if the dividend bits are greater, set the quotient to 1, otherwise set it to 0, and use the difference as the remainder. Concatenate the remainder with the highest remaining 1-bit of the dividend, and repeat the process until all dividend bits are processed.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n\nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe module uses two always blocks to perform the division operation.\nThe first always block is a combinational block triggered by any change in the input values A and B. It updates the values of two registers, a_reg and b_reg, with the values of A and B, respectively.\nThe second always block is also a combinational block triggered by any change in the input values A and B.\n\nGive me the complete code.\n"}, "clean_code": "module div_16bit(\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output wire [15:0] result,\n    output wire [15:0] odd\n    );\n\nreg [15:0] a_reg;\nreg [15:0] b_reg;\nreg [31:0] tmp_a;\nreg [31:0] tmp_b;\ninteger i;\n\nalways@(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways@(*) begin\n    begin\n        tmp_a = {16'b0, a_reg};\n        tmp_b = {b_reg, 16'b0};\n        for(i = 0;i < 16;i = i+1) begin\n            tmp_a = tmp_a << 1;\n            if (tmp_a >= tmp_b) begin\n                tmp_a = tmp_a - tmp_b + 1;\n            end\n            else begin\n                tmp_a = tmp_a;\n            end\n        end\n    end\nend\n\nassign odd = tmp_a[31:16];\nassign result = tmp_a[15:0];\n\nendmodule", "corrupted_code": "module div_16bit(\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output wire [15:0] result,\n    output wire [15:0] odd\n    );\n\nreg [15:0] a_reg;\nreg [15:0] b_reg;\nreg [31:0] tmp_a;\nreg [31:0] tmp_b;\ninteger i;\n\nalways@(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways@(*) begin\n    begin\n        tmp_a = {16'b0, a_reg};\n        tmp_b = {b_reg, 16'b1};\n        for(i = 0;i < 16;i = i+1) begin\n            tmp_a = tmp_a << 1;\n            if (tmp_a >= tmp_b) begin\n                tmp_a = tmp_a - tmp_b + 1;\n            end\n            else begin\n                tmp_a = tmp_a;\n            end\n        end\n    end\nend\n\nassign odd = tmp_a[31:16];\nassign result = tmp_a[15:0];\n\nendmodule", "corruption_explanation": "Changed constant from 16'b0 to 16'b1", "modification_type": "change_constant", "modification_line": 22, "original_snippet": "16'b0", "modified_snippet": "16'b1", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 16'b0 to 16'b1\n   \u2022 Line 22: Original: 16'b0\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 22.\n   \u2022 Restore the original code: 16'b0\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 9, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["change_constant"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.324029", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Divider", "design_name": "div_16bit", "module_name": "div_16bit", "description": "Please act as a professional verilog designer.\n\nImplement a 16-bit divider module, the dividend is 16-bit and the divider is 8-bit in combinational logic. Extract the higher bits of the dividend, matching the bit width of the divisor. Compare these bits with the divisor: if the dividend bits are greater, set the quotient to 1, otherwise set it to 0, and use the difference as the remainder. Concatenate the remainder with the highest remaining 1-bit of the dividend, and repeat the process until all dividend bits are processed.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n\nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe module uses two always blocks to perform the division operation.\nThe first always block is a combinational block triggered by any change in the input values A and B. It updates the values of two registers, a_reg and b_reg, with the values of A and B, respectively.\nThe second always block is also a combinational block triggered by any change in the input values A and B.\n\nGive me the complete code.\n"}, "clean_code": "module div_16bit(\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output wire [15:0] result,\n    output wire [15:0] odd\n    );\n\nreg [15:0] a_reg;\nreg [15:0] b_reg;\nreg [31:0] tmp_a;\nreg [31:0] tmp_b;\ninteger i;\n\nalways@(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways@(*) begin\n    begin\n        tmp_a = {16'b0, a_reg};\n        tmp_b = {b_reg, 16'b0};\n        for(i = 0;i < 16;i = i+1) begin\n            tmp_a = tmp_a << 1;\n            if (tmp_a >= tmp_b) begin\n                tmp_a = tmp_a - tmp_b + 1;\n            end\n            else begin\n                tmp_a = tmp_a;\n            end\n        end\n    end\nend\n\nassign odd = tmp_a[31:16];\nassign result = tmp_a[15:0];\n\nendmodule", "corrupted_code": "module div_16bit(\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output wire [15:0] result,\n    output wire [15:0] odd\n    );\n\nreg [15:0] a_reg;\nreg [15:0] b_reg;\nreg [31:0] tmp_a;\nreg [31:0] tmp_b;\ninteger i;\n\nalways@(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways@(*) begin\n    begin\n        tmp_a = {16'b0, a_reg};\n        tmp_b = {b_reg, 16'b0};\n        for(i = 0;i < 16;i = i+1) begin\n            tmp_a = tmp_a << 1;\n            if (!(tmp_a >= tmp_b)) begin\n                tmp_a = tmp_a - tmp_b + 1;\n            end\n            else begin\n                tmp_a = tmp_a;\n            end\n        end\n    end\nend\n\nassign odd = tmp_a[31:16];\nassign result = tmp_a[15:0];\n\nendmodule", "corruption_explanation": "Inverted condition: 'tmp_a >= tmp_b' -> '!(tmp_a >= tmp_b)'", "modification_type": "invert_condition", "modification_line": 25, "original_snippet": "if (tmp_a >= tmp_b) begin", "modified_snippet": "if (!(tmp_a >= tmp_b)) begin", "issue_description": "The buggy code has an inverted condition in an if statement. Instead of checking if(x), it checks if(!x), causing the logic to execute when it shouldn't and skip execution when it should. All conditional behavior is reversed from intended functionality.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_condition modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted condition: 'tmp_a >= tmp_b' -> '!(tmp_a >= tmp_b)'\n   \u2022 Line 25: Original: if (tmp_a >= tmp_b) begin\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 25.\n   \u2022 Restore the original code: if (tmp_a >= tmp_b) begin\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert condition.", "complexity": 9, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["invert_condition"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.324991", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Divider", "design_name": "div_16bit", "module_name": "div_16bit", "description": "Please act as a professional verilog designer.\n\nImplement a 16-bit divider module, the dividend is 16-bit and the divider is 8-bit in combinational logic. Extract the higher bits of the dividend, matching the bit width of the divisor. Compare these bits with the divisor: if the dividend bits are greater, set the quotient to 1, otherwise set it to 0, and use the difference as the remainder. Concatenate the remainder with the highest remaining 1-bit of the dividend, and repeat the process until all dividend bits are processed.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n\nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe module uses two always blocks to perform the division operation.\nThe first always block is a combinational block triggered by any change in the input values A and B. It updates the values of two registers, a_reg and b_reg, with the values of A and B, respectively.\nThe second always block is also a combinational block triggered by any change in the input values A and B.\n\nGive me the complete code.\n"}, "clean_code": "module div_16bit(\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output wire [15:0] result,\n    output wire [15:0] odd\n    );\n\nreg [15:0] a_reg;\nreg [15:0] b_reg;\nreg [31:0] tmp_a;\nreg [31:0] tmp_b;\ninteger i;\n\nalways@(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways@(*) begin\n    begin\n        tmp_a = {16'b0, a_reg};\n        tmp_b = {b_reg, 16'b0};\n        for(i = 0;i < 16;i = i+1) begin\n            tmp_a = tmp_a << 1;\n            if (tmp_a >= tmp_b) begin\n                tmp_a = tmp_a - tmp_b + 1;\n            end\n            else begin\n                tmp_a = tmp_a;\n            end\n        end\n    end\nend\n\nassign odd = tmp_a[31:16];\nassign result = tmp_a[15:0];\n\nendmodule", "corrupted_code": "module div_16bit(\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output wire [15:0] result,\n    output wire [15:0] odd\n    );\n\nreg [15:0] a_reg;\nreg [15:0] b_reg;\nreg [31:0] tmp_a;\nreg [31:0] tmp_b;\ninteger i;\n\nalways@(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\n\n            else begin\n                tmp_a = tmp_a;\n            end\n        end\n    end\nend\n\nassign odd = tmp_a[31:16];\nassign result = tmp_a[15:0];\n\nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 19, "original_snippet": "always@(*) begin\n    begin\n        tmp_a = {16'b0, a_reg};\n        tmp_b = {b_reg, 16'b0};\n        for(i = 0;i < 16;i = i+1) begin\n            tmp_a = tmp_a << 1;\n            if (tmp_a >= tmp_b) begin", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 19: Original: always@(*) begin\n    begin\n        tmp_a = {16'b0, a_reg};\n        tmp_b = {b_reg, 16'b0};\n        for(i = 0;i < 16;i = i+1) begin\n            tmp_a = tmp_a << 1;\n            if (tmp_a >= tmp_b) begin\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 19.\n   \u2022 Restore the original code: always@(*) begin\n    begin\n        tmp_a = {16'b0, a_reg};\n        tmp_b = {b_reg, 16'b0};\n        for(i = 0;i < 16;i = i+1) begin\n            tmp_a = tmp_a << 1;\n            if (tmp_a >= tmp_b) begin\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 9, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "invert_condition", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.325956", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Divider", "design_name": "radix2_div", "module_name": "radix2_div", "description": "Please act as a professional verilog designer.\n\nImplement a simplified radix-2 divider on 8-bit signed or unsigned integers. and the inputs are two 8-bit operands. The module accepts a dividend and a divisor as inputs and provides a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule name:  \n    radix2_div \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst: The reset signal to initialize or reset the module.\n    sign: 1-bit indicates if the operation is signed (1) or unsigned (0).\n    dividend: 8-bit input signal representing the dividend for division.\n    divisor: 8-bit input signal representing the divisor for division.\n    opn_valid: 1-bit indicates that a valid operation request is present.\nOutput ports:\n    res_valid: 1-bit output signal indicating the result is valid and ready.\n    result: 16-bit the output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nOperation Start:\nWhen opn_valid is high and res_valid is low, the module saves the inputs dividend and divisor.\nInitializes the shift register SR with the absolute value of the dividend shifted left by one bit.\nSets NEG_DIVISOR to the negated absolute value of the divisor.\nSets the counter cnt to 1 and start_cnt to 1 to begin the division process.\n\nDivision Process(If start_cnt is high, the module performs the following steps):\nIf the counter cnt reaches 8 (most significant bit of cnt is set), the division is complete:\ncnt and start_cnt are cleared.\nUpdates the shift register SR with the final remainder and quotient.\nOtherwise, the counter cnt is incremented, and the shift register SR is updated based on the subtraction result:\nComputes the subtraction of NEG_DIVISOR.\nUses a multiplexer to select the appropriate result based on the carry-out.\nUpdates SR by shifting left and inserting the carry-out.\n\nResult Validity:\nres_valid is managed based on the reset signal, the counter, and whether the result has been consumed.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ps\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n\n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    reg [7:0] dividend_save, divisor_save;\n    reg [15:0] SR;                  \n    reg [8 :0] NEG_DIVISOR;        \n    wire [7:0] REMAINER, QUOTIENT;\n    assign REMAINER = SR[15:8];\n    assign QUOTIENT = SR[7: 0];\n\n    wire [7:0] divident_abs;\n    wire [8:0] divisor_abs;\n    wire [7:0] remainer, quotient;\n\n    assign divident_abs = (sign & dividend[7]) ? ~dividend + 1'b1 : dividend;\n    assign remainer = (sign & dividend_save[7]) ? ~REMAINER + 1'b1 : REMAINER;\n    assign quotient = sign & (dividend_save[7] ^ divisor_save[7]) ? ~QUOTIENT + 1'b1 : QUOTIENT;\n    assign result = {remainer,quotient};\n\n    wire CO;\n    wire [8:0] sub_result;\n    wire [8:0] mux_result;\n\n    assign {CO,sub_result} = {1'b0,REMAINER} + NEG_DIVISOR;\n\n    assign mux_result = CO ? sub_result : {1'b0,REMAINER};\n\n    reg [3:0] cnt;\n    reg start_cnt;\n    always @(posedge clk) begin\n        if(rst) begin\n            SR <= 0;\n            dividend_save <= 0;\n            divisor_save <= 0;\n\n            cnt <= 0;\n            start_cnt <= 1'b0;\n        end\n        else if(~start_cnt & opn_valid & ~res_valid) begin\n            cnt <= 1;\n            start_cnt <= 1'b1;\n        \n            dividend_save <= dividend;\n            divisor_save <= divisor;\n\n            SR[15:0] <= {7'b0,divident_abs,1'b0}; \n            NEG_DIVISOR <= (sign & divisor[7]) ? {1'b1,divisor} : ~{1'b0,divisor} + 1'b1; \n        end\n        else if(start_cnt) begin\n            if(cnt[3]) begin    \n                cnt <= 0;\n                start_cnt <= 1'b0;\n                \n                SR[15:8] <= mux_result[7:0];\n                SR[0] <= CO;\n            end\n            else begin\n                cnt <= cnt + 1;\n\n                SR[15:0] <= {mux_result[6:0],SR[7:1],CO,1'b0}; \n            end\n        end\n    end\n\n    wire data_go;\n    assign data_go = res_valid & res_ready;\n    always @(posedge clk) begin\n        res_valid <= rst     ? 1'b0 :\n                     cnt[3]  ? 1'b1 :\n                     data_go ? 1'b0 : res_valid;\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns/1ps\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n\n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    reg [7:0] dividend_save, divisor_save;\n    reg [15:0] SR;                  \n    reg [8 :0] NEG_DIVISOR;        \n    wire [7:0] REMAINER, QUOTIENT;\n    assign REMAINER = SR[15:8];\n    assign QUOTIENT = SR[7: 0];\n\n    wire [7:0] divident_abs;\n    wire [8:0] divisor_abs;\n    wire [7:0] remainer, quotient;\n\n    assign divident_abs = (sign & dividend[7]) ? ~dividend + 1'b1 : dividend;\n    assign remainer = (sign & dividend_save[7]) ? ~REMAINER + 1'b1 : REMAINER;\n    assign quotient = sign & (dividend_save[7] ^ divisor_save[7]) ? ~QUOTIENT + 1'b1 : QUOTIENT;\n    assign result = {remainer,quotient};\n\n    wire CO;\n    wire [8:0] sub_result;\n    wire [8:0] mux_result;\n\n    assign {CO,sub_result} = {1'b0,REMAINER} + NEG_DIVISOR;\n\n    assign mux_result = CO ? sub_result : {1'b0,REMAINER};\n\n    reg [3:0] cnt;\n    reg start_cnt;\n    always @(posedge clk) begin\n        if(rst) begin\n            SR >= 0;\n            dividend_save <= 0;\n            divisor_save <= 0;\n\n            cnt <= 0;\n            start_cnt <= 1'b0;\n        end\n        else if(~start_cnt & opn_valid & ~res_valid) begin\n            cnt <= 1;\n            start_cnt <= 1'b1;\n        \n            dividend_save <= dividend;\n            divisor_save <= divisor;\n\n            SR[15:0] <= {7'b0,divident_abs,1'b0}; \n            NEG_DIVISOR <= (sign & divisor[7]) ? {1'b1,divisor} : ~{1'b0,divisor} + 1'b1; \n        end\n        else if(start_cnt) begin\n            if(cnt[3]) begin    \n                cnt <= 0;\n                start_cnt <= 1'b0;\n                \n                SR[15:8] <= mux_result[7:0];\n                SR[0] <= CO;\n            end\n            else begin\n                cnt <= cnt + 1;\n\n                SR[15:0] <= {mux_result[6:0],SR[7:1],CO,1'b0}; \n            end\n        end\n    end\n\n    wire data_go;\n    assign data_go = res_valid & res_ready;\n    always @(posedge clk) begin\n        res_valid <= rst     ? 1'b0 :\n                     cnt[3]  ? 1'b1 :\n                     data_go ? 1'b0 : res_valid;\n    end\nendmodule\n", "corruption_explanation": "Changed operator from '<=' to '>='", "modification_type": "change_operator", "modification_line": 43, "original_snippet": "R <= 0", "modified_snippet": "R >= 0", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '<=' to '>='\n   \u2022 Line 43: Original: R <= 0\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 43.\n   \u2022 Restore the original code: R <= 0\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 29, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.330292", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Divider", "design_name": "radix2_div", "module_name": "radix2_div", "description": "Please act as a professional verilog designer.\n\nImplement a simplified radix-2 divider on 8-bit signed or unsigned integers. and the inputs are two 8-bit operands. The module accepts a dividend and a divisor as inputs and provides a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule name:  \n    radix2_div \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst: The reset signal to initialize or reset the module.\n    sign: 1-bit indicates if the operation is signed (1) or unsigned (0).\n    dividend: 8-bit input signal representing the dividend for division.\n    divisor: 8-bit input signal representing the divisor for division.\n    opn_valid: 1-bit indicates that a valid operation request is present.\nOutput ports:\n    res_valid: 1-bit output signal indicating the result is valid and ready.\n    result: 16-bit the output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nOperation Start:\nWhen opn_valid is high and res_valid is low, the module saves the inputs dividend and divisor.\nInitializes the shift register SR with the absolute value of the dividend shifted left by one bit.\nSets NEG_DIVISOR to the negated absolute value of the divisor.\nSets the counter cnt to 1 and start_cnt to 1 to begin the division process.\n\nDivision Process(If start_cnt is high, the module performs the following steps):\nIf the counter cnt reaches 8 (most significant bit of cnt is set), the division is complete:\ncnt and start_cnt are cleared.\nUpdates the shift register SR with the final remainder and quotient.\nOtherwise, the counter cnt is incremented, and the shift register SR is updated based on the subtraction result:\nComputes the subtraction of NEG_DIVISOR.\nUses a multiplexer to select the appropriate result based on the carry-out.\nUpdates SR by shifting left and inserting the carry-out.\n\nResult Validity:\nres_valid is managed based on the reset signal, the counter, and whether the result has been consumed.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ps\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n\n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    reg [7:0] dividend_save, divisor_save;\n    reg [15:0] SR;                  \n    reg [8 :0] NEG_DIVISOR;        \n    wire [7:0] REMAINER, QUOTIENT;\n    assign REMAINER = SR[15:8];\n    assign QUOTIENT = SR[7: 0];\n\n    wire [7:0] divident_abs;\n    wire [8:0] divisor_abs;\n    wire [7:0] remainer, quotient;\n\n    assign divident_abs = (sign & dividend[7]) ? ~dividend + 1'b1 : dividend;\n    assign remainer = (sign & dividend_save[7]) ? ~REMAINER + 1'b1 : REMAINER;\n    assign quotient = sign & (dividend_save[7] ^ divisor_save[7]) ? ~QUOTIENT + 1'b1 : QUOTIENT;\n    assign result = {remainer,quotient};\n\n    wire CO;\n    wire [8:0] sub_result;\n    wire [8:0] mux_result;\n\n    assign {CO,sub_result} = {1'b0,REMAINER} + NEG_DIVISOR;\n\n    assign mux_result = CO ? sub_result : {1'b0,REMAINER};\n\n    reg [3:0] cnt;\n    reg start_cnt;\n    always @(posedge clk) begin\n        if(rst) begin\n            SR <= 0;\n            dividend_save <= 0;\n            divisor_save <= 0;\n\n            cnt <= 0;\n            start_cnt <= 1'b0;\n        end\n        else if(~start_cnt & opn_valid & ~res_valid) begin\n            cnt <= 1;\n            start_cnt <= 1'b1;\n        \n            dividend_save <= dividend;\n            divisor_save <= divisor;\n\n            SR[15:0] <= {7'b0,divident_abs,1'b0}; \n            NEG_DIVISOR <= (sign & divisor[7]) ? {1'b1,divisor} : ~{1'b0,divisor} + 1'b1; \n        end\n        else if(start_cnt) begin\n            if(cnt[3]) begin    \n                cnt <= 0;\n                start_cnt <= 1'b0;\n                \n                SR[15:8] <= mux_result[7:0];\n                SR[0] <= CO;\n            end\n            else begin\n                cnt <= cnt + 1;\n\n                SR[15:0] <= {mux_result[6:0],SR[7:1],CO,1'b0}; \n            end\n        end\n    end\n\n    wire data_go;\n    assign data_go = res_valid & res_ready;\n    always @(posedge clk) begin\n        res_valid <= rst     ? 1'b0 :\n                     cnt[3]  ? 1'b1 :\n                     data_go ? 1'b0 : res_valid;\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns/1ps\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n\n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    reg [7:0] dividend_save, divisor_save;\n    reg [15:0] SR;                  \n    reg [8 :0] NEG_DIVISOR;        \n    wire [7:0] REMAINER, QUOTIENT;\n    assign REMAINER = SR[15:8];\n    assign QUOTIENT = SR[7: 0];\n\n    wire [7:0] divident_abs;\n    wire [8:0] divisor_abs;\n    wire [7:0] remainer, quotient;\n\n    assign divident_abs = (sign & dividend[7]) ? ~dividend + 1'b1 : dividend;\n    assign remainer = (sign & dividend_save[7]) ? ~REMAINER + 1'b1 : REMAINER;\n    assign quotient = sign & (dividend_save[7] ^ divisor_save[7]) ? ~QUOTIENT + 1'b1 : QUOTIENT;\n    assign result = {remainer,quotient};\n\n    wire CO;\n    wire [8:0] sub_result;\n    wire [8:0] mux_result;\n\n    assign {CO,sub_result} = {1'b0,REMAINER} + NEG_DIVISOR;\n\n    assign mux_result = CO ? sub_result : {1'b0,REMAINER};\n\n    reg [3:0] cnt;\n    reg start_cnt;\n    always @(posedge clk) begin\n        if (!rst) begin\n            SR <= 0;\n            dividend_save <= 0;\n            divisor_save <= 0;\n\n            cnt <= 0;\n            start_cnt <= 1'b0;\n        end\n        else if(~start_cnt & opn_valid & ~res_valid) begin\n            cnt <= 1;\n            start_cnt <= 1'b1;\n        \n            dividend_save <= dividend;\n            divisor_save <= divisor;\n\n            SR[15:0] <= {7'b0,divident_abs,1'b0}; \n            NEG_DIVISOR <= (sign & divisor[7]) ? {1'b1,divisor} : ~{1'b0,divisor} + 1'b1; \n        end\n        else if(start_cnt) begin\n            if(cnt[3]) begin    \n                cnt <= 0;\n                start_cnt <= 1'b0;\n                \n                SR[15:8] <= mux_result[7:0];\n                SR[0] <= CO;\n            end\n            else begin\n                cnt <= cnt + 1;\n\n                SR[15:0] <= {mux_result[6:0],SR[7:1],CO,1'b0}; \n            end\n        end\n    end\n\n    wire data_go;\n    assign data_go = res_valid & res_ready;\n    always @(posedge clk) begin\n        res_valid <= rst     ? 1'b0 :\n                     cnt[3]  ? 1'b1 :\n                     data_go ? 1'b0 : res_valid;\n    end\nendmodule\n", "corruption_explanation": "Inverted reset polarity in condition", "modification_type": "invert_reset_polarity", "modification_line": 42, "original_snippet": "if(rst)", "modified_snippet": "if (!rst)", "issue_description": "The buggy code has inverted reset polarity. If the design expects active-low reset (!rst), it now uses active-high, or vice versa. This causes the reset logic to activate during normal operation and deactivate during actual reset, breaking initialization.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_reset_polarity modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted reset polarity in condition\n   \u2022 Line 42: Original: if(rst)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 42.\n   \u2022 Restore the original code: if(rst)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert reset polarity.", "complexity": 29, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_reset_polarity"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.332986", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Divider", "design_name": "radix2_div", "module_name": "radix2_div", "description": "Please act as a professional verilog designer.\n\nImplement a simplified radix-2 divider on 8-bit signed or unsigned integers. and the inputs are two 8-bit operands. The module accepts a dividend and a divisor as inputs and provides a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule name:  \n    radix2_div \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst: The reset signal to initialize or reset the module.\n    sign: 1-bit indicates if the operation is signed (1) or unsigned (0).\n    dividend: 8-bit input signal representing the dividend for division.\n    divisor: 8-bit input signal representing the divisor for division.\n    opn_valid: 1-bit indicates that a valid operation request is present.\nOutput ports:\n    res_valid: 1-bit output signal indicating the result is valid and ready.\n    result: 16-bit the output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nOperation Start:\nWhen opn_valid is high and res_valid is low, the module saves the inputs dividend and divisor.\nInitializes the shift register SR with the absolute value of the dividend shifted left by one bit.\nSets NEG_DIVISOR to the negated absolute value of the divisor.\nSets the counter cnt to 1 and start_cnt to 1 to begin the division process.\n\nDivision Process(If start_cnt is high, the module performs the following steps):\nIf the counter cnt reaches 8 (most significant bit of cnt is set), the division is complete:\ncnt and start_cnt are cleared.\nUpdates the shift register SR with the final remainder and quotient.\nOtherwise, the counter cnt is incremented, and the shift register SR is updated based on the subtraction result:\nComputes the subtraction of NEG_DIVISOR.\nUses a multiplexer to select the appropriate result based on the carry-out.\nUpdates SR by shifting left and inserting the carry-out.\n\nResult Validity:\nres_valid is managed based on the reset signal, the counter, and whether the result has been consumed.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ps\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n\n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    reg [7:0] dividend_save, divisor_save;\n    reg [15:0] SR;                  \n    reg [8 :0] NEG_DIVISOR;        \n    wire [7:0] REMAINER, QUOTIENT;\n    assign REMAINER = SR[15:8];\n    assign QUOTIENT = SR[7: 0];\n\n    wire [7:0] divident_abs;\n    wire [8:0] divisor_abs;\n    wire [7:0] remainer, quotient;\n\n    assign divident_abs = (sign & dividend[7]) ? ~dividend + 1'b1 : dividend;\n    assign remainer = (sign & dividend_save[7]) ? ~REMAINER + 1'b1 : REMAINER;\n    assign quotient = sign & (dividend_save[7] ^ divisor_save[7]) ? ~QUOTIENT + 1'b1 : QUOTIENT;\n    assign result = {remainer,quotient};\n\n    wire CO;\n    wire [8:0] sub_result;\n    wire [8:0] mux_result;\n\n    assign {CO,sub_result} = {1'b0,REMAINER} + NEG_DIVISOR;\n\n    assign mux_result = CO ? sub_result : {1'b0,REMAINER};\n\n    reg [3:0] cnt;\n    reg start_cnt;\n    always @(posedge clk) begin\n        if(rst) begin\n            SR <= 0;\n            dividend_save <= 0;\n            divisor_save <= 0;\n\n            cnt <= 0;\n            start_cnt <= 1'b0;\n        end\n        else if(~start_cnt & opn_valid & ~res_valid) begin\n            cnt <= 1;\n            start_cnt <= 1'b1;\n        \n            dividend_save <= dividend;\n            divisor_save <= divisor;\n\n            SR[15:0] <= {7'b0,divident_abs,1'b0}; \n            NEG_DIVISOR <= (sign & divisor[7]) ? {1'b1,divisor} : ~{1'b0,divisor} + 1'b1; \n        end\n        else if(start_cnt) begin\n            if(cnt[3]) begin    \n                cnt <= 0;\n                start_cnt <= 1'b0;\n                \n                SR[15:8] <= mux_result[7:0];\n                SR[0] <= CO;\n            end\n            else begin\n                cnt <= cnt + 1;\n\n                SR[15:0] <= {mux_result[6:0],SR[7:1],CO,1'b0}; \n            end\n        end\n    end\n\n    wire data_go;\n    assign data_go = res_valid & res_ready;\n    always @(posedge clk) begin\n        res_valid <= rst     ? 1'b0 :\n                     cnt[3]  ? 1'b1 :\n                     data_go ? 1'b0 : res_valid;\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns/1ps\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n\n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    reg [7:0] dividend_save, divisor_save;\n    reg [15:0] SR;                  \n    reg [8 :0] NEG_DIVISOR;        \n    wire [7:0] REMAINER, QUOTIENT;\n    assign REMAINER = SR[15:8];\n    assign QUOTIENT = SR[7: 0];\n\n    wire [7:0] divident_abs;\n    wire [8:0] divisor_abs;\n    wire [7:0] remainer, quotient;\n\n    assign divident_abs = (sign & dividend[7]) ? ~dividend + 1'b1 : dividend;\n    assign remainer = (sign & dividend_save[7]) ? ~REMAINER + 1'b1 : REMAINER;\n    assign quotient = sign & (dividend_save[7] ^ divisor_save[7]) ? ~QUOTIENT + 1'b1 : QUOTIENT;\n    assign result = {remainer,quotient};\n\n    wire CO;\n    wire [8:0] sub_result;\n    wire [8:0] mux_result;\n\n    assign {CO,sub_result} = {1'b0,REMAINER} + NEG_DIVISOR;\n\n    assign mux_result = CO ? sub_result : {1'b0,REMAINER};\n\n    reg [3:0] cnt;\n    reg start_cnt;\n    always @(posedge clk) begin\n        if(rst) begin\n            SR <= 0;\n            dividend_save <= 0;\n            divisor_save <= 0;\n\n            cnt <= 0;\n            start_cnt <= 1'b0;\n        end\n        else if(~start_cnt & opn_valid & ~res_valid) begin\n            cnt <= 1;\n            start_cnt <= 1'b1;\n        \n            dividend_save <= dividend;\n            divisor_save <= divisor;\n\n            SR[15:0] <= {7'b0,divident_abs,1'b0}; \n            NEG_DIVISOR <= (sign & divisor[7]) ? {1'b1,divisor} : ~{1'b0,divisor} + 1'b0; \n        end\n        else if(start_cnt) begin\n            if(cnt[3]) begin    \n                cnt <= 0;\n                start_cnt <= 1'b0;\n                \n                SR[15:8] <= mux_result[7:0];\n                SR[0] <= CO;\n            end\n            else begin\n                cnt <= cnt + 1;\n\n                SR[15:0] <= {mux_result[6:0],SR[7:1],CO,1'b0}; \n            end\n        end\n    end\n\n    wire data_go;\n    assign data_go = res_valid & res_ready;\n    always @(posedge clk) begin\n        res_valid <= rst     ? 1'b0 :\n                     cnt[3]  ? 1'b1 :\n                     data_go ? 1'b0 : res_valid;\n    end\nendmodule\n", "corruption_explanation": "Changed constant from 1'b1 to 1'b0", "modification_type": "change_constant", "modification_line": 58, "original_snippet": "1'b1", "modified_snippet": "1'b0", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 1'b1 to 1'b0\n   \u2022 Line 58: Original: 1'b1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 58.\n   \u2022 Restore the original code: 1'b1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 29, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_constant"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.358031", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Divider", "design_name": "radix2_div", "module_name": "radix2_div", "description": "Please act as a professional verilog designer.\n\nImplement a simplified radix-2 divider on 8-bit signed or unsigned integers. and the inputs are two 8-bit operands. The module accepts a dividend and a divisor as inputs and provides a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule name:  \n    radix2_div \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst: The reset signal to initialize or reset the module.\n    sign: 1-bit indicates if the operation is signed (1) or unsigned (0).\n    dividend: 8-bit input signal representing the dividend for division.\n    divisor: 8-bit input signal representing the divisor for division.\n    opn_valid: 1-bit indicates that a valid operation request is present.\nOutput ports:\n    res_valid: 1-bit output signal indicating the result is valid and ready.\n    result: 16-bit the output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nOperation Start:\nWhen opn_valid is high and res_valid is low, the module saves the inputs dividend and divisor.\nInitializes the shift register SR with the absolute value of the dividend shifted left by one bit.\nSets NEG_DIVISOR to the negated absolute value of the divisor.\nSets the counter cnt to 1 and start_cnt to 1 to begin the division process.\n\nDivision Process(If start_cnt is high, the module performs the following steps):\nIf the counter cnt reaches 8 (most significant bit of cnt is set), the division is complete:\ncnt and start_cnt are cleared.\nUpdates the shift register SR with the final remainder and quotient.\nOtherwise, the counter cnt is incremented, and the shift register SR is updated based on the subtraction result:\nComputes the subtraction of NEG_DIVISOR.\nUses a multiplexer to select the appropriate result based on the carry-out.\nUpdates SR by shifting left and inserting the carry-out.\n\nResult Validity:\nres_valid is managed based on the reset signal, the counter, and whether the result has been consumed.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ps\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n\n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    reg [7:0] dividend_save, divisor_save;\n    reg [15:0] SR;                  \n    reg [8 :0] NEG_DIVISOR;        \n    wire [7:0] REMAINER, QUOTIENT;\n    assign REMAINER = SR[15:8];\n    assign QUOTIENT = SR[7: 0];\n\n    wire [7:0] divident_abs;\n    wire [8:0] divisor_abs;\n    wire [7:0] remainer, quotient;\n\n    assign divident_abs = (sign & dividend[7]) ? ~dividend + 1'b1 : dividend;\n    assign remainer = (sign & dividend_save[7]) ? ~REMAINER + 1'b1 : REMAINER;\n    assign quotient = sign & (dividend_save[7] ^ divisor_save[7]) ? ~QUOTIENT + 1'b1 : QUOTIENT;\n    assign result = {remainer,quotient};\n\n    wire CO;\n    wire [8:0] sub_result;\n    wire [8:0] mux_result;\n\n    assign {CO,sub_result} = {1'b0,REMAINER} + NEG_DIVISOR;\n\n    assign mux_result = CO ? sub_result : {1'b0,REMAINER};\n\n    reg [3:0] cnt;\n    reg start_cnt;\n    always @(posedge clk) begin\n        if(rst) begin\n            SR <= 0;\n            dividend_save <= 0;\n            divisor_save <= 0;\n\n            cnt <= 0;\n            start_cnt <= 1'b0;\n        end\n        else if(~start_cnt & opn_valid & ~res_valid) begin\n            cnt <= 1;\n            start_cnt <= 1'b1;\n        \n            dividend_save <= dividend;\n            divisor_save <= divisor;\n\n            SR[15:0] <= {7'b0,divident_abs,1'b0}; \n            NEG_DIVISOR <= (sign & divisor[7]) ? {1'b1,divisor} : ~{1'b0,divisor} + 1'b1; \n        end\n        else if(start_cnt) begin\n            if(cnt[3]) begin    \n                cnt <= 0;\n                start_cnt <= 1'b0;\n                \n                SR[15:8] <= mux_result[7:0];\n                SR[0] <= CO;\n            end\n            else begin\n                cnt <= cnt + 1;\n\n                SR[15:0] <= {mux_result[6:0],SR[7:1],CO,1'b0}; \n            end\n        end\n    end\n\n    wire data_go;\n    assign data_go = res_valid & res_ready;\n    always @(posedge clk) begin\n        res_valid <= rst     ? 1'b0 :\n                     cnt[3]  ? 1'b1 :\n                     data_go ? 1'b0 : res_valid;\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns/1ps\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n\n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    reg [7:0] dividend_save, divisor_save;\n    reg [15:0] SR;                  \n    reg [8 :0] NEG_DIVISOR;        \n    wire [7:0] REMAINER, QUOTIENT;\n    assign REMAINER = SR[15:8];\n    assign QUOTIENT = SR[7: 0];\n\n    wire [7:0] divident_abs;\n    wire [8:0] divisor_abs;\n    wire [7:0] remainer, quotient;\n\n    assign divident_abs = (sign & dividend[7]) ? ~dividend + 1'b1 : dividend;\n    assign remainer = (sign & dividend_save[7]) ? ~REMAINER + 1'b1 : REMAINER;\n    assign quotient = sign & (dividend_save[7] ^ divisor_save[7]) ? ~QUOTIENT + 1'b1 : QUOTIENT;\n    assign result = {remainer,quotient};\n\n    wire CO;\n    wire [8:0] sub_result;\n    wire [8:0] mux_result;\n\n    assign {CO,sub_result} = {1'b0,REMAINER} + NEG_DIVISOR;\n\n    assign mux_result = CO ? sub_result : {1'b0,REMAINER};\n\n    reg [3:0] cnt;\n    reg start_cnt;\n    \n        else if(~start_cnt & opn_valid & ~res_valid) begin\n            cnt <= 1;\n            start_cnt <= 1'b1;\n        \n            dividend_save <= dividend;\n            divisor_save <= divisor;\n\n            SR[15:0] <= {7'b0,divident_abs,1'b0}; \n            NEG_DIVISOR <= (sign & divisor[7]) ? {1'b1,divisor} : ~{1'b0,divisor} + 1'b1; \n        end\n        else if(start_cnt) begin\n            if(cnt[3]) begin    \n                cnt <= 0;\n                start_cnt <= 1'b0;\n                \n                SR[15:8] <= mux_result[7:0];\n                SR[0] <= CO;\n            end\n            else begin\n                cnt <= cnt + 1;\n\n                SR[15:0] <= {mux_result[6:0],SR[7:1],CO,1'b0}; \n            end\n        end\n    end\n\n    wire data_go;\n    assign data_go = res_valid & res_ready;\n    always @(posedge clk) begin\n        res_valid <= rst     ? 1'b0 :\n                     cnt[3]  ? 1'b1 :\n                     data_go ? 1'b0 : res_valid;\n    end\nendmodule\n", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 41, "original_snippet": "always @(posedge clk) begin\n        if(rst) begin\n            SR <= 0;\n            dividend_save <= 0;\n            divisor_save <= 0;\n\n            cnt <= 0;\n            start_cnt <= 1'b0;\n        end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 41: Original: always @(posedge clk) begin\n        if(rst) begin\n            SR <= 0;\n            dividend_save <= 0;\n            divisor_save <= 0;\n\n            cnt <= 0;\n            start_cnt <= 1'b0;\n        end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 41.\n   \u2022 Restore the original code: always @(posedge clk) begin\n        if(rst) begin\n            SR <= 0;\n            dividend_save <= 0;\n            divisor_save <= 0;\n\n            cnt <= 0;\n            start_cnt <= 1'b0;\n        end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 29, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.360883", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Divider", "design_name": "radix2_div", "module_name": "radix2_div", "description": "Please act as a professional verilog designer.\n\nImplement a simplified radix-2 divider on 8-bit signed or unsigned integers. and the inputs are two 8-bit operands. The module accepts a dividend and a divisor as inputs and provides a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule name:  \n    radix2_div \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst: The reset signal to initialize or reset the module.\n    sign: 1-bit indicates if the operation is signed (1) or unsigned (0).\n    dividend: 8-bit input signal representing the dividend for division.\n    divisor: 8-bit input signal representing the divisor for division.\n    opn_valid: 1-bit indicates that a valid operation request is present.\nOutput ports:\n    res_valid: 1-bit output signal indicating the result is valid and ready.\n    result: 16-bit the output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nOperation Start:\nWhen opn_valid is high and res_valid is low, the module saves the inputs dividend and divisor.\nInitializes the shift register SR with the absolute value of the dividend shifted left by one bit.\nSets NEG_DIVISOR to the negated absolute value of the divisor.\nSets the counter cnt to 1 and start_cnt to 1 to begin the division process.\n\nDivision Process(If start_cnt is high, the module performs the following steps):\nIf the counter cnt reaches 8 (most significant bit of cnt is set), the division is complete:\ncnt and start_cnt are cleared.\nUpdates the shift register SR with the final remainder and quotient.\nOtherwise, the counter cnt is incremented, and the shift register SR is updated based on the subtraction result:\nComputes the subtraction of NEG_DIVISOR.\nUses a multiplexer to select the appropriate result based on the carry-out.\nUpdates SR by shifting left and inserting the carry-out.\n\nResult Validity:\nres_valid is managed based on the reset signal, the counter, and whether the result has been consumed.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ps\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n\n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    reg [7:0] dividend_save, divisor_save;\n    reg [15:0] SR;                  \n    reg [8 :0] NEG_DIVISOR;        \n    wire [7:0] REMAINER, QUOTIENT;\n    assign REMAINER = SR[15:8];\n    assign QUOTIENT = SR[7: 0];\n\n    wire [7:0] divident_abs;\n    wire [8:0] divisor_abs;\n    wire [7:0] remainer, quotient;\n\n    assign divident_abs = (sign & dividend[7]) ? ~dividend + 1'b1 : dividend;\n    assign remainer = (sign & dividend_save[7]) ? ~REMAINER + 1'b1 : REMAINER;\n    assign quotient = sign & (dividend_save[7] ^ divisor_save[7]) ? ~QUOTIENT + 1'b1 : QUOTIENT;\n    assign result = {remainer,quotient};\n\n    wire CO;\n    wire [8:0] sub_result;\n    wire [8:0] mux_result;\n\n    assign {CO,sub_result} = {1'b0,REMAINER} + NEG_DIVISOR;\n\n    assign mux_result = CO ? sub_result : {1'b0,REMAINER};\n\n    reg [3:0] cnt;\n    reg start_cnt;\n    always @(posedge clk) begin\n        if(rst) begin\n            SR <= 0;\n            dividend_save <= 0;\n            divisor_save <= 0;\n\n            cnt <= 0;\n            start_cnt <= 1'b0;\n        end\n        else if(~start_cnt & opn_valid & ~res_valid) begin\n            cnt <= 1;\n            start_cnt <= 1'b1;\n        \n            dividend_save <= dividend;\n            divisor_save <= divisor;\n\n            SR[15:0] <= {7'b0,divident_abs,1'b0}; \n            NEG_DIVISOR <= (sign & divisor[7]) ? {1'b1,divisor} : ~{1'b0,divisor} + 1'b1; \n        end\n        else if(start_cnt) begin\n            if(cnt[3]) begin    \n                cnt <= 0;\n                start_cnt <= 1'b0;\n                \n                SR[15:8] <= mux_result[7:0];\n                SR[0] <= CO;\n            end\n            else begin\n                cnt <= cnt + 1;\n\n                SR[15:0] <= {mux_result[6:0],SR[7:1],CO,1'b0}; \n            end\n        end\n    end\n\n    wire data_go;\n    assign data_go = res_valid & res_ready;\n    always @(posedge clk) begin\n        res_valid <= rst     ? 1'b0 :\n                     cnt[3]  ? 1'b1 :\n                     data_go ? 1'b0 : res_valid;\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns/1ps\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n\n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    reg [7:0] dividend_save, divisor_save;\n    reg [15:0] SR;                  \n    reg [8 :0] NEG_DIVISOR;        \n    wire [7:0] REMAINER, QUOTIENT;\n    assign REMAINER = SR[15:8];\n    assign QUOTIENT = SR[7: 0];\n\n    wire [7:0] divident_abs;\n    wire [8:0] divisor_abs;\n    wire [7:0] remainer, quotient;\n\n    assign divident_abs = (sign & dividend[7]) ? ~dividend + 1'b1 : dividend;\n    assign remainer = (sign & dividend_save[7]) ? ~REMAINER + 1'b1 : REMAINER;\n    assign quotient = sign & (dividend_save[7] ^ divisor_save[7]) ? ~QUOTIENT + 1'b1 : QUOTIENT;\n    assign result = {remainer,quotient};\n\n    wire CO;\n    wire [8:0] sub_result;\n    wire [8:0] mux_result;\n\n    assign {CO,sub_result} = {1'b0,REMAINER} + NEG_DIVISOR;\n\n    assign mux_result = CO ? sub_result : {1'b0,REMAINER};\n\n    reg [3:0] cnt;\n    reg start_cnt;\n    always @(posedge clk) begin\n        if(rst) begin\n            SR <= 0;\n            dividend_save <= 0;\n            divisor_save <= 0;\n\n            cnt <= 0;\n            start_cnt <= 1'b0;\n        end\n        else if(~start_cnt & opn_valid & ~res_valid) begin\n            cnt <= 1;\n            start_cnt <= 1'b1;\n        \n            dividend_save <= dividend;\n            divisor_save <= divisor;\n\n            SR[15:0] <= {7'b0,divident_abs,1'b0}; \n            NEG_DIVISOR <= (sign & divisor[7]) ? {1'b1,divisor} : ~{1'b0,divisor} + 1'b1; \n        end\n        else if(start_cnt) begin\n            if(cnt[3]) begin    \n                cnt <= 0;\n                start_cnt <= 1'b0;\n                \n                SR[15:8] <= mux_result[7:0];\n                SR[0] <= CO;\n            end\n            else begin\n                cnt <= cnt + 1;\n\n                SR[15:0] <= {mux_result[6:0],SR[7:1],CO,1'b0}; \n            end\n        end\n    end\n\n    wire data_go;\n    assign data_go = res_valid & res_ready;\n    always @(posedge clk) begin\n        res_valid <= rst     ? 1'b0 :\n                     cnt[3]  ? 1'b1 :\n                     data_go ? 1'b0 : res_valid;\n    end\n\n    wire clk_dup;\n    assign clk_dup = clk;\nendmodule\n", "corruption_explanation": "Added duplicate clock signal clk_dup", "modification_type": "duplicate_clock_signal", "modification_line": 47, "original_snippet": "(none)", "modified_snippet": "wire clk_dup;\n    assign clk_dup = clk;", "issue_description": "The buggy code has a duplicate clock signal. A phantom clock domain is created, which may confuse CDC analysis tools and create subtle timing issues in synthesis. This violates clock domain design best practices.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a duplicate_clock_signal modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added duplicate clock signal clk_dup\n   \u2022 Line 47: Original: (none)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 47.\n   \u2022 Restore the original code: (none)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to duplicate clock signal.", "complexity": 29, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["duplicate_clock_signal"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.363582", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Divider", "design_name": "radix2_div", "module_name": "radix2_div", "description": "Please act as a professional verilog designer.\n\nImplement a simplified radix-2 divider on 8-bit signed or unsigned integers. and the inputs are two 8-bit operands. The module accepts a dividend and a divisor as inputs and provides a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule name:  \n    radix2_div \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst: The reset signal to initialize or reset the module.\n    sign: 1-bit indicates if the operation is signed (1) or unsigned (0).\n    dividend: 8-bit input signal representing the dividend for division.\n    divisor: 8-bit input signal representing the divisor for division.\n    opn_valid: 1-bit indicates that a valid operation request is present.\nOutput ports:\n    res_valid: 1-bit output signal indicating the result is valid and ready.\n    result: 16-bit the output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nOperation Start:\nWhen opn_valid is high and res_valid is low, the module saves the inputs dividend and divisor.\nInitializes the shift register SR with the absolute value of the dividend shifted left by one bit.\nSets NEG_DIVISOR to the negated absolute value of the divisor.\nSets the counter cnt to 1 and start_cnt to 1 to begin the division process.\n\nDivision Process(If start_cnt is high, the module performs the following steps):\nIf the counter cnt reaches 8 (most significant bit of cnt is set), the division is complete:\ncnt and start_cnt are cleared.\nUpdates the shift register SR with the final remainder and quotient.\nOtherwise, the counter cnt is incremented, and the shift register SR is updated based on the subtraction result:\nComputes the subtraction of NEG_DIVISOR.\nUses a multiplexer to select the appropriate result based on the carry-out.\nUpdates SR by shifting left and inserting the carry-out.\n\nResult Validity:\nres_valid is managed based on the reset signal, the counter, and whether the result has been consumed.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ps\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n\n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    reg [7:0] dividend_save, divisor_save;\n    reg [15:0] SR;                  \n    reg [8 :0] NEG_DIVISOR;        \n    wire [7:0] REMAINER, QUOTIENT;\n    assign REMAINER = SR[15:8];\n    assign QUOTIENT = SR[7: 0];\n\n    wire [7:0] divident_abs;\n    wire [8:0] divisor_abs;\n    wire [7:0] remainer, quotient;\n\n    assign divident_abs = (sign & dividend[7]) ? ~dividend + 1'b1 : dividend;\n    assign remainer = (sign & dividend_save[7]) ? ~REMAINER + 1'b1 : REMAINER;\n    assign quotient = sign & (dividend_save[7] ^ divisor_save[7]) ? ~QUOTIENT + 1'b1 : QUOTIENT;\n    assign result = {remainer,quotient};\n\n    wire CO;\n    wire [8:0] sub_result;\n    wire [8:0] mux_result;\n\n    assign {CO,sub_result} = {1'b0,REMAINER} + NEG_DIVISOR;\n\n    assign mux_result = CO ? sub_result : {1'b0,REMAINER};\n\n    reg [3:0] cnt;\n    reg start_cnt;\n    always @(posedge clk) begin\n        if(rst) begin\n            SR <= 0;\n            dividend_save <= 0;\n            divisor_save <= 0;\n\n            cnt <= 0;\n            start_cnt <= 1'b0;\n        end\n        else if(~start_cnt & opn_valid & ~res_valid) begin\n            cnt <= 1;\n            start_cnt <= 1'b1;\n        \n            dividend_save <= dividend;\n            divisor_save <= divisor;\n\n            SR[15:0] <= {7'b0,divident_abs,1'b0}; \n            NEG_DIVISOR <= (sign & divisor[7]) ? {1'b1,divisor} : ~{1'b0,divisor} + 1'b1; \n        end\n        else if(start_cnt) begin\n            if(cnt[3]) begin    \n                cnt <= 0;\n                start_cnt <= 1'b0;\n                \n                SR[15:8] <= mux_result[7:0];\n                SR[0] <= CO;\n            end\n            else begin\n                cnt <= cnt + 1;\n\n                SR[15:0] <= {mux_result[6:0],SR[7:1],CO,1'b0}; \n            end\n        end\n    end\n\n    wire data_go;\n    assign data_go = res_valid & res_ready;\n    always @(posedge clk) begin\n        res_valid <= rst     ? 1'b0 :\n                     cnt[3]  ? 1'b1 :\n                     data_go ? 1'b0 : res_valid;\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns/1ps\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n\n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    reg [7:0] dividend_save, divisor_save;\n    reg [15:0] SR;                  \n    reg [8 :0] NEG_DIVISOR;        \n    wire [7:0] REMAINER, QUOTIENT;\n    assign REMAINER = SR[15:8];\n    assign QUOTIENT = SR[7: 0];\n\n    wire [7:0] divident_abs;\n    wire [8:0] divisor_abs;\n    wire [7:0] remainer, quotient;\n\n    assign divident_abs = (sign & dividend[7]) ? ~dividend + 1'b1 : dividend;\n    assign remainer = (sign & dividend_save[7]) ? ~REMAINER + 1'b1 : REMAINER;\n    assign quotient = sign & (dividend_save[7] ^ divisor_save[7]) ? ~QUOTIENT + 1'b1 : QUOTIENT;\n    assign result = {remainer,quotient};\n\n    wire CO;\n    wire [8:0] sub_result;\n    wire [8:0] mux_result;\n\n    assign {CO,sub_result} = {1'b0,REMAINER} + NEG_DIVISOR;\n\n    assign mux_result = CO ? sub_result : {1'b0,REMAINER};\n\n    reg [3:0] cnt;\n    reg start_cnt;\n    always @(posedge clk) begin\n        if(rst) begin\n            SR <= 0;\n            dividend_save <= 0;\n            divisor_save <= 0;\n\n            cnt <= 0;\n            start_cnt <= 1'b0;\n        end\n        else if(~start_cnt & opn_valid & ~res_valid) begin\n            cnt <= 1;\n            start_cnt <= 1'b1;\n        \n            dividend_save <= dividend;\n            divisor_save <= divisor;\n\n            SR[15:0] <= {7'b0,divident_abs,1'b0}; \n            NEG_DIVISOR <= (sign & divisor[7]) ? {1'b1,divisor} : ~{1'b0,divisor} + 1'b1; \n        end\n        else if(start_cnt) begin\n            if(cnt[3]) begin    \n                cnt <= 0;\n                start_cnt <= 1'b0;\n                \n                SR[15:8] <= mux_result[7:0];\n                SR[0] <= CO;\n            end\n            else begin\n                cnt <= cnt + 1;\n\n                SR[15:0] <= {mux_result[6:0],SR[7:1],CO,1'b0}; \n            end\n        end\n    end\n\n    wire data_go;\n    assign data_go = res_valid & res_ready;\n    always @(posedge clk) begin\n        res_valid <= rst     ? 1'b0 :\n                     cnt[3]  ? 1'b0 :\n                     data_go ? 1'b0 : res_valid;\n    end\nendmodule\n", "corruption_explanation": "Changed constant from 1'b1 to 1'b0", "modification_type": "change_constant", "modification_line": 80, "original_snippet": "1'b1", "modified_snippet": "1'b0", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 1'b1 to 1'b0\n   \u2022 Line 80: Original: 1'b1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 80.\n   \u2022 Restore the original code: 1'b1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 29, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_constant"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.366294", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Divider", "design_name": "radix2_div", "module_name": "radix2_div", "description": "Please act as a professional verilog designer.\n\nImplement a simplified radix-2 divider on 8-bit signed or unsigned integers. and the inputs are two 8-bit operands. The module accepts a dividend and a divisor as inputs and provides a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule name:  \n    radix2_div \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst: The reset signal to initialize or reset the module.\n    sign: 1-bit indicates if the operation is signed (1) or unsigned (0).\n    dividend: 8-bit input signal representing the dividend for division.\n    divisor: 8-bit input signal representing the divisor for division.\n    opn_valid: 1-bit indicates that a valid operation request is present.\nOutput ports:\n    res_valid: 1-bit output signal indicating the result is valid and ready.\n    result: 16-bit the output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nOperation Start:\nWhen opn_valid is high and res_valid is low, the module saves the inputs dividend and divisor.\nInitializes the shift register SR with the absolute value of the dividend shifted left by one bit.\nSets NEG_DIVISOR to the negated absolute value of the divisor.\nSets the counter cnt to 1 and start_cnt to 1 to begin the division process.\n\nDivision Process(If start_cnt is high, the module performs the following steps):\nIf the counter cnt reaches 8 (most significant bit of cnt is set), the division is complete:\ncnt and start_cnt are cleared.\nUpdates the shift register SR with the final remainder and quotient.\nOtherwise, the counter cnt is incremented, and the shift register SR is updated based on the subtraction result:\nComputes the subtraction of NEG_DIVISOR.\nUses a multiplexer to select the appropriate result based on the carry-out.\nUpdates SR by shifting left and inserting the carry-out.\n\nResult Validity:\nres_valid is managed based on the reset signal, the counter, and whether the result has been consumed.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ps\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n\n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    reg [7:0] dividend_save, divisor_save;\n    reg [15:0] SR;                  \n    reg [8 :0] NEG_DIVISOR;        \n    wire [7:0] REMAINER, QUOTIENT;\n    assign REMAINER = SR[15:8];\n    assign QUOTIENT = SR[7: 0];\n\n    wire [7:0] divident_abs;\n    wire [8:0] divisor_abs;\n    wire [7:0] remainer, quotient;\n\n    assign divident_abs = (sign & dividend[7]) ? ~dividend + 1'b1 : dividend;\n    assign remainer = (sign & dividend_save[7]) ? ~REMAINER + 1'b1 : REMAINER;\n    assign quotient = sign & (dividend_save[7] ^ divisor_save[7]) ? ~QUOTIENT + 1'b1 : QUOTIENT;\n    assign result = {remainer,quotient};\n\n    wire CO;\n    wire [8:0] sub_result;\n    wire [8:0] mux_result;\n\n    assign {CO,sub_result} = {1'b0,REMAINER} + NEG_DIVISOR;\n\n    assign mux_result = CO ? sub_result : {1'b0,REMAINER};\n\n    reg [3:0] cnt;\n    reg start_cnt;\n    always @(posedge clk) begin\n        if(rst) begin\n            SR <= 0;\n            dividend_save <= 0;\n            divisor_save <= 0;\n\n            cnt <= 0;\n            start_cnt <= 1'b0;\n        end\n        else if(~start_cnt & opn_valid & ~res_valid) begin\n            cnt <= 1;\n            start_cnt <= 1'b1;\n        \n            dividend_save <= dividend;\n            divisor_save <= divisor;\n\n            SR[15:0] <= {7'b0,divident_abs,1'b0}; \n            NEG_DIVISOR <= (sign & divisor[7]) ? {1'b1,divisor} : ~{1'b0,divisor} + 1'b1; \n        end\n        else if(start_cnt) begin\n            if(cnt[3]) begin    \n                cnt <= 0;\n                start_cnt <= 1'b0;\n                \n                SR[15:8] <= mux_result[7:0];\n                SR[0] <= CO;\n            end\n            else begin\n                cnt <= cnt + 1;\n\n                SR[15:0] <= {mux_result[6:0],SR[7:1],CO,1'b0}; \n            end\n        end\n    end\n\n    wire data_go;\n    assign data_go = res_valid & res_ready;\n    always @(posedge clk) begin\n        res_valid <= rst     ? 1'b0 :\n                     cnt[3]  ? 1'b1 :\n                     data_go ? 1'b0 : res_valid;\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns/1ps\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n\n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    reg [7:0] dividend_save, divisor_save;\n    reg [15:0] SR;                  \n    reg [8 :0] NEG_DIVISOR;        \n    wire [7:0] REMAINER, QUOTIENT;\n    assign REMAINER = SR[15:8];\n    assign QUOTIENT = SR[7: 0];\n\n    wire [7:0] divident_abs;\n    wire [8:0] divisor_abs;\n    wire [7:0] remainer, quotient;\n\n    assign divident_abs = (sign & dividend[7]) ? ~dividend + 1'b1 : dividend;\n    assign remainer = (sign & dividend_save[7]) ? ~REMAINER + 1'b1 : REMAINER;\n    assign quotient = sign & (dividend_save[7] ^ divisor_save[7]) ? ~QUOTIENT + 1'b1 : QUOTIENT;\n    assign result = {remainer,quotient};\n\n    wire CO;\n    wire [8:0] sub_result;\n    wire [8:0] mux_result;\n\n    assign {CO,sub_result} = {1'b0,REMAINER} + NEG_DIVISOR;\n\n    assign mux_result = CO ? sub_result : {1'b0,REMAINER};\n\n    reg [3:0] cnt;\n    reg start_cnt;\n    always @(posedge clk) begin\n        if(rst) begin\n            \n            dividend_save <= 0;\n            divisor_save <= 0;\n\n            cnt <= 0;\n            start_cnt <= 1'b0;\n        end\n        else if(~start_cnt & opn_valid & ~res_valid) begin\n            cnt <= 1;\n            start_cnt <= 1'b1;\n        \n            dividend_save <= dividend;\n            divisor_save <= divisor;\n\n            SR[15:0] <= {7'b0,divident_abs,1'b0}; \n            NEG_DIVISOR <= (sign & divisor[7]) ? {1'b1,divisor} : ~{1'b0,divisor} + 1'b1; \n        end\n        else if(start_cnt) begin\n            if(cnt[3]) begin    \n                cnt <= 0;\n                start_cnt <= 1'b0;\n                \n                SR[15:8] <= mux_result[7:0];\n                SR[0] <= CO;\n            end\n            else begin\n                cnt <= cnt + 1;\n\n                SR[15:0] <= {mux_result[6:0],SR[7:1],CO,1'b0}; \n            end\n        end\n    end\n\n    wire data_go;\n    assign data_go = res_valid & res_ready;\n    always @(posedge clk) begin\n        res_valid <= rst     ? 1'b0 :\n                     cnt[3]  ? 1'b1 :\n                     data_go ? 1'b0 : res_valid;\n    end\nendmodule\n", "corruption_explanation": "Removed assignment from reset block", "modification_type": "remove_reset_assignment", "modification_line": 42, "original_snippet": "SR <= 0;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing a signal initialization in the reset block. This leaves registers with undefined initial values after reset, causing unpredictable behavior on startup. Simulation may pass but hardware behavior will be incorrect.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_reset_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed assignment from reset block\n   \u2022 Line 42: Original: SR <= 0;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 42.\n   \u2022 Restore the original code: SR <= 0;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove reset assignment.", "complexity": 29, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_reset_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.369083", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Divider", "design_name": "radix2_div", "module_name": "radix2_div", "description": "Please act as a professional verilog designer.\n\nImplement a simplified radix-2 divider on 8-bit signed or unsigned integers. and the inputs are two 8-bit operands. The module accepts a dividend and a divisor as inputs and provides a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule name:  \n    radix2_div \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst: The reset signal to initialize or reset the module.\n    sign: 1-bit indicates if the operation is signed (1) or unsigned (0).\n    dividend: 8-bit input signal representing the dividend for division.\n    divisor: 8-bit input signal representing the divisor for division.\n    opn_valid: 1-bit indicates that a valid operation request is present.\nOutput ports:\n    res_valid: 1-bit output signal indicating the result is valid and ready.\n    result: 16-bit the output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nOperation Start:\nWhen opn_valid is high and res_valid is low, the module saves the inputs dividend and divisor.\nInitializes the shift register SR with the absolute value of the dividend shifted left by one bit.\nSets NEG_DIVISOR to the negated absolute value of the divisor.\nSets the counter cnt to 1 and start_cnt to 1 to begin the division process.\n\nDivision Process(If start_cnt is high, the module performs the following steps):\nIf the counter cnt reaches 8 (most significant bit of cnt is set), the division is complete:\ncnt and start_cnt are cleared.\nUpdates the shift register SR with the final remainder and quotient.\nOtherwise, the counter cnt is incremented, and the shift register SR is updated based on the subtraction result:\nComputes the subtraction of NEG_DIVISOR.\nUses a multiplexer to select the appropriate result based on the carry-out.\nUpdates SR by shifting left and inserting the carry-out.\n\nResult Validity:\nres_valid is managed based on the reset signal, the counter, and whether the result has been consumed.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ps\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n\n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    reg [7:0] dividend_save, divisor_save;\n    reg [15:0] SR;                  \n    reg [8 :0] NEG_DIVISOR;        \n    wire [7:0] REMAINER, QUOTIENT;\n    assign REMAINER = SR[15:8];\n    assign QUOTIENT = SR[7: 0];\n\n    wire [7:0] divident_abs;\n    wire [8:0] divisor_abs;\n    wire [7:0] remainer, quotient;\n\n    assign divident_abs = (sign & dividend[7]) ? ~dividend + 1'b1 : dividend;\n    assign remainer = (sign & dividend_save[7]) ? ~REMAINER + 1'b1 : REMAINER;\n    assign quotient = sign & (dividend_save[7] ^ divisor_save[7]) ? ~QUOTIENT + 1'b1 : QUOTIENT;\n    assign result = {remainer,quotient};\n\n    wire CO;\n    wire [8:0] sub_result;\n    wire [8:0] mux_result;\n\n    assign {CO,sub_result} = {1'b0,REMAINER} + NEG_DIVISOR;\n\n    assign mux_result = CO ? sub_result : {1'b0,REMAINER};\n\n    reg [3:0] cnt;\n    reg start_cnt;\n    always @(posedge clk) begin\n        if(rst) begin\n            SR <= 0;\n            dividend_save <= 0;\n            divisor_save <= 0;\n\n            cnt <= 0;\n            start_cnt <= 1'b0;\n        end\n        else if(~start_cnt & opn_valid & ~res_valid) begin\n            cnt <= 1;\n            start_cnt <= 1'b1;\n        \n            dividend_save <= dividend;\n            divisor_save <= divisor;\n\n            SR[15:0] <= {7'b0,divident_abs,1'b0}; \n            NEG_DIVISOR <= (sign & divisor[7]) ? {1'b1,divisor} : ~{1'b0,divisor} + 1'b1; \n        end\n        else if(start_cnt) begin\n            if(cnt[3]) begin    \n                cnt <= 0;\n                start_cnt <= 1'b0;\n                \n                SR[15:8] <= mux_result[7:0];\n                SR[0] <= CO;\n            end\n            else begin\n                cnt <= cnt + 1;\n\n                SR[15:0] <= {mux_result[6:0],SR[7:1],CO,1'b0}; \n            end\n        end\n    end\n\n    wire data_go;\n    assign data_go = res_valid & res_ready;\n    always @(posedge clk) begin\n        res_valid <= rst     ? 1'b0 :\n                     cnt[3]  ? 1'b1 :\n                     data_go ? 1'b0 : res_valid;\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns/1ps\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n\n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    reg [7:0] dividend_save, divisor_save;\n    reg [15:0] SR;                  \n    reg [8 :0] NEG_DIVISOR;        \n    wire [7:0] REMAINER, QUOTIENT;\n    assign REMAINER = SR[15:8];\n    assign QUOTIENT = SR[7: 0];\n\n    wire [7:0] divident_abs;\n    wire [8:0] divisor_abs;\n    wire [7:0] remainer, quotient;\n\n    assign divident_abs = (sign & dividend[7]) ? ~dividend + 1'b1 : dividend;\n    assign remainer = (sign & dividend_save[7]) ? ~REMAINER + 1'b1 : REMAINER;\n    assign quotient = sign & (dividend_save[7] ^ divisor_save[7]) ? ~QUOTIENT + 1'b1 : QUOTIENT;\n    assign result = {remainer,quotient};\n\n    wire CO;\n    wire [8:0] sub_result;\n    wire [8:0] mux_result;\n\n    assign {CO,sub_result} = {1'b0,REMAINER} + NEG_DIVISOR;\n\n    assign mux_result = CO ? sub_result : {1'b0,REMAINER};\n\n    reg [3:0] cnt;\n    reg start_cnt;\n    \n        else if(~start_cnt & opn_valid & ~res_valid) begin\n            cnt <= 1;\n            start_cnt <= 1'b1;\n        \n            dividend_save <= dividend;\n            divisor_save <= divisor;\n\n            SR[15:0] <= {7'b0,divident_abs,1'b0}; \n            NEG_DIVISOR <= (sign & divisor[7]) ? {1'b1,divisor} : ~{1'b0,divisor} + 1'b1; \n        end\n        else if(start_cnt) begin\n            if(cnt[3]) begin    \n                cnt <= 0;\n                start_cnt <= 1'b0;\n                \n                SR[15:8] <= mux_result[7:0];\n                SR[0] <= CO;\n            end\n            else begin\n                cnt <= cnt + 1;\n\n                SR[15:0] <= {mux_result[6:0],SR[7:1],CO,1'b0}; \n            end\n        end\n    end\n\n    wire data_go;\n    assign data_go = res_valid & res_ready;\n    always @(posedge clk) begin\n        res_valid <= rst     ? 1'b0 :\n                     cnt[3]  ? 1'b1 :\n                     data_go ? 1'b0 : res_valid;\n    end\nendmodule\n", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 41, "original_snippet": "always @(posedge clk) begin\n        if(rst) begin\n            SR <= 0;\n            dividend_save <= 0;\n            divisor_save <= 0;\n\n            cnt <= 0;\n            start_cnt <= 1'b0;\n        end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 41: Original: always @(posedge clk) begin\n        if(rst) begin\n            SR <= 0;\n            dividend_save <= 0;\n            divisor_save <= 0;\n\n            cnt <= 0;\n            start_cnt <= 1'b0;\n        end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 41.\n   \u2022 Restore the original code: always @(posedge clk) begin\n        if(rst) begin\n            SR <= 0;\n            dividend_save <= 0;\n            divisor_save <= 0;\n\n            cnt <= 0;\n            start_cnt <= 1'b0;\n        end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 29, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.371753", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Divider", "design_name": "radix2_div", "module_name": "radix2_div", "description": "Please act as a professional verilog designer.\n\nImplement a simplified radix-2 divider on 8-bit signed or unsigned integers. and the inputs are two 8-bit operands. The module accepts a dividend and a divisor as inputs and provides a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule name:  \n    radix2_div \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst: The reset signal to initialize or reset the module.\n    sign: 1-bit indicates if the operation is signed (1) or unsigned (0).\n    dividend: 8-bit input signal representing the dividend for division.\n    divisor: 8-bit input signal representing the divisor for division.\n    opn_valid: 1-bit indicates that a valid operation request is present.\nOutput ports:\n    res_valid: 1-bit output signal indicating the result is valid and ready.\n    result: 16-bit the output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nOperation Start:\nWhen opn_valid is high and res_valid is low, the module saves the inputs dividend and divisor.\nInitializes the shift register SR with the absolute value of the dividend shifted left by one bit.\nSets NEG_DIVISOR to the negated absolute value of the divisor.\nSets the counter cnt to 1 and start_cnt to 1 to begin the division process.\n\nDivision Process(If start_cnt is high, the module performs the following steps):\nIf the counter cnt reaches 8 (most significant bit of cnt is set), the division is complete:\ncnt and start_cnt are cleared.\nUpdates the shift register SR with the final remainder and quotient.\nOtherwise, the counter cnt is incremented, and the shift register SR is updated based on the subtraction result:\nComputes the subtraction of NEG_DIVISOR.\nUses a multiplexer to select the appropriate result based on the carry-out.\nUpdates SR by shifting left and inserting the carry-out.\n\nResult Validity:\nres_valid is managed based on the reset signal, the counter, and whether the result has been consumed.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ps\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n\n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    reg [7:0] dividend_save, divisor_save;\n    reg [15:0] SR;                  \n    reg [8 :0] NEG_DIVISOR;        \n    wire [7:0] REMAINER, QUOTIENT;\n    assign REMAINER = SR[15:8];\n    assign QUOTIENT = SR[7: 0];\n\n    wire [7:0] divident_abs;\n    wire [8:0] divisor_abs;\n    wire [7:0] remainer, quotient;\n\n    assign divident_abs = (sign & dividend[7]) ? ~dividend + 1'b1 : dividend;\n    assign remainer = (sign & dividend_save[7]) ? ~REMAINER + 1'b1 : REMAINER;\n    assign quotient = sign & (dividend_save[7] ^ divisor_save[7]) ? ~QUOTIENT + 1'b1 : QUOTIENT;\n    assign result = {remainer,quotient};\n\n    wire CO;\n    wire [8:0] sub_result;\n    wire [8:0] mux_result;\n\n    assign {CO,sub_result} = {1'b0,REMAINER} + NEG_DIVISOR;\n\n    assign mux_result = CO ? sub_result : {1'b0,REMAINER};\n\n    reg [3:0] cnt;\n    reg start_cnt;\n    always @(posedge clk) begin\n        if(rst) begin\n            SR <= 0;\n            dividend_save <= 0;\n            divisor_save <= 0;\n\n            cnt <= 0;\n            start_cnt <= 1'b0;\n        end\n        else if(~start_cnt & opn_valid & ~res_valid) begin\n            cnt <= 1;\n            start_cnt <= 1'b1;\n        \n            dividend_save <= dividend;\n            divisor_save <= divisor;\n\n            SR[15:0] <= {7'b0,divident_abs,1'b0}; \n            NEG_DIVISOR <= (sign & divisor[7]) ? {1'b1,divisor} : ~{1'b0,divisor} + 1'b1; \n        end\n        else if(start_cnt) begin\n            if(cnt[3]) begin    \n                cnt <= 0;\n                start_cnt <= 1'b0;\n                \n                SR[15:8] <= mux_result[7:0];\n                SR[0] <= CO;\n            end\n            else begin\n                cnt <= cnt + 1;\n\n                SR[15:0] <= {mux_result[6:0],SR[7:1],CO,1'b0}; \n            end\n        end\n    end\n\n    wire data_go;\n    assign data_go = res_valid & res_ready;\n    always @(posedge clk) begin\n        res_valid <= rst     ? 1'b0 :\n                     cnt[3]  ? 1'b1 :\n                     data_go ? 1'b0 : res_valid;\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns/1ps\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n\n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    reg [7:0] dividend_save, divisor_save;\n    reg [15:0] SR;                  \n    reg [8 :0] NEG_DIVISOR;        \n    wire [7:0] REMAINER, QUOTIENT;\n    assign REMAINER = SR[15:8];\n    assign QUOTIENT = SR[7: 0];\n\n    wire [7:0] divident_abs;\n    wire [8:0] divisor_abs;\n    wire [7:0] remainer, quotient;\n\n    assign divident_abs = (sign & dividend[7]) ? ~dividend + 1'b1 : dividend;\n    assign remainer = (sign & dividend_save[7]) ? ~REMAINER + 1'b1 : REMAINER;\n    assign quotient = sign & (dividend_save[7] ^ divisor_save[7]) ? ~QUOTIENT + 1'b1 : QUOTIENT;\n    assign result = {remainer,quotient};\n\n    wire CO;\n    wire [8:0] sub_result;\n    wire [8:0] mux_result;\n\n    assign {CO,sub_result} = {1'b0,REMAINER} + NEG_DIVISOR;\n\n    assign mux_result = CO ? sub_result : {1'b0,REMAINER};\n\n    reg [3:0] cnt;\n    reg start_cnt;\n    always @(posedge clk) begin\n        if(rst) begin\n                cnt <= cnt + 1;\n\n                SR[15:0] <= {mux_result[6:0],SR[7:1],CO,1'b0}; \n            end\n            else begin\n            SR <= 0;\n            dividend_save <= 0;\n            divisor_save <= 0;\n\n            cnt <= 0;\n            start_cnt <= 1'b0;\n        end\n        else if(~start_cnt & opn_valid & ~res_valid) begin\n            cnt <= 1;\n            start_cnt <= 1'b1;\n        \n            dividend_save <= dividend;\n            divisor_save <= divisor;\n\n            SR[15:0] <= {7'b0,divident_abs,1'b0}; \n            NEG_DIVISOR <= (sign & divisor[7]) ? {1'b1,divisor} : ~{1'b0,divisor} + 1'b1; \n        end\n        else if(start_cnt) begin\n            if(cnt[3]) begin    \n                cnt <= 0;\n                start_cnt <= 1'b0;\n                \n                SR[15:8] <= mux_result[7:0];\n                SR[0] <= CO;\n            end\n        end\n    end\n\n    wire data_go;\n    assign data_go = res_valid & res_ready;\n    always @(posedge clk) begin\n        res_valid <= rst     ? 1'b0 :\n                     cnt[3]  ? 1'b1 :\n                     data_go ? 1'b0 : res_valid;\n    end\nendmodule\n", "corruption_explanation": "Swapped if and else bodies", "modification_type": "invert_if_else", "modification_line": 42, "original_snippet": "if(rst) begin\n            SR <= 0;\n            dividend_save <= 0;\n            divisor_save <= 0;\n\n            cnt <= 0;\n            start_cnt <= 1'b0;\n        end\n        else if(~start_cnt & opn_val", "modified_snippet": "if(rst) begin\n                cnt <= cnt + 1;\n\n                SR[15:0] <= {mux_result[6:0],SR[7:1],CO,1'b0}; \n            end\n            else begin\n            SR <= 0;\n            dividend_save <= ", "issue_description": "The buggy code has swapped if and else bodies in a conditional block. This causes the logic to execute the opposite branch for each condition, leading to incorrect behavior when the condition is true vs false. Test cases that depend on the conditional logic will fail because the intended branch is not executed.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module contains conditional logic that should execute different code paths based on a condition.\n   \u2022 The if branch should handle the true case, and the else branch should handle the false case.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Identified a conditional block with both if and else branches.\n   \u2022 The branches contain different assignments or logic operations.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The if and else bodies have been swapped.\n   \u2022 Logic that should execute when condition is true now executes when false, and vice versa.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The conditional bodies are inverted.\n   \u2022 Impact: All conditional behavior is reversed, causing incorrect outputs for all test cases.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Swap the if and else bodies back to their correct positions.\n   \u2022 Verify that the condition evaluates correctly and executes the intended branch.\n\n6. RTL Design Principle Violated:\n   \u2022 Correct conditional logic requires matching the intended behavior with the branch bodies.", "complexity": 29, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_if_else"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.374382", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Divider", "design_name": "radix2_div", "module_name": "radix2_div", "description": "Please act as a professional verilog designer.\n\nImplement a simplified radix-2 divider on 8-bit signed or unsigned integers. and the inputs are two 8-bit operands. The module accepts a dividend and a divisor as inputs and provides a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule name:  \n    radix2_div \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst: The reset signal to initialize or reset the module.\n    sign: 1-bit indicates if the operation is signed (1) or unsigned (0).\n    dividend: 8-bit input signal representing the dividend for division.\n    divisor: 8-bit input signal representing the divisor for division.\n    opn_valid: 1-bit indicates that a valid operation request is present.\nOutput ports:\n    res_valid: 1-bit output signal indicating the result is valid and ready.\n    result: 16-bit the output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nOperation Start:\nWhen opn_valid is high and res_valid is low, the module saves the inputs dividend and divisor.\nInitializes the shift register SR with the absolute value of the dividend shifted left by one bit.\nSets NEG_DIVISOR to the negated absolute value of the divisor.\nSets the counter cnt to 1 and start_cnt to 1 to begin the division process.\n\nDivision Process(If start_cnt is high, the module performs the following steps):\nIf the counter cnt reaches 8 (most significant bit of cnt is set), the division is complete:\ncnt and start_cnt are cleared.\nUpdates the shift register SR with the final remainder and quotient.\nOtherwise, the counter cnt is incremented, and the shift register SR is updated based on the subtraction result:\nComputes the subtraction of NEG_DIVISOR.\nUses a multiplexer to select the appropriate result based on the carry-out.\nUpdates SR by shifting left and inserting the carry-out.\n\nResult Validity:\nres_valid is managed based on the reset signal, the counter, and whether the result has been consumed.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ps\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n\n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    reg [7:0] dividend_save, divisor_save;\n    reg [15:0] SR;                  \n    reg [8 :0] NEG_DIVISOR;        \n    wire [7:0] REMAINER, QUOTIENT;\n    assign REMAINER = SR[15:8];\n    assign QUOTIENT = SR[7: 0];\n\n    wire [7:0] divident_abs;\n    wire [8:0] divisor_abs;\n    wire [7:0] remainer, quotient;\n\n    assign divident_abs = (sign & dividend[7]) ? ~dividend + 1'b1 : dividend;\n    assign remainer = (sign & dividend_save[7]) ? ~REMAINER + 1'b1 : REMAINER;\n    assign quotient = sign & (dividend_save[7] ^ divisor_save[7]) ? ~QUOTIENT + 1'b1 : QUOTIENT;\n    assign result = {remainer,quotient};\n\n    wire CO;\n    wire [8:0] sub_result;\n    wire [8:0] mux_result;\n\n    assign {CO,sub_result} = {1'b0,REMAINER} + NEG_DIVISOR;\n\n    assign mux_result = CO ? sub_result : {1'b0,REMAINER};\n\n    reg [3:0] cnt;\n    reg start_cnt;\n    always @(posedge clk) begin\n        if(rst) begin\n            SR <= 0;\n            dividend_save <= 0;\n            divisor_save <= 0;\n\n            cnt <= 0;\n            start_cnt <= 1'b0;\n        end\n        else if(~start_cnt & opn_valid & ~res_valid) begin\n            cnt <= 1;\n            start_cnt <= 1'b1;\n        \n            dividend_save <= dividend;\n            divisor_save <= divisor;\n\n            SR[15:0] <= {7'b0,divident_abs,1'b0}; \n            NEG_DIVISOR <= (sign & divisor[7]) ? {1'b1,divisor} : ~{1'b0,divisor} + 1'b1; \n        end\n        else if(start_cnt) begin\n            if(cnt[3]) begin    \n                cnt <= 0;\n                start_cnt <= 1'b0;\n                \n                SR[15:8] <= mux_result[7:0];\n                SR[0] <= CO;\n            end\n            else begin\n                cnt <= cnt + 1;\n\n                SR[15:0] <= {mux_result[6:0],SR[7:1],CO,1'b0}; \n            end\n        end\n    end\n\n    wire data_go;\n    assign data_go = res_valid & res_ready;\n    always @(posedge clk) begin\n        res_valid <= rst     ? 1'b0 :\n                     cnt[3]  ? 1'b1 :\n                     data_go ? 1'b0 : res_valid;\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns/1ps\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n\n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    reg [7:0] dividend_save, divisor_save;\n    reg [15:0] SR;                  \n    reg [8 :0] NEG_DIVISOR;        \n    wire [7:0] REMAINER, QUOTIENT;\n    assign REMAINER = SR[15:8];\n    assign QUOTIENT = SR[7: 0];\n\n    wire [7:0] divident_abs;\n    wire [8:0] divisor_abs;\n    wire [7:0] remainer, quotient;\n\n    assign divident_abs = (sign & dividend[7]) ? ~dividend + 1'b1 : dividend;\n    assign remainer = (sign & dividend_save[7]) ? ~REMAINER + 1'b1 : REMAINER;\n    assign quotient = sign & (dividend_save[7] ^ divisor_save[7]) ? ~QUOTIENT + 1'b1 : QUOTIENT;\n    assign result = {remainer,quotient};\n\n    wire CO;\n    wire [8:0] sub_result;\n    wire [8:0] mux_result;\n\n    assign {CO,sub_result} = {1'b0,REMAINER} + NEG_DIVISOR;\n\n    assign mux_result = CO ? sub_result : {1'b0,REMAINER};\n\n    reg [3:0] cnt;\n    reg start_cnt;\n    always @(posedge clk) begin\n        if(rst) begin\n            SR <= 0;\n            dividend_save <= 0;\n            divisor_save <= 0;\n\n            cnt <= 0;\n            start_cnt <= 1'b0;\n        end\n        else if(~start_cnt & opn_valid & ~res_valid) begin\n            cnt <= 1;\n            start_cnt <= 1'b1;\n        \n            dividend_save <= dividend;\n            divisor_save <= divisor;\n\n            SR[15:0] <= {7'b0,divident_abs,1'b0}; \n            NEG_DIVISOR <= (sign & divisor[7]) ? {1'b1,divisor} : ~{1'b0,divisor} + 1'b1; \n        end\n        else if(start_cnt) begin\n            if(cnt[3]) begin    \n                cnt <= 0;\n                start_cnt <= 1'b0;\n                \n                SR[15:8] <= mux_result[7:0];\n                SR[0] <= CO;\n            end\n            else begin\n                cnt <= cnt + 1;\n\n                SR[15:0] <= {mux_result[6:0],SR[7:1],CO,1'b0}; \n            end\n        end\n    end\n\n    wire data_go;\n    assign data_go = res_valid & res_ready;\nassign data_go = 1'b0;  // Conflicting assignment\n    always @(posedge clk) begin\n        res_valid <= rst     ? 1'b0 :\n                     cnt[3]  ? 1'b1 :\n                     data_go ? 1'b0 : res_valid;\n    end\nendmodule\n", "corruption_explanation": "Added conflicting driver for signal 'data_go'", "modification_type": "add_multiple_driver", "modification_line": 77, "original_snippet": "assign data_go = res_valid & res_ready;", "modified_snippet": "assign data_go = res_valid & res_ready;\nassign data_go = 1'b0;  // Conflicting assignment", "issue_description": "The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_multiple_driver modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added conflicting driver for signal 'data_go'\n   \u2022 Line 77: Original: assign data_go = res_valid & res_ready;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 77.\n   \u2022 Restore the original code: assign data_go = res_valid & res_ready;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add multiple driver.", "complexity": 29, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["add_multiple_driver"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.377249", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Accumulator", "design_name": "accu", "module_name": "accu", "description": "Please act as a professional verilog designer.\n\nImplement a module to achieve serial input data accumulation output, input is 8bit data. The valid_in will be set to 1 before the first data comes in. Whenever the module receives 4 input data, the data_out outputs 4 received data accumulation results and sets the valid_out to be 1 (will last only 1 cycle).\n\nModule name:  \n    accu               \nInput ports:\n\tclk: Clock input for synchronization.\n\trst_n: Active-low reset signal.\n\tdata_in[7:0]: 8-bit input data for addition.\n\tvalid_in: Input signal indicating readiness for new data.   \nOutput ports:\n    valid_out: Output signal indicating when 4 input data accumulation is reached.\n\tdata_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nWhen valid_in is 1, data_in is a valid input. Accumulate four valid input data_in values and calculate the output data_out by adding these four values together. \nThere is no output when there are fewer than four data_in inputs in the interim. Along with the output data_out, a cycle of valid_out=1 will appear as a signal. \nThe valid_out signal is set to 1 when the data_out outputs 4 received data accumulation results. Otherwise, it is set to 0.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\nmodule accu(\n    input               clk         ,   \n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               valid_in     ,\n \n    output  reg         valid_out     ,\n    output  reg [9:0]   data_out\n);\n    \n   reg [1:0] count;\n   wire add_cnt;\n   wire ready_add;\n   wire end_cnt;\n   reg [9:0]   data_out_reg;\n\n   assign add_cnt = ready_add;\n   assign end_cnt = ready_add && (count == 'd3);\n   \n   //count\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n          count <= 0;\n       end\n       else if(end_cnt) begin\n          count <= 0;\n       end\n       else if(add_cnt) begin\n          count <= count + 1;\n       end\n   end\n\n    //data_out_reg\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out_reg <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out_reg <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out_reg <= data_out_reg + data_in;\n      end\n   end\n\n    //data_out\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out <= data_out + data_in;\n      end\n   end\n\n   //ready_add\n   assign ready_add = !valid_out | valid_in;\n\n   //valid_out\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n           valid_out <= 0;\n       end\n       else if(end_cnt) begin\n           valid_out <= 1;\n       end\n       else begin\n           valid_out <= 0;\n       end\n   end  \n     \nendmodule", "corrupted_code": "`timescale 1ns/1ns\n\nmodule accu(\n    input               clk         ,   \n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               valid_in     ,\n \n    output  reg         valid_out     ,\n    output  reg [9:0]   data_out\n);\n    \n   reg [1:0] count;\n   wire add_cnt;\n   wire ready_add;\n   wire end_cnt;\n   reg [9:0]   data_out_reg;\n\n   assign add_cnt = ready_add;\n   assign end_cnt = ready_add && (count == 'd3);\n   \n   //count\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n          count <= 0;\n       end\n       else if(end_cnt) begin\n          count <= 0;\n       end\n       else if(add_cnt) begin\n          count <= count + 1;\n       end\n   end\n\n    //data_out_reg\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out_reg <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out_reg <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out_reg <= data_out_reg + data_in;\n      end\n   end\n\n    //data_out\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n\n      end\n      else if (add_cnt) begin\n          data_out <= data_out + data_in;\n      end\n   end\n\n   //ready_add\n   assign ready_add = !valid_out | valid_in;\n\n   //valid_out\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n           valid_out <= 0;\n       end\n       else if(end_cnt) begin\n           valid_out <= 1;\n       end\n       else begin\n           valid_out <= 0;\n       end\n   end  \n     \nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 54, "original_snippet": "data_out <= data_in;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 54: Original: data_out <= data_in;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 54.\n   \u2022 Restore the original code: data_out <= data_in;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 36, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.381050", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Accumulator", "design_name": "accu", "module_name": "accu", "description": "Please act as a professional verilog designer.\n\nImplement a module to achieve serial input data accumulation output, input is 8bit data. The valid_in will be set to 1 before the first data comes in. Whenever the module receives 4 input data, the data_out outputs 4 received data accumulation results and sets the valid_out to be 1 (will last only 1 cycle).\n\nModule name:  \n    accu               \nInput ports:\n\tclk: Clock input for synchronization.\n\trst_n: Active-low reset signal.\n\tdata_in[7:0]: 8-bit input data for addition.\n\tvalid_in: Input signal indicating readiness for new data.   \nOutput ports:\n    valid_out: Output signal indicating when 4 input data accumulation is reached.\n\tdata_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nWhen valid_in is 1, data_in is a valid input. Accumulate four valid input data_in values and calculate the output data_out by adding these four values together. \nThere is no output when there are fewer than four data_in inputs in the interim. Along with the output data_out, a cycle of valid_out=1 will appear as a signal. \nThe valid_out signal is set to 1 when the data_out outputs 4 received data accumulation results. Otherwise, it is set to 0.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\nmodule accu(\n    input               clk         ,   \n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               valid_in     ,\n \n    output  reg         valid_out     ,\n    output  reg [9:0]   data_out\n);\n    \n   reg [1:0] count;\n   wire add_cnt;\n   wire ready_add;\n   wire end_cnt;\n   reg [9:0]   data_out_reg;\n\n   assign add_cnt = ready_add;\n   assign end_cnt = ready_add && (count == 'd3);\n   \n   //count\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n          count <= 0;\n       end\n       else if(end_cnt) begin\n          count <= 0;\n       end\n       else if(add_cnt) begin\n          count <= count + 1;\n       end\n   end\n\n    //data_out_reg\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out_reg <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out_reg <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out_reg <= data_out_reg + data_in;\n      end\n   end\n\n    //data_out\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out <= data_out + data_in;\n      end\n   end\n\n   //ready_add\n   assign ready_add = !valid_out | valid_in;\n\n   //valid_out\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n           valid_out <= 0;\n       end\n       else if(end_cnt) begin\n           valid_out <= 1;\n       end\n       else begin\n           valid_out <= 0;\n       end\n   end  \n     \nendmodule", "corrupted_code": "`timescale 1ns/1ns\n\nmodule accu(\n    input               clk         ,   \n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               valid_in     ,\n \n    output  reg         valid_out     ,\n    output  reg [9:0]   data_out\n);\n    \n   reg [1:0] count;\n   wire add_cnt;\n   wire ready_add;\n   wire end_cnt;\n   reg [9:0]   data_out_reg;\n\n   assign add_cnt = ready_add;\n   assign end_cnt = ready_add && (count == 'd3);\n   \n   //count\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n          count <= 0;\n       end\n       else if(end_cnt) begin\n          count <= 0;\n       end\n       else if(add_cnt) begin\n          count <= count + 1;\n       end\n   end\n\n    //data_out_reg\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out_reg <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out_reg <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out_reg <= data_out_reg + data_in;\n      end\n   end\n\n    //data_out\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out <= data_out + data_in;\n      end\n   end\n\n   //ready_add\n   assign ready_add = !valid_out | valid_in;\n\n   //valid_out\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n           valid_out <= 0;\n       end\n       else if(end_cnt) begin\n           valid_out <= 1;\n       end\n       else begin\n           valid_out = 0;\n       end\n   end  \n     \nendmodule", "corruption_explanation": "Changed non-blocking (<=) to blocking (=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 73, "original_snippet": "valid_out <= 0;", "modified_snippet": "valid_out = 0;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 36, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.383566", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Accumulator", "design_name": "accu", "module_name": "accu", "description": "Please act as a professional verilog designer.\n\nImplement a module to achieve serial input data accumulation output, input is 8bit data. The valid_in will be set to 1 before the first data comes in. Whenever the module receives 4 input data, the data_out outputs 4 received data accumulation results and sets the valid_out to be 1 (will last only 1 cycle).\n\nModule name:  \n    accu               \nInput ports:\n\tclk: Clock input for synchronization.\n\trst_n: Active-low reset signal.\n\tdata_in[7:0]: 8-bit input data for addition.\n\tvalid_in: Input signal indicating readiness for new data.   \nOutput ports:\n    valid_out: Output signal indicating when 4 input data accumulation is reached.\n\tdata_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nWhen valid_in is 1, data_in is a valid input. Accumulate four valid input data_in values and calculate the output data_out by adding these four values together. \nThere is no output when there are fewer than four data_in inputs in the interim. Along with the output data_out, a cycle of valid_out=1 will appear as a signal. \nThe valid_out signal is set to 1 when the data_out outputs 4 received data accumulation results. Otherwise, it is set to 0.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\nmodule accu(\n    input               clk         ,   \n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               valid_in     ,\n \n    output  reg         valid_out     ,\n    output  reg [9:0]   data_out\n);\n    \n   reg [1:0] count;\n   wire add_cnt;\n   wire ready_add;\n   wire end_cnt;\n   reg [9:0]   data_out_reg;\n\n   assign add_cnt = ready_add;\n   assign end_cnt = ready_add && (count == 'd3);\n   \n   //count\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n          count <= 0;\n       end\n       else if(end_cnt) begin\n          count <= 0;\n       end\n       else if(add_cnt) begin\n          count <= count + 1;\n       end\n   end\n\n    //data_out_reg\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out_reg <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out_reg <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out_reg <= data_out_reg + data_in;\n      end\n   end\n\n    //data_out\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out <= data_out + data_in;\n      end\n   end\n\n   //ready_add\n   assign ready_add = !valid_out | valid_in;\n\n   //valid_out\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n           valid_out <= 0;\n       end\n       else if(end_cnt) begin\n           valid_out <= 1;\n       end\n       else begin\n           valid_out <= 0;\n       end\n   end  \n     \nendmodule", "corrupted_code": "`timescale 1ns/1ns\n\nmodule accu(\n    input               clk         ,   \n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               valid_in     ,\n \n    output  reg         valid_out     ,\n    output  reg [9:0]   data_out\n);\n    \n   reg [1:0] count;\n   wire add_cnt;\n   wire ready_add;\n   wire end_cnt;\n   reg [9:0]   data_out_reg;\n\n   assign add_cnt = ready_add;\n   assign end_cnt = ready_add && (count == 'd3);\n   \n   //count\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n          count <= 0;\n       end\n       else if(end_cnt) begin\n          count = 0;\n       end\n       else if(add_cnt) begin\n          count <= count + 1;\n       end\n   end\n\n    //data_out_reg\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out_reg <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out_reg <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out_reg <= data_out_reg + data_in;\n      end\n   end\n\n    //data_out\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out <= data_out + data_in;\n      end\n   end\n\n   //ready_add\n   assign ready_add = !valid_out | valid_in;\n\n   //valid_out\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n           valid_out <= 0;\n       end\n       else if(end_cnt) begin\n           valid_out <= 1;\n       end\n       else begin\n           valid_out <= 0;\n       end\n   end  \n     \nendmodule", "corruption_explanation": "Changed non-blocking (<=) to blocking (=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 28, "original_snippet": "count <= 0;", "modified_snippet": "count = 0;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 36, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.386049", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Accumulator", "design_name": "accu", "module_name": "accu", "description": "Please act as a professional verilog designer.\n\nImplement a module to achieve serial input data accumulation output, input is 8bit data. The valid_in will be set to 1 before the first data comes in. Whenever the module receives 4 input data, the data_out outputs 4 received data accumulation results and sets the valid_out to be 1 (will last only 1 cycle).\n\nModule name:  \n    accu               \nInput ports:\n\tclk: Clock input for synchronization.\n\trst_n: Active-low reset signal.\n\tdata_in[7:0]: 8-bit input data for addition.\n\tvalid_in: Input signal indicating readiness for new data.   \nOutput ports:\n    valid_out: Output signal indicating when 4 input data accumulation is reached.\n\tdata_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nWhen valid_in is 1, data_in is a valid input. Accumulate four valid input data_in values and calculate the output data_out by adding these four values together. \nThere is no output when there are fewer than four data_in inputs in the interim. Along with the output data_out, a cycle of valid_out=1 will appear as a signal. \nThe valid_out signal is set to 1 when the data_out outputs 4 received data accumulation results. Otherwise, it is set to 0.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\nmodule accu(\n    input               clk         ,   \n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               valid_in     ,\n \n    output  reg         valid_out     ,\n    output  reg [9:0]   data_out\n);\n    \n   reg [1:0] count;\n   wire add_cnt;\n   wire ready_add;\n   wire end_cnt;\n   reg [9:0]   data_out_reg;\n\n   assign add_cnt = ready_add;\n   assign end_cnt = ready_add && (count == 'd3);\n   \n   //count\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n          count <= 0;\n       end\n       else if(end_cnt) begin\n          count <= 0;\n       end\n       else if(add_cnt) begin\n          count <= count + 1;\n       end\n   end\n\n    //data_out_reg\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out_reg <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out_reg <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out_reg <= data_out_reg + data_in;\n      end\n   end\n\n    //data_out\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out <= data_out + data_in;\n      end\n   end\n\n   //ready_add\n   assign ready_add = !valid_out | valid_in;\n\n   //valid_out\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n           valid_out <= 0;\n       end\n       else if(end_cnt) begin\n           valid_out <= 1;\n       end\n       else begin\n           valid_out <= 0;\n       end\n   end  \n     \nendmodule", "corrupted_code": "`timescale 1ns/1ns\n\nmodule accu(\n    input               clk         ,   \n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               valid_in     ,\n \n    output  reg         valid_out     ,\n    output  reg [9:0]   data_out\n);\n    \n   reg [1:0] count;\n   wire add_cnt;\n   wire ready_add;\n   wire end_cnt;\n   reg [9:0]   data_out_reg;\n\n   assign add_cnt = ready_add;\n   assign end_cnt = ready_add && (count == 'd3);\nassign end_cnt = 1'b0;  // Conflicting assignment\n   \n   //count\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n          count <= 0;\n       end\n       else if(end_cnt) begin\n          count <= 0;\n       end\n       else if(add_cnt) begin\n          count <= count + 1;\n       end\n   end\n\n    //data_out_reg\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out_reg <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out_reg <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out_reg <= data_out_reg + data_in;\n      end\n   end\n\n    //data_out\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out <= data_out + data_in;\n      end\n   end\n\n   //ready_add\n   assign ready_add = !valid_out | valid_in;\n\n   //valid_out\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n           valid_out <= 0;\n       end\n       else if(end_cnt) begin\n           valid_out <= 1;\n       end\n       else begin\n           valid_out <= 0;\n       end\n   end  \n     \nendmodule", "corruption_explanation": "Added conflicting driver for signal 'end_cnt'", "modification_type": "add_multiple_driver", "modification_line": 20, "original_snippet": "assign end_cnt = ready_add && (count == 'd3);", "modified_snippet": "assign end_cnt = ready_add && (count == 'd3);\nassign end_cnt = 1'b0;  // Conflicting assignment", "issue_description": "The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_multiple_driver modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added conflicting driver for signal 'end_cnt'\n   \u2022 Line 20: Original: assign end_cnt = ready_add && (count == 'd3);\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 20.\n   \u2022 Restore the original code: assign end_cnt = ready_add && (count == 'd3);\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add multiple driver.", "complexity": 36, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["add_multiple_driver"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.388687", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Accumulator", "design_name": "accu", "module_name": "accu", "description": "Please act as a professional verilog designer.\n\nImplement a module to achieve serial input data accumulation output, input is 8bit data. The valid_in will be set to 1 before the first data comes in. Whenever the module receives 4 input data, the data_out outputs 4 received data accumulation results and sets the valid_out to be 1 (will last only 1 cycle).\n\nModule name:  \n    accu               \nInput ports:\n\tclk: Clock input for synchronization.\n\trst_n: Active-low reset signal.\n\tdata_in[7:0]: 8-bit input data for addition.\n\tvalid_in: Input signal indicating readiness for new data.   \nOutput ports:\n    valid_out: Output signal indicating when 4 input data accumulation is reached.\n\tdata_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nWhen valid_in is 1, data_in is a valid input. Accumulate four valid input data_in values and calculate the output data_out by adding these four values together. \nThere is no output when there are fewer than four data_in inputs in the interim. Along with the output data_out, a cycle of valid_out=1 will appear as a signal. \nThe valid_out signal is set to 1 when the data_out outputs 4 received data accumulation results. Otherwise, it is set to 0.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\nmodule accu(\n    input               clk         ,   \n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               valid_in     ,\n \n    output  reg         valid_out     ,\n    output  reg [9:0]   data_out\n);\n    \n   reg [1:0] count;\n   wire add_cnt;\n   wire ready_add;\n   wire end_cnt;\n   reg [9:0]   data_out_reg;\n\n   assign add_cnt = ready_add;\n   assign end_cnt = ready_add && (count == 'd3);\n   \n   //count\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n          count <= 0;\n       end\n       else if(end_cnt) begin\n          count <= 0;\n       end\n       else if(add_cnt) begin\n          count <= count + 1;\n       end\n   end\n\n    //data_out_reg\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out_reg <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out_reg <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out_reg <= data_out_reg + data_in;\n      end\n   end\n\n    //data_out\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out <= data_out + data_in;\n      end\n   end\n\n   //ready_add\n   assign ready_add = !valid_out | valid_in;\n\n   //valid_out\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n           valid_out <= 0;\n       end\n       else if(end_cnt) begin\n           valid_out <= 1;\n       end\n       else begin\n           valid_out <= 0;\n       end\n   end  \n     \nendmodule", "corrupted_code": "`timescale 1ns/1ns\n\nmodule accu(\n    input               clk         ,   \n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               valid_in     ,\n \n    output  reg         valid_out     ,\n    output  reg [9:0]   data_out\n);\n    \n   reg [1:0] count;\n   wire add_cnt;\n   wire ready_add;\n   wire end_cnt;\n   reg [9:0]   data_out_reg;\n\n   assign add_cnt = ready_add;\n   assign end_cnt = ready_add && (count == 'd3);\n   \n   //count\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n          count <= 0;\n       end\n       else if(end_cnt) begin\n          count <= 0;\n       end\n       else if(add_cnt) begin\n          count <= count + 1;\n       end\n   end\n\n    //data_out_reg\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out_reg <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out_reg <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out_reg <= data_out_reg + data_in;\n      end\n   end\n\n    //data_out\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out >= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out <= data_out + data_in;\n      end\n   end\n\n   //ready_add\n   assign ready_add = !valid_out | valid_in;\n\n   //valid_out\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n           valid_out <= 0;\n       end\n       else if(end_cnt) begin\n           valid_out <= 1;\n       end\n       else begin\n           valid_out <= 0;\n       end\n   end  \n     \nendmodule", "corruption_explanation": "Changed operator from '<=' to '>='", "modification_type": "change_operator", "modification_line": 51, "original_snippet": "t <= 0", "modified_snippet": "t >= 0", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '<=' to '>='\n   \u2022 Line 51: Original: t <= 0\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 51.\n   \u2022 Restore the original code: t <= 0\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 36, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.391209", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Accumulator", "design_name": "accu", "module_name": "accu", "description": "Please act as a professional verilog designer.\n\nImplement a module to achieve serial input data accumulation output, input is 8bit data. The valid_in will be set to 1 before the first data comes in. Whenever the module receives 4 input data, the data_out outputs 4 received data accumulation results and sets the valid_out to be 1 (will last only 1 cycle).\n\nModule name:  \n    accu               \nInput ports:\n\tclk: Clock input for synchronization.\n\trst_n: Active-low reset signal.\n\tdata_in[7:0]: 8-bit input data for addition.\n\tvalid_in: Input signal indicating readiness for new data.   \nOutput ports:\n    valid_out: Output signal indicating when 4 input data accumulation is reached.\n\tdata_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nWhen valid_in is 1, data_in is a valid input. Accumulate four valid input data_in values and calculate the output data_out by adding these four values together. \nThere is no output when there are fewer than four data_in inputs in the interim. Along with the output data_out, a cycle of valid_out=1 will appear as a signal. \nThe valid_out signal is set to 1 when the data_out outputs 4 received data accumulation results. Otherwise, it is set to 0.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\nmodule accu(\n    input               clk         ,   \n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               valid_in     ,\n \n    output  reg         valid_out     ,\n    output  reg [9:0]   data_out\n);\n    \n   reg [1:0] count;\n   wire add_cnt;\n   wire ready_add;\n   wire end_cnt;\n   reg [9:0]   data_out_reg;\n\n   assign add_cnt = ready_add;\n   assign end_cnt = ready_add && (count == 'd3);\n   \n   //count\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n          count <= 0;\n       end\n       else if(end_cnt) begin\n          count <= 0;\n       end\n       else if(add_cnt) begin\n          count <= count + 1;\n       end\n   end\n\n    //data_out_reg\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out_reg <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out_reg <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out_reg <= data_out_reg + data_in;\n      end\n   end\n\n    //data_out\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out <= data_out + data_in;\n      end\n   end\n\n   //ready_add\n   assign ready_add = !valid_out | valid_in;\n\n   //valid_out\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n           valid_out <= 0;\n       end\n       else if(end_cnt) begin\n           valid_out <= 1;\n       end\n       else begin\n           valid_out <= 0;\n       end\n   end  \n     \nendmodule", "corrupted_code": "`timescale 1ns/1ns\n\nmodule accu(\n    input               clk         ,   \n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               valid_in     ,\n \n    output  reg         valid_out     ,\n    output  reg [9:0]   data_out\n);\n    \n   reg [1:0] count;\n   wire add_cnt;\n   wire ready_add;\n   wire end_cnt;\n   reg [9:0]   data_out_reg;\n\n   assign add_cnt = ready_add;\n   assign end_cnt = ready_add && (count == 'd3);\n   \n   //count\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n          count <= 0;\n       end\n       else if(end_cnt) begin\n          count <= 0;\n       end\n       else if(add_cnt) begin\n          count <= count + 1;\n       end\n   end\n\n    //data_out_reg\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out_reg <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out_reg <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out_reg <= data_out_reg + data_in;\n      end\n   end\n\n    //data_out\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_in <= data_out;\n      end\n      else if (add_cnt) begin\n          data_out <= data_out + data_in;\n      end\n   end\n\n   //ready_add\n   assign ready_add = !valid_out | valid_in;\n\n   //valid_out\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n           valid_out <= 0;\n       end\n       else if(end_cnt) begin\n           valid_out <= 1;\n       end\n       else begin\n           valid_out <= 0;\n       end\n   end  \n     \nendmodule", "corruption_explanation": "Swapped operands: 'data_out <= data_in' -> 'data_in <= data_out'", "modification_type": "swap_operands", "modification_line": 54, "original_snippet": "data_out <= data_in", "modified_snippet": "data_in <= data_out", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'data_out <= data_in' -> 'data_in <= data_out'\n   \u2022 Line 54: Original: data_out <= data_in\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 54.\n   \u2022 Restore the original code: data_out <= data_in\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 36, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_operands"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.393542", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Accumulator", "design_name": "accu", "module_name": "accu", "description": "Please act as a professional verilog designer.\n\nImplement a module to achieve serial input data accumulation output, input is 8bit data. The valid_in will be set to 1 before the first data comes in. Whenever the module receives 4 input data, the data_out outputs 4 received data accumulation results and sets the valid_out to be 1 (will last only 1 cycle).\n\nModule name:  \n    accu               \nInput ports:\n\tclk: Clock input for synchronization.\n\trst_n: Active-low reset signal.\n\tdata_in[7:0]: 8-bit input data for addition.\n\tvalid_in: Input signal indicating readiness for new data.   \nOutput ports:\n    valid_out: Output signal indicating when 4 input data accumulation is reached.\n\tdata_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nWhen valid_in is 1, data_in is a valid input. Accumulate four valid input data_in values and calculate the output data_out by adding these four values together. \nThere is no output when there are fewer than four data_in inputs in the interim. Along with the output data_out, a cycle of valid_out=1 will appear as a signal. \nThe valid_out signal is set to 1 when the data_out outputs 4 received data accumulation results. Otherwise, it is set to 0.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\nmodule accu(\n    input               clk         ,   \n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               valid_in     ,\n \n    output  reg         valid_out     ,\n    output  reg [9:0]   data_out\n);\n    \n   reg [1:0] count;\n   wire add_cnt;\n   wire ready_add;\n   wire end_cnt;\n   reg [9:0]   data_out_reg;\n\n   assign add_cnt = ready_add;\n   assign end_cnt = ready_add && (count == 'd3);\n   \n   //count\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n          count <= 0;\n       end\n       else if(end_cnt) begin\n          count <= 0;\n       end\n       else if(add_cnt) begin\n          count <= count + 1;\n       end\n   end\n\n    //data_out_reg\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out_reg <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out_reg <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out_reg <= data_out_reg + data_in;\n      end\n   end\n\n    //data_out\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out <= data_out + data_in;\n      end\n   end\n\n   //ready_add\n   assign ready_add = !valid_out | valid_in;\n\n   //valid_out\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n           valid_out <= 0;\n       end\n       else if(end_cnt) begin\n           valid_out <= 1;\n       end\n       else begin\n           valid_out <= 0;\n       end\n   end  \n     \nendmodule", "corrupted_code": "`timescale 1ns/1ns\n\nmodule accu(\n    input               clk         ,   \n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               valid_in     ,\n \n    output  reg         valid_out     ,\n    output  reg [9:0]   data_out\n);\n    \n   reg [1:0] count;\n   wire add_cnt;\n   wire ready_add;\n   wire end_cnt;\n   reg [9:0]   data_out_reg;\n\n   assign add_cnt = ready_add;\n   assign end_cnt = ready_add && (count == 'd3);\n   \n   //count\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n          count <= 0;\n       end\n       else if(end_cnt) begin\n          count <= 0;\n       end\n       else if(add_cnt) begin\n          count <= count + 1;\n       end\n   end\n\n    //data_out_reg\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out_reg <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out_reg <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out_reg <= data_out_reg + data_in;\n      end\n   end\n\n    //data_out\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out <= data_out + data_in;\n      end\n   end\n\n   //ready_add\n   assign ready_add = !valid_out | valid_in;\nassign ready_add = 1'b0;  // Conflicting assignment\n\n   //valid_out\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n           valid_out <= 0;\n       end\n       else if(end_cnt) begin\n           valid_out <= 1;\n       end\n       else begin\n           valid_out <= 0;\n       end\n   end  \n     \nendmodule", "corruption_explanation": "Added conflicting driver for signal 'ready_add'", "modification_type": "add_multiple_driver", "modification_line": 62, "original_snippet": "assign ready_add = !valid_out | valid_in;", "modified_snippet": "assign ready_add = !valid_out | valid_in;\nassign ready_add = 1'b0;  // Conflicting assignment", "issue_description": "The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_multiple_driver modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added conflicting driver for signal 'ready_add'\n   \u2022 Line 62: Original: assign ready_add = !valid_out | valid_in;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 62.\n   \u2022 Restore the original code: assign ready_add = !valid_out | valid_in;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add multiple driver.", "complexity": 36, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["add_multiple_driver"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.395708", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Accumulator", "design_name": "accu", "module_name": "accu", "description": "Please act as a professional verilog designer.\n\nImplement a module to achieve serial input data accumulation output, input is 8bit data. The valid_in will be set to 1 before the first data comes in. Whenever the module receives 4 input data, the data_out outputs 4 received data accumulation results and sets the valid_out to be 1 (will last only 1 cycle).\n\nModule name:  \n    accu               \nInput ports:\n\tclk: Clock input for synchronization.\n\trst_n: Active-low reset signal.\n\tdata_in[7:0]: 8-bit input data for addition.\n\tvalid_in: Input signal indicating readiness for new data.   \nOutput ports:\n    valid_out: Output signal indicating when 4 input data accumulation is reached.\n\tdata_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nWhen valid_in is 1, data_in is a valid input. Accumulate four valid input data_in values and calculate the output data_out by adding these four values together. \nThere is no output when there are fewer than four data_in inputs in the interim. Along with the output data_out, a cycle of valid_out=1 will appear as a signal. \nThe valid_out signal is set to 1 when the data_out outputs 4 received data accumulation results. Otherwise, it is set to 0.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\nmodule accu(\n    input               clk         ,   \n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               valid_in     ,\n \n    output  reg         valid_out     ,\n    output  reg [9:0]   data_out\n);\n    \n   reg [1:0] count;\n   wire add_cnt;\n   wire ready_add;\n   wire end_cnt;\n   reg [9:0]   data_out_reg;\n\n   assign add_cnt = ready_add;\n   assign end_cnt = ready_add && (count == 'd3);\n   \n   //count\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n          count <= 0;\n       end\n       else if(end_cnt) begin\n          count <= 0;\n       end\n       else if(add_cnt) begin\n          count <= count + 1;\n       end\n   end\n\n    //data_out_reg\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out_reg <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out_reg <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out_reg <= data_out_reg + data_in;\n      end\n   end\n\n    //data_out\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out <= data_out + data_in;\n      end\n   end\n\n   //ready_add\n   assign ready_add = !valid_out | valid_in;\n\n   //valid_out\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n           valid_out <= 0;\n       end\n       else if(end_cnt) begin\n           valid_out <= 1;\n       end\n       else begin\n           valid_out <= 0;\n       end\n   end  \n     \nendmodule", "corrupted_code": "`timescale 1ns/1ns\n\nmodule accu(\n    input               clk         ,   \n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               valid_in     ,\n \n    output  reg         valid_out     ,\n    output  reg [9:0]   data_out\n);\n    \n   reg [1:0] count;\n   wire add_cnt;\n   wire ready_add;\n   wire end_cnt;\n   reg [9:0]   data_out_reg;\n\n   assign add_cnt = ready_add;\n   assign end_cnt = ready_add && (count == 'd3);\n   \n   //count\n   always @(posedge clk) begin\n       if(!rst_n) begin\n          count <= 0;\n       end\n       else if(end_cnt) begin\n          count <= 0;\n       end\n       else if(add_cnt) begin\n          count <= count + 1;\n       end\n   end\n\n    //data_out_reg\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out_reg <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out_reg <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out_reg <= data_out_reg + data_in;\n      end\n   end\n\n    //data_out\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out <= data_out + data_in;\n      end\n   end\n\n   //ready_add\n   assign ready_add = !valid_out | valid_in;\n\n   //valid_out\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n           valid_out <= 0;\n       end\n       else if(end_cnt) begin\n           valid_out <= 1;\n       end\n       else begin\n           valid_out <= 0;\n       end\n   end  \n     \nendmodule", "corruption_explanation": "Removed async reset from sensitivity list", "modification_type": "remove_async_reset", "modification_line": 23, "original_snippet": "always @(posedge clk or negedge rst_n)", "modified_snippet": "always @(posedge clk)", "issue_description": "The buggy code has removed async reset from the sensitivity list. The always block only triggers on clock edges, not reset. This causes metastability on power-up and removes the ability to asynchronously reset the design.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_async_reset modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed async reset from sensitivity list\n   \u2022 Line 23: Original: always @(posedge clk or negedge rst_n)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 23.\n   \u2022 Restore the original code: always @(posedge clk or negedge rst_n)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove async reset.", "complexity": 36, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_async_reset"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.397911", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Accumulator", "design_name": "accu", "module_name": "accu", "description": "Please act as a professional verilog designer.\n\nImplement a module to achieve serial input data accumulation output, input is 8bit data. The valid_in will be set to 1 before the first data comes in. Whenever the module receives 4 input data, the data_out outputs 4 received data accumulation results and sets the valid_out to be 1 (will last only 1 cycle).\n\nModule name:  \n    accu               \nInput ports:\n\tclk: Clock input for synchronization.\n\trst_n: Active-low reset signal.\n\tdata_in[7:0]: 8-bit input data for addition.\n\tvalid_in: Input signal indicating readiness for new data.   \nOutput ports:\n    valid_out: Output signal indicating when 4 input data accumulation is reached.\n\tdata_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nWhen valid_in is 1, data_in is a valid input. Accumulate four valid input data_in values and calculate the output data_out by adding these four values together. \nThere is no output when there are fewer than four data_in inputs in the interim. Along with the output data_out, a cycle of valid_out=1 will appear as a signal. \nThe valid_out signal is set to 1 when the data_out outputs 4 received data accumulation results. Otherwise, it is set to 0.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\nmodule accu(\n    input               clk         ,   \n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               valid_in     ,\n \n    output  reg         valid_out     ,\n    output  reg [9:0]   data_out\n);\n    \n   reg [1:0] count;\n   wire add_cnt;\n   wire ready_add;\n   wire end_cnt;\n   reg [9:0]   data_out_reg;\n\n   assign add_cnt = ready_add;\n   assign end_cnt = ready_add && (count == 'd3);\n   \n   //count\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n          count <= 0;\n       end\n       else if(end_cnt) begin\n          count <= 0;\n       end\n       else if(add_cnt) begin\n          count <= count + 1;\n       end\n   end\n\n    //data_out_reg\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out_reg <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out_reg <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out_reg <= data_out_reg + data_in;\n      end\n   end\n\n    //data_out\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out <= data_out + data_in;\n      end\n   end\n\n   //ready_add\n   assign ready_add = !valid_out | valid_in;\n\n   //valid_out\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n           valid_out <= 0;\n       end\n       else if(end_cnt) begin\n           valid_out <= 1;\n       end\n       else begin\n           valid_out <= 0;\n       end\n   end  \n     \nendmodule", "corrupted_code": "`timescale 1ns/1ns\n\nmodule accu(\n    input               clk         ,   \n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               valid_in     ,\n \n    output  reg         valid_out     ,\n    output  reg [9:0]   data_out\n);\n    \n   reg [1:0] count;\n   wire add_cnt;\n   wire ready_add;\n   wire end_cnt;\n   reg [9:0]   data_out_reg;\n\n   assign add_cnt = ready_add;\n   assign end_cnt = ready_add && (count == 'd3);\n   \n   //count\n   always @(posedge clk or rst_n) begin\n       if(!rst_n) begin\n          count <= 0;\n       end\n       else if(end_cnt) begin\n          count <= 0;\n       end\n       else if(add_cnt) begin\n          count <= count + 1;\n       end\n   end\n\n    //data_out_reg\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out_reg <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out_reg <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out_reg <= data_out_reg + data_in;\n      end\n   end\n\n    //data_out\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out <= data_out + data_in;\n      end\n   end\n\n   //ready_add\n   assign ready_add = !valid_out | valid_in;\n\n   //valid_out\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n           valid_out <= 0;\n       end\n       else if(end_cnt) begin\n           valid_out <= 1;\n       end\n       else begin\n           valid_out <= 0;\n       end\n   end  \n     \nendmodule", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 23, "original_snippet": "always @(posedge clk or negedge rst_n)", "modified_snippet": "always @(posedge clk or rst_n)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 23: Original: always @(posedge clk or negedge rst_n)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 23.\n   \u2022 Restore the original code: always @(posedge clk or negedge rst_n)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 36, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_sensitivity_list"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.400159", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Accumulator", "design_name": "accu", "module_name": "accu", "description": "Please act as a professional verilog designer.\n\nImplement a module to achieve serial input data accumulation output, input is 8bit data. The valid_in will be set to 1 before the first data comes in. Whenever the module receives 4 input data, the data_out outputs 4 received data accumulation results and sets the valid_out to be 1 (will last only 1 cycle).\n\nModule name:  \n    accu               \nInput ports:\n\tclk: Clock input for synchronization.\n\trst_n: Active-low reset signal.\n\tdata_in[7:0]: 8-bit input data for addition.\n\tvalid_in: Input signal indicating readiness for new data.   \nOutput ports:\n    valid_out: Output signal indicating when 4 input data accumulation is reached.\n\tdata_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nWhen valid_in is 1, data_in is a valid input. Accumulate four valid input data_in values and calculate the output data_out by adding these four values together. \nThere is no output when there are fewer than four data_in inputs in the interim. Along with the output data_out, a cycle of valid_out=1 will appear as a signal. \nThe valid_out signal is set to 1 when the data_out outputs 4 received data accumulation results. Otherwise, it is set to 0.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\nmodule accu(\n    input               clk         ,   \n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               valid_in     ,\n \n    output  reg         valid_out     ,\n    output  reg [9:0]   data_out\n);\n    \n   reg [1:0] count;\n   wire add_cnt;\n   wire ready_add;\n   wire end_cnt;\n   reg [9:0]   data_out_reg;\n\n   assign add_cnt = ready_add;\n   assign end_cnt = ready_add && (count == 'd3);\n   \n   //count\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n          count <= 0;\n       end\n       else if(end_cnt) begin\n          count <= 0;\n       end\n       else if(add_cnt) begin\n          count <= count + 1;\n       end\n   end\n\n    //data_out_reg\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out_reg <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out_reg <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out_reg <= data_out_reg + data_in;\n      end\n   end\n\n    //data_out\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out <= data_out + data_in;\n      end\n   end\n\n   //ready_add\n   assign ready_add = !valid_out | valid_in;\n\n   //valid_out\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n           valid_out <= 0;\n       end\n       else if(end_cnt) begin\n           valid_out <= 1;\n       end\n       else begin\n           valid_out <= 0;\n       end\n   end  \n     \nendmodule", "corrupted_code": "`timescale 1ns/1ns\n\nmodule accu(\n    input               clk         ,   \n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               valid_in     ,\n \n    output  reg         valid_out     ,\n    output  reg [9:0]   data_out\n);\n    \n   reg [1:0] count;\n   wire add_cnt;\n   wire ready_add;\n   wire end_cnt;\n   reg [9:0]   data_out_reg;\n\n   assign add_cnt = ready_add;\n   assign end_cnt = ready_add && (count == 'd3);\n   \n   //count\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n          count <= 0;\n       end\n       else if(end_cnt) begin\n          count <= 0;\n       end\n       else if(add_cnt) begin\n          count <= count + 1;\n       end\n   end\n\n    //data_out_reg\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out_reg <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out_reg <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out_reg <= data_out_reg + data_in;\n      end\n   end\n\n    //data_out\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out <= data_out + data_in;\n      end\n   end\n\n   //ready_add\n   assign ready_add = !valid_out | valid_in;\n\n   //valid_out\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n           valid_out <= 0;\n       end\n       else if(end_cnt) begin\n           valid_out <= 1;\n       end\n       else begin\n           valid_out <= 0;\n       end\n   end  \n     \n\n    wire clk_dup;\n    assign clk_dup = clk;\nendmodule", "corruption_explanation": "Added duplicate clock signal clk_dup", "modification_type": "duplicate_clock_signal", "modification_line": 34, "original_snippet": "(none)", "modified_snippet": "wire clk_dup;\n    assign clk_dup = clk;", "issue_description": "The buggy code has a duplicate clock signal. A phantom clock domain is created, which may confuse CDC analysis tools and create subtle timing issues in synthesis. This violates clock domain design best practices.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a duplicate_clock_signal modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added duplicate clock signal clk_dup\n   \u2022 Line 34: Original: (none)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 34.\n   \u2022 Restore the original code: (none)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to duplicate clock signal.", "complexity": 36, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["duplicate_clock_signal"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.402349", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_32bit", "module_name": "adder_32bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\n"}, "clean_code": "module adder_32bit(A,B,S,C32);\n     input [32:1] A;\n     input [32:1] B;\n     output [32:1] S;\n     output C32;\n\n     wire px1,gx1,px2,gx2;\n     wire c16;\n\n  CLA_16 CLA1(\n      .A(A[16:1]),\n        .B(B[16:1]),\n        .c0(0),\n        .S(S[16:1]),\n        .px(px1),\n        .gx(gx1)\n    );\n\n  CLA_16 CLA2(\n        .A(A[32:17]),\n          .B(B[32:17]),\n          .c0(c16),\n          .S(S[32:17]),\n          .px(px2),\n          .gx(gx2)\n    );\n\n  assign c16 = gx1 ^ (px1 && 0), //c0 = 0\n         C32 = gx2 ^ (px2 && c16);\nendmodule\n\nmodule CLA_16(A,B,c0,S,px,gx);\n    input [16:1] A;\n    input [16:1] B;\n    input c0;\n    output gx,px;\n    output [16:1] S;\n\n    wire c4,c8,c12;\n    wire Pm1,Gm1,Pm2,Gm2,Pm3,Gm3,Pm4,Gm4;\n\n    adder_4 adder1(\n         .x(A[4:1]),\n          .y(B[4:1]),\n          .c0(c0),\n          .c4(),\n          .F(S[4:1]),\n          .Gm(Gm1),\n          .Pm(Pm1)\n    );\n\n    adder_4 adder2(\n         .x(A[8:5]),\n          .y(B[8:5]),\n          .c0(c4),\n          .c4(),\n          .F(S[8:5]),\n          .Gm(Gm2),\n          .Pm(Pm2)\n    );\n\n    adder_4 adder3(\n         .x(A[12:9]),\n          .y(B[12:9]),\n          .c0(c8),\n          .c4(),\n          .F(S[12:9]),\n          .Gm(Gm3),\n          .Pm(Pm3)\n    );\n\n    adder_4 adder4(\n         .x(A[16:13]),\n          .y(B[16:13]),\n          .c0(c12),\n          .c4(),\n          .F(S[16:13]),\n          .Gm(Gm4),\n          .Pm(Pm4)\n    );\n\n    assign   c4 = Gm1 ^ (Pm1 & c0),\n             c8 = Gm2 ^ (Pm2 & Gm1) ^ (Pm2 & Pm1 & c0),\n             c12 = Gm3 ^ (Pm3 & Gm2) ^ (Pm3 & Pm2 & Gm1) ^ (Pm3 & Pm2 & Pm1 & c0);\n\n    assign  px = Pm1 & Pm2 & Pm3 & Pm4,\n            gx = Gm4 ^ (Pm4 & Gm3) ^ (Pm4 & Pm3 & Gm2) ^ (Pm4 & Pm3 & Pm2 & Gm1);\nendmodule\n\nmodule adder_4(x,y,c0,c4,F,Gm,Pm);\n      input [4:1] x;\n      input [4:1] y;\n      input c0;\n      output c4,Gm,Pm;\n      output [4:1] F;\n\n      wire p1,p2,p3,p4,g1,g2,g3,g4;\n      wire c1,c2,c3;\n      adder adder1(\n                 .X(x[1]),\n                     .Y(y[1]),\n                     .Cin(c0),\n                     .F(F[1]),\n                     .Cout()\n                );\n\n      adder adder2(\n                 .X(x[2]),\n                     .Y(y[2]),\n                     .Cin(c1),\n                     .F(F[2]),\n                     .Cout()\n                );  \n\n      adder adder3(\n                 .X(x[3]),\n                     .Y(y[3]),\n                     .Cin(c2),\n                     .F(F[3]),\n                     .Cout()\n                );\n\n      adder adder4(\n                 .X(x[4]),\n                     .Y(y[4]),\n                     .Cin(c3),\n                     .F(F[4]),\n                     .Cout()\n                );      \n\n        CLA CLA(\n            .c0(c0),\n            .c1(c1),\n            .c2(c2),\n            .c3(c3),\n            .c4(c4),\n            .p1(p1),\n            .p2(p2),\n            .p3(p3),\n            .p4(p4),\n            .g1(g1),\n            .g2(g2),\n            .g3(g3),\n            .g4(g4)\n        );\n\n\n\n  assign   p1 = x[1] ^ y[1],      \n           p2 = x[2] ^ y[2],\n           p3 = x[3] ^ y[3],\n           p4 = x[4] ^ y[4];\n\n  assign   g1 = x[1] & y[1],\n           g2 = x[2] & y[2],\n           g3 = x[3] & y[3],\n           g4 = x[4] & y[4];\n\n  assign Pm = p1 & p2 & p3 & p4,\n         Gm = g4 ^ (p4 & g3) ^ (p4 & p3 & g2) ^ (p4 & p3 & p2 & g1);\nendmodule\n\nmodule CLA(c0,c1,c2,c3,c4,p1,p2,p3,p4,g1,g2,g3,g4);\n\n     input c0,g1,g2,g3,g4,p1,p2,p3,p4;\n     output c1,c2,c3,c4;\n\n     assign c1 = g1 ^ (p1 & c0),\n            c2 = g2 ^ (p2 & g1) ^ (p2 & p1 & c0),\n            c3 = g3 ^ (p3 & g2) ^ (p3 & p2 & g1) ^ (p3 & p2 & p1 & c0),\n            c4 = g4^(p4&g3)^(p4&p3&g2)^(p4&p3&p2&g1)^(p4&p3&p2&p1&c0);\nendmodule\n\nmodule adder(X,Y,Cin,F,Cout);\n\n  input X,Y,Cin;\n  output F,Cout;\n\n  assign F = X ^ Y ^ Cin;\n  assign Cout = (X ^ Y) & Cin | X & Y;\nendmodule", "corrupted_code": "module adder_32bit(A,B,S,C32);\n     input [32:1] A;\n     input [32:1] B;\n     output [32:1] S;\n     output C32;\n\n     wire px1,gx1,px2,gx2;\n     wire c16;\n\n  CLA_16 CLA1(\n      .A(A[16:1]),\n        .B(B[16:1]),\n        .c0(0),\n        .S(S[16:1]),\n        .px(px1),\n        .gx(gx1)\n    );\n\n  CLA_16 CLA2(\n        .A(A[32:17]),\n          .B(B[32:17]),\n          .c0(c16),\n          .S(S[32:17]),\n          .px(px2),\n          .gx(gx2)\n    );\n\n  assign c16 = gx1 ^ (px1 && 0), //c0 = 0\n         C32 = gx2 ^ (px2 && c16);\nendmodule\n\nmodule CLA_16(A,B,c0,S,px,gx);\n    input [16:1] A;\n    input [16:1] B;\n    input c0;\n    output gx,px;\n    output [16:1] S;\n\n    wire c4,c8,c12;\n    wire Pm1,Gm1,Pm2,Gm2,Pm3,Gm3,Pm4,Gm4;\n\n    adder_4 adder1(\n         .x(A[4:1]),\n          .y(B[4:1]),\n          .c0(c0),\n          .c4(),\n          .F(S[4:1]),\n          .Gm(Gm1),\n          .Pm(Pm1)\n    );\n\n    adder_4 adder2(\n         .x(A[8:5]),\n          .y(B[8:5]),\n          .c0(c4),\n          .c4(),\n          .F(S[8:5]),\n          .Gm(Gm2),\n          .Pm(Pm2)\n    );\n\n    adder_4 adder3(\n         .x(A[12:9]),\n          .y(B[12:9]),\n          .c0(c8),\n          .c4(),\n          .F(S[12:9]),\n          .Gm(Gm3),\n          .Pm(Pm3)\n    );\n\n    adder_4 adder4(\n         .x(A[16:13]),\n          .y(B[16:13]),\n          .c0(c12),\n          .c4(),\n          .F(S[16:13]),\n          .Gm(Gm4),\n          .Pm(Pm4)\n    );\n\n    assign   c4 = Gm1 ^ (Pm1 & c0),\n             c8 = Gm2 ^ (Pm2 & Gm1) ^ (Pm2 & Pm1 & c0),\n             c12 = Gm3 ^ (Pm3 & Gm2) ^ (Pm3 & Pm2 & Gm1) ^ (Pm3 & Pm2 & Pm1 & c0);\n\n    assign  px = Pm1 & Pm2 & Pm3 & Pm4,\n            gx = Gm4 ^ (Pm4 & Gm3) ^ (Pm4 & Pm3 & Gm2) ^ (Pm4 & Pm3 & Pm2 & Gm1);\nendmodule\n\nmodule adder_4(x,y,c0,c4,F,Gm,Pm);\n      input [4:1] x;\n      input [4:1] y;\n      input c0;\n      output c4,Gm,Pm;\n      output [4:1] F;\n\n      wire p1,p2,p3,p4,g1,g2,g3,g4;\n      wire c1,c2,c3;\n      adder adder1(\n                 .X(x[1]),\n                     .Y(y[1]),\n                     .Cin(c0),\n                     .F(F[1]),\n                     .Cout()\n                );\n\n      adder adder2(\n                 .X(x[2]),\n                     .Y(y[2]),\n                     .Cin(c1),\n                     .F(F[2]),\n                     .Cout()\n                );  \n\n      adder adder3(\n                 .X(x[3]),\n                     .Y(y[3]),\n                     .Cin(c2),\n                     .F(F[3]),\n                     .Cout()\n                );\n\n      adder adder4(\n                 .X(x[4]),\n                     .Y(y[4]),\n                     .Cin(c3),\n                     .F(F[4]),\n                     .Cout()\n                );      \n\n        CLA CLA(\n            .c0(c0),\n            .c1(c1),\n            .c2(c2),\n            .c3(c3),\n            .c4(c4),\n            .p1(p1),\n            .p2(p2),\n            .p3(p3),\n            .p4(p4),\n            .g1(g1),\n            .g2(g2),\n            .g3(g3),\n            .g4(g4)\n        );\n\n\n\n  assign   p1 = x[1] ^ y[1],      \n           p2 = x[2] ^ y[2],\n           p3 = x[3] ^ y[3],\n           p4 = x[4] ^ y[4];\n\n  assign   g1 = x[1] & y[1],\n           g2 = x[2] & y[2],\n           g3 = x[3] & y[3],\n           g4 = x[4] & y[4];\nassign g1 = 1'b0;  // Conflicting assignment\n\n  assign Pm = p1 & p2 & p3 & p4,\n         Gm = g4 ^ (p4 & g3) ^ (p4 & p3 & g2) ^ (p4 & p3 & p2 & g1);\nendmodule\n\nmodule CLA(c0,c1,c2,c3,c4,p1,p2,p3,p4,g1,g2,g3,g4);\n\n     input c0,g1,g2,g3,g4,p1,p2,p3,p4;\n     output c1,c2,c3,c4;\n\n     assign c1 = g1 ^ (p1 & c0),\n            c2 = g2 ^ (p2 & g1) ^ (p2 & p1 & c0),\n            c3 = g3 ^ (p3 & g2) ^ (p3 & p2 & g1) ^ (p3 & p2 & p1 & c0),\n            c4 = g4^(p4&g3)^(p4&p3&g2)^(p4&p3&p2&g1)^(p4&p3&p2&p1&c0);\nendmodule\n\nmodule adder(X,Y,Cin,F,Cout);\n\n  input X,Y,Cin;\n  output F,Cout;\n\n  assign F = X ^ Y ^ Cin;\n  assign Cout = (X ^ Y) & Cin | X & Y;\nendmodule", "corruption_explanation": "Added conflicting driver for signal 'g1'", "modification_type": "add_multiple_driver", "modification_line": 153, "original_snippet": "assign   g1 = x[1] & y[1],\n           g2 = x[2] & y[2],\n           g3 = x[3] & y[3],\n           g4 = x[4] & y[4];", "modified_snippet": "assign   g1 = x[1] & y[1],\n           g2 = x[2] & y[2],\n           g3 = x[3] & y[3],\n           g4 = x[4] & y[4];\nassign g1 = 1'b0;  // Conflicting assignment", "issue_description": "The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_multiple_driver modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added conflicting driver for signal 'g1'\n   \u2022 Line 153: Original: assign   g1 = x[1] & y[1],\n           g2 = x[2] & y[2],\n           g3 = x[3] & y[3],\n           g4 = x[4] & y[4];\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 153.\n   \u2022 Restore the original code: assign   g1 = x[1] & y[1],\n           g2 = x[2] & y[2],\n           g3 = x[3] & y[3],\n           g4 = x[4] & y[4];\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add multiple driver.", "complexity": 37, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["add_multiple_driver"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.408051", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_32bit", "module_name": "adder_32bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\n"}, "clean_code": "module adder_32bit(A,B,S,C32);\n     input [32:1] A;\n     input [32:1] B;\n     output [32:1] S;\n     output C32;\n\n     wire px1,gx1,px2,gx2;\n     wire c16;\n\n  CLA_16 CLA1(\n      .A(A[16:1]),\n        .B(B[16:1]),\n        .c0(0),\n        .S(S[16:1]),\n        .px(px1),\n        .gx(gx1)\n    );\n\n  CLA_16 CLA2(\n        .A(A[32:17]),\n          .B(B[32:17]),\n          .c0(c16),\n          .S(S[32:17]),\n          .px(px2),\n          .gx(gx2)\n    );\n\n  assign c16 = gx1 ^ (px1 && 0), //c0 = 0\n         C32 = gx2 ^ (px2 && c16);\nendmodule\n\nmodule CLA_16(A,B,c0,S,px,gx);\n    input [16:1] A;\n    input [16:1] B;\n    input c0;\n    output gx,px;\n    output [16:1] S;\n\n    wire c4,c8,c12;\n    wire Pm1,Gm1,Pm2,Gm2,Pm3,Gm3,Pm4,Gm4;\n\n    adder_4 adder1(\n         .x(A[4:1]),\n          .y(B[4:1]),\n          .c0(c0),\n          .c4(),\n          .F(S[4:1]),\n          .Gm(Gm1),\n          .Pm(Pm1)\n    );\n\n    adder_4 adder2(\n         .x(A[8:5]),\n          .y(B[8:5]),\n          .c0(c4),\n          .c4(),\n          .F(S[8:5]),\n          .Gm(Gm2),\n          .Pm(Pm2)\n    );\n\n    adder_4 adder3(\n         .x(A[12:9]),\n          .y(B[12:9]),\n          .c0(c8),\n          .c4(),\n          .F(S[12:9]),\n          .Gm(Gm3),\n          .Pm(Pm3)\n    );\n\n    adder_4 adder4(\n         .x(A[16:13]),\n          .y(B[16:13]),\n          .c0(c12),\n          .c4(),\n          .F(S[16:13]),\n          .Gm(Gm4),\n          .Pm(Pm4)\n    );\n\n    assign   c4 = Gm1 ^ (Pm1 & c0),\n             c8 = Gm2 ^ (Pm2 & Gm1) ^ (Pm2 & Pm1 & c0),\n             c12 = Gm3 ^ (Pm3 & Gm2) ^ (Pm3 & Pm2 & Gm1) ^ (Pm3 & Pm2 & Pm1 & c0);\n\n    assign  px = Pm1 & Pm2 & Pm3 & Pm4,\n            gx = Gm4 ^ (Pm4 & Gm3) ^ (Pm4 & Pm3 & Gm2) ^ (Pm4 & Pm3 & Pm2 & Gm1);\nendmodule\n\nmodule adder_4(x,y,c0,c4,F,Gm,Pm);\n      input [4:1] x;\n      input [4:1] y;\n      input c0;\n      output c4,Gm,Pm;\n      output [4:1] F;\n\n      wire p1,p2,p3,p4,g1,g2,g3,g4;\n      wire c1,c2,c3;\n      adder adder1(\n                 .X(x[1]),\n                     .Y(y[1]),\n                     .Cin(c0),\n                     .F(F[1]),\n                     .Cout()\n                );\n\n      adder adder2(\n                 .X(x[2]),\n                     .Y(y[2]),\n                     .Cin(c1),\n                     .F(F[2]),\n                     .Cout()\n                );  \n\n      adder adder3(\n                 .X(x[3]),\n                     .Y(y[3]),\n                     .Cin(c2),\n                     .F(F[3]),\n                     .Cout()\n                );\n\n      adder adder4(\n                 .X(x[4]),\n                     .Y(y[4]),\n                     .Cin(c3),\n                     .F(F[4]),\n                     .Cout()\n                );      \n\n        CLA CLA(\n            .c0(c0),\n            .c1(c1),\n            .c2(c2),\n            .c3(c3),\n            .c4(c4),\n            .p1(p1),\n            .p2(p2),\n            .p3(p3),\n            .p4(p4),\n            .g1(g1),\n            .g2(g2),\n            .g3(g3),\n            .g4(g4)\n        );\n\n\n\n  assign   p1 = x[1] ^ y[1],      \n           p2 = x[2] ^ y[2],\n           p3 = x[3] ^ y[3],\n           p4 = x[4] ^ y[4];\n\n  assign   g1 = x[1] & y[1],\n           g2 = x[2] & y[2],\n           g3 = x[3] & y[3],\n           g4 = x[4] & y[4];\n\n  assign Pm = p1 & p2 & p3 & p4,\n         Gm = g4 ^ (p4 & g3) ^ (p4 & p3 & g2) ^ (p4 & p3 & p2 & g1);\nendmodule\n\nmodule CLA(c0,c1,c2,c3,c4,p1,p2,p3,p4,g1,g2,g3,g4);\n\n     input c0,g1,g2,g3,g4,p1,p2,p3,p4;\n     output c1,c2,c3,c4;\n\n     assign c1 = g1 ^ (p1 & c0),\n            c2 = g2 ^ (p2 & g1) ^ (p2 & p1 & c0),\n            c3 = g3 ^ (p3 & g2) ^ (p3 & p2 & g1) ^ (p3 & p2 & p1 & c0),\n            c4 = g4^(p4&g3)^(p4&p3&g2)^(p4&p3&p2&g1)^(p4&p3&p2&p1&c0);\nendmodule\n\nmodule adder(X,Y,Cin,F,Cout);\n\n  input X,Y,Cin;\n  output F,Cout;\n\n  assign F = X ^ Y ^ Cin;\n  assign Cout = (X ^ Y) & Cin | X & Y;\nendmodule", "corrupted_code": "module adder_32bit(A,B,S,C32);\n     input [32:1] A;\n     input [32:1] B;\n     output [32:1] S;\n     output C32;\n\n     wire px1,gx1,px2,gx2;\n     wire c16;\n\n  CLA_16 CLA1(\n      .A(A[16:1]),\n        .B(B[16:1]),\n        .c0(0),\n        .S(S[16:1]),\n        .px(px1),\n        .gx(gx1)\n    );\n\n  CLA_16 CLA2(\n        .A(A[32:17]),\n          .B(B[32:17]),\n          .c0(c16),\n          .S(S[32:17]),\n          .px(px2),\n          .gx(gx2)\n    );\n\n  assign c16 = gx1 ^ (px1 && 0), //c0 = 0\n         C32 <= gx2 ^ (px2 && c16);\nendmodule\n\nmodule CLA_16(A,B,c0,S,px,gx);\n    input [16:1] A;\n    input [16:1] B;\n    input c0;\n    output gx,px;\n    output [16:1] S;\n\n    wire c4,c8,c12;\n    wire Pm1,Gm1,Pm2,Gm2,Pm3,Gm3,Pm4,Gm4;\n\n    adder_4 adder1(\n         .x(A[4:1]),\n          .y(B[4:1]),\n          .c0(c0),\n          .c4(),\n          .F(S[4:1]),\n          .Gm(Gm1),\n          .Pm(Pm1)\n    );\n\n    adder_4 adder2(\n         .x(A[8:5]),\n          .y(B[8:5]),\n          .c0(c4),\n          .c4(),\n          .F(S[8:5]),\n          .Gm(Gm2),\n          .Pm(Pm2)\n    );\n\n    adder_4 adder3(\n         .x(A[12:9]),\n          .y(B[12:9]),\n          .c0(c8),\n          .c4(),\n          .F(S[12:9]),\n          .Gm(Gm3),\n          .Pm(Pm3)\n    );\n\n    adder_4 adder4(\n         .x(A[16:13]),\n          .y(B[16:13]),\n          .c0(c12),\n          .c4(),\n          .F(S[16:13]),\n          .Gm(Gm4),\n          .Pm(Pm4)\n    );\n\n    assign   c4 = Gm1 ^ (Pm1 & c0),\n             c8 = Gm2 ^ (Pm2 & Gm1) ^ (Pm2 & Pm1 & c0),\n             c12 = Gm3 ^ (Pm3 & Gm2) ^ (Pm3 & Pm2 & Gm1) ^ (Pm3 & Pm2 & Pm1 & c0);\n\n    assign  px = Pm1 & Pm2 & Pm3 & Pm4,\n            gx = Gm4 ^ (Pm4 & Gm3) ^ (Pm4 & Pm3 & Gm2) ^ (Pm4 & Pm3 & Pm2 & Gm1);\nendmodule\n\nmodule adder_4(x,y,c0,c4,F,Gm,Pm);\n      input [4:1] x;\n      input [4:1] y;\n      input c0;\n      output c4,Gm,Pm;\n      output [4:1] F;\n\n      wire p1,p2,p3,p4,g1,g2,g3,g4;\n      wire c1,c2,c3;\n      adder adder1(\n                 .X(x[1]),\n                     .Y(y[1]),\n                     .Cin(c0),\n                     .F(F[1]),\n                     .Cout()\n                );\n\n      adder adder2(\n                 .X(x[2]),\n                     .Y(y[2]),\n                     .Cin(c1),\n                     .F(F[2]),\n                     .Cout()\n                );  \n\n      adder adder3(\n                 .X(x[3]),\n                     .Y(y[3]),\n                     .Cin(c2),\n                     .F(F[3]),\n                     .Cout()\n                );\n\n      adder adder4(\n                 .X(x[4]),\n                     .Y(y[4]),\n                     .Cin(c3),\n                     .F(F[4]),\n                     .Cout()\n                );      \n\n        CLA CLA(\n            .c0(c0),\n            .c1(c1),\n            .c2(c2),\n            .c3(c3),\n            .c4(c4),\n            .p1(p1),\n            .p2(p2),\n            .p3(p3),\n            .p4(p4),\n            .g1(g1),\n            .g2(g2),\n            .g3(g3),\n            .g4(g4)\n        );\n\n\n\n  assign   p1 = x[1] ^ y[1],      \n           p2 = x[2] ^ y[2],\n           p3 = x[3] ^ y[3],\n           p4 = x[4] ^ y[4];\n\n  assign   g1 = x[1] & y[1],\n           g2 = x[2] & y[2],\n           g3 = x[3] & y[3],\n           g4 = x[4] & y[4];\n\n  assign Pm = p1 & p2 & p3 & p4,\n         Gm = g4 ^ (p4 & g3) ^ (p4 & p3 & g2) ^ (p4 & p3 & p2 & g1);\nendmodule\n\nmodule CLA(c0,c1,c2,c3,c4,p1,p2,p3,p4,g1,g2,g3,g4);\n\n     input c0,g1,g2,g3,g4,p1,p2,p3,p4;\n     output c1,c2,c3,c4;\n\n     assign c1 = g1 ^ (p1 & c0),\n            c2 = g2 ^ (p2 & g1) ^ (p2 & p1 & c0),\n            c3 = g3 ^ (p3 & g2) ^ (p3 & p2 & g1) ^ (p3 & p2 & p1 & c0),\n            c4 = g4^(p4&g3)^(p4&p3&g2)^(p4&p3&p2&g1)^(p4&p3&p2&p1&c0);\nendmodule\n\nmodule adder(X,Y,Cin,F,Cout);\n\n  input X,Y,Cin;\n  output F,Cout;\n\n  assign F = X ^ Y ^ Cin;\n  assign Cout = (X ^ Y) & Cin | X & Y;\nendmodule", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 29, "original_snippet": "C32 = gx2 ^ (px2 && c16);", "modified_snippet": "C32 <= gx2 ^ (px2 && c16);", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 37, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.419293", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_32bit", "module_name": "adder_32bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\n"}, "clean_code": "module adder_32bit(A,B,S,C32);\n     input [32:1] A;\n     input [32:1] B;\n     output [32:1] S;\n     output C32;\n\n     wire px1,gx1,px2,gx2;\n     wire c16;\n\n  CLA_16 CLA1(\n      .A(A[16:1]),\n        .B(B[16:1]),\n        .c0(0),\n        .S(S[16:1]),\n        .px(px1),\n        .gx(gx1)\n    );\n\n  CLA_16 CLA2(\n        .A(A[32:17]),\n          .B(B[32:17]),\n          .c0(c16),\n          .S(S[32:17]),\n          .px(px2),\n          .gx(gx2)\n    );\n\n  assign c16 = gx1 ^ (px1 && 0), //c0 = 0\n         C32 = gx2 ^ (px2 && c16);\nendmodule\n\nmodule CLA_16(A,B,c0,S,px,gx);\n    input [16:1] A;\n    input [16:1] B;\n    input c0;\n    output gx,px;\n    output [16:1] S;\n\n    wire c4,c8,c12;\n    wire Pm1,Gm1,Pm2,Gm2,Pm3,Gm3,Pm4,Gm4;\n\n    adder_4 adder1(\n         .x(A[4:1]),\n          .y(B[4:1]),\n          .c0(c0),\n          .c4(),\n          .F(S[4:1]),\n          .Gm(Gm1),\n          .Pm(Pm1)\n    );\n\n    adder_4 adder2(\n         .x(A[8:5]),\n          .y(B[8:5]),\n          .c0(c4),\n          .c4(),\n          .F(S[8:5]),\n          .Gm(Gm2),\n          .Pm(Pm2)\n    );\n\n    adder_4 adder3(\n         .x(A[12:9]),\n          .y(B[12:9]),\n          .c0(c8),\n          .c4(),\n          .F(S[12:9]),\n          .Gm(Gm3),\n          .Pm(Pm3)\n    );\n\n    adder_4 adder4(\n         .x(A[16:13]),\n          .y(B[16:13]),\n          .c0(c12),\n          .c4(),\n          .F(S[16:13]),\n          .Gm(Gm4),\n          .Pm(Pm4)\n    );\n\n    assign   c4 = Gm1 ^ (Pm1 & c0),\n             c8 = Gm2 ^ (Pm2 & Gm1) ^ (Pm2 & Pm1 & c0),\n             c12 = Gm3 ^ (Pm3 & Gm2) ^ (Pm3 & Pm2 & Gm1) ^ (Pm3 & Pm2 & Pm1 & c0);\n\n    assign  px = Pm1 & Pm2 & Pm3 & Pm4,\n            gx = Gm4 ^ (Pm4 & Gm3) ^ (Pm4 & Pm3 & Gm2) ^ (Pm4 & Pm3 & Pm2 & Gm1);\nendmodule\n\nmodule adder_4(x,y,c0,c4,F,Gm,Pm);\n      input [4:1] x;\n      input [4:1] y;\n      input c0;\n      output c4,Gm,Pm;\n      output [4:1] F;\n\n      wire p1,p2,p3,p4,g1,g2,g3,g4;\n      wire c1,c2,c3;\n      adder adder1(\n                 .X(x[1]),\n                     .Y(y[1]),\n                     .Cin(c0),\n                     .F(F[1]),\n                     .Cout()\n                );\n\n      adder adder2(\n                 .X(x[2]),\n                     .Y(y[2]),\n                     .Cin(c1),\n                     .F(F[2]),\n                     .Cout()\n                );  \n\n      adder adder3(\n                 .X(x[3]),\n                     .Y(y[3]),\n                     .Cin(c2),\n                     .F(F[3]),\n                     .Cout()\n                );\n\n      adder adder4(\n                 .X(x[4]),\n                     .Y(y[4]),\n                     .Cin(c3),\n                     .F(F[4]),\n                     .Cout()\n                );      \n\n        CLA CLA(\n            .c0(c0),\n            .c1(c1),\n            .c2(c2),\n            .c3(c3),\n            .c4(c4),\n            .p1(p1),\n            .p2(p2),\n            .p3(p3),\n            .p4(p4),\n            .g1(g1),\n            .g2(g2),\n            .g3(g3),\n            .g4(g4)\n        );\n\n\n\n  assign   p1 = x[1] ^ y[1],      \n           p2 = x[2] ^ y[2],\n           p3 = x[3] ^ y[3],\n           p4 = x[4] ^ y[4];\n\n  assign   g1 = x[1] & y[1],\n           g2 = x[2] & y[2],\n           g3 = x[3] & y[3],\n           g4 = x[4] & y[4];\n\n  assign Pm = p1 & p2 & p3 & p4,\n         Gm = g4 ^ (p4 & g3) ^ (p4 & p3 & g2) ^ (p4 & p3 & p2 & g1);\nendmodule\n\nmodule CLA(c0,c1,c2,c3,c4,p1,p2,p3,p4,g1,g2,g3,g4);\n\n     input c0,g1,g2,g3,g4,p1,p2,p3,p4;\n     output c1,c2,c3,c4;\n\n     assign c1 = g1 ^ (p1 & c0),\n            c2 = g2 ^ (p2 & g1) ^ (p2 & p1 & c0),\n            c3 = g3 ^ (p3 & g2) ^ (p3 & p2 & g1) ^ (p3 & p2 & p1 & c0),\n            c4 = g4^(p4&g3)^(p4&p3&g2)^(p4&p3&p2&g1)^(p4&p3&p2&p1&c0);\nendmodule\n\nmodule adder(X,Y,Cin,F,Cout);\n\n  input X,Y,Cin;\n  output F,Cout;\n\n  assign F = X ^ Y ^ Cin;\n  assign Cout = (X ^ Y) & Cin | X & Y;\nendmodule", "corrupted_code": "module adder_32bit(A,B,S,C32);\n     input [32:1] A;\n     input [32:1] B;\n     output [32:1] S;\n     output C32;\n\n     wire px1,gx1,px2,gx2;\n     wire c16;\n\n  CLA_16 CLA1(\n      .A(A[16:1]),\n        .B(B[16:1]),\n        .c0(0),\n        .S(S[16:1]),\n        .px(px1),\n        .gx(gx1)\n    );\n\n  CLA_16 CLA2(\n        .A(A[32:17]),\n          .B(B[32:17]),\n          .c0(c16),\n          .S(S[32:17]),\n          .px(px2),\n          .gx(gx2)\n    );\n\n  assign c16 = gx1 ^ (px1 && 0), //c0 = 0\n         C32 = gx2 ^ (px2 && c16);\nendmodule\n\nmodule CLA_16(A,B,c0,S,px,gx);\n    input [16:1] A;\n    input [16:1] B;\n    input c0;\n    output gx,px;\n    output [16:1] S;\n\n    wire c4,c8,c12;\n    wire Pm1,Gm1,Pm2,Gm2,Pm3,Gm3,Pm4,Gm4;\n\n    adder_4 adder1(\n         .x(A[4:1]),\n          .y(B[4:1]),\n          .c0(c0),\n          .c4(),\n          .F(S[4:1]),\n          .Gm(Gm1),\n          .Pm(Pm1)\n    );\n\n    adder_4 adder2(\n         .x(A[8:5]),\n          .y(B[8:5]),\n          .c0(c4),\n          .c4(),\n          .F(S[8:5]),\n          .Gm(Gm2),\n          .Pm(Pm2)\n    );\n\n    adder_4 adder3(\n         .x(A[12:9]),\n          .y(B[12:9]),\n          .c0(c8),\n          .c4(),\n          .F(S[12:9]),\n          .Gm(Gm3),\n          .Pm(Pm3)\n    );\n\n    adder_4 adder4(\n         .x(A[16:13]),\n          .y(B[16:13]),\n          .c0(c12),\n          .c4(),\n          .F(S[16:13]),\n          .Gm(Gm4),\n          .Pm(Pm4)\n    );\n\n    assign   c4 = Gm1 ^ (Pm1 & c0),\n             c8 = Gm2 ^ (Pm2 & Gm1) ^ (Pm2 & Pm1 & c0),\n             c12 = Gm3 ^ (Pm3 & Gm2) ^ (Pm3 & Pm2 & Gm1) ^ (Pm3 & Pm2 & Pm1 & c0);\n\n    assign  px = Pm1 & Pm2 & Pm3 & Pm4,\n            gx = Gm4 ^ (Pm4 & Gm3) ^ (Pm4 & Pm3 & Gm2) ^ (Pm4 & Pm3 & Pm2 & Gm1);\nendmodule\n\nmodule adder_4(x,y,c0,c4,F,Gm,Pm);\n      input [4:1] x;\n      input [4:1] y;\n      input c0;\n      output c4,Gm,Pm;\n      output [4:1] F;\n\n      wire p1,p2,p3,p4,g1,g2,g3,g4;\n      wire c1,c2,c3;\n      adder adder1(\n                 .X(x[1]),\n                     .Y(y[1]),\n                     .Cin(c0),\n                     .F(F[1]),\n                     .Cout()\n                );\n\n      adder adder2(\n                 .X(x[2]),\n                     .Y(y[2]),\n                     .Cin(c1),\n                     .F(F[2]),\n                     .Cout()\n                );  \n\n      adder adder3(\n                 .X(x[3]),\n                     .Y(y[3]),\n                     .Cin(c2),\n                     .F(F[3]),\n                     .Cout()\n                );\n\n      adder adder4(\n                 .X(x[4]),\n                     .Y(y[4]),\n                     .Cin(c3),\n                     .F(F[4]),\n                     .Cout()\n                );      \n\n        CLA CLA(\n            .c0(c0),\n            .c1(c1),\n            .c2(c2),\n            .c3(c3),\n            .c4(c4),\n            .p1(p1),\n            .p2(p2),\n            .p3(p3),\n            .p4(p4),\n            .g1(g1),\n            .g2(g2),\n            .g3(g3),\n            .g4(g4)\n        );\n\n\n\n  assign   p1 = x[1] ^ y[1],      \n           p2 = x[2] ^ y[2],\n           p3 = x[3] ^ y[3],\n           p4 = x[4] ^ y[4];\n\n  assign   g1 = x[1] & y[1],\n           g2 = x[2] & y[2],\n           g3 = x[3] & y[3],\n           g4 = x[4] & y[4];\n\n  assign Pm = p1 & p2 & p3 & p4,\n         Gm = g4 ^ (p4 & g3) ^ (p4 & p3 & g2) ^ (p4 & p3 & p2 & g1);\nendmodule\n\nmodule CLA(c0,c1,c2,c3,c4,p1,p2,p3,p4,g1,g2,g3,g4);\n\n     input c0,g1,g2,g3,g4,p1,p2,p3,p4;\n     output c1,c2,c3,c4;\n\n     assign c1 = g1 ^ (p1 & c0),\n            c2 = g2 ^ (p2 & g1) ^ (p2 & p1 & c0),\n            c3 = g3 ^ (p3 & g2) ^ (p3 & p2 & g1) ^ (p3 & p2 & p1 & c0),\n            c4 = g4^(p4&g3)^(p4&p3&g2)^(p4&p3&p2&g1)^(p4&p3&p2&p1&c0);\nendmodule\n\nmodule adder(X,Y,Cin,F,Cout);\n\n  input X,Y,Cin;\n  output F,Cout;\n\n  assign F = X ^ Y ^ Cin;\n  assign Cout = (X ^ Y) & Cin | X & Y;\nassign Cout = 1'b0;  // Conflicting assignment\nendmodule", "corruption_explanation": "Added conflicting driver for signal 'Cout'", "modification_type": "add_multiple_driver", "modification_line": 180, "original_snippet": "assign Cout = (X ^ Y) & Cin | X & Y;", "modified_snippet": "assign Cout = (X ^ Y) & Cin | X & Y;\nassign Cout = 1'b0;  // Conflicting assignment", "issue_description": "The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_multiple_driver modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added conflicting driver for signal 'Cout'\n   \u2022 Line 180: Original: assign Cout = (X ^ Y) & Cin | X & Y;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 180.\n   \u2022 Restore the original code: assign Cout = (X ^ Y) & Cin | X & Y;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add multiple driver.", "complexity": 37, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["add_multiple_driver"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.423535", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_32bit", "module_name": "adder_32bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\n"}, "clean_code": "module adder_32bit(A,B,S,C32);\n     input [32:1] A;\n     input [32:1] B;\n     output [32:1] S;\n     output C32;\n\n     wire px1,gx1,px2,gx2;\n     wire c16;\n\n  CLA_16 CLA1(\n      .A(A[16:1]),\n        .B(B[16:1]),\n        .c0(0),\n        .S(S[16:1]),\n        .px(px1),\n        .gx(gx1)\n    );\n\n  CLA_16 CLA2(\n        .A(A[32:17]),\n          .B(B[32:17]),\n          .c0(c16),\n          .S(S[32:17]),\n          .px(px2),\n          .gx(gx2)\n    );\n\n  assign c16 = gx1 ^ (px1 && 0), //c0 = 0\n         C32 = gx2 ^ (px2 && c16);\nendmodule\n\nmodule CLA_16(A,B,c0,S,px,gx);\n    input [16:1] A;\n    input [16:1] B;\n    input c0;\n    output gx,px;\n    output [16:1] S;\n\n    wire c4,c8,c12;\n    wire Pm1,Gm1,Pm2,Gm2,Pm3,Gm3,Pm4,Gm4;\n\n    adder_4 adder1(\n         .x(A[4:1]),\n          .y(B[4:1]),\n          .c0(c0),\n          .c4(),\n          .F(S[4:1]),\n          .Gm(Gm1),\n          .Pm(Pm1)\n    );\n\n    adder_4 adder2(\n         .x(A[8:5]),\n          .y(B[8:5]),\n          .c0(c4),\n          .c4(),\n          .F(S[8:5]),\n          .Gm(Gm2),\n          .Pm(Pm2)\n    );\n\n    adder_4 adder3(\n         .x(A[12:9]),\n          .y(B[12:9]),\n          .c0(c8),\n          .c4(),\n          .F(S[12:9]),\n          .Gm(Gm3),\n          .Pm(Pm3)\n    );\n\n    adder_4 adder4(\n         .x(A[16:13]),\n          .y(B[16:13]),\n          .c0(c12),\n          .c4(),\n          .F(S[16:13]),\n          .Gm(Gm4),\n          .Pm(Pm4)\n    );\n\n    assign   c4 = Gm1 ^ (Pm1 & c0),\n             c8 = Gm2 ^ (Pm2 & Gm1) ^ (Pm2 & Pm1 & c0),\n             c12 = Gm3 ^ (Pm3 & Gm2) ^ (Pm3 & Pm2 & Gm1) ^ (Pm3 & Pm2 & Pm1 & c0);\n\n    assign  px = Pm1 & Pm2 & Pm3 & Pm4,\n            gx = Gm4 ^ (Pm4 & Gm3) ^ (Pm4 & Pm3 & Gm2) ^ (Pm4 & Pm3 & Pm2 & Gm1);\nendmodule\n\nmodule adder_4(x,y,c0,c4,F,Gm,Pm);\n      input [4:1] x;\n      input [4:1] y;\n      input c0;\n      output c4,Gm,Pm;\n      output [4:1] F;\n\n      wire p1,p2,p3,p4,g1,g2,g3,g4;\n      wire c1,c2,c3;\n      adder adder1(\n                 .X(x[1]),\n                     .Y(y[1]),\n                     .Cin(c0),\n                     .F(F[1]),\n                     .Cout()\n                );\n\n      adder adder2(\n                 .X(x[2]),\n                     .Y(y[2]),\n                     .Cin(c1),\n                     .F(F[2]),\n                     .Cout()\n                );  \n\n      adder adder3(\n                 .X(x[3]),\n                     .Y(y[3]),\n                     .Cin(c2),\n                     .F(F[3]),\n                     .Cout()\n                );\n\n      adder adder4(\n                 .X(x[4]),\n                     .Y(y[4]),\n                     .Cin(c3),\n                     .F(F[4]),\n                     .Cout()\n                );      \n\n        CLA CLA(\n            .c0(c0),\n            .c1(c1),\n            .c2(c2),\n            .c3(c3),\n            .c4(c4),\n            .p1(p1),\n            .p2(p2),\n            .p3(p3),\n            .p4(p4),\n            .g1(g1),\n            .g2(g2),\n            .g3(g3),\n            .g4(g4)\n        );\n\n\n\n  assign   p1 = x[1] ^ y[1],      \n           p2 = x[2] ^ y[2],\n           p3 = x[3] ^ y[3],\n           p4 = x[4] ^ y[4];\n\n  assign   g1 = x[1] & y[1],\n           g2 = x[2] & y[2],\n           g3 = x[3] & y[3],\n           g4 = x[4] & y[4];\n\n  assign Pm = p1 & p2 & p3 & p4,\n         Gm = g4 ^ (p4 & g3) ^ (p4 & p3 & g2) ^ (p4 & p3 & p2 & g1);\nendmodule\n\nmodule CLA(c0,c1,c2,c3,c4,p1,p2,p3,p4,g1,g2,g3,g4);\n\n     input c0,g1,g2,g3,g4,p1,p2,p3,p4;\n     output c1,c2,c3,c4;\n\n     assign c1 = g1 ^ (p1 & c0),\n            c2 = g2 ^ (p2 & g1) ^ (p2 & p1 & c0),\n            c3 = g3 ^ (p3 & g2) ^ (p3 & p2 & g1) ^ (p3 & p2 & p1 & c0),\n            c4 = g4^(p4&g3)^(p4&p3&g2)^(p4&p3&p2&g1)^(p4&p3&p2&p1&c0);\nendmodule\n\nmodule adder(X,Y,Cin,F,Cout);\n\n  input X,Y,Cin;\n  output F,Cout;\n\n  assign F = X ^ Y ^ Cin;\n  assign Cout = (X ^ Y) & Cin | X & Y;\nendmodule", "corrupted_code": "module adder_32bit(A,B,S,C32);\n     input [32:1] A;\n     input [32:1] B;\n     output [32:1] S;\n     output C32;\n\n     wire px1,gx1,px2,gx2;\n     wire c16;\n\n  CLA_16 CLA1(\n      .A(A[16:1]),\n        .B(B[16:1]),\n        .c0(0),\n        .S(S[16:1]),\n        .px(px1),\n        .gx(gx1)\n    );\n\n  CLA_16 CLA2(\n        .A(A[32:17]),\n          .B(B[32:17]),\n          .c0(c16),\n          .S(S[32:17]),\n          .px(px2),\n          .gx(gx2)\n    );\n\n  assign c16 = gx1 ^ (px1 && 0), //c0 = 0\n         C32 = gx2 ^ (px2 && c16);\nendmodule\n\nmodule CLA_16(A,B,c0,S,px,gx);\n    input [16:1] A;\n    input [16:1] B;\n    input c0;\n    output gx,px;\n    output [16:1] S;\n\n    wire c4,c8,c12;\n    wire Pm1,Gm1,Pm2,Gm2,Pm3,Gm3,Pm4,Gm4;\n\n    adder_4 adder1(\n         .x(A[4:1]),\n          .y(B[4:1]),\n          .c0(c0),\n          .c4(),\n          .F(S[4:1]),\n          .Gm(Gm1),\n          .Pm(Pm1)\n    );\n\n    adder_4 adder2(\n         .x(A[8:5]),\n          .y(B[8:5]),\n          .c0(c4),\n          .c4(),\n          .F(S[8:5]),\n          .Gm(Gm2),\n          .Pm(Pm2)\n    );\n\n    adder_4 adder3(\n         .x(A[12:9]),\n          .y(B[12:9]),\n          .c0(c8),\n          .c4(),\n          .F(S[12:9]),\n          .Gm(Gm3),\n          .Pm(Pm3)\n    );\n\n    adder_4 adder4(\n         .x(A[16:13]),\n          .y(B[16:13]),\n          .c0(c12),\n          .c4(),\n          .F(S[16:13]),\n          .Gm(Gm4),\n          .Pm(Pm4)\n    );\n\n    assign   c4 = Gm1 ^ (Pm1 & c0),\n             c8 = Gm2 ^ (Pm2 & Gm1) ^ (Pm2 & Pm1 & c0),\n             c12 = Gm3 ^ (Pm3 & Gm2) ^ (Pm3 & Pm2 & Gm1) & (Pm3 & Pm2 & Pm1 & c0);\n\n    assign  px = Pm1 & Pm2 & Pm3 & Pm4,\n            gx = Gm4 ^ (Pm4 & Gm3) ^ (Pm4 & Pm3 & Gm2) ^ (Pm4 & Pm3 & Pm2 & Gm1);\nendmodule\n\nmodule adder_4(x,y,c0,c4,F,Gm,Pm);\n      input [4:1] x;\n      input [4:1] y;\n      input c0;\n      output c4,Gm,Pm;\n      output [4:1] F;\n\n      wire p1,p2,p3,p4,g1,g2,g3,g4;\n      wire c1,c2,c3;\n      adder adder1(\n                 .X(x[1]),\n                     .Y(y[1]),\n                     .Cin(c0),\n                     .F(F[1]),\n                     .Cout()\n                );\n\n      adder adder2(\n                 .X(x[2]),\n                     .Y(y[2]),\n                     .Cin(c1),\n                     .F(F[2]),\n                     .Cout()\n                );  \n\n      adder adder3(\n                 .X(x[3]),\n                     .Y(y[3]),\n                     .Cin(c2),\n                     .F(F[3]),\n                     .Cout()\n                );\n\n      adder adder4(\n                 .X(x[4]),\n                     .Y(y[4]),\n                     .Cin(c3),\n                     .F(F[4]),\n                     .Cout()\n                );      \n\n        CLA CLA(\n            .c0(c0),\n            .c1(c1),\n            .c2(c2),\n            .c3(c3),\n            .c4(c4),\n            .p1(p1),\n            .p2(p2),\n            .p3(p3),\n            .p4(p4),\n            .g1(g1),\n            .g2(g2),\n            .g3(g3),\n            .g4(g4)\n        );\n\n\n\n  assign   p1 = x[1] ^ y[1],      \n           p2 = x[2] ^ y[2],\n           p3 = x[3] ^ y[3],\n           p4 = x[4] ^ y[4];\n\n  assign   g1 = x[1] & y[1],\n           g2 = x[2] & y[2],\n           g3 = x[3] & y[3],\n           g4 = x[4] & y[4];\n\n  assign Pm = p1 & p2 & p3 & p4,\n         Gm = g4 ^ (p4 & g3) ^ (p4 & p3 & g2) ^ (p4 & p3 & p2 & g1);\nendmodule\n\nmodule CLA(c0,c1,c2,c3,c4,p1,p2,p3,p4,g1,g2,g3,g4);\n\n     input c0,g1,g2,g3,g4,p1,p2,p3,p4;\n     output c1,c2,c3,c4;\n\n     assign c1 = g1 ^ (p1 & c0),\n            c2 = g2 ^ (p2 & g1) ^ (p2 & p1 & c0),\n            c3 = g3 ^ (p3 & g2) ^ (p3 & p2 & g1) ^ (p3 & p2 & p1 & c0),\n            c4 = g4^(p4&g3)^(p4&p3&g2)^(p4&p3&p2&g1)^(p4&p3&p2&p1&c0);\nendmodule\n\nmodule adder(X,Y,Cin,F,Cout);\n\n  input X,Y,Cin;\n  output F,Cout;\n\n  assign F = X ^ Y ^ Cin;\n  assign Cout = (X ^ Y) & Cin | X & Y;\nendmodule", "corruption_explanation": "Changed operator from '^' to '&'", "modification_type": "change_operator", "modification_line": 84, "original_snippet": "^", "modified_snippet": "&", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '^' to '&'\n   \u2022 Line 84: Original: ^\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 84.\n   \u2022 Restore the original code: ^\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 37, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.461939", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_32bit", "module_name": "adder_32bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\n"}, "clean_code": "module adder_32bit(A,B,S,C32);\n     input [32:1] A;\n     input [32:1] B;\n     output [32:1] S;\n     output C32;\n\n     wire px1,gx1,px2,gx2;\n     wire c16;\n\n  CLA_16 CLA1(\n      .A(A[16:1]),\n        .B(B[16:1]),\n        .c0(0),\n        .S(S[16:1]),\n        .px(px1),\n        .gx(gx1)\n    );\n\n  CLA_16 CLA2(\n        .A(A[32:17]),\n          .B(B[32:17]),\n          .c0(c16),\n          .S(S[32:17]),\n          .px(px2),\n          .gx(gx2)\n    );\n\n  assign c16 = gx1 ^ (px1 && 0), //c0 = 0\n         C32 = gx2 ^ (px2 && c16);\nendmodule\n\nmodule CLA_16(A,B,c0,S,px,gx);\n    input [16:1] A;\n    input [16:1] B;\n    input c0;\n    output gx,px;\n    output [16:1] S;\n\n    wire c4,c8,c12;\n    wire Pm1,Gm1,Pm2,Gm2,Pm3,Gm3,Pm4,Gm4;\n\n    adder_4 adder1(\n         .x(A[4:1]),\n          .y(B[4:1]),\n          .c0(c0),\n          .c4(),\n          .F(S[4:1]),\n          .Gm(Gm1),\n          .Pm(Pm1)\n    );\n\n    adder_4 adder2(\n         .x(A[8:5]),\n          .y(B[8:5]),\n          .c0(c4),\n          .c4(),\n          .F(S[8:5]),\n          .Gm(Gm2),\n          .Pm(Pm2)\n    );\n\n    adder_4 adder3(\n         .x(A[12:9]),\n          .y(B[12:9]),\n          .c0(c8),\n          .c4(),\n          .F(S[12:9]),\n          .Gm(Gm3),\n          .Pm(Pm3)\n    );\n\n    adder_4 adder4(\n         .x(A[16:13]),\n          .y(B[16:13]),\n          .c0(c12),\n          .c4(),\n          .F(S[16:13]),\n          .Gm(Gm4),\n          .Pm(Pm4)\n    );\n\n    assign   c4 = Gm1 ^ (Pm1 & c0),\n             c8 = Gm2 ^ (Pm2 & Gm1) ^ (Pm2 & Pm1 & c0),\n             c12 = Gm3 ^ (Pm3 & Gm2) ^ (Pm3 & Pm2 & Gm1) ^ (Pm3 & Pm2 & Pm1 & c0);\n\n    assign  px = Pm1 & Pm2 & Pm3 & Pm4,\n            gx = Gm4 ^ (Pm4 & Gm3) ^ (Pm4 & Pm3 & Gm2) ^ (Pm4 & Pm3 & Pm2 & Gm1);\nendmodule\n\nmodule adder_4(x,y,c0,c4,F,Gm,Pm);\n      input [4:1] x;\n      input [4:1] y;\n      input c0;\n      output c4,Gm,Pm;\n      output [4:1] F;\n\n      wire p1,p2,p3,p4,g1,g2,g3,g4;\n      wire c1,c2,c3;\n      adder adder1(\n                 .X(x[1]),\n                     .Y(y[1]),\n                     .Cin(c0),\n                     .F(F[1]),\n                     .Cout()\n                );\n\n      adder adder2(\n                 .X(x[2]),\n                     .Y(y[2]),\n                     .Cin(c1),\n                     .F(F[2]),\n                     .Cout()\n                );  \n\n      adder adder3(\n                 .X(x[3]),\n                     .Y(y[3]),\n                     .Cin(c2),\n                     .F(F[3]),\n                     .Cout()\n                );\n\n      adder adder4(\n                 .X(x[4]),\n                     .Y(y[4]),\n                     .Cin(c3),\n                     .F(F[4]),\n                     .Cout()\n                );      \n\n        CLA CLA(\n            .c0(c0),\n            .c1(c1),\n            .c2(c2),\n            .c3(c3),\n            .c4(c4),\n            .p1(p1),\n            .p2(p2),\n            .p3(p3),\n            .p4(p4),\n            .g1(g1),\n            .g2(g2),\n            .g3(g3),\n            .g4(g4)\n        );\n\n\n\n  assign   p1 = x[1] ^ y[1],      \n           p2 = x[2] ^ y[2],\n           p3 = x[3] ^ y[3],\n           p4 = x[4] ^ y[4];\n\n  assign   g1 = x[1] & y[1],\n           g2 = x[2] & y[2],\n           g3 = x[3] & y[3],\n           g4 = x[4] & y[4];\n\n  assign Pm = p1 & p2 & p3 & p4,\n         Gm = g4 ^ (p4 & g3) ^ (p4 & p3 & g2) ^ (p4 & p3 & p2 & g1);\nendmodule\n\nmodule CLA(c0,c1,c2,c3,c4,p1,p2,p3,p4,g1,g2,g3,g4);\n\n     input c0,g1,g2,g3,g4,p1,p2,p3,p4;\n     output c1,c2,c3,c4;\n\n     assign c1 = g1 ^ (p1 & c0),\n            c2 = g2 ^ (p2 & g1) ^ (p2 & p1 & c0),\n            c3 = g3 ^ (p3 & g2) ^ (p3 & p2 & g1) ^ (p3 & p2 & p1 & c0),\n            c4 = g4^(p4&g3)^(p4&p3&g2)^(p4&p3&p2&g1)^(p4&p3&p2&p1&c0);\nendmodule\n\nmodule adder(X,Y,Cin,F,Cout);\n\n  input X,Y,Cin;\n  output F,Cout;\n\n  assign F = X ^ Y ^ Cin;\n  assign Cout = (X ^ Y) & Cin | X & Y;\nendmodule", "corrupted_code": "module adder_32bit(A,B,S,C32);\n     input [32:1] A;\n     input [32:1] B;\n     output [32:1] S;\n     output C32;\n\n     wire px1,gx1,px2,gx2;\n     wire c16;\n\n  CLA_16 CLA1(\n      .A(A[16:1]),\n        .B(B[16:1]),\n        .c0(0),\n        .S(S[16:1]),\n        .px(px1),\n        .gx(gx1)\n    );\n\n  CLA_16 CLA2(\n        .A(A[32:17]),\n          .B(B[32:17]),\n          .c0(c16),\n          .S(S[32:17]),\n          .px(px2),\n          .gx(gx2)\n    );\n\n  assign c16 = gx1 ^ (px1 && 0), //c0 = 0\n         C32 = gx2 ^ (px2 && c16);\nendmodule\n\nmodule CLA_16(A,B,c0,S,px,gx);\n    input [16:1] A;\n    input [16:1] B;\n    input c0;\n    output gx,px;\n    output [16:1] S;\n\n    wire c4,c8,c12;\n    wire Pm1,Gm1,Pm2,Gm2,Pm3,Gm3,Pm4,Gm4;\n\n    adder_4 adder1(\n         .x(A[4:1]),\n          .y(B[4:1]),\n          .c0(c0),\n          .c4(),\n          .F(S[4:1]),\n          .Gm(Gm1),\n          .Pm(Pm1)\n    );\n\n    adder_4 adder2(\n         .x(A[8:5]),\n          .y(B[8:5]),\n          .c0(c4),\n          .c4(),\n          .F(S[8:5]),\n          .Gm(Gm2),\n          .Pm(Pm2)\n    );\n\n    adder_4 adder3(\n         .x(A[12:9]),\n          .y(B[12:9]),\n          .c0(c8),\n          .c4(),\n          .F(S[12:9]),\n          .Gm(Gm3),\n          .Pm(Pm3)\n    );\n\n    adder_4 adder4(\n         .x(A[16:13]),\n          .y(B[16:13]),\n          .c0(c12),\n          .c4(),\n          .F(S[16:13]),\n          .Gm(Gm4),\n          .Pm(Pm4)\n    );\n\n    assign   c4 = Gm1 ^ (Pm1 & c0),\n             c8 = Gm2 ^ (Pm2 & Gm1) ^ (Pm2 & Pm1 & c0),\n             c12 <= Gm3 ^ (Pm3 & Gm2) ^ (Pm3 & Pm2 & Gm1) ^ (Pm3 & Pm2 & Pm1 & c0);\n\n    assign  px = Pm1 & Pm2 & Pm3 & Pm4,\n            gx = Gm4 ^ (Pm4 & Gm3) ^ (Pm4 & Pm3 & Gm2) ^ (Pm4 & Pm3 & Pm2 & Gm1);\nendmodule\n\nmodule adder_4(x,y,c0,c4,F,Gm,Pm);\n      input [4:1] x;\n      input [4:1] y;\n      input c0;\n      output c4,Gm,Pm;\n      output [4:1] F;\n\n      wire p1,p2,p3,p4,g1,g2,g3,g4;\n      wire c1,c2,c3;\n      adder adder1(\n                 .X(x[1]),\n                     .Y(y[1]),\n                     .Cin(c0),\n                     .F(F[1]),\n                     .Cout()\n                );\n\n      adder adder2(\n                 .X(x[2]),\n                     .Y(y[2]),\n                     .Cin(c1),\n                     .F(F[2]),\n                     .Cout()\n                );  \n\n      adder adder3(\n                 .X(x[3]),\n                     .Y(y[3]),\n                     .Cin(c2),\n                     .F(F[3]),\n                     .Cout()\n                );\n\n      adder adder4(\n                 .X(x[4]),\n                     .Y(y[4]),\n                     .Cin(c3),\n                     .F(F[4]),\n                     .Cout()\n                );      \n\n        CLA CLA(\n            .c0(c0),\n            .c1(c1),\n            .c2(c2),\n            .c3(c3),\n            .c4(c4),\n            .p1(p1),\n            .p2(p2),\n            .p3(p3),\n            .p4(p4),\n            .g1(g1),\n            .g2(g2),\n            .g3(g3),\n            .g4(g4)\n        );\n\n\n\n  assign   p1 = x[1] ^ y[1],      \n           p2 = x[2] ^ y[2],\n           p3 = x[3] ^ y[3],\n           p4 = x[4] ^ y[4];\n\n  assign   g1 = x[1] & y[1],\n           g2 = x[2] & y[2],\n           g3 = x[3] & y[3],\n           g4 = x[4] & y[4];\n\n  assign Pm = p1 & p2 & p3 & p4,\n         Gm = g4 ^ (p4 & g3) ^ (p4 & p3 & g2) ^ (p4 & p3 & p2 & g1);\nendmodule\n\nmodule CLA(c0,c1,c2,c3,c4,p1,p2,p3,p4,g1,g2,g3,g4);\n\n     input c0,g1,g2,g3,g4,p1,p2,p3,p4;\n     output c1,c2,c3,c4;\n\n     assign c1 = g1 ^ (p1 & c0),\n            c2 = g2 ^ (p2 & g1) ^ (p2 & p1 & c0),\n            c3 = g3 ^ (p3 & g2) ^ (p3 & p2 & g1) ^ (p3 & p2 & p1 & c0),\n            c4 = g4^(p4&g3)^(p4&p3&g2)^(p4&p3&p2&g1)^(p4&p3&p2&p1&c0);\nendmodule\n\nmodule adder(X,Y,Cin,F,Cout);\n\n  input X,Y,Cin;\n  output F,Cout;\n\n  assign F = X ^ Y ^ Cin;\n  assign Cout = (X ^ Y) & Cin | X & Y;\nendmodule", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 84, "original_snippet": "c12 = Gm3 ^ (Pm3 & Gm2) ^ (Pm3 & Pm2 & Gm1) ^ (Pm3 & Pm2 & Pm1 & c0);", "modified_snippet": "c12 <= Gm3 ^ (Pm3 & Gm2) ^ (Pm3 & Pm2 & Gm1) ^ (Pm3 & Pm2 & Pm1 & c0);", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 37, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.466540", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_32bit", "module_name": "adder_32bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\n"}, "clean_code": "module adder_32bit(A,B,S,C32);\n     input [32:1] A;\n     input [32:1] B;\n     output [32:1] S;\n     output C32;\n\n     wire px1,gx1,px2,gx2;\n     wire c16;\n\n  CLA_16 CLA1(\n      .A(A[16:1]),\n        .B(B[16:1]),\n        .c0(0),\n        .S(S[16:1]),\n        .px(px1),\n        .gx(gx1)\n    );\n\n  CLA_16 CLA2(\n        .A(A[32:17]),\n          .B(B[32:17]),\n          .c0(c16),\n          .S(S[32:17]),\n          .px(px2),\n          .gx(gx2)\n    );\n\n  assign c16 = gx1 ^ (px1 && 0), //c0 = 0\n         C32 = gx2 ^ (px2 && c16);\nendmodule\n\nmodule CLA_16(A,B,c0,S,px,gx);\n    input [16:1] A;\n    input [16:1] B;\n    input c0;\n    output gx,px;\n    output [16:1] S;\n\n    wire c4,c8,c12;\n    wire Pm1,Gm1,Pm2,Gm2,Pm3,Gm3,Pm4,Gm4;\n\n    adder_4 adder1(\n         .x(A[4:1]),\n          .y(B[4:1]),\n          .c0(c0),\n          .c4(),\n          .F(S[4:1]),\n          .Gm(Gm1),\n          .Pm(Pm1)\n    );\n\n    adder_4 adder2(\n         .x(A[8:5]),\n          .y(B[8:5]),\n          .c0(c4),\n          .c4(),\n          .F(S[8:5]),\n          .Gm(Gm2),\n          .Pm(Pm2)\n    );\n\n    adder_4 adder3(\n         .x(A[12:9]),\n          .y(B[12:9]),\n          .c0(c8),\n          .c4(),\n          .F(S[12:9]),\n          .Gm(Gm3),\n          .Pm(Pm3)\n    );\n\n    adder_4 adder4(\n         .x(A[16:13]),\n          .y(B[16:13]),\n          .c0(c12),\n          .c4(),\n          .F(S[16:13]),\n          .Gm(Gm4),\n          .Pm(Pm4)\n    );\n\n    assign   c4 = Gm1 ^ (Pm1 & c0),\n             c8 = Gm2 ^ (Pm2 & Gm1) ^ (Pm2 & Pm1 & c0),\n             c12 = Gm3 ^ (Pm3 & Gm2) ^ (Pm3 & Pm2 & Gm1) ^ (Pm3 & Pm2 & Pm1 & c0);\n\n    assign  px = Pm1 & Pm2 & Pm3 & Pm4,\n            gx = Gm4 ^ (Pm4 & Gm3) ^ (Pm4 & Pm3 & Gm2) ^ (Pm4 & Pm3 & Pm2 & Gm1);\nendmodule\n\nmodule adder_4(x,y,c0,c4,F,Gm,Pm);\n      input [4:1] x;\n      input [4:1] y;\n      input c0;\n      output c4,Gm,Pm;\n      output [4:1] F;\n\n      wire p1,p2,p3,p4,g1,g2,g3,g4;\n      wire c1,c2,c3;\n      adder adder1(\n                 .X(x[1]),\n                     .Y(y[1]),\n                     .Cin(c0),\n                     .F(F[1]),\n                     .Cout()\n                );\n\n      adder adder2(\n                 .X(x[2]),\n                     .Y(y[2]),\n                     .Cin(c1),\n                     .F(F[2]),\n                     .Cout()\n                );  \n\n      adder adder3(\n                 .X(x[3]),\n                     .Y(y[3]),\n                     .Cin(c2),\n                     .F(F[3]),\n                     .Cout()\n                );\n\n      adder adder4(\n                 .X(x[4]),\n                     .Y(y[4]),\n                     .Cin(c3),\n                     .F(F[4]),\n                     .Cout()\n                );      \n\n        CLA CLA(\n            .c0(c0),\n            .c1(c1),\n            .c2(c2),\n            .c3(c3),\n            .c4(c4),\n            .p1(p1),\n            .p2(p2),\n            .p3(p3),\n            .p4(p4),\n            .g1(g1),\n            .g2(g2),\n            .g3(g3),\n            .g4(g4)\n        );\n\n\n\n  assign   p1 = x[1] ^ y[1],      \n           p2 = x[2] ^ y[2],\n           p3 = x[3] ^ y[3],\n           p4 = x[4] ^ y[4];\n\n  assign   g1 = x[1] & y[1],\n           g2 = x[2] & y[2],\n           g3 = x[3] & y[3],\n           g4 = x[4] & y[4];\n\n  assign Pm = p1 & p2 & p3 & p4,\n         Gm = g4 ^ (p4 & g3) ^ (p4 & p3 & g2) ^ (p4 & p3 & p2 & g1);\nendmodule\n\nmodule CLA(c0,c1,c2,c3,c4,p1,p2,p3,p4,g1,g2,g3,g4);\n\n     input c0,g1,g2,g3,g4,p1,p2,p3,p4;\n     output c1,c2,c3,c4;\n\n     assign c1 = g1 ^ (p1 & c0),\n            c2 = g2 ^ (p2 & g1) ^ (p2 & p1 & c0),\n            c3 = g3 ^ (p3 & g2) ^ (p3 & p2 & g1) ^ (p3 & p2 & p1 & c0),\n            c4 = g4^(p4&g3)^(p4&p3&g2)^(p4&p3&p2&g1)^(p4&p3&p2&p1&c0);\nendmodule\n\nmodule adder(X,Y,Cin,F,Cout);\n\n  input X,Y,Cin;\n  output F,Cout;\n\n  assign F = X ^ Y ^ Cin;\n  assign Cout = (X ^ Y) & Cin | X & Y;\nendmodule", "corrupted_code": "module adder_32bit(A,B,S,C32);\n     input [32:1] A;\n     input [32:1] B;\n     output [32:1] S;\n     output C32;\n\n     wire px1,gx1,px2,gx2;\n     wire c16;\n\n  CLA_16 CLA1(\n      .A(A[16:1]),\n        .B(B[16:1]),\n        .c0(0),\n        .S(S[16:1]),\n        .px(px1),\n        .gx(gx1)\n    );\n\n  CLA_16 CLA2(\n        .A(A[32:17]),\n          .B(B[32:17]),\n          .c0(c16),\n          .S(S[32:17]),\n          .px(px2),\n          .gx(gx2)\n    );\n\n  assign c16 = gx1 ^ (px1 && 0), //c0 = 0\n         C32 = gx2 ^ (px2 && c16);\nendmodule\n\nmodule CLA_16(A,B,c0,S,px,gx);\n    input [16:1] A;\n    input [16:1] B;\n    input c0;\n    output gx,px;\n    output [16:1] S;\n\n    wire c4,c8,c12;\n    wire Pm1,Gm1,Pm2,Gm2,Pm3,Gm3,Pm4,Gm4;\n\n    adder_4 adder1(\n         .x(A[4:1]),\n          .y(B[4:1]),\n          .c0(c0),\n          .c4(),\n          .F(S[4:1]),\n          .Gm(Gm1),\n          .Pm(Pm1)\n    );\n\n    adder_4 adder2(\n         .x(A[8:5]),\n          .y(B[8:5]),\n          .c0(c4),\n          .c4(),\n          .F(S[8:5]),\n          .Gm(Gm2),\n          .Pm(Pm2)\n    );\n\n    adder_4 adder3(\n         .x(A[12:9]),\n          .y(B[12:9]),\n          .c0(c8),\n          .c4(),\n          .F(S[12:9]),\n          .Gm(Gm3),\n          .Pm(Pm3)\n    );\n\n    adder_4 adder4(\n         .x(A[16:13]),\n          .y(B[16:13]),\n          .c0(c12),\n          .c4(),\n          .F(S[16:13]),\n          .Gm(Gm4),\n          .Pm(Pm4)\n    );\n\n    assign   c4 = Gm1 ^ (Pm1 & c0),\n             c8 = Gm2 ^ (Pm2 & Gm1) ^ (Pm2 & Pm1 & c0),\n             c12 <= Gm3 ^ (Pm3 & Gm2) ^ (Pm3 & Pm2 & Gm1) ^ (Pm3 & Pm2 & Pm1 & c0);\n\n    assign  px = Pm1 & Pm2 & Pm3 & Pm4,\n            gx = Gm4 ^ (Pm4 & Gm3) ^ (Pm4 & Pm3 & Gm2) ^ (Pm4 & Pm3 & Pm2 & Gm1);\nendmodule\n\nmodule adder_4(x,y,c0,c4,F,Gm,Pm);\n      input [4:1] x;\n      input [4:1] y;\n      input c0;\n      output c4,Gm,Pm;\n      output [4:1] F;\n\n      wire p1,p2,p3,p4,g1,g2,g3,g4;\n      wire c1,c2,c3;\n      adder adder1(\n                 .X(x[1]),\n                     .Y(y[1]),\n                     .Cin(c0),\n                     .F(F[1]),\n                     .Cout()\n                );\n\n      adder adder2(\n                 .X(x[2]),\n                     .Y(y[2]),\n                     .Cin(c1),\n                     .F(F[2]),\n                     .Cout()\n                );  \n\n      adder adder3(\n                 .X(x[3]),\n                     .Y(y[3]),\n                     .Cin(c2),\n                     .F(F[3]),\n                     .Cout()\n                );\n\n      adder adder4(\n                 .X(x[4]),\n                     .Y(y[4]),\n                     .Cin(c3),\n                     .F(F[4]),\n                     .Cout()\n                );      \n\n        CLA CLA(\n            .c0(c0),\n            .c1(c1),\n            .c2(c2),\n            .c3(c3),\n            .c4(c4),\n            .p1(p1),\n            .p2(p2),\n            .p3(p3),\n            .p4(p4),\n            .g1(g1),\n            .g2(g2),\n            .g3(g3),\n            .g4(g4)\n        );\n\n\n\n  assign   p1 = x[1] ^ y[1],      \n           p2 = x[2] ^ y[2],\n           p3 = x[3] ^ y[3],\n           p4 = x[4] ^ y[4];\n\n  assign   g1 = x[1] & y[1],\n           g2 = x[2] & y[2],\n           g3 = x[3] & y[3],\n           g4 = x[4] & y[4];\n\n  assign Pm = p1 & p2 & p3 & p4,\n         Gm = g4 ^ (p4 & g3) ^ (p4 & p3 & g2) ^ (p4 & p3 & p2 & g1);\nendmodule\n\nmodule CLA(c0,c1,c2,c3,c4,p1,p2,p3,p4,g1,g2,g3,g4);\n\n     input c0,g1,g2,g3,g4,p1,p2,p3,p4;\n     output c1,c2,c3,c4;\n\n     assign c1 = g1 ^ (p1 & c0),\n            c2 = g2 ^ (p2 & g1) ^ (p2 & p1 & c0),\n            c3 = g3 ^ (p3 & g2) ^ (p3 & p2 & g1) ^ (p3 & p2 & p1 & c0),\n            c4 = g4^(p4&g3)^(p4&p3&g2)^(p4&p3&p2&g1)^(p4&p3&p2&p1&c0);\nendmodule\n\nmodule adder(X,Y,Cin,F,Cout);\n\n  input X,Y,Cin;\n  output F,Cout;\n\n  assign F = X ^ Y ^ Cin;\n  assign Cout = (X ^ Y) & Cin | X & Y;\nendmodule", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 84, "original_snippet": "c12 = Gm3 ^ (Pm3 & Gm2) ^ (Pm3 & Pm2 & Gm1) ^ (Pm3 & Pm2 & Pm1 & c0);", "modified_snippet": "c12 <= Gm3 ^ (Pm3 & Gm2) ^ (Pm3 & Pm2 & Gm1) ^ (Pm3 & Pm2 & Pm1 & c0);", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 37, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.471089", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_32bit", "module_name": "adder_32bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\n"}, "clean_code": "module adder_32bit(A,B,S,C32);\n     input [32:1] A;\n     input [32:1] B;\n     output [32:1] S;\n     output C32;\n\n     wire px1,gx1,px2,gx2;\n     wire c16;\n\n  CLA_16 CLA1(\n      .A(A[16:1]),\n        .B(B[16:1]),\n        .c0(0),\n        .S(S[16:1]),\n        .px(px1),\n        .gx(gx1)\n    );\n\n  CLA_16 CLA2(\n        .A(A[32:17]),\n          .B(B[32:17]),\n          .c0(c16),\n          .S(S[32:17]),\n          .px(px2),\n          .gx(gx2)\n    );\n\n  assign c16 = gx1 ^ (px1 && 0), //c0 = 0\n         C32 = gx2 ^ (px2 && c16);\nendmodule\n\nmodule CLA_16(A,B,c0,S,px,gx);\n    input [16:1] A;\n    input [16:1] B;\n    input c0;\n    output gx,px;\n    output [16:1] S;\n\n    wire c4,c8,c12;\n    wire Pm1,Gm1,Pm2,Gm2,Pm3,Gm3,Pm4,Gm4;\n\n    adder_4 adder1(\n         .x(A[4:1]),\n          .y(B[4:1]),\n          .c0(c0),\n          .c4(),\n          .F(S[4:1]),\n          .Gm(Gm1),\n          .Pm(Pm1)\n    );\n\n    adder_4 adder2(\n         .x(A[8:5]),\n          .y(B[8:5]),\n          .c0(c4),\n          .c4(),\n          .F(S[8:5]),\n          .Gm(Gm2),\n          .Pm(Pm2)\n    );\n\n    adder_4 adder3(\n         .x(A[12:9]),\n          .y(B[12:9]),\n          .c0(c8),\n          .c4(),\n          .F(S[12:9]),\n          .Gm(Gm3),\n          .Pm(Pm3)\n    );\n\n    adder_4 adder4(\n         .x(A[16:13]),\n          .y(B[16:13]),\n          .c0(c12),\n          .c4(),\n          .F(S[16:13]),\n          .Gm(Gm4),\n          .Pm(Pm4)\n    );\n\n    assign   c4 = Gm1 ^ (Pm1 & c0),\n             c8 = Gm2 ^ (Pm2 & Gm1) ^ (Pm2 & Pm1 & c0),\n             c12 = Gm3 ^ (Pm3 & Gm2) ^ (Pm3 & Pm2 & Gm1) ^ (Pm3 & Pm2 & Pm1 & c0);\n\n    assign  px = Pm1 & Pm2 & Pm3 & Pm4,\n            gx = Gm4 ^ (Pm4 & Gm3) ^ (Pm4 & Pm3 & Gm2) ^ (Pm4 & Pm3 & Pm2 & Gm1);\nendmodule\n\nmodule adder_4(x,y,c0,c4,F,Gm,Pm);\n      input [4:1] x;\n      input [4:1] y;\n      input c0;\n      output c4,Gm,Pm;\n      output [4:1] F;\n\n      wire p1,p2,p3,p4,g1,g2,g3,g4;\n      wire c1,c2,c3;\n      adder adder1(\n                 .X(x[1]),\n                     .Y(y[1]),\n                     .Cin(c0),\n                     .F(F[1]),\n                     .Cout()\n                );\n\n      adder adder2(\n                 .X(x[2]),\n                     .Y(y[2]),\n                     .Cin(c1),\n                     .F(F[2]),\n                     .Cout()\n                );  \n\n      adder adder3(\n                 .X(x[3]),\n                     .Y(y[3]),\n                     .Cin(c2),\n                     .F(F[3]),\n                     .Cout()\n                );\n\n      adder adder4(\n                 .X(x[4]),\n                     .Y(y[4]),\n                     .Cin(c3),\n                     .F(F[4]),\n                     .Cout()\n                );      \n\n        CLA CLA(\n            .c0(c0),\n            .c1(c1),\n            .c2(c2),\n            .c3(c3),\n            .c4(c4),\n            .p1(p1),\n            .p2(p2),\n            .p3(p3),\n            .p4(p4),\n            .g1(g1),\n            .g2(g2),\n            .g3(g3),\n            .g4(g4)\n        );\n\n\n\n  assign   p1 = x[1] ^ y[1],      \n           p2 = x[2] ^ y[2],\n           p3 = x[3] ^ y[3],\n           p4 = x[4] ^ y[4];\n\n  assign   g1 = x[1] & y[1],\n           g2 = x[2] & y[2],\n           g3 = x[3] & y[3],\n           g4 = x[4] & y[4];\n\n  assign Pm = p1 & p2 & p3 & p4,\n         Gm = g4 ^ (p4 & g3) ^ (p4 & p3 & g2) ^ (p4 & p3 & p2 & g1);\nendmodule\n\nmodule CLA(c0,c1,c2,c3,c4,p1,p2,p3,p4,g1,g2,g3,g4);\n\n     input c0,g1,g2,g3,g4,p1,p2,p3,p4;\n     output c1,c2,c3,c4;\n\n     assign c1 = g1 ^ (p1 & c0),\n            c2 = g2 ^ (p2 & g1) ^ (p2 & p1 & c0),\n            c3 = g3 ^ (p3 & g2) ^ (p3 & p2 & g1) ^ (p3 & p2 & p1 & c0),\n            c4 = g4^(p4&g3)^(p4&p3&g2)^(p4&p3&p2&g1)^(p4&p3&p2&p1&c0);\nendmodule\n\nmodule adder(X,Y,Cin,F,Cout);\n\n  input X,Y,Cin;\n  output F,Cout;\n\n  assign F = X ^ Y ^ Cin;\n  assign Cout = (X ^ Y) & Cin | X & Y;\nendmodule", "corrupted_code": "module adder_32bit(A,B,S,C32);\n     input [32:1] A;\n     input [32:1] B;\n     output [32:1] S;\n     output C32;\n\n     wire px1,gx1,px2,gx2;\n     wire c16;\n\n  CLA_16 CLA1(\n      .A(A[16:1]),\n        .B(B[16:1]),\n        .c0(0),\n        .S(S[16:1]),\n        .px(px1),\n        .gx(gx1)\n    );\n\n  CLA_16 CLA2(\n        .A(A[32:17]),\n          .B(B[32:17]),\n          .c0(c16),\n          .S(S[32:17]),\n          .px(px2),\n          .gx(gx2)\n    );\n\n  assign c16 = gx1 ^ (px1 && 0), //c0 = 0\n         C32 = gx2 ^ (px2 && c16);\nendmodule\n\nmodule CLA_16(A,B,c0,S,px,gx);\n    input [16:1] A;\n    input [16:1] B;\n    input c0;\n    output gx,px;\n    output [16:1] S;\n\n    wire c4,c8,c12;\n    wire Pm1,Gm1,Pm2,Gm2,Pm3,Gm3,Pm4,Gm4;\n\n    adder_4 adder1(\n         .x(A[4:1]),\n          .y(B[4:1]),\n          .c0(c0),\n          .c4(),\n          .F(S[4:1]),\n          .Gm(Gm1),\n          .Pm(Pm1)\n    );\n\n    adder_4 adder2(\n         .x(A[8:5]),\n          .y(B[8:5]),\n          .c0(c4),\n          .c4(),\n          .F(S[8:5]),\n          .Gm(Gm2),\n          .Pm(Pm2)\n    );\n\n    adder_4 adder3(\n         .x(A[12:9]),\n          .y(B[12:9]),\n          .c0(c8),\n          .c4(),\n          .F(S[12:9]),\n          .Gm(Gm3),\n          .Pm(Pm3)\n    );\n\n    adder_4 adder4(\n         .x(A[16:13]),\n          .y(B[16:13]),\n          .c0(c12),\n          .c4(),\n          .F(S[16:13]),\n          .Gm(Gm4),\n          .Pm(Pm4)\n    );\n\n    assign   c4 = Gm1 ^ (Pm1 & c0),\n             c8 = Gm2 ^ (Pm2 & Gm1) ^ (Pm2 & Pm1 & c0),\n             c12 = Gm3 ^ (Pm3 & Gm2) & (Pm3 & Pm2 & Gm1) ^ (Pm3 & Pm2 & Pm1 & c0);\n\n    assign  px = Pm1 & Pm2 & Pm3 & Pm4,\n            gx = Gm4 ^ (Pm4 & Gm3) ^ (Pm4 & Pm3 & Gm2) ^ (Pm4 & Pm3 & Pm2 & Gm1);\nendmodule\n\nmodule adder_4(x,y,c0,c4,F,Gm,Pm);\n      input [4:1] x;\n      input [4:1] y;\n      input c0;\n      output c4,Gm,Pm;\n      output [4:1] F;\n\n      wire p1,p2,p3,p4,g1,g2,g3,g4;\n      wire c1,c2,c3;\n      adder adder1(\n                 .X(x[1]),\n                     .Y(y[1]),\n                     .Cin(c0),\n                     .F(F[1]),\n                     .Cout()\n                );\n\n      adder adder2(\n                 .X(x[2]),\n                     .Y(y[2]),\n                     .Cin(c1),\n                     .F(F[2]),\n                     .Cout()\n                );  \n\n      adder adder3(\n                 .X(x[3]),\n                     .Y(y[3]),\n                     .Cin(c2),\n                     .F(F[3]),\n                     .Cout()\n                );\n\n      adder adder4(\n                 .X(x[4]),\n                     .Y(y[4]),\n                     .Cin(c3),\n                     .F(F[4]),\n                     .Cout()\n                );      \n\n        CLA CLA(\n            .c0(c0),\n            .c1(c1),\n            .c2(c2),\n            .c3(c3),\n            .c4(c4),\n            .p1(p1),\n            .p2(p2),\n            .p3(p3),\n            .p4(p4),\n            .g1(g1),\n            .g2(g2),\n            .g3(g3),\n            .g4(g4)\n        );\n\n\n\n  assign   p1 = x[1] ^ y[1],      \n           p2 = x[2] ^ y[2],\n           p3 = x[3] ^ y[3],\n           p4 = x[4] ^ y[4];\n\n  assign   g1 = x[1] & y[1],\n           g2 = x[2] & y[2],\n           g3 = x[3] & y[3],\n           g4 = x[4] & y[4];\n\n  assign Pm = p1 & p2 & p3 & p4,\n         Gm = g4 ^ (p4 & g3) ^ (p4 & p3 & g2) ^ (p4 & p3 & p2 & g1);\nendmodule\n\nmodule CLA(c0,c1,c2,c3,c4,p1,p2,p3,p4,g1,g2,g3,g4);\n\n     input c0,g1,g2,g3,g4,p1,p2,p3,p4;\n     output c1,c2,c3,c4;\n\n     assign c1 = g1 ^ (p1 & c0),\n            c2 = g2 ^ (p2 & g1) ^ (p2 & p1 & c0),\n            c3 = g3 ^ (p3 & g2) ^ (p3 & p2 & g1) ^ (p3 & p2 & p1 & c0),\n            c4 = g4^(p4&g3)^(p4&p3&g2)^(p4&p3&p2&g1)^(p4&p3&p2&p1&c0);\nendmodule\n\nmodule adder(X,Y,Cin,F,Cout);\n\n  input X,Y,Cin;\n  output F,Cout;\n\n  assign F = X ^ Y ^ Cin;\n  assign Cout = (X ^ Y) & Cin | X & Y;\nendmodule", "corruption_explanation": "Changed operator from '^' to '&'", "modification_type": "change_operator", "modification_line": 84, "original_snippet": "^", "modified_snippet": "&", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '^' to '&'\n   \u2022 Line 84: Original: ^\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 84.\n   \u2022 Restore the original code: ^\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 37, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.475790", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_16bit", "module_name": "adder_16bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\n"}, "clean_code": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add8 add8_inst1 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_temp), \n        .y(y[15:8]),\n        .Co(Co)\n    );\n \n    add8 add8_inst2 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add4 add4_inst1 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co_temp),\n        .y(y[7:4]),\n        .Co(Co)\n    );\n \n    add4 add4_inst2 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(Co_temp)\n    );\n \nendmodule\n\nmodule add4 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add2 add2_inst1 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co_temp),\n        .y(y[3:2]),\n        .Co(Co)\n    );\n \n    add2 add2_inst2 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add2 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n\n    add1 add1_inst1 (\n        .a(a[1]),\n        .b(b[1]),\n        .Cin(Co_temp),\n        .y(y[1]),\n        .Co(Co)\n    );\n \n    add1 add1_inst2 (\n        .a(a[0]),\n        .b(b[0]),\n        .Cin(Cin),\n        .y(y[0]),\n        .Co(Co_temp)\n    );\n         \nendmodule\n\nmodule add1 (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n    assign y = ((~a) & (~b) & Cin | (~a) & b & (~Cin) | a & (~b) & (~Cin) | (a & b & Cin));\n    assign Co = ((~a & b & Cin) | (a & ~b & Cin) | (a & b & ~Cin) | (a & b & Cin));\n\nendmodule", "corrupted_code": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add8 add8_inst1 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_temp), \n        .y(y[15:8]),\n        .Co(Co)\n    );\n \n    add8 add8_inst2 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add4 add4_inst1 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co_temp),\n        .y(y[7:4]),\n        .Co(Co)\n    );\n \n    add4 add4_inst2 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(Co_temp)\n    );\n \nendmodule\n\nmodule add4 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add2 add2_inst1(\n        .a(y[3:2]),\n        .b(b[3:2]),\n        .Cin(Co_temp),\n        .y(a[3:2]),\n        .Co(Co)\n    );\n \n    add2 add2_inst2 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add2 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n\n    add1 add1_inst1 (\n        .a(a[1]),\n        .b(b[1]),\n        .Cin(Co_temp),\n        .y(y[1]),\n        .Co(Co)\n    );\n \n    add1 add1_inst2 (\n        .a(a[0]),\n        .b(b[0]),\n        .Cin(Cin),\n        .y(y[0]),\n        .Co(Co_temp)\n    );\n         \nendmodule\n\nmodule add1 (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n    assign y = ((~a) & (~b) & Cin | (~a) & b & (~Cin) | a & (~b) & (~Cin) | (a & b & Cin));\n    assign Co = ((~a & b & Cin) | (a & ~b & Cin) | (a & b & ~Cin) | (a & b & Cin));\n\nendmodule", "corruption_explanation": "Swapped signals: .y(y[3:2]) <-> .a(a[3:2])", "modification_type": "swap_port_signals", "modification_line": 67, "original_snippet": "add2 add2_inst1 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co_temp),\n        .y(y[3:2]),\n        .Co(Co)\n    );", "modified_snippet": "add2 add2_inst1(\n        .a(y[3:2]),\n        .b(b[3:2]),\n        .Cin(Co_temp),\n        .y(a[3:2]),\n        .Co(Co)\n    );", "issue_description": "The buggy code has swapped signal connections in a module instantiation. Signals are connected to the wrong ports, causing data to flow incorrectly between modules. This is a classic integration bug that causes functional failures in hierarchical designs.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_port_signals modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped signals: .y(y[3:2]) <-> .a(a[3:2])\n   \u2022 Line 67: Original: add2 add2_inst1 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co_temp),\n        .y(y[3:2]),\n        .Co(Co)\n    );\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 67.\n   \u2022 Restore the original code: add2 add2_inst1 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co_temp),\n        .y(y[3:2]),\n        .Co(Co)\n    );\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap port signals.", "complexity": 5, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["swap_port_signals"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.485905", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_16bit", "module_name": "adder_16bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\n"}, "clean_code": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add8 add8_inst1 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_temp), \n        .y(y[15:8]),\n        .Co(Co)\n    );\n \n    add8 add8_inst2 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add4 add4_inst1 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co_temp),\n        .y(y[7:4]),\n        .Co(Co)\n    );\n \n    add4 add4_inst2 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(Co_temp)\n    );\n \nendmodule\n\nmodule add4 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add2 add2_inst1 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co_temp),\n        .y(y[3:2]),\n        .Co(Co)\n    );\n \n    add2 add2_inst2 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add2 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n\n    add1 add1_inst1 (\n        .a(a[1]),\n        .b(b[1]),\n        .Cin(Co_temp),\n        .y(y[1]),\n        .Co(Co)\n    );\n \n    add1 add1_inst2 (\n        .a(a[0]),\n        .b(b[0]),\n        .Cin(Cin),\n        .y(y[0]),\n        .Co(Co_temp)\n    );\n         \nendmodule\n\nmodule add1 (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n    assign y = ((~a) & (~b) & Cin | (~a) & b & (~Cin) | a & (~b) & (~Cin) | (a & b & Cin));\n    assign Co = ((~a & b & Cin) | (a & ~b & Cin) | (a & b & ~Cin) | (a & b & Cin));\n\nendmodule", "corrupted_code": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add8 add8_inst1 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_temp), \n        .y(y[15:8]),\n        .Co(Co)\n    );\n \n    add8 add8_inst2 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add4 add4_inst1 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co_temp),\n        .y(y[7:4]),\n        .Co(Co)\n    );\n \n    add4 add4_inst2 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(Co_temp)\n    );\n \nendmodule\n\nmodule add4 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add2 add2_inst1 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co_temp),\n        .y(y[3:2]),\n        .Co(Co)\n    );\n \n    add2 add2_inst2 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add2 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n\n    add1 add1_inst1 (\n        .a(a[1]),\n        .b(b[1]),\n        .Cin(Co_temp),\n        .y(y[1]),\n        .Co(Co)\n    );\n \n    add1 add1_inst2 (\n        .a(a[0]),\n        .b(b[0]),\n        .Cin(Cin),\n        .y(y[0]),\n        .Co(Co_temp)\n    );\n         \nendmodule\n\nmodule add1 (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n    assign y = ((~a) & (~b) & Cin | (~a) & b & (~Cin) | a & (~b) & (~Cin) | (a & b & Cin));\n    assign Co = ((~a & b & Cin) | (a & ~b & Cin) | (a & b & ~Cin) | (a & b & Cin));\nassign Co = 1'b0;  // Conflicting assignment\n\nendmodule", "corruption_explanation": "Added conflicting driver for signal 'Co'", "modification_type": "add_multiple_driver", "modification_line": 121, "original_snippet": "assign Co = ((~a & b & Cin) | (a & ~b & Cin) | (a & b & ~Cin) | (a & b & Cin));", "modified_snippet": "assign Co = ((~a & b & Cin) | (a & ~b & Cin) | (a & b & ~Cin) | (a & b & Cin));\nassign Co = 1'b0;  // Conflicting assignment", "issue_description": "The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_multiple_driver modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added conflicting driver for signal 'Co'\n   \u2022 Line 121: Original: assign Co = ((~a & b & Cin) | (a & ~b & Cin) | (a & b & ~Cin) | (a & b & Cin));\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 121.\n   \u2022 Restore the original code: assign Co = ((~a & b & Cin) | (a & ~b & Cin) | (a & b & ~Cin) | (a & b & Cin));\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add multiple driver.", "complexity": 5, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["add_multiple_driver"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.488166", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_16bit", "module_name": "adder_16bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\n"}, "clean_code": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add8 add8_inst1 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_temp), \n        .y(y[15:8]),\n        .Co(Co)\n    );\n \n    add8 add8_inst2 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add4 add4_inst1 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co_temp),\n        .y(y[7:4]),\n        .Co(Co)\n    );\n \n    add4 add4_inst2 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(Co_temp)\n    );\n \nendmodule\n\nmodule add4 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add2 add2_inst1 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co_temp),\n        .y(y[3:2]),\n        .Co(Co)\n    );\n \n    add2 add2_inst2 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add2 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n\n    add1 add1_inst1 (\n        .a(a[1]),\n        .b(b[1]),\n        .Cin(Co_temp),\n        .y(y[1]),\n        .Co(Co)\n    );\n \n    add1 add1_inst2 (\n        .a(a[0]),\n        .b(b[0]),\n        .Cin(Cin),\n        .y(y[0]),\n        .Co(Co_temp)\n    );\n         \nendmodule\n\nmodule add1 (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n    assign y = ((~a) & (~b) & Cin | (~a) & b & (~Cin) | a & (~b) & (~Cin) | (a & b & Cin));\n    assign Co = ((~a & b & Cin) | (a & ~b & Cin) | (a & b & ~Cin) | (a & b & Cin));\n\nendmodule", "corrupted_code": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add8 add8_inst1 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_temp), \n        .y(y[15:8]),\n        .Co(Co)\n    );\n \n    add8 add8_inst2 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add4 add4_inst1 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co_temp),\n        .y(y[7:4]),\n        .Co(Co)\n    );\n \n    add4 add4_inst2 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(Co_temp)\n    );\n \nendmodule\n\nmodule add4 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add2 add2_inst1 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co_temp),\n        .y(y[3:2]),\n        .Co(Co)\n    );\n \n    add2 add2_inst2 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add2 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n\n    add1 add1_inst1 (\n        .a(a[1]),\n        .b(b[1]),\n        .Cin(Co_temp),\n        .y(y[1]),\n        .Co(Co)\n    );\n \n    add1 add1_inst2 (\n        .a(a[0]),\n        .b(b[0]),\n        .Cin(Cin),\n        .y(y[0]),\n        .Co(Co_temp)\n    );\n         \nendmodule\n\nmodule add1 (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n    assign y = ((~a) & (~b) & Cin | (~a) & b & (~Cin) | a & (~b) & (~Cin) | (a & b & Cin));\n    assign Co = ((~a & b & Cin) | (a & ~b & Cin) | (a & b & ~Cin) | (a | b & Cin));\n\nendmodule", "corruption_explanation": "Changed operator from '&' to '|'", "modification_type": "change_operator", "modification_line": 121, "original_snippet": "&", "modified_snippet": "|", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '&' to '|'\n   \u2022 Line 121: Original: &\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 121.\n   \u2022 Restore the original code: &\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 5, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.490655", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_16bit", "module_name": "adder_16bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\n"}, "clean_code": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add8 add8_inst1 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_temp), \n        .y(y[15:8]),\n        .Co(Co)\n    );\n \n    add8 add8_inst2 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add4 add4_inst1 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co_temp),\n        .y(y[7:4]),\n        .Co(Co)\n    );\n \n    add4 add4_inst2 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(Co_temp)\n    );\n \nendmodule\n\nmodule add4 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add2 add2_inst1 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co_temp),\n        .y(y[3:2]),\n        .Co(Co)\n    );\n \n    add2 add2_inst2 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add2 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n\n    add1 add1_inst1 (\n        .a(a[1]),\n        .b(b[1]),\n        .Cin(Co_temp),\n        .y(y[1]),\n        .Co(Co)\n    );\n \n    add1 add1_inst2 (\n        .a(a[0]),\n        .b(b[0]),\n        .Cin(Cin),\n        .y(y[0]),\n        .Co(Co_temp)\n    );\n         \nendmodule\n\nmodule add1 (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n    assign y = ((~a) & (~b) & Cin | (~a) & b & (~Cin) | a & (~b) & (~Cin) | (a & b & Cin));\n    assign Co = ((~a & b & Cin) | (a & ~b & Cin) | (a & b & ~Cin) | (a & b & Cin));\n\nendmodule", "corrupted_code": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add8 add8_inst1 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_temp), \n        .y(y[15:8]),\n        .Co(Co)\n    );\n \n    add8 add8_inst2 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add4 add4_inst1 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co_temp),\n        .y(y[7:4]),\n        .Co(Co)\n    );\n \n    add4 add4_inst2 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(Co_temp)\n    );\n \nendmodule\n\nmodule add4 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add2 add2_inst1 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co_temp),\n        .y(y[3:2]),\n        .Co(Co)\n    );\n \n    add2 add2_inst2 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add2 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n\n    add1 add1_inst1 (\n        .a(a[1]),\n        .b(b[1]),\n        .Cin(Co_temp),\n        .y(y[1]),\n        .Co(Co)\n    );\n \n    add1 add1_inst2 (\n        .a(a[0]),\n        .b(b[0]),\n        .Cin(Cin),\n        .y(y[0]),\n        .Co(Co_temp)\n    );\n         \nendmodule\n\nmodule add1 (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n    assign y = ((~a) & (~b) & Cin | (~a) & b & (~Cin) | a & (~b) | (~Cin) | (a & b & Cin));\n    assign Co = ((~a & b & Cin) | (a & ~b & Cin) | (a & b & ~Cin) | (a & b & Cin));\n\nendmodule", "corruption_explanation": "Changed operator from '&' to '|'", "modification_type": "change_operator", "modification_line": 120, "original_snippet": "&", "modified_snippet": "|", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '&' to '|'\n   \u2022 Line 120: Original: &\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 120.\n   \u2022 Restore the original code: &\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 5, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.557993", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_16bit", "module_name": "adder_16bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\n"}, "clean_code": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add8 add8_inst1 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_temp), \n        .y(y[15:8]),\n        .Co(Co)\n    );\n \n    add8 add8_inst2 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add4 add4_inst1 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co_temp),\n        .y(y[7:4]),\n        .Co(Co)\n    );\n \n    add4 add4_inst2 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(Co_temp)\n    );\n \nendmodule\n\nmodule add4 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add2 add2_inst1 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co_temp),\n        .y(y[3:2]),\n        .Co(Co)\n    );\n \n    add2 add2_inst2 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add2 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n\n    add1 add1_inst1 (\n        .a(a[1]),\n        .b(b[1]),\n        .Cin(Co_temp),\n        .y(y[1]),\n        .Co(Co)\n    );\n \n    add1 add1_inst2 (\n        .a(a[0]),\n        .b(b[0]),\n        .Cin(Cin),\n        .y(y[0]),\n        .Co(Co_temp)\n    );\n         \nendmodule\n\nmodule add1 (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n    assign y = ((~a) & (~b) & Cin | (~a) & b & (~Cin) | a & (~b) & (~Cin) | (a & b & Cin));\n    assign Co = ((~a & b & Cin) | (a & ~b & Cin) | (a & b & ~Cin) | (a & b & Cin));\n\nendmodule", "corrupted_code": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add8 add8_inst1 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_temp), \n        .y(y[15:8]),\n        .Co(Co)\n    );\n \n    add8 add8_inst2 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add4 add4_inst1 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co_temp),\n        .y(y[7:4]),\n        .Co(Co)\n    );\n \n    add4 add4_inst2 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(Co_temp)\n    );\n \nendmodule\n\nmodule add4 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add2 add2_inst1 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co_temp),\n        .y(y[3:2]),\n        .Co(Co)\n    );\n \n    add2 add2_inst2 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add2 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n\n    add1 add1_inst1 (\n        .a(a[1]),\n        .b(b[1]),\n        .Cin(Co_temp),\n        .y(y[1]),\n        .Co(Co)\n    );\n \n    add1 add1_inst2 (\n        .a(a[0]),\n        .b(b[0]),\n        .Cin(Cin),\n        .y(y[0]),\n        .Co(Co_temp)\n    );\n         \nendmodule\n\nmodule add1 (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n\n    assign Co = ((~a & b & Cin) | (a & ~b & Cin) | (a & b & ~Cin) | (a & b & Cin));\n\nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 120, "original_snippet": "assign y = ((~a) & (~b) & Cin | (~a) & b & (~Cin) | a & (~b) & (~Cin) | (a & b & Cin));", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 120: Original: assign y = ((~a) & (~b) & Cin | (~a) & b & (~Cin) | a & (~b) & (~Cin) | (a & b & Cin));\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 120.\n   \u2022 Restore the original code: assign y = ((~a) & (~b) & Cin | (~a) & b & (~Cin) | a & (~b) & (~Cin) | (a & b & Cin));\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 5, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["remove_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.560487", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_16bit", "module_name": "adder_16bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\n"}, "clean_code": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add8 add8_inst1 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_temp), \n        .y(y[15:8]),\n        .Co(Co)\n    );\n \n    add8 add8_inst2 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add4 add4_inst1 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co_temp),\n        .y(y[7:4]),\n        .Co(Co)\n    );\n \n    add4 add4_inst2 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(Co_temp)\n    );\n \nendmodule\n\nmodule add4 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add2 add2_inst1 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co_temp),\n        .y(y[3:2]),\n        .Co(Co)\n    );\n \n    add2 add2_inst2 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add2 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n\n    add1 add1_inst1 (\n        .a(a[1]),\n        .b(b[1]),\n        .Cin(Co_temp),\n        .y(y[1]),\n        .Co(Co)\n    );\n \n    add1 add1_inst2 (\n        .a(a[0]),\n        .b(b[0]),\n        .Cin(Cin),\n        .y(y[0]),\n        .Co(Co_temp)\n    );\n         \nendmodule\n\nmodule add1 (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n    assign y = ((~a) & (~b) & Cin | (~a) & b & (~Cin) | a & (~b) & (~Cin) | (a & b & Cin));\n    assign Co = ((~a & b & Cin) | (a & ~b & Cin) | (a & b & ~Cin) | (a & b & Cin));\n\nendmodule", "corrupted_code": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add8 add8_inst1 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_temp), \n        .y(y[15:8]),\n        .Co(Co)\n    );\n \n    add8 add8_inst2 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add4 add4_inst1 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co_temp),\n        .y(y[7:4]),\n        .Co(Co)\n    );\n \n    add4 add4_inst2 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(Co_temp)\n    );\n \nendmodule\n\nmodule add4 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add2 add2_inst1 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co_temp),\n        .y(y[3:2]),\n        .Co(Co)\n    );\n \n    add2 add2_inst2 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add2 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n\n    add1 add1_inst1 (\n        .a(a[1]),\n        .b(b[1]),\n        .Cin(Co_temp),\n        .y(y[1]),\n        .Co(Co)\n    );\n \n    add1 add1_inst2 (\n        .a(a[0]),\n        .b(b[0]),\n        .Cin(Cin),\n        .y(y[0]),\n        .Co(Co_temp)\n    );\n         \nendmodule\n\nmodule add1 (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n    assign y = ((~a) & (~b) & Cin | (~a) & b & (~Cin) | a & (~b) & (~Cin) | (a & b & Cin));\n    assign Co = ((~a & b & Cin) & (a & ~b & Cin) | (a & b & ~Cin) | (a & b & Cin));\n\nendmodule", "corruption_explanation": "Changed operator from '|' to '&'", "modification_type": "change_operator", "modification_line": 121, "original_snippet": "|", "modified_snippet": "&", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '|' to '&'\n   \u2022 Line 121: Original: |\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 121.\n   \u2022 Restore the original code: |\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 5, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.566461", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_16bit", "module_name": "adder_16bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\n"}, "clean_code": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add8 add8_inst1 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_temp), \n        .y(y[15:8]),\n        .Co(Co)\n    );\n \n    add8 add8_inst2 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add4 add4_inst1 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co_temp),\n        .y(y[7:4]),\n        .Co(Co)\n    );\n \n    add4 add4_inst2 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(Co_temp)\n    );\n \nendmodule\n\nmodule add4 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add2 add2_inst1 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co_temp),\n        .y(y[3:2]),\n        .Co(Co)\n    );\n \n    add2 add2_inst2 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add2 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n\n    add1 add1_inst1 (\n        .a(a[1]),\n        .b(b[1]),\n        .Cin(Co_temp),\n        .y(y[1]),\n        .Co(Co)\n    );\n \n    add1 add1_inst2 (\n        .a(a[0]),\n        .b(b[0]),\n        .Cin(Cin),\n        .y(y[0]),\n        .Co(Co_temp)\n    );\n         \nendmodule\n\nmodule add1 (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n    assign y = ((~a) & (~b) & Cin | (~a) & b & (~Cin) | a & (~b) & (~Cin) | (a & b & Cin));\n    assign Co = ((~a & b & Cin) | (a & ~b & Cin) | (a & b & ~Cin) | (a & b & Cin));\n\nendmodule", "corrupted_code": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add8 add8_inst1 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_temp), \n        .y(y[15:8]),\n        .Co(Co)\n    );\n \n    add8 add8_inst2 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add4 add4_inst1 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co_temp),\n        .y(y[7:4]),\n        .Co(Co)\n    );\n \n    add4 add4_inst2 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(Co_temp)\n    );\n \nendmodule\n\nmodule add4 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add2 add2_inst1 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co_temp),\n        .y(y[3:2]),\n        .Co(Co)\n    );\n \n    add2 add2_inst2 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add2 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n\n    add1 add1_inst1 (\n        .a(a[1]),\n        .b(b[1]),\n        .Cin(Co_temp),\n        .y(y[1]),\n        .Co(Co)\n    );\n \n    add1 add1_inst2 (\n        .a(a[0]),\n        .b(b[0]),\n        .Cin(Cin),\n        .y(y[0]),\n        .Co(Co_temp)\n    );\n         \nendmodule\n\nmodule add1 (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n    assign y = ((~a) & (~b) & Cin | (~a) & b & (~Cin) | a & (~b) & (~Cin) | (a & b & Cin));\n    assign Co <= ((~a & b & Cin) | (a & ~b & Cin) | (a & b & ~Cin) | (a & b & Cin));\n\nendmodule", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 121, "original_snippet": "o = ((~a & b & Cin) | (a & ~b & Cin) | (a & b & ~Cin) | (a & b & Cin));", "modified_snippet": "o <= ((~a & b & Cin) | (a & ~b & Cin) | (a & b & ~Cin) | (a & b & Cin));", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 5, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.569988", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_8bit", "module_name": "adder_8bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\n "}, "clean_code": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n    \n    wire [8:0] c;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(c[3]));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c[3]), .sum(sum[4]), .cout(c[4]));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c[4]), .sum(sum[5]), .cout(c[5]));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c[5]), .sum(sum[6]), .cout(c[6]));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c[6]), .sum(sum[7]), .cout(c[7]));\n\n    assign cout = c[7]; \nendmodule\n\nmodule full_adder (input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule", "corrupted_code": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n    \n    wire [8:0] c;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(c[3]));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c[3]), .sum(sum[4]), .cout(c[4]));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c[4]), .sum(sum[5]), .cout(c[5]));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c[5]), .sum(sum[6]), .cout(c[6]));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c[6]), .sum(sum[7]), .cout(c[7]));\n\n    assign cout = c[7]; \nendmodule\n\nmodule full_adder (input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b - cin;\nendmodule", "corruption_explanation": "Changed operator from '+' to '-'", "modification_type": "change_operator", "modification_line": 22, "original_snippet": "+", "modified_snippet": "-", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '+' to '-'\n   \u2022 Line 22: Original: +\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 22.\n   \u2022 Restore the original code: +\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 1, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.572761", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_8bit", "module_name": "adder_8bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\n "}, "clean_code": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n    \n    wire [8:0] c;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(c[3]));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c[3]), .sum(sum[4]), .cout(c[4]));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c[4]), .sum(sum[5]), .cout(c[5]));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c[5]), .sum(sum[6]), .cout(c[6]));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c[6]), .sum(sum[7]), .cout(c[7]));\n\n    assign cout = c[7]; \nendmodule\n\nmodule full_adder (input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule", "corrupted_code": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n    \n    wire [8:0] c;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(c[3]));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c[3]), .sum(sum[4]), .cout(c[4]));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c[4]), .sum(sum[5]), .cout(c[5]));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c[5]), .sum(sum[6]), .cout(c[6]));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c[6]), .sum(sum[7]), .cout(c[7]));\n\n    assign cout = c[7];\nassign cout = 1'b0;  // Conflicting assignment \nendmodule\n\nmodule full_adder (input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule", "corruption_explanation": "Added conflicting driver for signal 'cout'", "modification_type": "add_multiple_driver", "modification_line": 17, "original_snippet": "assign cout = c[7];", "modified_snippet": "assign cout = c[7];\nassign cout = 1'b0;  // Conflicting assignment", "issue_description": "The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_multiple_driver modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added conflicting driver for signal 'cout'\n   \u2022 Line 17: Original: assign cout = c[7];\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 17.\n   \u2022 Restore the original code: assign cout = c[7];\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add multiple driver.", "complexity": 1, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["add_multiple_driver"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.573881", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_8bit", "module_name": "adder_8bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\n "}, "clean_code": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n    \n    wire [8:0] c;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(c[3]));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c[3]), .sum(sum[4]), .cout(c[4]));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c[4]), .sum(sum[5]), .cout(c[5]));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c[5]), .sum(sum[6]), .cout(c[6]));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c[6]), .sum(sum[7]), .cout(c[7]));\n\n    assign cout = c[7]; \nendmodule\n\nmodule full_adder (input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule", "corrupted_code": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n    \n    wire [8:0] c;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(c[3]));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c[3]), .sum(sum[4]), .cout(c[4]));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c[4]), .sum(sum[5]), .cout(c[5]));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c[5]), .sum(sum[6]), .cout(c[6]));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c[6]), .sum(sum[7]), .cout(c[7]));\n\n    assign cout <= c[7]; \nendmodule\n\nmodule full_adder (input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 18, "original_snippet": "out = c[7];", "modified_snippet": "out <= c[7];", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 1, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.575136", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_8bit", "module_name": "adder_8bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\n "}, "clean_code": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n    \n    wire [8:0] c;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(c[3]));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c[3]), .sum(sum[4]), .cout(c[4]));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c[4]), .sum(sum[5]), .cout(c[5]));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c[5]), .sum(sum[6]), .cout(c[6]));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c[6]), .sum(sum[7]), .cout(c[7]));\n\n    assign cout = c[7]; \nendmodule\n\nmodule full_adder (input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule", "corrupted_code": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n    \n    wire [8:0] c;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(c[3]));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c[3]), .sum(sum[4]), .cout(c[4]));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c[4]), .sum(sum[5]), .cout(c[5]));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c[5]), .sum(sum[6]), .cout(c[6]));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c[6]), .sum(sum[7]), .cout(c[7]));\n\n    assign cout <= c[7]; \nendmodule\n\nmodule full_adder (input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 18, "original_snippet": "out = c[7];", "modified_snippet": "out <= c[7];", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 1, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.576376", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_8bit", "module_name": "adder_8bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\n "}, "clean_code": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n    \n    wire [8:0] c;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(c[3]));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c[3]), .sum(sum[4]), .cout(c[4]));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c[4]), .sum(sum[5]), .cout(c[5]));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c[5]), .sum(sum[6]), .cout(c[6]));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c[6]), .sum(sum[7]), .cout(c[7]));\n\n    assign cout = c[7]; \nendmodule\n\nmodule full_adder (input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule", "corrupted_code": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n    \n    wire [8:0] c;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(c[3]));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c[3]), .sum(sum[4]), .cout(c[4]));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c[4]), .sum(sum[5]), .cout(c[5]));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c[5]), .sum(sum[6]), .cout(c[6]));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c[6]), .sum(sum[7]), .cout(c[7]));\n\n    assign cout = c[7];\nassign cout = 1'b0;  // Conflicting assignment \nendmodule\n\nmodule full_adder (input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule", "corruption_explanation": "Added conflicting driver for signal 'cout'", "modification_type": "add_multiple_driver", "modification_line": 17, "original_snippet": "assign cout = c[7];", "modified_snippet": "assign cout = c[7];\nassign cout = 1'b0;  // Conflicting assignment", "issue_description": "The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_multiple_driver modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added conflicting driver for signal 'cout'\n   \u2022 Line 17: Original: assign cout = c[7];\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 17.\n   \u2022 Restore the original code: assign cout = c[7];\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add multiple driver.", "complexity": 1, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["add_multiple_driver"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.578363", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_8bit", "module_name": "adder_8bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\n "}, "clean_code": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n    \n    wire [8:0] c;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(c[3]));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c[3]), .sum(sum[4]), .cout(c[4]));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c[4]), .sum(sum[5]), .cout(c[5]));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c[5]), .sum(sum[6]), .cout(c[6]));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c[6]), .sum(sum[7]), .cout(c[7]));\n\n    assign cout = c[7]; \nendmodule\n\nmodule full_adder (input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule", "corrupted_code": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n    \n    wire [8:0] c;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(c[3]));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c[3]), .sum(sum[4]), .cout(c[4]));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c[4]), .sum(sum[5]), .cout(c[5]));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c[5]), .sum(sum[6]), .cout(c[6]));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c[6]), .sum(sum[7]), .cout(c[7]));\n\nendmodule\n\nmodule full_adder (input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 17, "original_snippet": "assign cout = c[7];", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 17: Original: assign cout = c[7];\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 17.\n   \u2022 Restore the original code: assign cout = c[7];\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 1, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["remove_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.580355", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_8bit", "module_name": "adder_8bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\n "}, "clean_code": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n    \n    wire [8:0] c;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(c[3]));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c[3]), .sum(sum[4]), .cout(c[4]));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c[4]), .sum(sum[5]), .cout(c[5]));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c[5]), .sum(sum[6]), .cout(c[6]));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c[6]), .sum(sum[7]), .cout(c[7]));\n\n    assign cout = c[7]; \nendmodule\n\nmodule full_adder (input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule", "corrupted_code": "module adder_8bit(\n    input [8:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n    \n    wire [8:0] c;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(c[3]));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c[3]), .sum(sum[4]), .cout(c[4]));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c[4]), .sum(sum[5]), .cout(c[5]));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c[5]), .sum(sum[6]), .cout(c[6]));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c[6]), .sum(sum[7]), .cout(c[7]));\n\n    assign cout = c[7]; \nendmodule\n\nmodule full_adder (input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule", "corruption_explanation": "Changed bit width from [7:0] to [8:0]", "modification_type": "change_bit_width", "modification_line": 2, "original_snippet": "[7:0]", "modified_snippet": "[8:0]", "issue_description": "The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_bit_width modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed bit width from [7:0] to [8:0]\n   \u2022 Line 2: Original: [7:0]\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 2.\n   \u2022 Restore the original code: [7:0]\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change bit width.", "complexity": 1, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["change_bit_width"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.581447", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_pipe_64bit", "module_name": "adder_64bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of a 64-bit ripple carry adder, which includes several registers to enable the pipeline stages. The output result is available on the result port, and the o_en = 1 indicates the availability of the result.\n\nModule name:  \n    adder_pipe_64bit               \nInput ports:\n    clk: Clock input\n    rst_n: Active low reset signal\n    i_en: Enable signal for addition operation\n    adda: 64-bit input operand A\n    addb: 64-bit input operand B\n   \nOutput ports:\n    result: 65-bit output representing the sum of adda and addb.\n    o_en: Output enable signal.   \n\nImplementation:\nThe module includes several registers to enable the pipeline stages and synchronize the input enable signal (i_en). These registers are controlled by the clock (clk) and reset (rst_n) signals.\nThe sum values for each pipeline stage are calculated by adding the corresponding input operands and carry signals.\nThe output enable signal (o_en) is updated based on the pipeline stages and synchronized with the clock (clk) and reset (rst_n) signals.\n\nGive me the complete code.\n"}, "clean_code": "module adder_64bit\n#(\n    parameter DATA_WIDTH = 64,\n    parameter STG_WIDTH = 16\n)\n(\n    input clk,\n    input rst_n,\n    input i_en,\n    input [DATA_WIDTH-1:0] adda,\n    input [DATA_WIDTH-1:0] addb,\n    output [DATA_WIDTH:0] result,\n    output reg o_en\n);\n\nreg stage1;\nreg stage2;\nreg stage3;\n\nwire [STG_WIDTH-1:0] a1;\nwire [STG_WIDTH-1:0] b1;\nwire [STG_WIDTH-1:0] a2;\nwire [STG_WIDTH-1:0] b2;\nwire [STG_WIDTH-1:0] a3;\nwire [STG_WIDTH-1:0] b3;\nwire [STG_WIDTH-1:0] a4;\nwire [STG_WIDTH-1:0] b4;\n\nreg [STG_WIDTH-1:0] a2_ff1;\nreg [STG_WIDTH-1:0] b2_ff1;\n\nreg [STG_WIDTH-1:0] a3_ff1;\nreg [STG_WIDTH-1:0] b3_ff1;\nreg [STG_WIDTH-1:0] a3_ff2;\nreg [STG_WIDTH-1:0] b3_ff2;\n\nreg [STG_WIDTH-1:0] a4_ff1;\nreg [STG_WIDTH-1:0] b4_ff1;\nreg [STG_WIDTH-1:0] a4_ff2;\nreg [STG_WIDTH-1:0] b4_ff2;\nreg [STG_WIDTH-1:0] a4_ff3;\nreg [STG_WIDTH-1:0] b4_ff3;\n\nreg c1;\nreg c2;\nreg c3;\nreg c4;\n\nreg [STG_WIDTH-1:0] s1;\nreg [STG_WIDTH-1:0] s2;\nreg [STG_WIDTH-1:0] s3;\nreg [STG_WIDTH-1:0] s4;\n\nreg [STG_WIDTH-1:0] s1_ff1;\nreg [STG_WIDTH-1:0] s1_ff2;\nreg [STG_WIDTH-1:0] s1_ff3;\n\nreg [STG_WIDTH-1:0] s2_ff1;\nreg [STG_WIDTH-1:0] s2_ff2;\n\nreg [STG_WIDTH-1:0] s3_ff1;\n\nassign a1 = adda[STG_WIDTH-1:0];\nassign b1 = addb[STG_WIDTH-1:0];\nassign a2 = adda[STG_WIDTH*2-1:16];\nassign b2 = addb[STG_WIDTH*2-1:16];\nassign a3 = adda[STG_WIDTH*3-1:32];\nassign b3 = addb[STG_WIDTH*3-1:32];\nassign a4 = adda[STG_WIDTH*4-1:48];\nassign b4 = addb[STG_WIDTH*4-1:48];\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        stage1 <= 1'b0;\n        stage2 <= 1'b0;\n        stage3 <= 1'b0;\n        o_en <= 1'b0;\n    end\n    else begin\n        stage1 <= i_en;\n        stage2 <= stage1;\n        stage3 <= stage2;\n        o_en <= stage3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        a2_ff1 <= 'd0;\n        b2_ff1 <= 'd0;\n        a3_ff1 <= 'd0;\n        b3_ff1 <= 'd0;\n        a3_ff2 <= 'd0;\n        b3_ff2 <= 'd0;\n        a4_ff1 <= 'd0;\n        b4_ff1 <= 'd0;\n        a4_ff2 <= 'd0;\n        b4_ff2 <= 'd0;\n        a4_ff3 <= 'd0;\n        b4_ff3 <= 'd0;\n    end\n    else begin\n        a2_ff1 <= a2;\n        b2_ff1 <= b2;\n        a3_ff1 <= a3;\n        b3_ff1 <= b3;\n        a3_ff2 <= a3_ff1;\n        b3_ff2 <= b3_ff1;\n        a4_ff1 <= a4;\n        b4_ff1 <= b4;\n        a4_ff2 <= a4_ff1;\n        b4_ff2<= b4_ff1;\n        a4_ff3 <= a4_ff2;\n        b4_ff3 <= b4_ff2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        s1_ff1 <= 'd0;\n        s1_ff2 <= 'd0;\n        s1_ff3 <= 'd0;\n        s2_ff1 <= 'd0;\n        s2_ff2 <= 'd0;\n        s3_ff1 <= 'd0;\n    end\n    else begin\n        s1_ff1 <= s1;\n        s1_ff2 <= s1_ff1;\n        s1_ff3 <= s1_ff2;\n        s2_ff1 <= s2;\n        s2_ff2 <= s2_ff1;\n        s3_ff1 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c1 <= 1'b0;\n        s1 <= 'd0;\n    end\n    else if (i_en) begin\n        {c1, s1} <= a1 + b1;\n    end\n    else begin\n        c1 <= c1;\n        s1 <= s1;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c2 <= 1'b0;\n        s2 <= 'd0;\n    end\n    else if (stage1) begin\n        {c2, s2} <= a2_ff1 + b2_ff1 + c1;\n    end\n    else begin\n        c2 <= c2;\n        s2 <= s2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c3 <= 1'b0;\n        s3 <= 'd0;\n    end\n    else if (stage2) begin\n        {c3, s3} <= a3_ff2 + b3_ff2 + c2;\n    end\n    else begin\n        c3 <= c3;\n        s3 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c4 <= 1'b0;\n        s4 <= 'd0;\n    end\n    else if (stage3) begin\n        {c4, s4} <= a4_ff3 + b4_ff3 + c3;\n    end\n    else begin\n        c4 <= c4;\n        s4 <= s4;\n    end\nend\n\nassign result = {c4, s4, s3_ff1, s2_ff2, s1_ff3};\n\nendmodule", "corrupted_code": "module adder_64bit\n#(\n    parameter DATA_WIDTH = 64,\n    parameter STG_WIDTH = 16\n)\n(\n    input clk,\n    input rst_n,\n    input i_en,\n    input [DATA_WIDTH-1:0] adda,\n    input [DATA_WIDTH-1:0] addb,\n    output [DATA_WIDTH:0] result,\n    output reg o_en\n);\n\nreg stage1;\nreg stage2;\nreg stage3;\n\nwire [STG_WIDTH-1:0] a1;\nwire [STG_WIDTH-1:0] b1;\nwire [STG_WIDTH-1:0] a2;\nwire [STG_WIDTH-1:0] b2;\nwire [STG_WIDTH-1:0] a3;\nwire [STG_WIDTH-1:0] b3;\nwire [STG_WIDTH-1:0] a4;\nwire [STG_WIDTH-1:0] b4;\n\nreg [STG_WIDTH-1:0] a2_ff1;\nreg [STG_WIDTH-1:0] b2_ff1;\n\nreg [STG_WIDTH-1:0] a3_ff1;\nreg [STG_WIDTH-1:0] b3_ff1;\nreg [STG_WIDTH-1:0] a3_ff2;\nreg [STG_WIDTH-1:0] b3_ff2;\n\nreg [STG_WIDTH-1:0] a4_ff1;\nreg [STG_WIDTH-1:0] b4_ff1;\nreg [STG_WIDTH-1:0] a4_ff2;\nreg [STG_WIDTH-1:0] b4_ff2;\nreg [STG_WIDTH-1:0] a4_ff3;\nreg [STG_WIDTH-1:0] b4_ff3;\n\nreg c1;\nreg c2;\nreg c3;\nreg c4;\n\nreg [STG_WIDTH-1:0] s1;\nreg [STG_WIDTH-1:0] s2;\nreg [STG_WIDTH-1:0] s3;\nreg [STG_WIDTH-1:0] s4;\n\nreg [STG_WIDTH-1:0] s1_ff1;\nreg [STG_WIDTH-1:0] s1_ff2;\nreg [STG_WIDTH-1:0] s1_ff3;\n\nreg [STG_WIDTH-1:0] s2_ff1;\nreg [STG_WIDTH-1:0] s2_ff2;\n\nreg [STG_WIDTH-1:0] s3_ff1;\n\nassign a1 = adda[STG_WIDTH-1:0];\nassign b1 = addb[STG_WIDTH-1:0];\nassign a2 = adda[STG_WIDTH*2-1:16];\nassign b2 = addb[STG_WIDTH*2-1:16];\nassign a3 = adda[STG_WIDTH*3-1:32];\nassign b3 = addb[STG_WIDTH*3-1:32];\nassign a4 = adda[STG_WIDTH*4-1:48];\nassign b4 = addb[STG_WIDTH*4-1:48];\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        stage1 <= 1'b0;\n        stage2 <= 1'b0;\n        stage3 <= 1'b0;\n        o_en <= 1'b0;\n    end\n    else begin\n        stage1 <= i_en;\n        stage2 <= stage1;\n        stage3 <= stage2;\n        o_en <= stage3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        a2_ff1 <= 'd0;\n        b2_ff1 <= 'd0;\n        a3_ff1 <= 'd0;\n        b3_ff1 <= 'd0;\n        a3_ff2 <= 'd0;\n        b3_ff2 <= 'd0;\n        a4_ff1 <= 'd0;\n        b4_ff1 <= 'd0;\n        a4_ff2 <= 'd0;\n        b4_ff2 <= 'd0;\n        a4_ff3 <= 'd0;\n        b4_ff3 <= 'd0;\n    end\n    else begin\n        a2_ff1 <= a2;\n        b2_ff1 <= b2;\n        a3_ff1 <= a3;\n        b3_ff1 <= b3;\n        a3_ff2 <= a3_ff1;\n        b3_ff2 <= b3_ff1;\n        a4_ff1 <= a4;\n        b4_ff1 <= b4;\n        a4_ff2 <= a4_ff1;\n        b4_ff2<= b4_ff1;\n        a4_ff3 <= a4_ff2;\n        b4_ff3 <= b4_ff2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        s1_ff1 <= 'd0;\n        s1_ff2 <= 'd0;\n        s1_ff3 <= 'd0;\n        s2_ff1 <= 'd0;\n        s2_ff2 <= 'd0;\n        s3_ff1 <= 'd0;\n    end\n    else begin\n        s1_ff1 <= s1;\n        s1_ff2 <= s1_ff1;\n        s1_ff3 <= s1_ff2;\n        s2_ff1 <= s2;\n        s2_ff2 <= s2_ff1;\n        s3_ff1 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c1 <= 1'b0;\n        s1 <= 'd0;\n    end\n    else if (i_en) begin\n        {c1, s1} <= a1 + b1;\n    end\n    else begin\n        c1 <= c1;\n        s1 <= s1;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c2 <= 1'b0;\n        s2 <= 'd0;\n    end\n    else if (stage1) begin\n        {c2, s2} <= a2_ff1 + b2_ff1 + c1;\n    end\n    else begin\n        c2 <= c2;\n        s2 <= s2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c3 <= 1'b0;\n        s3 <= 'd0;\n    end\n    else if (stage2) begin\n        {c3, s3} <= a3_ff2 + b3_ff2 + c2;\n    end\n    else begin\n        c3 <= c3;\n        s3 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c4 <= 1'b0;\n        s4 <= 'd0;\n    end\n    else if (stage3) begin\n        {c4, s4} <= a4_ff3 + b4_ff3 + c3;\n    end\n    else begin\n        c4 <= c4;\n        s4 <= s4;\n    end\nend\n\nassign result = {c4, s4, s3_ff1, s2_ff2, s1_ff3};\nassign result = 1'b0;  // Conflicting assignment\n\nendmodule", "corruption_explanation": "Added conflicting driver for signal 'result'", "modification_type": "add_multiple_driver", "modification_line": 192, "original_snippet": "assign result = {c4, s4, s3_ff1, s2_ff2, s1_ff3};", "modified_snippet": "assign result = {c4, s4, s3_ff1, s2_ff2, s1_ff3};\nassign result = 1'b0;  // Conflicting assignment", "issue_description": "The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_multiple_driver modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added conflicting driver for signal 'result'\n   \u2022 Line 192: Original: assign result = {c4, s4, s3_ff1, s2_ff2, s1_ff3};\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 192.\n   \u2022 Restore the original code: assign result = {c4, s4, s3_ff1, s2_ff2, s1_ff3};\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add multiple driver.", "complexity": 100, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["add_multiple_driver"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.588893", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_pipe_64bit", "module_name": "adder_64bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of a 64-bit ripple carry adder, which includes several registers to enable the pipeline stages. The output result is available on the result port, and the o_en = 1 indicates the availability of the result.\n\nModule name:  \n    adder_pipe_64bit               \nInput ports:\n    clk: Clock input\n    rst_n: Active low reset signal\n    i_en: Enable signal for addition operation\n    adda: 64-bit input operand A\n    addb: 64-bit input operand B\n   \nOutput ports:\n    result: 65-bit output representing the sum of adda and addb.\n    o_en: Output enable signal.   \n\nImplementation:\nThe module includes several registers to enable the pipeline stages and synchronize the input enable signal (i_en). These registers are controlled by the clock (clk) and reset (rst_n) signals.\nThe sum values for each pipeline stage are calculated by adding the corresponding input operands and carry signals.\nThe output enable signal (o_en) is updated based on the pipeline stages and synchronized with the clock (clk) and reset (rst_n) signals.\n\nGive me the complete code.\n"}, "clean_code": "module adder_64bit\n#(\n    parameter DATA_WIDTH = 64,\n    parameter STG_WIDTH = 16\n)\n(\n    input clk,\n    input rst_n,\n    input i_en,\n    input [DATA_WIDTH-1:0] adda,\n    input [DATA_WIDTH-1:0] addb,\n    output [DATA_WIDTH:0] result,\n    output reg o_en\n);\n\nreg stage1;\nreg stage2;\nreg stage3;\n\nwire [STG_WIDTH-1:0] a1;\nwire [STG_WIDTH-1:0] b1;\nwire [STG_WIDTH-1:0] a2;\nwire [STG_WIDTH-1:0] b2;\nwire [STG_WIDTH-1:0] a3;\nwire [STG_WIDTH-1:0] b3;\nwire [STG_WIDTH-1:0] a4;\nwire [STG_WIDTH-1:0] b4;\n\nreg [STG_WIDTH-1:0] a2_ff1;\nreg [STG_WIDTH-1:0] b2_ff1;\n\nreg [STG_WIDTH-1:0] a3_ff1;\nreg [STG_WIDTH-1:0] b3_ff1;\nreg [STG_WIDTH-1:0] a3_ff2;\nreg [STG_WIDTH-1:0] b3_ff2;\n\nreg [STG_WIDTH-1:0] a4_ff1;\nreg [STG_WIDTH-1:0] b4_ff1;\nreg [STG_WIDTH-1:0] a4_ff2;\nreg [STG_WIDTH-1:0] b4_ff2;\nreg [STG_WIDTH-1:0] a4_ff3;\nreg [STG_WIDTH-1:0] b4_ff3;\n\nreg c1;\nreg c2;\nreg c3;\nreg c4;\n\nreg [STG_WIDTH-1:0] s1;\nreg [STG_WIDTH-1:0] s2;\nreg [STG_WIDTH-1:0] s3;\nreg [STG_WIDTH-1:0] s4;\n\nreg [STG_WIDTH-1:0] s1_ff1;\nreg [STG_WIDTH-1:0] s1_ff2;\nreg [STG_WIDTH-1:0] s1_ff3;\n\nreg [STG_WIDTH-1:0] s2_ff1;\nreg [STG_WIDTH-1:0] s2_ff2;\n\nreg [STG_WIDTH-1:0] s3_ff1;\n\nassign a1 = adda[STG_WIDTH-1:0];\nassign b1 = addb[STG_WIDTH-1:0];\nassign a2 = adda[STG_WIDTH*2-1:16];\nassign b2 = addb[STG_WIDTH*2-1:16];\nassign a3 = adda[STG_WIDTH*3-1:32];\nassign b3 = addb[STG_WIDTH*3-1:32];\nassign a4 = adda[STG_WIDTH*4-1:48];\nassign b4 = addb[STG_WIDTH*4-1:48];\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        stage1 <= 1'b0;\n        stage2 <= 1'b0;\n        stage3 <= 1'b0;\n        o_en <= 1'b0;\n    end\n    else begin\n        stage1 <= i_en;\n        stage2 <= stage1;\n        stage3 <= stage2;\n        o_en <= stage3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        a2_ff1 <= 'd0;\n        b2_ff1 <= 'd0;\n        a3_ff1 <= 'd0;\n        b3_ff1 <= 'd0;\n        a3_ff2 <= 'd0;\n        b3_ff2 <= 'd0;\n        a4_ff1 <= 'd0;\n        b4_ff1 <= 'd0;\n        a4_ff2 <= 'd0;\n        b4_ff2 <= 'd0;\n        a4_ff3 <= 'd0;\n        b4_ff3 <= 'd0;\n    end\n    else begin\n        a2_ff1 <= a2;\n        b2_ff1 <= b2;\n        a3_ff1 <= a3;\n        b3_ff1 <= b3;\n        a3_ff2 <= a3_ff1;\n        b3_ff2 <= b3_ff1;\n        a4_ff1 <= a4;\n        b4_ff1 <= b4;\n        a4_ff2 <= a4_ff1;\n        b4_ff2<= b4_ff1;\n        a4_ff3 <= a4_ff2;\n        b4_ff3 <= b4_ff2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        s1_ff1 <= 'd0;\n        s1_ff2 <= 'd0;\n        s1_ff3 <= 'd0;\n        s2_ff1 <= 'd0;\n        s2_ff2 <= 'd0;\n        s3_ff1 <= 'd0;\n    end\n    else begin\n        s1_ff1 <= s1;\n        s1_ff2 <= s1_ff1;\n        s1_ff3 <= s1_ff2;\n        s2_ff1 <= s2;\n        s2_ff2 <= s2_ff1;\n        s3_ff1 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c1 <= 1'b0;\n        s1 <= 'd0;\n    end\n    else if (i_en) begin\n        {c1, s1} <= a1 + b1;\n    end\n    else begin\n        c1 <= c1;\n        s1 <= s1;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c2 <= 1'b0;\n        s2 <= 'd0;\n    end\n    else if (stage1) begin\n        {c2, s2} <= a2_ff1 + b2_ff1 + c1;\n    end\n    else begin\n        c2 <= c2;\n        s2 <= s2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c3 <= 1'b0;\n        s3 <= 'd0;\n    end\n    else if (stage2) begin\n        {c3, s3} <= a3_ff2 + b3_ff2 + c2;\n    end\n    else begin\n        c3 <= c3;\n        s3 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c4 <= 1'b0;\n        s4 <= 'd0;\n    end\n    else if (stage3) begin\n        {c4, s4} <= a4_ff3 + b4_ff3 + c3;\n    end\n    else begin\n        c4 <= c4;\n        s4 <= s4;\n    end\nend\n\nassign result = {c4, s4, s3_ff1, s2_ff2, s1_ff3};\n\nendmodule", "corrupted_code": "module adder_64bit\n#(\n    parameter DATA_WIDTH = 64,\n    parameter STG_WIDTH = 16\n)\n(\n    input clk,\n    input rst_n,\n    input i_en,\n    input [DATA_WIDTH-1:0] adda,\n    input [DATA_WIDTH-1:0] addb,\n    output [DATA_WIDTH:0] result,\n    output reg o_en\n);\n\nreg stage1;\nreg stage2;\nreg stage3;\n\nwire [STG_WIDTH-1:0] a1;\nwire [STG_WIDTH-1:0] b1;\nwire [STG_WIDTH-1:0] a2;\nwire [STG_WIDTH-1:0] b2;\nwire [STG_WIDTH-1:0] a3;\nwire [STG_WIDTH-1:0] b3;\nwire [STG_WIDTH-1:0] a4;\nwire [STG_WIDTH-1:0] b4;\n\nreg [STG_WIDTH-1:0] a2_ff1;\nreg [STG_WIDTH-1:0] b2_ff1;\n\nreg [STG_WIDTH-1:0] a3_ff1;\nreg [STG_WIDTH-1:0] b3_ff1;\nreg [STG_WIDTH-1:0] a3_ff2;\nreg [STG_WIDTH-1:0] b3_ff2;\n\nreg [STG_WIDTH-1:0] a4_ff1;\nreg [STG_WIDTH-1:0] b4_ff1;\nreg [STG_WIDTH-1:0] a4_ff2;\nreg [STG_WIDTH-1:0] b4_ff2;\nreg [STG_WIDTH-1:0] a4_ff3;\nreg [STG_WIDTH-1:0] b4_ff3;\n\nreg c1;\nreg c2;\nreg c3;\nreg c4;\n\nreg [STG_WIDTH-1:0] s1;\nreg [STG_WIDTH-1:0] s2;\nreg [STG_WIDTH-1:0] s3;\nreg [STG_WIDTH-1:0] s4;\n\nreg [STG_WIDTH-1:0] s1_ff1;\nreg [STG_WIDTH-1:0] s1_ff2;\nreg [STG_WIDTH-1:0] s1_ff3;\n\nreg [STG_WIDTH-1:0] s2_ff1;\nreg [STG_WIDTH-1:0] s2_ff2;\n\nreg [STG_WIDTH-1:0] s3_ff1;\n\nassign a1 = adda[STG_WIDTH-1:0];\nassign b1 = addb[STG_WIDTH-1:0];\nassign a2 = adda[STG_WIDTH*2-1:16];\nassign b2 = addb[STG_WIDTH*2-1:16];\nassign a3 = adda[STG_WIDTH*3-1:32];\nassign b3 = addb[STG_WIDTH*3-1:32];\nassign a4 = adda[STG_WIDTH*4-1:48];\nassign b4 = addb[STG_WIDTH*4-1:48];\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        stage1 <= 1'b0;\n        stage2 <= 1'b0;\n        stage3 <= 1'b0;\n        o_en <= 1'b0;\n    end\n    else begin\n        stage1 <= i_en;\n        stage2 <= stage1;\n        stage3 <= stage2;\n        o_en <= stage3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        a2_ff1 <= 'd0;\n        b2_ff1 <= 'd0;\n        a3_ff1 <= 'd0;\n        b3_ff1 <= 'd0;\n        a3_ff2 <= 'd0;\n        b3_ff2 <= 'd0;\n        a4_ff1 <= 'd0;\n        b4_ff1 <= 'd0;\n        a4_ff2 <= 'd0;\n        b4_ff2 <= 'd0;\n        a4_ff3 <= 'd0;\n        b4_ff3 <= 'd0;\n    end\n    else begin\n        a2_ff1 <= a2;\n        b2_ff1 <= b2;\n        a3_ff1 <= a3;\n        b3_ff1 <= b3;\n        a3_ff2 <= a3_ff1;\n        b3_ff2 <= b3_ff1;\n        a4_ff1 <= a4;\n        b4_ff1 <= b4;\n        a4_ff2 <= a4_ff1;\n        b4_ff2<= b4_ff1;\n        a4_ff3 <= a4_ff2;\n        b4_ff3 <= b4_ff2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        s1_ff1 <= 'd0;\n        s1_ff2 <= 'd0;\n        s1_ff3 <= 'd0;\n        s2_ff1 <= 'd0;\n        s2_ff2 <= 'd0;\n        s3_ff1 <= 'd0;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c1 <= 1'b0;\n        s1 <= 'd0;\n    end\n    else if (i_en) begin\n        {c1, s1} <= a1 + b1;\n    end\n    else begin\n        c1 <= c1;\n        s1 <= s1;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c2 <= 1'b0;\n        s2 <= 'd0;\n    end\n    else if (stage1) begin\n        {c2, s2} <= a2_ff1 + b2_ff1 + c1;\n    end\n    else begin\n        c2 <= c2;\n        s2 <= s2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c3 <= 1'b0;\n        s3 <= 'd0;\n    end\n    else if (stage2) begin\n        {c3, s3} <= a3_ff2 + b3_ff2 + c2;\n    end\n    else begin\n        c3 <= c3;\n        s3 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c4 <= 1'b0;\n        s4 <= 'd0;\n    end\n    else if (stage3) begin\n        {c4, s4} <= a4_ff3 + b4_ff3 + c3;\n    end\n    else begin\n        c4 <= c4;\n        s4 <= s4;\n    end\nend\n\nassign result = {c4, s4, s3_ff1, s2_ff2, s1_ff3};\n\nendmodule", "corruption_explanation": "Removed else branch (may cause latch inference)", "modification_type": "remove_else_branch", "modification_line": 119, "original_snippet": "if (!rst_n) begin\n        s1_ff1 <= 'd0;\n        s1_ff2 <= 'd0;\n        s1_ff3 <= 'd0;\n        s2_ff1 <= 'd0;\n        s2_ff2 <= 'd0;\n        s3_ff1 <= 'd0;\n    end\n    else begin\n        s1_ff1 <= s1;", "modified_snippet": "if (!rst_n) begin\n        s1_ff1 <= 'd0;\n        s1_ff2 <= 'd0;\n        s1_ff3 <= 'd0;\n        s2_ff1 <= 'd0;\n        s2_ff2 <= 'd0;\n        s3_ff1 <= 'd0;\n    end", "issue_description": "The buggy code is missing an else branch in a conditional statement. In combinational logic (always_comb or always @*), this can cause latch inference because the output is not defined for all input conditions. In sequential logic, signals may retain old values unexpectedly. This violates RTL design best practices requiring complete conditional assignments.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module should provide a complete conditional assignment to avoid latch inference.\n   \u2022 Combinational logic must define outputs for all input conditions.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an if statement without an else branch.\n   \u2022 The assigned signal is not defined when the condition is false.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The else branch has been removed from the conditional.\n   \u2022 This creates an incomplete conditional assignment.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Missing else branch leaves the signal undefined in some cases.\n   \u2022 Impact: Latch inference in combinational blocks, or stale values in sequential blocks.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Add an else branch with appropriate default or alternative assignment.\n   \u2022 Ensure all signals are assigned in all branches of the conditional.\n\n6. RTL Design Principle Violated:\n   \u2022 Combinational logic must have complete assignments to avoid latch inference.\n   \u2022 All conditional blocks should have else clauses or default values.", "complexity": 100, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_else_branch"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.593801", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_pipe_64bit", "module_name": "adder_64bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of a 64-bit ripple carry adder, which includes several registers to enable the pipeline stages. The output result is available on the result port, and the o_en = 1 indicates the availability of the result.\n\nModule name:  \n    adder_pipe_64bit               \nInput ports:\n    clk: Clock input\n    rst_n: Active low reset signal\n    i_en: Enable signal for addition operation\n    adda: 64-bit input operand A\n    addb: 64-bit input operand B\n   \nOutput ports:\n    result: 65-bit output representing the sum of adda and addb.\n    o_en: Output enable signal.   \n\nImplementation:\nThe module includes several registers to enable the pipeline stages and synchronize the input enable signal (i_en). These registers are controlled by the clock (clk) and reset (rst_n) signals.\nThe sum values for each pipeline stage are calculated by adding the corresponding input operands and carry signals.\nThe output enable signal (o_en) is updated based on the pipeline stages and synchronized with the clock (clk) and reset (rst_n) signals.\n\nGive me the complete code.\n"}, "clean_code": "module adder_64bit\n#(\n    parameter DATA_WIDTH = 64,\n    parameter STG_WIDTH = 16\n)\n(\n    input clk,\n    input rst_n,\n    input i_en,\n    input [DATA_WIDTH-1:0] adda,\n    input [DATA_WIDTH-1:0] addb,\n    output [DATA_WIDTH:0] result,\n    output reg o_en\n);\n\nreg stage1;\nreg stage2;\nreg stage3;\n\nwire [STG_WIDTH-1:0] a1;\nwire [STG_WIDTH-1:0] b1;\nwire [STG_WIDTH-1:0] a2;\nwire [STG_WIDTH-1:0] b2;\nwire [STG_WIDTH-1:0] a3;\nwire [STG_WIDTH-1:0] b3;\nwire [STG_WIDTH-1:0] a4;\nwire [STG_WIDTH-1:0] b4;\n\nreg [STG_WIDTH-1:0] a2_ff1;\nreg [STG_WIDTH-1:0] b2_ff1;\n\nreg [STG_WIDTH-1:0] a3_ff1;\nreg [STG_WIDTH-1:0] b3_ff1;\nreg [STG_WIDTH-1:0] a3_ff2;\nreg [STG_WIDTH-1:0] b3_ff2;\n\nreg [STG_WIDTH-1:0] a4_ff1;\nreg [STG_WIDTH-1:0] b4_ff1;\nreg [STG_WIDTH-1:0] a4_ff2;\nreg [STG_WIDTH-1:0] b4_ff2;\nreg [STG_WIDTH-1:0] a4_ff3;\nreg [STG_WIDTH-1:0] b4_ff3;\n\nreg c1;\nreg c2;\nreg c3;\nreg c4;\n\nreg [STG_WIDTH-1:0] s1;\nreg [STG_WIDTH-1:0] s2;\nreg [STG_WIDTH-1:0] s3;\nreg [STG_WIDTH-1:0] s4;\n\nreg [STG_WIDTH-1:0] s1_ff1;\nreg [STG_WIDTH-1:0] s1_ff2;\nreg [STG_WIDTH-1:0] s1_ff3;\n\nreg [STG_WIDTH-1:0] s2_ff1;\nreg [STG_WIDTH-1:0] s2_ff2;\n\nreg [STG_WIDTH-1:0] s3_ff1;\n\nassign a1 = adda[STG_WIDTH-1:0];\nassign b1 = addb[STG_WIDTH-1:0];\nassign a2 = adda[STG_WIDTH*2-1:16];\nassign b2 = addb[STG_WIDTH*2-1:16];\nassign a3 = adda[STG_WIDTH*3-1:32];\nassign b3 = addb[STG_WIDTH*3-1:32];\nassign a4 = adda[STG_WIDTH*4-1:48];\nassign b4 = addb[STG_WIDTH*4-1:48];\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        stage1 <= 1'b0;\n        stage2 <= 1'b0;\n        stage3 <= 1'b0;\n        o_en <= 1'b0;\n    end\n    else begin\n        stage1 <= i_en;\n        stage2 <= stage1;\n        stage3 <= stage2;\n        o_en <= stage3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        a2_ff1 <= 'd0;\n        b2_ff1 <= 'd0;\n        a3_ff1 <= 'd0;\n        b3_ff1 <= 'd0;\n        a3_ff2 <= 'd0;\n        b3_ff2 <= 'd0;\n        a4_ff1 <= 'd0;\n        b4_ff1 <= 'd0;\n        a4_ff2 <= 'd0;\n        b4_ff2 <= 'd0;\n        a4_ff3 <= 'd0;\n        b4_ff3 <= 'd0;\n    end\n    else begin\n        a2_ff1 <= a2;\n        b2_ff1 <= b2;\n        a3_ff1 <= a3;\n        b3_ff1 <= b3;\n        a3_ff2 <= a3_ff1;\n        b3_ff2 <= b3_ff1;\n        a4_ff1 <= a4;\n        b4_ff1 <= b4;\n        a4_ff2 <= a4_ff1;\n        b4_ff2<= b4_ff1;\n        a4_ff3 <= a4_ff2;\n        b4_ff3 <= b4_ff2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        s1_ff1 <= 'd0;\n        s1_ff2 <= 'd0;\n        s1_ff3 <= 'd0;\n        s2_ff1 <= 'd0;\n        s2_ff2 <= 'd0;\n        s3_ff1 <= 'd0;\n    end\n    else begin\n        s1_ff1 <= s1;\n        s1_ff2 <= s1_ff1;\n        s1_ff3 <= s1_ff2;\n        s2_ff1 <= s2;\n        s2_ff2 <= s2_ff1;\n        s3_ff1 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c1 <= 1'b0;\n        s1 <= 'd0;\n    end\n    else if (i_en) begin\n        {c1, s1} <= a1 + b1;\n    end\n    else begin\n        c1 <= c1;\n        s1 <= s1;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c2 <= 1'b0;\n        s2 <= 'd0;\n    end\n    else if (stage1) begin\n        {c2, s2} <= a2_ff1 + b2_ff1 + c1;\n    end\n    else begin\n        c2 <= c2;\n        s2 <= s2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c3 <= 1'b0;\n        s3 <= 'd0;\n    end\n    else if (stage2) begin\n        {c3, s3} <= a3_ff2 + b3_ff2 + c2;\n    end\n    else begin\n        c3 <= c3;\n        s3 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c4 <= 1'b0;\n        s4 <= 'd0;\n    end\n    else if (stage3) begin\n        {c4, s4} <= a4_ff3 + b4_ff3 + c3;\n    end\n    else begin\n        c4 <= c4;\n        s4 <= s4;\n    end\nend\n\nassign result = {c4, s4, s3_ff1, s2_ff2, s1_ff3};\n\nendmodule", "corrupted_code": "module adder_64bit\n#(\n    parameter DATA_WIDTH = 64,\n    parameter STG_WIDTH = 16\n)\n(\n    input clk,\n    input rst_n,\n    input i_en,\n    input [DATA_WIDTH-1:0] adda,\n    input [DATA_WIDTH-1:0] addb,\n    output [DATA_WIDTH:0] result,\n    output reg o_en\n);\n\nreg stage1;\nreg stage2;\nreg stage3;\n\nwire [STG_WIDTH-1:0] a1;\nwire [STG_WIDTH-1:0] b1;\nwire [STG_WIDTH-1:0] a2;\nwire [STG_WIDTH-1:0] b2;\nwire [STG_WIDTH-1:0] a3;\nwire [STG_WIDTH-1:0] b3;\nwire [STG_WIDTH-1:0] a4;\nwire [STG_WIDTH-1:0] b4;\n\nreg [STG_WIDTH-1:0] a2_ff1;\nreg [STG_WIDTH-1:0] b2_ff1;\n\nreg [STG_WIDTH-1:0] a3_ff1;\nreg [STG_WIDTH-1:0] b3_ff1;\nreg [STG_WIDTH-1:0] a3_ff2;\nreg [STG_WIDTH-1:0] b3_ff2;\n\nreg [STG_WIDTH-1:0] a4_ff1;\nreg [STG_WIDTH-1:0] b4_ff1;\nreg [STG_WIDTH-1:0] a4_ff2;\nreg [STG_WIDTH-1:0] b4_ff2;\nreg [STG_WIDTH-1:0] a4_ff3;\nreg [STG_WIDTH-1:0] b4_ff3;\n\nreg c1;\nreg c2;\nreg c3;\nreg c4;\n\nreg [STG_WIDTH-1:0] s1;\nreg [STG_WIDTH-1:0] s2;\nreg [STG_WIDTH-1:0] s3;\nreg [STG_WIDTH-1:0] s4;\n\nreg [STG_WIDTH-1:0] s1_ff1;\nreg [STG_WIDTH-1:0] s1_ff2;\nreg [STG_WIDTH-1:0] s1_ff3;\n\nreg [STG_WIDTH-1:0] s2_ff1;\nreg [STG_WIDTH-1:0] s2_ff2;\n\nreg [STG_WIDTH-1:0] s3_ff1;\n\nassign a1 = adda[STG_WIDTH-1:0];\nassign b1 = addb[STG_WIDTH-1:0];\nassign a2 = adda[STG_WIDTH*2-1:16];\nassign b2 = addb[STG_WIDTH*2-1:16];\nassign a3 = adda[STG_WIDTH*3-1:32];\nassign b3 = addb[STG_WIDTH*3-1:32];\nassign a4 = adda[STG_WIDTH*4-1:48];\nassign b4 = addb[STG_WIDTH*4-1:48];\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        stage1 <= 1'b0;\n        stage2 <= 1'b0;\n        stage3 <= 1'b0;\n        o_en <= 1'b0;\n    end\n    else begin\n        stage1 <= i_en;\n        stage2 <= stage1;\n        stage3 <= stage2;\n        o_en <= stage3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        a2_ff1 <= 'd0;\n        b2_ff1 <= 'd0;\n        a3_ff1 <= 'd0;\n        b3_ff1 <= 'd0;\n        a3_ff2 <= 'd0;\n        b3_ff2 <= 'd0;\n        a4_ff1 <= 'd0;\n        b4_ff1 <= 'd0;\n        a4_ff2 <= 'd0;\n        b4_ff2 <= 'd0;\n        a4_ff3 <= 'd0;\n        b4_ff3 <= 'd0;\n    end\n    else begin\n        a2_ff1 <= a2;\n        b2_ff1 <= b2;\n        a3_ff1 <= a3;\n        b3_ff1 <= b3;\n        a3_ff2 <= a3_ff1;\n        b3_ff2 <= b3_ff1;\n        a4_ff1 <= a4;\n        b4_ff1 <= b4;\n        a4_ff2 <= a4_ff1;\n        b4_ff2<= b4_ff1;\n        a4_ff3 <= a4_ff2;\n        b4_ff3 <= b4_ff2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        s1_ff1 <= s1;\n        s1_ff2 <= s1_ff1;\n        s1_ff3 <= s1_ff2;\n        s2_ff1 <= s2;\n        s2_ff2 <= s2_ff1;\n        s3_ff1 <= s3;\n    end\n    else begin\n        s1_ff1 <= 'd0;\n        s1_ff2 <= 'd0;\n        s1_ff3 <= 'd0;\n        s2_ff1 <= 'd0;\n        s2_ff2 <= 'd0;\n        s3_ff1 <= 'd0;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c1 <= 1'b0;\n        s1 <= 'd0;\n    end\n    else if (i_en) begin\n        {c1, s1} <= a1 + b1;\n    end\n    else begin\n        c1 <= c1;\n        s1 <= s1;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c2 <= 1'b0;\n        s2 <= 'd0;\n    end\n    else if (stage1) begin\n        {c2, s2} <= a2_ff1 + b2_ff1 + c1;\n    end\n    else begin\n        c2 <= c2;\n        s2 <= s2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c3 <= 1'b0;\n        s3 <= 'd0;\n    end\n    else if (stage2) begin\n        {c3, s3} <= a3_ff2 + b3_ff2 + c2;\n    end\n    else begin\n        c3 <= c3;\n        s3 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c4 <= 1'b0;\n        s4 <= 'd0;\n    end\n    else if (stage3) begin\n        {c4, s4} <= a4_ff3 + b4_ff3 + c3;\n    end\n    else begin\n        c4 <= c4;\n        s4 <= s4;\n    end\nend\n\nassign result = {c4, s4, s3_ff1, s2_ff2, s1_ff3};\n\nendmodule", "corruption_explanation": "Swapped if and else bodies", "modification_type": "invert_if_else", "modification_line": 119, "original_snippet": "if (!rst_n) begin\n        s1_ff1 <= 'd0;\n        s1_ff2 <= 'd0;\n        s1_ff3 <= 'd0;\n        s2_ff1 <= 'd0;\n        s2_ff2 <= 'd0;\n        s3_ff1 <= 'd0;\n    end\n    else begin\n        s1_ff1 <= s1;", "modified_snippet": "if (!rst_n) begin\n        s1_ff1 <= s1;\n        s1_ff2 <= s1_ff1;\n        s1_ff3 <= s1_ff2;\n        s2_ff1 <= s2;\n        s2_ff2 <= s2_ff1;\n        s3_ff1 <= s3;\n    end\n    else begin\n        s1_ff1 ", "issue_description": "The buggy code has swapped if and else bodies in a conditional block. This causes the logic to execute the opposite branch for each condition, leading to incorrect behavior when the condition is true vs false. Test cases that depend on the conditional logic will fail because the intended branch is not executed.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module contains conditional logic that should execute different code paths based on a condition.\n   \u2022 The if branch should handle the true case, and the else branch should handle the false case.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Identified a conditional block with both if and else branches.\n   \u2022 The branches contain different assignments or logic operations.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The if and else bodies have been swapped.\n   \u2022 Logic that should execute when condition is true now executes when false, and vice versa.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The conditional bodies are inverted.\n   \u2022 Impact: All conditional behavior is reversed, causing incorrect outputs for all test cases.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Swap the if and else bodies back to their correct positions.\n   \u2022 Verify that the condition evaluates correctly and executes the intended branch.\n\n6. RTL Design Principle Violated:\n   \u2022 Correct conditional logic requires matching the intended behavior with the branch bodies.", "complexity": 100, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_if_else"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.598671", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_pipe_64bit", "module_name": "adder_64bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of a 64-bit ripple carry adder, which includes several registers to enable the pipeline stages. The output result is available on the result port, and the o_en = 1 indicates the availability of the result.\n\nModule name:  \n    adder_pipe_64bit               \nInput ports:\n    clk: Clock input\n    rst_n: Active low reset signal\n    i_en: Enable signal for addition operation\n    adda: 64-bit input operand A\n    addb: 64-bit input operand B\n   \nOutput ports:\n    result: 65-bit output representing the sum of adda and addb.\n    o_en: Output enable signal.   \n\nImplementation:\nThe module includes several registers to enable the pipeline stages and synchronize the input enable signal (i_en). These registers are controlled by the clock (clk) and reset (rst_n) signals.\nThe sum values for each pipeline stage are calculated by adding the corresponding input operands and carry signals.\nThe output enable signal (o_en) is updated based on the pipeline stages and synchronized with the clock (clk) and reset (rst_n) signals.\n\nGive me the complete code.\n"}, "clean_code": "module adder_64bit\n#(\n    parameter DATA_WIDTH = 64,\n    parameter STG_WIDTH = 16\n)\n(\n    input clk,\n    input rst_n,\n    input i_en,\n    input [DATA_WIDTH-1:0] adda,\n    input [DATA_WIDTH-1:0] addb,\n    output [DATA_WIDTH:0] result,\n    output reg o_en\n);\n\nreg stage1;\nreg stage2;\nreg stage3;\n\nwire [STG_WIDTH-1:0] a1;\nwire [STG_WIDTH-1:0] b1;\nwire [STG_WIDTH-1:0] a2;\nwire [STG_WIDTH-1:0] b2;\nwire [STG_WIDTH-1:0] a3;\nwire [STG_WIDTH-1:0] b3;\nwire [STG_WIDTH-1:0] a4;\nwire [STG_WIDTH-1:0] b4;\n\nreg [STG_WIDTH-1:0] a2_ff1;\nreg [STG_WIDTH-1:0] b2_ff1;\n\nreg [STG_WIDTH-1:0] a3_ff1;\nreg [STG_WIDTH-1:0] b3_ff1;\nreg [STG_WIDTH-1:0] a3_ff2;\nreg [STG_WIDTH-1:0] b3_ff2;\n\nreg [STG_WIDTH-1:0] a4_ff1;\nreg [STG_WIDTH-1:0] b4_ff1;\nreg [STG_WIDTH-1:0] a4_ff2;\nreg [STG_WIDTH-1:0] b4_ff2;\nreg [STG_WIDTH-1:0] a4_ff3;\nreg [STG_WIDTH-1:0] b4_ff3;\n\nreg c1;\nreg c2;\nreg c3;\nreg c4;\n\nreg [STG_WIDTH-1:0] s1;\nreg [STG_WIDTH-1:0] s2;\nreg [STG_WIDTH-1:0] s3;\nreg [STG_WIDTH-1:0] s4;\n\nreg [STG_WIDTH-1:0] s1_ff1;\nreg [STG_WIDTH-1:0] s1_ff2;\nreg [STG_WIDTH-1:0] s1_ff3;\n\nreg [STG_WIDTH-1:0] s2_ff1;\nreg [STG_WIDTH-1:0] s2_ff2;\n\nreg [STG_WIDTH-1:0] s3_ff1;\n\nassign a1 = adda[STG_WIDTH-1:0];\nassign b1 = addb[STG_WIDTH-1:0];\nassign a2 = adda[STG_WIDTH*2-1:16];\nassign b2 = addb[STG_WIDTH*2-1:16];\nassign a3 = adda[STG_WIDTH*3-1:32];\nassign b3 = addb[STG_WIDTH*3-1:32];\nassign a4 = adda[STG_WIDTH*4-1:48];\nassign b4 = addb[STG_WIDTH*4-1:48];\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        stage1 <= 1'b0;\n        stage2 <= 1'b0;\n        stage3 <= 1'b0;\n        o_en <= 1'b0;\n    end\n    else begin\n        stage1 <= i_en;\n        stage2 <= stage1;\n        stage3 <= stage2;\n        o_en <= stage3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        a2_ff1 <= 'd0;\n        b2_ff1 <= 'd0;\n        a3_ff1 <= 'd0;\n        b3_ff1 <= 'd0;\n        a3_ff2 <= 'd0;\n        b3_ff2 <= 'd0;\n        a4_ff1 <= 'd0;\n        b4_ff1 <= 'd0;\n        a4_ff2 <= 'd0;\n        b4_ff2 <= 'd0;\n        a4_ff3 <= 'd0;\n        b4_ff3 <= 'd0;\n    end\n    else begin\n        a2_ff1 <= a2;\n        b2_ff1 <= b2;\n        a3_ff1 <= a3;\n        b3_ff1 <= b3;\n        a3_ff2 <= a3_ff1;\n        b3_ff2 <= b3_ff1;\n        a4_ff1 <= a4;\n        b4_ff1 <= b4;\n        a4_ff2 <= a4_ff1;\n        b4_ff2<= b4_ff1;\n        a4_ff3 <= a4_ff2;\n        b4_ff3 <= b4_ff2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        s1_ff1 <= 'd0;\n        s1_ff2 <= 'd0;\n        s1_ff3 <= 'd0;\n        s2_ff1 <= 'd0;\n        s2_ff2 <= 'd0;\n        s3_ff1 <= 'd0;\n    end\n    else begin\n        s1_ff1 <= s1;\n        s1_ff2 <= s1_ff1;\n        s1_ff3 <= s1_ff2;\n        s2_ff1 <= s2;\n        s2_ff2 <= s2_ff1;\n        s3_ff1 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c1 <= 1'b0;\n        s1 <= 'd0;\n    end\n    else if (i_en) begin\n        {c1, s1} <= a1 + b1;\n    end\n    else begin\n        c1 <= c1;\n        s1 <= s1;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c2 <= 1'b0;\n        s2 <= 'd0;\n    end\n    else if (stage1) begin\n        {c2, s2} <= a2_ff1 + b2_ff1 + c1;\n    end\n    else begin\n        c2 <= c2;\n        s2 <= s2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c3 <= 1'b0;\n        s3 <= 'd0;\n    end\n    else if (stage2) begin\n        {c3, s3} <= a3_ff2 + b3_ff2 + c2;\n    end\n    else begin\n        c3 <= c3;\n        s3 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c4 <= 1'b0;\n        s4 <= 'd0;\n    end\n    else if (stage3) begin\n        {c4, s4} <= a4_ff3 + b4_ff3 + c3;\n    end\n    else begin\n        c4 <= c4;\n        s4 <= s4;\n    end\nend\n\nassign result = {c4, s4, s3_ff1, s2_ff2, s1_ff3};\n\nendmodule", "corrupted_code": "module adder_64bit\n#(\n    parameter DATA_WIDTH = 64,\n    parameter STG_WIDTH = 16\n)\n(\n    input clk,\n    input rst_n,\n    input i_en,\n    input [DATA_WIDTH-1:0] adda,\n    input [DATA_WIDTH-1:0] addb,\n    output [DATA_WIDTH:0] result,\n    output reg o_en\n);\n\nreg stage1;\nreg stage2;\nreg stage3;\n\nwire [STG_WIDTH-1:0] a1;\nwire [STG_WIDTH-1:0] b1;\nwire [STG_WIDTH-1:0] a2;\nwire [STG_WIDTH-1:0] b2;\nwire [STG_WIDTH-1:0] a3;\nwire [STG_WIDTH-1:0] b3;\nwire [STG_WIDTH-1:0] a4;\nwire [STG_WIDTH-1:0] b4;\n\nreg [STG_WIDTH-1:0] a2_ff1;\nreg [STG_WIDTH-1:0] b2_ff1;\n\nreg [STG_WIDTH-1:0] a3_ff1;\nreg [STG_WIDTH-1:0] b3_ff1;\nreg [STG_WIDTH-1:0] a3_ff2;\nreg [STG_WIDTH-1:0] b3_ff2;\n\nreg [STG_WIDTH-1:0] a4_ff1;\nreg [STG_WIDTH-1:0] b4_ff1;\nreg [STG_WIDTH-1:0] a4_ff2;\nreg [STG_WIDTH-1:0] b4_ff2;\nreg [STG_WIDTH-1:0] a4_ff3;\nreg [STG_WIDTH-1:0] b4_ff3;\n\nreg c1;\nreg c2;\nreg c3;\nreg c4;\n\nreg [STG_WIDTH-1:0] s1;\nreg [STG_WIDTH-1:0] s2;\nreg [STG_WIDTH-1:0] s3;\nreg [STG_WIDTH-1:0] s4;\n\nreg [STG_WIDTH-1:0] s1_ff1;\nreg [STG_WIDTH-1:0] s1_ff2;\nreg [STG_WIDTH-1:0] s1_ff3;\n\nreg [STG_WIDTH-1:0] s2_ff1;\nreg [STG_WIDTH-1:0] s2_ff2;\n\nreg [STG_WIDTH-1:0] s3_ff1;\n\nassign a1 = adda[STG_WIDTH-1:0];\nassign b1 = addb[STG_WIDTH-1:0];\nassign a2 = adda[STG_WIDTH*1-1:16];\nassign b2 = addb[STG_WIDTH*2-1:16];\nassign a3 = adda[STG_WIDTH*3-1:32];\nassign b3 = addb[STG_WIDTH*3-1:32];\nassign a4 = adda[STG_WIDTH*4-1:48];\nassign b4 = addb[STG_WIDTH*4-1:48];\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        stage1 <= 1'b0;\n        stage2 <= 1'b0;\n        stage3 <= 1'b0;\n        o_en <= 1'b0;\n    end\n    else begin\n        stage1 <= i_en;\n        stage2 <= stage1;\n        stage3 <= stage2;\n        o_en <= stage3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        a2_ff1 <= 'd0;\n        b2_ff1 <= 'd0;\n        a3_ff1 <= 'd0;\n        b3_ff1 <= 'd0;\n        a3_ff2 <= 'd0;\n        b3_ff2 <= 'd0;\n        a4_ff1 <= 'd0;\n        b4_ff1 <= 'd0;\n        a4_ff2 <= 'd0;\n        b4_ff2 <= 'd0;\n        a4_ff3 <= 'd0;\n        b4_ff3 <= 'd0;\n    end\n    else begin\n        a2_ff1 <= a2;\n        b2_ff1 <= b2;\n        a3_ff1 <= a3;\n        b3_ff1 <= b3;\n        a3_ff2 <= a3_ff1;\n        b3_ff2 <= b3_ff1;\n        a4_ff1 <= a4;\n        b4_ff1 <= b4;\n        a4_ff2 <= a4_ff1;\n        b4_ff2<= b4_ff1;\n        a4_ff3 <= a4_ff2;\n        b4_ff3 <= b4_ff2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        s1_ff1 <= 'd0;\n        s1_ff2 <= 'd0;\n        s1_ff3 <= 'd0;\n        s2_ff1 <= 'd0;\n        s2_ff2 <= 'd0;\n        s3_ff1 <= 'd0;\n    end\n    else begin\n        s1_ff1 <= s1;\n        s1_ff2 <= s1_ff1;\n        s1_ff3 <= s1_ff2;\n        s2_ff1 <= s2;\n        s2_ff2 <= s2_ff1;\n        s3_ff1 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c1 <= 1'b0;\n        s1 <= 'd0;\n    end\n    else if (i_en) begin\n        {c1, s1} <= a1 + b1;\n    end\n    else begin\n        c1 <= c1;\n        s1 <= s1;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c2 <= 1'b0;\n        s2 <= 'd0;\n    end\n    else if (stage1) begin\n        {c2, s2} <= a2_ff1 + b2_ff1 + c1;\n    end\n    else begin\n        c2 <= c2;\n        s2 <= s2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c3 <= 1'b0;\n        s3 <= 'd0;\n    end\n    else if (stage2) begin\n        {c3, s3} <= a3_ff2 + b3_ff2 + c2;\n    end\n    else begin\n        c3 <= c3;\n        s3 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c4 <= 1'b0;\n        s4 <= 'd0;\n    end\n    else if (stage3) begin\n        {c4, s4} <= a4_ff3 + b4_ff3 + c3;\n    end\n    else begin\n        c4 <= c4;\n        s4 <= s4;\n    end\nend\n\nassign result = {c4, s4, s3_ff1, s2_ff2, s1_ff3};\n\nendmodule", "corruption_explanation": "Changed constant from 2 to 1", "modification_type": "change_constant", "modification_line": 65, "original_snippet": "2", "modified_snippet": "1", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 2 to 1\n   \u2022 Line 65: Original: 2\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 65.\n   \u2022 Restore the original code: 2\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 100, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_constant"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.607815", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_pipe_64bit", "module_name": "adder_64bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of a 64-bit ripple carry adder, which includes several registers to enable the pipeline stages. The output result is available on the result port, and the o_en = 1 indicates the availability of the result.\n\nModule name:  \n    adder_pipe_64bit               \nInput ports:\n    clk: Clock input\n    rst_n: Active low reset signal\n    i_en: Enable signal for addition operation\n    adda: 64-bit input operand A\n    addb: 64-bit input operand B\n   \nOutput ports:\n    result: 65-bit output representing the sum of adda and addb.\n    o_en: Output enable signal.   \n\nImplementation:\nThe module includes several registers to enable the pipeline stages and synchronize the input enable signal (i_en). These registers are controlled by the clock (clk) and reset (rst_n) signals.\nThe sum values for each pipeline stage are calculated by adding the corresponding input operands and carry signals.\nThe output enable signal (o_en) is updated based on the pipeline stages and synchronized with the clock (clk) and reset (rst_n) signals.\n\nGive me the complete code.\n"}, "clean_code": "module adder_64bit\n#(\n    parameter DATA_WIDTH = 64,\n    parameter STG_WIDTH = 16\n)\n(\n    input clk,\n    input rst_n,\n    input i_en,\n    input [DATA_WIDTH-1:0] adda,\n    input [DATA_WIDTH-1:0] addb,\n    output [DATA_WIDTH:0] result,\n    output reg o_en\n);\n\nreg stage1;\nreg stage2;\nreg stage3;\n\nwire [STG_WIDTH-1:0] a1;\nwire [STG_WIDTH-1:0] b1;\nwire [STG_WIDTH-1:0] a2;\nwire [STG_WIDTH-1:0] b2;\nwire [STG_WIDTH-1:0] a3;\nwire [STG_WIDTH-1:0] b3;\nwire [STG_WIDTH-1:0] a4;\nwire [STG_WIDTH-1:0] b4;\n\nreg [STG_WIDTH-1:0] a2_ff1;\nreg [STG_WIDTH-1:0] b2_ff1;\n\nreg [STG_WIDTH-1:0] a3_ff1;\nreg [STG_WIDTH-1:0] b3_ff1;\nreg [STG_WIDTH-1:0] a3_ff2;\nreg [STG_WIDTH-1:0] b3_ff2;\n\nreg [STG_WIDTH-1:0] a4_ff1;\nreg [STG_WIDTH-1:0] b4_ff1;\nreg [STG_WIDTH-1:0] a4_ff2;\nreg [STG_WIDTH-1:0] b4_ff2;\nreg [STG_WIDTH-1:0] a4_ff3;\nreg [STG_WIDTH-1:0] b4_ff3;\n\nreg c1;\nreg c2;\nreg c3;\nreg c4;\n\nreg [STG_WIDTH-1:0] s1;\nreg [STG_WIDTH-1:0] s2;\nreg [STG_WIDTH-1:0] s3;\nreg [STG_WIDTH-1:0] s4;\n\nreg [STG_WIDTH-1:0] s1_ff1;\nreg [STG_WIDTH-1:0] s1_ff2;\nreg [STG_WIDTH-1:0] s1_ff3;\n\nreg [STG_WIDTH-1:0] s2_ff1;\nreg [STG_WIDTH-1:0] s2_ff2;\n\nreg [STG_WIDTH-1:0] s3_ff1;\n\nassign a1 = adda[STG_WIDTH-1:0];\nassign b1 = addb[STG_WIDTH-1:0];\nassign a2 = adda[STG_WIDTH*2-1:16];\nassign b2 = addb[STG_WIDTH*2-1:16];\nassign a3 = adda[STG_WIDTH*3-1:32];\nassign b3 = addb[STG_WIDTH*3-1:32];\nassign a4 = adda[STG_WIDTH*4-1:48];\nassign b4 = addb[STG_WIDTH*4-1:48];\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        stage1 <= 1'b0;\n        stage2 <= 1'b0;\n        stage3 <= 1'b0;\n        o_en <= 1'b0;\n    end\n    else begin\n        stage1 <= i_en;\n        stage2 <= stage1;\n        stage3 <= stage2;\n        o_en <= stage3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        a2_ff1 <= 'd0;\n        b2_ff1 <= 'd0;\n        a3_ff1 <= 'd0;\n        b3_ff1 <= 'd0;\n        a3_ff2 <= 'd0;\n        b3_ff2 <= 'd0;\n        a4_ff1 <= 'd0;\n        b4_ff1 <= 'd0;\n        a4_ff2 <= 'd0;\n        b4_ff2 <= 'd0;\n        a4_ff3 <= 'd0;\n        b4_ff3 <= 'd0;\n    end\n    else begin\n        a2_ff1 <= a2;\n        b2_ff1 <= b2;\n        a3_ff1 <= a3;\n        b3_ff1 <= b3;\n        a3_ff2 <= a3_ff1;\n        b3_ff2 <= b3_ff1;\n        a4_ff1 <= a4;\n        b4_ff1 <= b4;\n        a4_ff2 <= a4_ff1;\n        b4_ff2<= b4_ff1;\n        a4_ff3 <= a4_ff2;\n        b4_ff3 <= b4_ff2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        s1_ff1 <= 'd0;\n        s1_ff2 <= 'd0;\n        s1_ff3 <= 'd0;\n        s2_ff1 <= 'd0;\n        s2_ff2 <= 'd0;\n        s3_ff1 <= 'd0;\n    end\n    else begin\n        s1_ff1 <= s1;\n        s1_ff2 <= s1_ff1;\n        s1_ff3 <= s1_ff2;\n        s2_ff1 <= s2;\n        s2_ff2 <= s2_ff1;\n        s3_ff1 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c1 <= 1'b0;\n        s1 <= 'd0;\n    end\n    else if (i_en) begin\n        {c1, s1} <= a1 + b1;\n    end\n    else begin\n        c1 <= c1;\n        s1 <= s1;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c2 <= 1'b0;\n        s2 <= 'd0;\n    end\n    else if (stage1) begin\n        {c2, s2} <= a2_ff1 + b2_ff1 + c1;\n    end\n    else begin\n        c2 <= c2;\n        s2 <= s2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c3 <= 1'b0;\n        s3 <= 'd0;\n    end\n    else if (stage2) begin\n        {c3, s3} <= a3_ff2 + b3_ff2 + c2;\n    end\n    else begin\n        c3 <= c3;\n        s3 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c4 <= 1'b0;\n        s4 <= 'd0;\n    end\n    else if (stage3) begin\n        {c4, s4} <= a4_ff3 + b4_ff3 + c3;\n    end\n    else begin\n        c4 <= c4;\n        s4 <= s4;\n    end\nend\n\nassign result = {c4, s4, s3_ff1, s2_ff2, s1_ff3};\n\nendmodule", "corrupted_code": "module adder_64bit\n#(\n    parameter DATA_WIDTH = 64,\n    parameter STG_WIDTH = 16\n)\n(\n    input clk,\n    input rst_n,\n    input i_en,\n    input [DATA_WIDTH-1:0] adda,\n    input [1 - DATA_WIDTH:0] addb,\n    output [DATA_WIDTH:0] result,\n    output reg o_en\n);\n\nreg stage1;\nreg stage2;\nreg stage3;\n\nwire [STG_WIDTH-1:0] a1;\nwire [STG_WIDTH-1:0] b1;\nwire [STG_WIDTH-1:0] a2;\nwire [STG_WIDTH-1:0] b2;\nwire [STG_WIDTH-1:0] a3;\nwire [STG_WIDTH-1:0] b3;\nwire [STG_WIDTH-1:0] a4;\nwire [STG_WIDTH-1:0] b4;\n\nreg [STG_WIDTH-1:0] a2_ff1;\nreg [STG_WIDTH-1:0] b2_ff1;\n\nreg [STG_WIDTH-1:0] a3_ff1;\nreg [STG_WIDTH-1:0] b3_ff1;\nreg [STG_WIDTH-1:0] a3_ff2;\nreg [STG_WIDTH-1:0] b3_ff2;\n\nreg [STG_WIDTH-1:0] a4_ff1;\nreg [STG_WIDTH-1:0] b4_ff1;\nreg [STG_WIDTH-1:0] a4_ff2;\nreg [STG_WIDTH-1:0] b4_ff2;\nreg [STG_WIDTH-1:0] a4_ff3;\nreg [STG_WIDTH-1:0] b4_ff3;\n\nreg c1;\nreg c2;\nreg c3;\nreg c4;\n\nreg [STG_WIDTH-1:0] s1;\nreg [STG_WIDTH-1:0] s2;\nreg [STG_WIDTH-1:0] s3;\nreg [STG_WIDTH-1:0] s4;\n\nreg [STG_WIDTH-1:0] s1_ff1;\nreg [STG_WIDTH-1:0] s1_ff2;\nreg [STG_WIDTH-1:0] s1_ff3;\n\nreg [STG_WIDTH-1:0] s2_ff1;\nreg [STG_WIDTH-1:0] s2_ff2;\n\nreg [STG_WIDTH-1:0] s3_ff1;\n\nassign a1 = adda[STG_WIDTH-1:0];\nassign b1 = addb[STG_WIDTH-1:0];\nassign a2 = adda[STG_WIDTH*2-1:16];\nassign b2 = addb[STG_WIDTH*2-1:16];\nassign a3 = adda[STG_WIDTH*3-1:32];\nassign b3 = addb[STG_WIDTH*3-1:32];\nassign a4 = adda[STG_WIDTH*4-1:48];\nassign b4 = addb[STG_WIDTH*4-1:48];\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        stage1 <= 1'b0;\n        stage2 <= 1'b0;\n        stage3 <= 1'b0;\n        o_en <= 1'b0;\n    end\n    else begin\n        stage1 <= i_en;\n        stage2 <= stage1;\n        stage3 <= stage2;\n        o_en <= stage3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        a2_ff1 <= 'd0;\n        b2_ff1 <= 'd0;\n        a3_ff1 <= 'd0;\n        b3_ff1 <= 'd0;\n        a3_ff2 <= 'd0;\n        b3_ff2 <= 'd0;\n        a4_ff1 <= 'd0;\n        b4_ff1 <= 'd0;\n        a4_ff2 <= 'd0;\n        b4_ff2 <= 'd0;\n        a4_ff3 <= 'd0;\n        b4_ff3 <= 'd0;\n    end\n    else begin\n        a2_ff1 <= a2;\n        b2_ff1 <= b2;\n        a3_ff1 <= a3;\n        b3_ff1 <= b3;\n        a3_ff2 <= a3_ff1;\n        b3_ff2 <= b3_ff1;\n        a4_ff1 <= a4;\n        b4_ff1 <= b4;\n        a4_ff2 <= a4_ff1;\n        b4_ff2<= b4_ff1;\n        a4_ff3 <= a4_ff2;\n        b4_ff3 <= b4_ff2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        s1_ff1 <= 'd0;\n        s1_ff2 <= 'd0;\n        s1_ff3 <= 'd0;\n        s2_ff1 <= 'd0;\n        s2_ff2 <= 'd0;\n        s3_ff1 <= 'd0;\n    end\n    else begin\n        s1_ff1 <= s1;\n        s1_ff2 <= s1_ff1;\n        s1_ff3 <= s1_ff2;\n        s2_ff1 <= s2;\n        s2_ff2 <= s2_ff1;\n        s3_ff1 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c1 <= 1'b0;\n        s1 <= 'd0;\n    end\n    else if (i_en) begin\n        {c1, s1} <= a1 + b1;\n    end\n    else begin\n        c1 <= c1;\n        s1 <= s1;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c2 <= 1'b0;\n        s2 <= 'd0;\n    end\n    else if (stage1) begin\n        {c2, s2} <= a2_ff1 + b2_ff1 + c1;\n    end\n    else begin\n        c2 <= c2;\n        s2 <= s2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c3 <= 1'b0;\n        s3 <= 'd0;\n    end\n    else if (stage2) begin\n        {c3, s3} <= a3_ff2 + b3_ff2 + c2;\n    end\n    else begin\n        c3 <= c3;\n        s3 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c4 <= 1'b0;\n        s4 <= 'd0;\n    end\n    else if (stage3) begin\n        {c4, s4} <= a4_ff3 + b4_ff3 + c3;\n    end\n    else begin\n        c4 <= c4;\n        s4 <= s4;\n    end\nend\n\nassign result = {c4, s4, s3_ff1, s2_ff2, s1_ff3};\n\nendmodule", "corruption_explanation": "Swapped operands: 'DATA_WIDTH - 1' -> '1 - DATA_WIDTH'", "modification_type": "swap_operands", "modification_line": 11, "original_snippet": "DATA_WIDTH-1", "modified_snippet": "1 - DATA_WIDTH", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'DATA_WIDTH - 1' -> '1 - DATA_WIDTH'\n   \u2022 Line 11: Original: DATA_WIDTH-1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 11.\n   \u2022 Restore the original code: DATA_WIDTH-1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 100, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_operands"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.662553", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_pipe_64bit", "module_name": "adder_64bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of a 64-bit ripple carry adder, which includes several registers to enable the pipeline stages. The output result is available on the result port, and the o_en = 1 indicates the availability of the result.\n\nModule name:  \n    adder_pipe_64bit               \nInput ports:\n    clk: Clock input\n    rst_n: Active low reset signal\n    i_en: Enable signal for addition operation\n    adda: 64-bit input operand A\n    addb: 64-bit input operand B\n   \nOutput ports:\n    result: 65-bit output representing the sum of adda and addb.\n    o_en: Output enable signal.   \n\nImplementation:\nThe module includes several registers to enable the pipeline stages and synchronize the input enable signal (i_en). These registers are controlled by the clock (clk) and reset (rst_n) signals.\nThe sum values for each pipeline stage are calculated by adding the corresponding input operands and carry signals.\nThe output enable signal (o_en) is updated based on the pipeline stages and synchronized with the clock (clk) and reset (rst_n) signals.\n\nGive me the complete code.\n"}, "clean_code": "module adder_64bit\n#(\n    parameter DATA_WIDTH = 64,\n    parameter STG_WIDTH = 16\n)\n(\n    input clk,\n    input rst_n,\n    input i_en,\n    input [DATA_WIDTH-1:0] adda,\n    input [DATA_WIDTH-1:0] addb,\n    output [DATA_WIDTH:0] result,\n    output reg o_en\n);\n\nreg stage1;\nreg stage2;\nreg stage3;\n\nwire [STG_WIDTH-1:0] a1;\nwire [STG_WIDTH-1:0] b1;\nwire [STG_WIDTH-1:0] a2;\nwire [STG_WIDTH-1:0] b2;\nwire [STG_WIDTH-1:0] a3;\nwire [STG_WIDTH-1:0] b3;\nwire [STG_WIDTH-1:0] a4;\nwire [STG_WIDTH-1:0] b4;\n\nreg [STG_WIDTH-1:0] a2_ff1;\nreg [STG_WIDTH-1:0] b2_ff1;\n\nreg [STG_WIDTH-1:0] a3_ff1;\nreg [STG_WIDTH-1:0] b3_ff1;\nreg [STG_WIDTH-1:0] a3_ff2;\nreg [STG_WIDTH-1:0] b3_ff2;\n\nreg [STG_WIDTH-1:0] a4_ff1;\nreg [STG_WIDTH-1:0] b4_ff1;\nreg [STG_WIDTH-1:0] a4_ff2;\nreg [STG_WIDTH-1:0] b4_ff2;\nreg [STG_WIDTH-1:0] a4_ff3;\nreg [STG_WIDTH-1:0] b4_ff3;\n\nreg c1;\nreg c2;\nreg c3;\nreg c4;\n\nreg [STG_WIDTH-1:0] s1;\nreg [STG_WIDTH-1:0] s2;\nreg [STG_WIDTH-1:0] s3;\nreg [STG_WIDTH-1:0] s4;\n\nreg [STG_WIDTH-1:0] s1_ff1;\nreg [STG_WIDTH-1:0] s1_ff2;\nreg [STG_WIDTH-1:0] s1_ff3;\n\nreg [STG_WIDTH-1:0] s2_ff1;\nreg [STG_WIDTH-1:0] s2_ff2;\n\nreg [STG_WIDTH-1:0] s3_ff1;\n\nassign a1 = adda[STG_WIDTH-1:0];\nassign b1 = addb[STG_WIDTH-1:0];\nassign a2 = adda[STG_WIDTH*2-1:16];\nassign b2 = addb[STG_WIDTH*2-1:16];\nassign a3 = adda[STG_WIDTH*3-1:32];\nassign b3 = addb[STG_WIDTH*3-1:32];\nassign a4 = adda[STG_WIDTH*4-1:48];\nassign b4 = addb[STG_WIDTH*4-1:48];\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        stage1 <= 1'b0;\n        stage2 <= 1'b0;\n        stage3 <= 1'b0;\n        o_en <= 1'b0;\n    end\n    else begin\n        stage1 <= i_en;\n        stage2 <= stage1;\n        stage3 <= stage2;\n        o_en <= stage3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        a2_ff1 <= 'd0;\n        b2_ff1 <= 'd0;\n        a3_ff1 <= 'd0;\n        b3_ff1 <= 'd0;\n        a3_ff2 <= 'd0;\n        b3_ff2 <= 'd0;\n        a4_ff1 <= 'd0;\n        b4_ff1 <= 'd0;\n        a4_ff2 <= 'd0;\n        b4_ff2 <= 'd0;\n        a4_ff3 <= 'd0;\n        b4_ff3 <= 'd0;\n    end\n    else begin\n        a2_ff1 <= a2;\n        b2_ff1 <= b2;\n        a3_ff1 <= a3;\n        b3_ff1 <= b3;\n        a3_ff2 <= a3_ff1;\n        b3_ff2 <= b3_ff1;\n        a4_ff1 <= a4;\n        b4_ff1 <= b4;\n        a4_ff2 <= a4_ff1;\n        b4_ff2<= b4_ff1;\n        a4_ff3 <= a4_ff2;\n        b4_ff3 <= b4_ff2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        s1_ff1 <= 'd0;\n        s1_ff2 <= 'd0;\n        s1_ff3 <= 'd0;\n        s2_ff1 <= 'd0;\n        s2_ff2 <= 'd0;\n        s3_ff1 <= 'd0;\n    end\n    else begin\n        s1_ff1 <= s1;\n        s1_ff2 <= s1_ff1;\n        s1_ff3 <= s1_ff2;\n        s2_ff1 <= s2;\n        s2_ff2 <= s2_ff1;\n        s3_ff1 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c1 <= 1'b0;\n        s1 <= 'd0;\n    end\n    else if (i_en) begin\n        {c1, s1} <= a1 + b1;\n    end\n    else begin\n        c1 <= c1;\n        s1 <= s1;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c2 <= 1'b0;\n        s2 <= 'd0;\n    end\n    else if (stage1) begin\n        {c2, s2} <= a2_ff1 + b2_ff1 + c1;\n    end\n    else begin\n        c2 <= c2;\n        s2 <= s2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c3 <= 1'b0;\n        s3 <= 'd0;\n    end\n    else if (stage2) begin\n        {c3, s3} <= a3_ff2 + b3_ff2 + c2;\n    end\n    else begin\n        c3 <= c3;\n        s3 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c4 <= 1'b0;\n        s4 <= 'd0;\n    end\n    else if (stage3) begin\n        {c4, s4} <= a4_ff3 + b4_ff3 + c3;\n    end\n    else begin\n        c4 <= c4;\n        s4 <= s4;\n    end\nend\n\nassign result = {c4, s4, s3_ff1, s2_ff2, s1_ff3};\n\nendmodule", "corrupted_code": "module adder_64bit\n#(\n    parameter DATA_WIDTH = 64,\n    parameter STG_WIDTH = 16\n)\n(\n    input clk,\n    input rst_n,\n    input i_en,\n    input [DATA_WIDTH-1:0] adda,\n    input [DATA_WIDTH-1:0] addb,\n    output [DATA_WIDTH:0] result,\n    output reg o_en\n);\n\nreg stage1;\nreg stage2;\nreg stage3;\n\nwire [STG_WIDTH-1:0] a1;\nwire [STG_WIDTH-1:0] b1;\nwire [STG_WIDTH-1:0] a2;\nwire [STG_WIDTH-1:0] b2;\nwire [STG_WIDTH-1:0] a3;\nwire [STG_WIDTH-1:0] b3;\nwire [STG_WIDTH-1:0] a4;\nwire [STG_WIDTH-1:0] b4;\n\nreg [STG_WIDTH-1:0] a2_ff1;\nreg [STG_WIDTH-1:0] b2_ff1;\n\nreg [STG_WIDTH-1:0] a3_ff1;\nreg [STG_WIDTH-1:0] b3_ff1;\nreg [STG_WIDTH-1:0] a3_ff2;\nreg [STG_WIDTH-1:0] b3_ff2;\n\nreg [STG_WIDTH-1:0] a4_ff1;\nreg [STG_WIDTH-1:0] b4_ff1;\nreg [STG_WIDTH-1:0] a4_ff2;\nreg [STG_WIDTH-1:0] b4_ff2;\nreg [STG_WIDTH-1:0] a4_ff3;\nreg [STG_WIDTH-1:0] b4_ff3;\n\nreg c1;\nreg c2;\nreg c3;\nreg c4;\n\nreg [STG_WIDTH-1:0] s1;\nreg [STG_WIDTH-1:0] s2;\nreg [STG_WIDTH-1:0] s3;\nreg [STG_WIDTH-1:0] s4;\n\nreg [STG_WIDTH-1:0] s1_ff1;\nreg [STG_WIDTH-1:0] s1_ff2;\nreg [STG_WIDTH-1:0] s1_ff3;\n\nreg [STG_WIDTH-1:0] s2_ff1;\nreg [STG_WIDTH-1:0] s2_ff2;\n\nreg [STG_WIDTH-1:0] s3_ff1;\n\nassign a1 = adda[STG_WIDTH-1:0];\nassign b1 = addb[STG_WIDTH-1:0];\nassign a2 = adda[STG_WIDTH*2-1:16];\nassign b2 = addb[STG_WIDTH*2-1:16];\nassign a3 = adda[STG_WIDTH*3-1:32];\nassign b3 = addb[STG_WIDTH*3-1:32];\nassign a4 = adda[STG_WIDTH*4-1:48];\nassign b4 = addb[STG_WIDTH*4-1:48];\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        stage1 <= 1'b0;\n        stage2 <= 1'b0;\n        stage3 <= 1'b0;\n        o_en <= 1'b0;\n    end\n    else begin\n        stage1 <= i_en;\n        stage2 <= stage1;\n        stage3 <= stage2;\n        o_en <= stage3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        a2_ff1 <= 'd0;\n        b2_ff1 <= 'd0;\n        a3_ff1 <= 'd0;\n        b3_ff1 <= 'd0;\n        a3_ff2 <= 'd0;\n        b3_ff2 <= 'd0;\n        a4_ff1 <= 'd0;\n        b4_ff1 <= 'd0;\n        a4_ff2 <= 'd0;\n        b4_ff2 <= 'd0;\n        a4_ff3 <= 'd0;\n        b4_ff3 <= 'd0;\n    end\n    else begin\n        a2_ff1 <= a2;\n        b2_ff1 <= b2;\n        a3_ff1 <= a3;\n        b3_ff1 <= b3;\n        a3_ff2 <= a3_ff1;\n        b3_ff2 <= b3_ff1;\n        a4_ff1 <= a4;\n        b4_ff1 <= b4;\n        a4_ff2 <= a4_ff1;\n        b4_ff2<= b4_ff1;\n        a4_ff3 <= a4_ff2;\n        b4_ff3 <= b4_ff2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        s1_ff1 <= 'd0;\n        s1_ff2 <= 'd0;\n        s1_ff3 <= 'd0;\n        s2_ff1 <= 'd0;\n        s2_ff2 <= 'd0;\n        s3_ff1 <= 'd0;\n    end\n    else begin\n        s1_ff1 <= s1;\n        s1_ff2 <= s1_ff1;\n        s1_ff3 <= s1_ff2;\n        s2_ff1 <= s2;\n        s2_ff2 <= s2_ff1;\n        s3_ff1 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c1 <= 1'b0;\n        s1 <= 'd0;\n    end\n    else if (i_en) begin\n        {c1, s1} <= a1 + b1;\n    end\n    else begin\n        c1 <= c1;\n        s1 <= s1;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c2 <= 1'b0;\n        s2 <= 'd0;\n    end\n    else if (stage1) begin\n        {c2, s2} <= a2_ff1 + b2_ff1 + c1;\n    end\n    else begin\n        c2 <= c2;\n        s2 <= s2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c3 <= 1'b0;\n        s3 <= 'd0;\n    end\n    else if (stage2) begin\n        {c3, s3} <= a3_ff2 + b3_ff2 + c2;\n    end\n    else begin\n        c3 <= c3;\n        s3 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c4 <= 1'b0;\n        s4 <= 'd0;\n    end\n    else if (stage3) begin\n        {c4, s4} <= a4_ff3 + b4_ff3 + c3;\n    end\n    else begin\n        c4 <= c4;\n        s4 <= s4;\n    end\nend\n\nassign result = {c4, s4, s3_ff1, s2_ff2, s1_ff3};\n\n\n    wire clk_dup;\n    assign clk_dup = clk;\nendmodule", "corruption_explanation": "Added duplicate clock signal clk_dup", "modification_type": "duplicate_clock_signal", "modification_line": 77, "original_snippet": "(none)", "modified_snippet": "wire clk_dup;\n    assign clk_dup = clk;", "issue_description": "The buggy code has a duplicate clock signal. A phantom clock domain is created, which may confuse CDC analysis tools and create subtle timing issues in synthesis. This violates clock domain design best practices.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a duplicate_clock_signal modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added duplicate clock signal clk_dup\n   \u2022 Line 77: Original: (none)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 77.\n   \u2022 Restore the original code: (none)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to duplicate clock signal.", "complexity": 100, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["duplicate_clock_signal"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.668989", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_pipe_64bit", "module_name": "adder_64bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of a 64-bit ripple carry adder, which includes several registers to enable the pipeline stages. The output result is available on the result port, and the o_en = 1 indicates the availability of the result.\n\nModule name:  \n    adder_pipe_64bit               \nInput ports:\n    clk: Clock input\n    rst_n: Active low reset signal\n    i_en: Enable signal for addition operation\n    adda: 64-bit input operand A\n    addb: 64-bit input operand B\n   \nOutput ports:\n    result: 65-bit output representing the sum of adda and addb.\n    o_en: Output enable signal.   \n\nImplementation:\nThe module includes several registers to enable the pipeline stages and synchronize the input enable signal (i_en). These registers are controlled by the clock (clk) and reset (rst_n) signals.\nThe sum values for each pipeline stage are calculated by adding the corresponding input operands and carry signals.\nThe output enable signal (o_en) is updated based on the pipeline stages and synchronized with the clock (clk) and reset (rst_n) signals.\n\nGive me the complete code.\n"}, "clean_code": "module adder_64bit\n#(\n    parameter DATA_WIDTH = 64,\n    parameter STG_WIDTH = 16\n)\n(\n    input clk,\n    input rst_n,\n    input i_en,\n    input [DATA_WIDTH-1:0] adda,\n    input [DATA_WIDTH-1:0] addb,\n    output [DATA_WIDTH:0] result,\n    output reg o_en\n);\n\nreg stage1;\nreg stage2;\nreg stage3;\n\nwire [STG_WIDTH-1:0] a1;\nwire [STG_WIDTH-1:0] b1;\nwire [STG_WIDTH-1:0] a2;\nwire [STG_WIDTH-1:0] b2;\nwire [STG_WIDTH-1:0] a3;\nwire [STG_WIDTH-1:0] b3;\nwire [STG_WIDTH-1:0] a4;\nwire [STG_WIDTH-1:0] b4;\n\nreg [STG_WIDTH-1:0] a2_ff1;\nreg [STG_WIDTH-1:0] b2_ff1;\n\nreg [STG_WIDTH-1:0] a3_ff1;\nreg [STG_WIDTH-1:0] b3_ff1;\nreg [STG_WIDTH-1:0] a3_ff2;\nreg [STG_WIDTH-1:0] b3_ff2;\n\nreg [STG_WIDTH-1:0] a4_ff1;\nreg [STG_WIDTH-1:0] b4_ff1;\nreg [STG_WIDTH-1:0] a4_ff2;\nreg [STG_WIDTH-1:0] b4_ff2;\nreg [STG_WIDTH-1:0] a4_ff3;\nreg [STG_WIDTH-1:0] b4_ff3;\n\nreg c1;\nreg c2;\nreg c3;\nreg c4;\n\nreg [STG_WIDTH-1:0] s1;\nreg [STG_WIDTH-1:0] s2;\nreg [STG_WIDTH-1:0] s3;\nreg [STG_WIDTH-1:0] s4;\n\nreg [STG_WIDTH-1:0] s1_ff1;\nreg [STG_WIDTH-1:0] s1_ff2;\nreg [STG_WIDTH-1:0] s1_ff3;\n\nreg [STG_WIDTH-1:0] s2_ff1;\nreg [STG_WIDTH-1:0] s2_ff2;\n\nreg [STG_WIDTH-1:0] s3_ff1;\n\nassign a1 = adda[STG_WIDTH-1:0];\nassign b1 = addb[STG_WIDTH-1:0];\nassign a2 = adda[STG_WIDTH*2-1:16];\nassign b2 = addb[STG_WIDTH*2-1:16];\nassign a3 = adda[STG_WIDTH*3-1:32];\nassign b3 = addb[STG_WIDTH*3-1:32];\nassign a4 = adda[STG_WIDTH*4-1:48];\nassign b4 = addb[STG_WIDTH*4-1:48];\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        stage1 <= 1'b0;\n        stage2 <= 1'b0;\n        stage3 <= 1'b0;\n        o_en <= 1'b0;\n    end\n    else begin\n        stage1 <= i_en;\n        stage2 <= stage1;\n        stage3 <= stage2;\n        o_en <= stage3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        a2_ff1 <= 'd0;\n        b2_ff1 <= 'd0;\n        a3_ff1 <= 'd0;\n        b3_ff1 <= 'd0;\n        a3_ff2 <= 'd0;\n        b3_ff2 <= 'd0;\n        a4_ff1 <= 'd0;\n        b4_ff1 <= 'd0;\n        a4_ff2 <= 'd0;\n        b4_ff2 <= 'd0;\n        a4_ff3 <= 'd0;\n        b4_ff3 <= 'd0;\n    end\n    else begin\n        a2_ff1 <= a2;\n        b2_ff1 <= b2;\n        a3_ff1 <= a3;\n        b3_ff1 <= b3;\n        a3_ff2 <= a3_ff1;\n        b3_ff2 <= b3_ff1;\n        a4_ff1 <= a4;\n        b4_ff1 <= b4;\n        a4_ff2 <= a4_ff1;\n        b4_ff2<= b4_ff1;\n        a4_ff3 <= a4_ff2;\n        b4_ff3 <= b4_ff2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        s1_ff1 <= 'd0;\n        s1_ff2 <= 'd0;\n        s1_ff3 <= 'd0;\n        s2_ff1 <= 'd0;\n        s2_ff2 <= 'd0;\n        s3_ff1 <= 'd0;\n    end\n    else begin\n        s1_ff1 <= s1;\n        s1_ff2 <= s1_ff1;\n        s1_ff3 <= s1_ff2;\n        s2_ff1 <= s2;\n        s2_ff2 <= s2_ff1;\n        s3_ff1 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c1 <= 1'b0;\n        s1 <= 'd0;\n    end\n    else if (i_en) begin\n        {c1, s1} <= a1 + b1;\n    end\n    else begin\n        c1 <= c1;\n        s1 <= s1;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c2 <= 1'b0;\n        s2 <= 'd0;\n    end\n    else if (stage1) begin\n        {c2, s2} <= a2_ff1 + b2_ff1 + c1;\n    end\n    else begin\n        c2 <= c2;\n        s2 <= s2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c3 <= 1'b0;\n        s3 <= 'd0;\n    end\n    else if (stage2) begin\n        {c3, s3} <= a3_ff2 + b3_ff2 + c2;\n    end\n    else begin\n        c3 <= c3;\n        s3 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c4 <= 1'b0;\n        s4 <= 'd0;\n    end\n    else if (stage3) begin\n        {c4, s4} <= a4_ff3 + b4_ff3 + c3;\n    end\n    else begin\n        c4 <= c4;\n        s4 <= s4;\n    end\nend\n\nassign result = {c4, s4, s3_ff1, s2_ff2, s1_ff3};\n\nendmodule", "corrupted_code": "module adder_64bit\n#(\n    parameter DATA_WIDTH = 64,\n    parameter STG_WIDTH = 16\n)\n(\n    input clk,\n    input rst_n,\n    input i_en,\n    input [DATA_WIDTH-1:0] adda,\n    input [DATA_WIDTH-1:0] addb,\n    output [DATA_WIDTH:0] result,\n    output reg o_en\n);\n\nreg stage1;\nreg stage2;\nreg stage3;\n\nwire [STG_WIDTH-1:0] a1;\nwire [STG_WIDTH-1:0] b1;\nwire [STG_WIDTH-1:0] a2;\nwire [STG_WIDTH-1:0] b2;\nwire [STG_WIDTH-1:0] a3;\nwire [STG_WIDTH-1:0] b3;\nwire [STG_WIDTH-1:0] a4;\nwire [STG_WIDTH-1:0] b4;\n\nreg [STG_WIDTH-1:0] a2_ff1;\nreg [STG_WIDTH-1:0] b2_ff1;\n\nreg [STG_WIDTH-1:0] a3_ff1;\nreg [STG_WIDTH-1:0] b3_ff1;\nreg [STG_WIDTH-1:0] a3_ff2;\nreg [STG_WIDTH-1:0] b3_ff2;\n\nreg [STG_WIDTH-1:0] a4_ff1;\nreg [STG_WIDTH-1:0] b4_ff1;\nreg [STG_WIDTH-1:0] a4_ff2;\nreg [STG_WIDTH-1:0] b4_ff2;\nreg [STG_WIDTH-1:0] a4_ff3;\nreg [STG_WIDTH-1:0] b4_ff3;\n\nreg c1;\nreg c2;\nreg c3;\nreg c4;\n\nreg [STG_WIDTH-1:0] s1;\nreg [STG_WIDTH-1:0] s2;\nreg [STG_WIDTH-1:0] s3;\nreg [STG_WIDTH-1:0] s4;\n\nreg [STG_WIDTH-1:0] s1_ff1;\nreg [STG_WIDTH-1:0] s1_ff2;\nreg [STG_WIDTH-1:0] s1_ff3;\n\nreg [STG_WIDTH-1:0] s2_ff1;\nreg [STG_WIDTH-1:0] s2_ff2;\n\nreg [STG_WIDTH-1:0] s3_ff1;\n\nassign a1 = adda[STG_WIDTH-1:0];\nassign b1 = addb[STG_WIDTH-1:0];\nassign a2 = adda[STG_WIDTH*2-1:16];\nassign b2 = addb[STG_WIDTH*2-1:16];\nassign a3 = adda[STG_WIDTH*3-1:32];\nassign b3 = addb[STG_WIDTH*3-1:32];\nassign a4 = adda[STG_WIDTH*4-1:48];\nassign b4 = addb[STG_WIDTH*4-1:48];\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        stage1 <= 1'b0;\n        stage2 <= 1'b0;\n        stage3 <= 1'b0;\n        o_en <= 1'b0;\n    end\n    else begin\n        stage1 <= i_en;\n        stage2 <= stage1;\n        stage3 <= stage2;\n        o_en <= stage3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        a2_ff1 <= 'd0;\n        b2_ff1 <= 'd0;\n        a3_ff1 <= 'd0;\n        b3_ff1 <= 'd0;\n        a3_ff2 <= 'd0;\n        b3_ff2 <= 'd0;\n        a4_ff1 <= 'd0;\n        b4_ff1 <= 'd0;\n        a4_ff2 <= 'd0;\n        b4_ff2 <= 'd0;\n        a4_ff3 <= 'd0;\n        b4_ff3 <= 'd0;\n    end\n    else begin\n        a2_ff1 <= a2;\n        b2_ff1 <= b2;\n        a3_ff1 <= a3;\n        b3_ff1 <= b3;\n        a3_ff2 <= a3_ff1;\n        b3_ff2 <= b3_ff1;\n        a4_ff1 <= a4;\n        b4_ff1 <= b4;\n        a4_ff2 <= a4_ff1;\n        b4_ff2<= b4_ff1;\n        a4_ff3 <= a4_ff2;\n        b4_ff3 <= b4_ff2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        s1_ff1 <= 'd0;\n        s1_ff2 <= 'd0;\n        s1_ff3 <= 'd0;\n        s2_ff1 <= 'd0;\n        s2_ff2 <= 'd0;\n        s3_ff1 <= 'd0;\n    end\n    else begin\n        s1_ff1 <= s1;\n        s1_ff2 <= s1_ff1;\n        s1_ff3 <= s1_ff2;\n        s2_ff1 <= s2;\n        s2_ff2 <= s2_ff1;\n        s3_ff1 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c1 <= 1'b0;\n        s1 <= 'd0;\n    end\n    else if (i_en) begin\n        {c1, s1} <= a1 + b1;\n    end\n    else begin\n        c1 <= c1;\n        s1 <= s1;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c2 <= 1'b0;\n        s2 <= 'd0;\n    end\n    else if (stage1) begin\n        {c2, s2} <= a2_ff1 + b2_ff1 + c1;\n    end\n    else begin\n        c2 <= c2;\n        s2 <= s2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c3 <= 1'b0;\n        s3 <= 'd0;\n    end\n    else if (stage2) begin\n        {c3, s3} <= a3_ff2 + b3_ff2 + c2;\n    end\n    else begin\n        c3 <= c3;\n        s3 <= s3;\n    end\nend\n\nalways @(clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c4 <= 1'b0;\n        s4 <= 'd0;\n    end\n    else if (stage3) begin\n        {c4, s4} <= a4_ff3 + b4_ff3 + c3;\n    end\n    else begin\n        c4 <= c4;\n        s4 <= s4;\n    end\nend\n\nassign result = {c4, s4, s3_ff1, s2_ff2, s1_ff3};\n\nendmodule", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 179, "original_snippet": "always @(posedge clk, negedge rst_n)", "modified_snippet": "always @(clk, negedge rst_n)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 179: Original: always @(posedge clk, negedge rst_n)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 179.\n   \u2022 Restore the original code: always @(posedge clk, negedge rst_n)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 100, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_sensitivity_list"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.675882", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_pipe_64bit", "module_name": "adder_64bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of a 64-bit ripple carry adder, which includes several registers to enable the pipeline stages. The output result is available on the result port, and the o_en = 1 indicates the availability of the result.\n\nModule name:  \n    adder_pipe_64bit               \nInput ports:\n    clk: Clock input\n    rst_n: Active low reset signal\n    i_en: Enable signal for addition operation\n    adda: 64-bit input operand A\n    addb: 64-bit input operand B\n   \nOutput ports:\n    result: 65-bit output representing the sum of adda and addb.\n    o_en: Output enable signal.   \n\nImplementation:\nThe module includes several registers to enable the pipeline stages and synchronize the input enable signal (i_en). These registers are controlled by the clock (clk) and reset (rst_n) signals.\nThe sum values for each pipeline stage are calculated by adding the corresponding input operands and carry signals.\nThe output enable signal (o_en) is updated based on the pipeline stages and synchronized with the clock (clk) and reset (rst_n) signals.\n\nGive me the complete code.\n"}, "clean_code": "module adder_64bit\n#(\n    parameter DATA_WIDTH = 64,\n    parameter STG_WIDTH = 16\n)\n(\n    input clk,\n    input rst_n,\n    input i_en,\n    input [DATA_WIDTH-1:0] adda,\n    input [DATA_WIDTH-1:0] addb,\n    output [DATA_WIDTH:0] result,\n    output reg o_en\n);\n\nreg stage1;\nreg stage2;\nreg stage3;\n\nwire [STG_WIDTH-1:0] a1;\nwire [STG_WIDTH-1:0] b1;\nwire [STG_WIDTH-1:0] a2;\nwire [STG_WIDTH-1:0] b2;\nwire [STG_WIDTH-1:0] a3;\nwire [STG_WIDTH-1:0] b3;\nwire [STG_WIDTH-1:0] a4;\nwire [STG_WIDTH-1:0] b4;\n\nreg [STG_WIDTH-1:0] a2_ff1;\nreg [STG_WIDTH-1:0] b2_ff1;\n\nreg [STG_WIDTH-1:0] a3_ff1;\nreg [STG_WIDTH-1:0] b3_ff1;\nreg [STG_WIDTH-1:0] a3_ff2;\nreg [STG_WIDTH-1:0] b3_ff2;\n\nreg [STG_WIDTH-1:0] a4_ff1;\nreg [STG_WIDTH-1:0] b4_ff1;\nreg [STG_WIDTH-1:0] a4_ff2;\nreg [STG_WIDTH-1:0] b4_ff2;\nreg [STG_WIDTH-1:0] a4_ff3;\nreg [STG_WIDTH-1:0] b4_ff3;\n\nreg c1;\nreg c2;\nreg c3;\nreg c4;\n\nreg [STG_WIDTH-1:0] s1;\nreg [STG_WIDTH-1:0] s2;\nreg [STG_WIDTH-1:0] s3;\nreg [STG_WIDTH-1:0] s4;\n\nreg [STG_WIDTH-1:0] s1_ff1;\nreg [STG_WIDTH-1:0] s1_ff2;\nreg [STG_WIDTH-1:0] s1_ff3;\n\nreg [STG_WIDTH-1:0] s2_ff1;\nreg [STG_WIDTH-1:0] s2_ff2;\n\nreg [STG_WIDTH-1:0] s3_ff1;\n\nassign a1 = adda[STG_WIDTH-1:0];\nassign b1 = addb[STG_WIDTH-1:0];\nassign a2 = adda[STG_WIDTH*2-1:16];\nassign b2 = addb[STG_WIDTH*2-1:16];\nassign a3 = adda[STG_WIDTH*3-1:32];\nassign b3 = addb[STG_WIDTH*3-1:32];\nassign a4 = adda[STG_WIDTH*4-1:48];\nassign b4 = addb[STG_WIDTH*4-1:48];\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        stage1 <= 1'b0;\n        stage2 <= 1'b0;\n        stage3 <= 1'b0;\n        o_en <= 1'b0;\n    end\n    else begin\n        stage1 <= i_en;\n        stage2 <= stage1;\n        stage3 <= stage2;\n        o_en <= stage3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        a2_ff1 <= 'd0;\n        b2_ff1 <= 'd0;\n        a3_ff1 <= 'd0;\n        b3_ff1 <= 'd0;\n        a3_ff2 <= 'd0;\n        b3_ff2 <= 'd0;\n        a4_ff1 <= 'd0;\n        b4_ff1 <= 'd0;\n        a4_ff2 <= 'd0;\n        b4_ff2 <= 'd0;\n        a4_ff3 <= 'd0;\n        b4_ff3 <= 'd0;\n    end\n    else begin\n        a2_ff1 <= a2;\n        b2_ff1 <= b2;\n        a3_ff1 <= a3;\n        b3_ff1 <= b3;\n        a3_ff2 <= a3_ff1;\n        b3_ff2 <= b3_ff1;\n        a4_ff1 <= a4;\n        b4_ff1 <= b4;\n        a4_ff2 <= a4_ff1;\n        b4_ff2<= b4_ff1;\n        a4_ff3 <= a4_ff2;\n        b4_ff3 <= b4_ff2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        s1_ff1 <= 'd0;\n        s1_ff2 <= 'd0;\n        s1_ff3 <= 'd0;\n        s2_ff1 <= 'd0;\n        s2_ff2 <= 'd0;\n        s3_ff1 <= 'd0;\n    end\n    else begin\n        s1_ff1 <= s1;\n        s1_ff2 <= s1_ff1;\n        s1_ff3 <= s1_ff2;\n        s2_ff1 <= s2;\n        s2_ff2 <= s2_ff1;\n        s3_ff1 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c1 <= 1'b0;\n        s1 <= 'd0;\n    end\n    else if (i_en) begin\n        {c1, s1} <= a1 + b1;\n    end\n    else begin\n        c1 <= c1;\n        s1 <= s1;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c2 <= 1'b0;\n        s2 <= 'd0;\n    end\n    else if (stage1) begin\n        {c2, s2} <= a2_ff1 + b2_ff1 + c1;\n    end\n    else begin\n        c2 <= c2;\n        s2 <= s2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c3 <= 1'b0;\n        s3 <= 'd0;\n    end\n    else if (stage2) begin\n        {c3, s3} <= a3_ff2 + b3_ff2 + c2;\n    end\n    else begin\n        c3 <= c3;\n        s3 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c4 <= 1'b0;\n        s4 <= 'd0;\n    end\n    else if (stage3) begin\n        {c4, s4} <= a4_ff3 + b4_ff3 + c3;\n    end\n    else begin\n        c4 <= c4;\n        s4 <= s4;\n    end\nend\n\nassign result = {c4, s4, s3_ff1, s2_ff2, s1_ff3};\n\nendmodule", "corrupted_code": "module adder_64bit\n#(\n    parameter DATA_WIDTH = 64,\n    parameter STG_WIDTH = 16\n)\n(\n    input clk,\n    input rst_n,\n    input i_en,\n    input [DATA_WIDTH-1:0] adda,\n    input [DATA_WIDTH-1:0] addb,\n    output [DATA_WIDTH:0] result,\n    output reg o_en\n);\n\nreg stage1;\nreg stage2;\nreg stage3;\n\nwire [STG_WIDTH-1:0] a1;\nwire [STG_WIDTH-1:0] b1;\nwire [STG_WIDTH-1:0] a2;\nwire [STG_WIDTH-1:0] b2;\nwire [STG_WIDTH-1:0] a3;\nwire [STG_WIDTH-1:0] b3;\nwire [STG_WIDTH-1:0] a4;\nwire [STG_WIDTH-1:0] b4;\n\nreg [STG_WIDTH-1:0] a2_ff1;\nreg [STG_WIDTH-1:0] b2_ff1;\n\nreg [STG_WIDTH-1:0] a3_ff1;\nreg [STG_WIDTH-1:0] b3_ff1;\nreg [STG_WIDTH-1:0] a3_ff2;\nreg [STG_WIDTH-1:0] b3_ff2;\n\nreg [STG_WIDTH-1:0] a4_ff1;\nreg [STG_WIDTH-1:0] b4_ff1;\nreg [STG_WIDTH-1:0] a4_ff2;\nreg [STG_WIDTH-1:0] b4_ff2;\nreg [STG_WIDTH-1:0] a4_ff3;\nreg [STG_WIDTH-1:0] b4_ff3;\n\nreg c1;\nreg c2;\nreg c3;\nreg c4;\n\nreg [STG_WIDTH-1:0] s1;\nreg [STG_WIDTH-1:0] s2;\nreg [STG_WIDTH-1:0] s3;\nreg [STG_WIDTH-1:0] s4;\n\nreg [STG_WIDTH-1:0] s1_ff1;\nreg [STG_WIDTH-1:0] s1_ff2;\nreg [STG_WIDTH-1:0] s1_ff3;\n\nreg [STG_WIDTH-1:0] s2_ff1;\nreg [STG_WIDTH-1:0] s2_ff2;\n\nreg [STG_WIDTH-1:0] s3_ff1;\n\nassign a1 = adda[STG_WIDTH-1:0];\nassign b1 = addb[STG_WIDTH-1:0];\nassign a2 = adda[STG_WIDTH*2-1:16];\nassign b2 = addb[STG_WIDTH*2-1:16];\nassign a3 = adda[STG_WIDTH*3-1:32];\nassign b3 = addb[STG_WIDTH*3-1:32];\nassign a4 = adda[STG_WIDTH*4-1:48];\nassign b4 = addb[STG_WIDTH*4-1:48];\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        stage1 <= 1'b0;\n        stage2 <= 1'b0;\n        stage3 <= 1'b0;\n        o_en <= 1'b0;\n    end\n    else begin\n        stage1 <= i_en;\n        stage2 <= stage1;\n        stage3 <= stage2;\n        o_en <= stage3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        a2_ff1 <= 'd0;\n        b2_ff1 <= 'd0;\n        a3_ff1 <= 'd0;\n        b3_ff1 <= 'd0;\n        a3_ff2 = 'd0;\n        b3_ff2 <= 'd0;\n        a4_ff1 <= 'd0;\n        b4_ff1 <= 'd0;\n        a4_ff2 <= 'd0;\n        b4_ff2 <= 'd0;\n        a4_ff3 <= 'd0;\n        b4_ff3 <= 'd0;\n    end\n    else begin\n        a2_ff1 <= a2;\n        b2_ff1 <= b2;\n        a3_ff1 <= a3;\n        b3_ff1 <= b3;\n        a3_ff2 <= a3_ff1;\n        b3_ff2 <= b3_ff1;\n        a4_ff1 <= a4;\n        b4_ff1 <= b4;\n        a4_ff2 <= a4_ff1;\n        b4_ff2<= b4_ff1;\n        a4_ff3 <= a4_ff2;\n        b4_ff3 <= b4_ff2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        s1_ff1 <= 'd0;\n        s1_ff2 <= 'd0;\n        s1_ff3 <= 'd0;\n        s2_ff1 <= 'd0;\n        s2_ff2 <= 'd0;\n        s3_ff1 <= 'd0;\n    end\n    else begin\n        s1_ff1 <= s1;\n        s1_ff2 <= s1_ff1;\n        s1_ff3 <= s1_ff2;\n        s2_ff1 <= s2;\n        s2_ff2 <= s2_ff1;\n        s3_ff1 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c1 <= 1'b0;\n        s1 <= 'd0;\n    end\n    else if (i_en) begin\n        {c1, s1} <= a1 + b1;\n    end\n    else begin\n        c1 <= c1;\n        s1 <= s1;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c2 <= 1'b0;\n        s2 <= 'd0;\n    end\n    else if (stage1) begin\n        {c2, s2} <= a2_ff1 + b2_ff1 + c1;\n    end\n    else begin\n        c2 <= c2;\n        s2 <= s2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c3 <= 1'b0;\n        s3 <= 'd0;\n    end\n    else if (stage2) begin\n        {c3, s3} <= a3_ff2 + b3_ff2 + c2;\n    end\n    else begin\n        c3 <= c3;\n        s3 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c4 <= 1'b0;\n        s4 <= 'd0;\n    end\n    else if (stage3) begin\n        {c4, s4} <= a4_ff3 + b4_ff3 + c3;\n    end\n    else begin\n        c4 <= c4;\n        s4 <= s4;\n    end\nend\n\nassign result = {c4, s4, s3_ff1, s2_ff2, s1_ff3};\n\nendmodule", "corruption_explanation": "Changed non-blocking (<=) to blocking (=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 93, "original_snippet": "a3_ff2 <= 'd0;", "modified_snippet": "a3_ff2 = 'd0;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 100, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.681474", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Adder", "design_name": "adder_pipe_64bit", "module_name": "adder_64bit", "description": "Please act as a professional verilog designer.\n\nImplement a module of a 64-bit ripple carry adder, which includes several registers to enable the pipeline stages. The output result is available on the result port, and the o_en = 1 indicates the availability of the result.\n\nModule name:  \n    adder_pipe_64bit               \nInput ports:\n    clk: Clock input\n    rst_n: Active low reset signal\n    i_en: Enable signal for addition operation\n    adda: 64-bit input operand A\n    addb: 64-bit input operand B\n   \nOutput ports:\n    result: 65-bit output representing the sum of adda and addb.\n    o_en: Output enable signal.   \n\nImplementation:\nThe module includes several registers to enable the pipeline stages and synchronize the input enable signal (i_en). These registers are controlled by the clock (clk) and reset (rst_n) signals.\nThe sum values for each pipeline stage are calculated by adding the corresponding input operands and carry signals.\nThe output enable signal (o_en) is updated based on the pipeline stages and synchronized with the clock (clk) and reset (rst_n) signals.\n\nGive me the complete code.\n"}, "clean_code": "module adder_64bit\n#(\n    parameter DATA_WIDTH = 64,\n    parameter STG_WIDTH = 16\n)\n(\n    input clk,\n    input rst_n,\n    input i_en,\n    input [DATA_WIDTH-1:0] adda,\n    input [DATA_WIDTH-1:0] addb,\n    output [DATA_WIDTH:0] result,\n    output reg o_en\n);\n\nreg stage1;\nreg stage2;\nreg stage3;\n\nwire [STG_WIDTH-1:0] a1;\nwire [STG_WIDTH-1:0] b1;\nwire [STG_WIDTH-1:0] a2;\nwire [STG_WIDTH-1:0] b2;\nwire [STG_WIDTH-1:0] a3;\nwire [STG_WIDTH-1:0] b3;\nwire [STG_WIDTH-1:0] a4;\nwire [STG_WIDTH-1:0] b4;\n\nreg [STG_WIDTH-1:0] a2_ff1;\nreg [STG_WIDTH-1:0] b2_ff1;\n\nreg [STG_WIDTH-1:0] a3_ff1;\nreg [STG_WIDTH-1:0] b3_ff1;\nreg [STG_WIDTH-1:0] a3_ff2;\nreg [STG_WIDTH-1:0] b3_ff2;\n\nreg [STG_WIDTH-1:0] a4_ff1;\nreg [STG_WIDTH-1:0] b4_ff1;\nreg [STG_WIDTH-1:0] a4_ff2;\nreg [STG_WIDTH-1:0] b4_ff2;\nreg [STG_WIDTH-1:0] a4_ff3;\nreg [STG_WIDTH-1:0] b4_ff3;\n\nreg c1;\nreg c2;\nreg c3;\nreg c4;\n\nreg [STG_WIDTH-1:0] s1;\nreg [STG_WIDTH-1:0] s2;\nreg [STG_WIDTH-1:0] s3;\nreg [STG_WIDTH-1:0] s4;\n\nreg [STG_WIDTH-1:0] s1_ff1;\nreg [STG_WIDTH-1:0] s1_ff2;\nreg [STG_WIDTH-1:0] s1_ff3;\n\nreg [STG_WIDTH-1:0] s2_ff1;\nreg [STG_WIDTH-1:0] s2_ff2;\n\nreg [STG_WIDTH-1:0] s3_ff1;\n\nassign a1 = adda[STG_WIDTH-1:0];\nassign b1 = addb[STG_WIDTH-1:0];\nassign a2 = adda[STG_WIDTH*2-1:16];\nassign b2 = addb[STG_WIDTH*2-1:16];\nassign a3 = adda[STG_WIDTH*3-1:32];\nassign b3 = addb[STG_WIDTH*3-1:32];\nassign a4 = adda[STG_WIDTH*4-1:48];\nassign b4 = addb[STG_WIDTH*4-1:48];\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        stage1 <= 1'b0;\n        stage2 <= 1'b0;\n        stage3 <= 1'b0;\n        o_en <= 1'b0;\n    end\n    else begin\n        stage1 <= i_en;\n        stage2 <= stage1;\n        stage3 <= stage2;\n        o_en <= stage3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        a2_ff1 <= 'd0;\n        b2_ff1 <= 'd0;\n        a3_ff1 <= 'd0;\n        b3_ff1 <= 'd0;\n        a3_ff2 <= 'd0;\n        b3_ff2 <= 'd0;\n        a4_ff1 <= 'd0;\n        b4_ff1 <= 'd0;\n        a4_ff2 <= 'd0;\n        b4_ff2 <= 'd0;\n        a4_ff3 <= 'd0;\n        b4_ff3 <= 'd0;\n    end\n    else begin\n        a2_ff1 <= a2;\n        b2_ff1 <= b2;\n        a3_ff1 <= a3;\n        b3_ff1 <= b3;\n        a3_ff2 <= a3_ff1;\n        b3_ff2 <= b3_ff1;\n        a4_ff1 <= a4;\n        b4_ff1 <= b4;\n        a4_ff2 <= a4_ff1;\n        b4_ff2<= b4_ff1;\n        a4_ff3 <= a4_ff2;\n        b4_ff3 <= b4_ff2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        s1_ff1 <= 'd0;\n        s1_ff2 <= 'd0;\n        s1_ff3 <= 'd0;\n        s2_ff1 <= 'd0;\n        s2_ff2 <= 'd0;\n        s3_ff1 <= 'd0;\n    end\n    else begin\n        s1_ff1 <= s1;\n        s1_ff2 <= s1_ff1;\n        s1_ff3 <= s1_ff2;\n        s2_ff1 <= s2;\n        s2_ff2 <= s2_ff1;\n        s3_ff1 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c1 <= 1'b0;\n        s1 <= 'd0;\n    end\n    else if (i_en) begin\n        {c1, s1} <= a1 + b1;\n    end\n    else begin\n        c1 <= c1;\n        s1 <= s1;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c2 <= 1'b0;\n        s2 <= 'd0;\n    end\n    else if (stage1) begin\n        {c2, s2} <= a2_ff1 + b2_ff1 + c1;\n    end\n    else begin\n        c2 <= c2;\n        s2 <= s2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c3 <= 1'b0;\n        s3 <= 'd0;\n    end\n    else if (stage2) begin\n        {c3, s3} <= a3_ff2 + b3_ff2 + c2;\n    end\n    else begin\n        c3 <= c3;\n        s3 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c4 <= 1'b0;\n        s4 <= 'd0;\n    end\n    else if (stage3) begin\n        {c4, s4} <= a4_ff3 + b4_ff3 + c3;\n    end\n    else begin\n        c4 <= c4;\n        s4 <= s4;\n    end\nend\n\nassign result = {c4, s4, s3_ff1, s2_ff2, s1_ff3};\n\nendmodule", "corrupted_code": "module adder_64bit\n#(\n    parameter DATA_WIDTH = 64,\n    parameter STG_WIDTH = 16\n)\n(\n    input clk,\n    input rst_n,\n    input i_en,\n    input [DATA_WIDTH-1:0] adda,\n    input [DATA_WIDTH-1:0] addb,\n    output [DATA_WIDTH:0] result,\n    output reg o_en\n);\n\nreg stage1;\nreg stage2;\nreg stage3;\n\nwire [STG_WIDTH-1:0] a1;\nwire [STG_WIDTH-1:0] b1;\nwire [STG_WIDTH-1:0] a2;\nwire [STG_WIDTH-1:0] b2;\nwire [STG_WIDTH-1:0] a3;\nwire [STG_WIDTH-1:0] b3;\nwire [STG_WIDTH-1:0] a4;\nwire [STG_WIDTH-1:0] b4;\n\nreg [STG_WIDTH-1:0] a2_ff1;\nreg [STG_WIDTH-1:0] b2_ff1;\n\nreg [STG_WIDTH-1:0] a3_ff1;\nreg [STG_WIDTH-1:0] b3_ff1;\nreg [STG_WIDTH-1:0] a3_ff2;\nreg [STG_WIDTH-1:0] b3_ff2;\n\nreg [STG_WIDTH-1:0] a4_ff1;\nreg [STG_WIDTH-1:0] b4_ff1;\nreg [STG_WIDTH-1:0] a4_ff2;\nreg [STG_WIDTH-1:0] b4_ff2;\nreg [1 - STG_WIDTH:0] a4_ff3;\nreg [STG_WIDTH-1:0] b4_ff3;\n\nreg c1;\nreg c2;\nreg c3;\nreg c4;\n\nreg [STG_WIDTH-1:0] s1;\nreg [STG_WIDTH-1:0] s2;\nreg [STG_WIDTH-1:0] s3;\nreg [STG_WIDTH-1:0] s4;\n\nreg [STG_WIDTH-1:0] s1_ff1;\nreg [STG_WIDTH-1:0] s1_ff2;\nreg [STG_WIDTH-1:0] s1_ff3;\n\nreg [STG_WIDTH-1:0] s2_ff1;\nreg [STG_WIDTH-1:0] s2_ff2;\n\nreg [STG_WIDTH-1:0] s3_ff1;\n\nassign a1 = adda[STG_WIDTH-1:0];\nassign b1 = addb[STG_WIDTH-1:0];\nassign a2 = adda[STG_WIDTH*2-1:16];\nassign b2 = addb[STG_WIDTH*2-1:16];\nassign a3 = adda[STG_WIDTH*3-1:32];\nassign b3 = addb[STG_WIDTH*3-1:32];\nassign a4 = adda[STG_WIDTH*4-1:48];\nassign b4 = addb[STG_WIDTH*4-1:48];\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        stage1 <= 1'b0;\n        stage2 <= 1'b0;\n        stage3 <= 1'b0;\n        o_en <= 1'b0;\n    end\n    else begin\n        stage1 <= i_en;\n        stage2 <= stage1;\n        stage3 <= stage2;\n        o_en <= stage3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        a2_ff1 <= 'd0;\n        b2_ff1 <= 'd0;\n        a3_ff1 <= 'd0;\n        b3_ff1 <= 'd0;\n        a3_ff2 <= 'd0;\n        b3_ff2 <= 'd0;\n        a4_ff1 <= 'd0;\n        b4_ff1 <= 'd0;\n        a4_ff2 <= 'd0;\n        b4_ff2 <= 'd0;\n        a4_ff3 <= 'd0;\n        b4_ff3 <= 'd0;\n    end\n    else begin\n        a2_ff1 <= a2;\n        b2_ff1 <= b2;\n        a3_ff1 <= a3;\n        b3_ff1 <= b3;\n        a3_ff2 <= a3_ff1;\n        b3_ff2 <= b3_ff1;\n        a4_ff1 <= a4;\n        b4_ff1 <= b4;\n        a4_ff2 <= a4_ff1;\n        b4_ff2<= b4_ff1;\n        a4_ff3 <= a4_ff2;\n        b4_ff3 <= b4_ff2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        s1_ff1 <= 'd0;\n        s1_ff2 <= 'd0;\n        s1_ff3 <= 'd0;\n        s2_ff1 <= 'd0;\n        s2_ff2 <= 'd0;\n        s3_ff1 <= 'd0;\n    end\n    else begin\n        s1_ff1 <= s1;\n        s1_ff2 <= s1_ff1;\n        s1_ff3 <= s1_ff2;\n        s2_ff1 <= s2;\n        s2_ff2 <= s2_ff1;\n        s3_ff1 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c1 <= 1'b0;\n        s1 <= 'd0;\n    end\n    else if (i_en) begin\n        {c1, s1} <= a1 + b1;\n    end\n    else begin\n        c1 <= c1;\n        s1 <= s1;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c2 <= 1'b0;\n        s2 <= 'd0;\n    end\n    else if (stage1) begin\n        {c2, s2} <= a2_ff1 + b2_ff1 + c1;\n    end\n    else begin\n        c2 <= c2;\n        s2 <= s2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c3 <= 1'b0;\n        s3 <= 'd0;\n    end\n    else if (stage2) begin\n        {c3, s3} <= a3_ff2 + b3_ff2 + c2;\n    end\n    else begin\n        c3 <= c3;\n        s3 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c4 <= 1'b0;\n        s4 <= 'd0;\n    end\n    else if (stage3) begin\n        {c4, s4} <= a4_ff3 + b4_ff3 + c3;\n    end\n    else begin\n        c4 <= c4;\n        s4 <= s4;\n    end\nend\n\nassign result = {c4, s4, s3_ff1, s2_ff2, s1_ff3};\n\nendmodule", "corruption_explanation": "Swapped operands: 'STG_WIDTH - 1' -> '1 - STG_WIDTH'", "modification_type": "swap_operands", "modification_line": 41, "original_snippet": "STG_WIDTH-1", "modified_snippet": "1 - STG_WIDTH", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'STG_WIDTH - 1' -> '1 - STG_WIDTH'\n   \u2022 Line 41: Original: STG_WIDTH-1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 41.\n   \u2022 Restore the original code: STG_WIDTH-1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 100, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_operands"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.686548", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Substractor", "design_name": "sub_64bit", "module_name": "sub_64bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 64-bit subtractor with overflow checking for high-precision arithmetic operations. \n\nModule name:  \n    sub_64bit               \nInput ports:\n    A [63:0]: First 64-bit input operand (representing a large signed integer).\n    B [63:0]: Second 64-bit input operand (representing a large signed integer to be subtracted from A).\nOutput ports:\n    result [63:0]: 64-bit output representing the difference of the two operands (A - B).\n    overflow: 1-bit output indicating whether an overflow occurred during the subtraction operation.\n\nImplementation:\nSubtraction: The module performs binary subtraction of A and B to obtain the result.\nOverflow Detection: The module checks for overflow conditions by examining the sign bits of A, B, and the result. \n- Positive overflow occurs when a positive number (A) is subtracted by a negative number (B) and the result is negative.\n- Negative overflow occurs when a negative number (A) is subtracted by a positive number (B) and the result is positive.\n\nThe overflow flag is set to 1 if an overflow condition is detected; otherwise, it is set to 0.\n\nGive me the complete code."}, "clean_code": "module sub_64bit(\n  input [63:0] A,\n  input [63:0] B,\n  output reg [63:0] result,\n  output reg overflow\n);\n  always @(*) begin\n    result = A - B;\n\n    // Overflow happens when the sign of A and B are different, but the sign of result matches B\n    if ((A[63] != B[63]) && (result[63] != A[63])) begin\n      overflow = 1;\n    end else begin\n      overflow = 0;\n    end\n  end\n\nendmodule", "corrupted_code": "module sub_64bit(\n  input [63:0] A,\n  input [63:0] B,\n  output reg [63:0] result,\n  output reg overflow\n);\n  always @(*) begin\n    result = A - B;\n\n    // Overflow happens when the sign of A and B are different, but the sign of result matches B\n    if ((A[63] != B[63]) && (result[63] != A[63])) begin\n\n    end else begin\n      overflow = 0;\n    end\n  end\n\nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 12, "original_snippet": "overflow = 1;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 12: Original: overflow = 1;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 12.\n   \u2022 Restore the original code: overflow = 1;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["remove_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.688748", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Substractor", "design_name": "sub_64bit", "module_name": "sub_64bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 64-bit subtractor with overflow checking for high-precision arithmetic operations. \n\nModule name:  \n    sub_64bit               \nInput ports:\n    A [63:0]: First 64-bit input operand (representing a large signed integer).\n    B [63:0]: Second 64-bit input operand (representing a large signed integer to be subtracted from A).\nOutput ports:\n    result [63:0]: 64-bit output representing the difference of the two operands (A - B).\n    overflow: 1-bit output indicating whether an overflow occurred during the subtraction operation.\n\nImplementation:\nSubtraction: The module performs binary subtraction of A and B to obtain the result.\nOverflow Detection: The module checks for overflow conditions by examining the sign bits of A, B, and the result. \n- Positive overflow occurs when a positive number (A) is subtracted by a negative number (B) and the result is negative.\n- Negative overflow occurs when a negative number (A) is subtracted by a positive number (B) and the result is positive.\n\nThe overflow flag is set to 1 if an overflow condition is detected; otherwise, it is set to 0.\n\nGive me the complete code."}, "clean_code": "module sub_64bit(\n  input [63:0] A,\n  input [63:0] B,\n  output reg [63:0] result,\n  output reg overflow\n);\n  always @(*) begin\n    result = A - B;\n\n    // Overflow happens when the sign of A and B are different, but the sign of result matches B\n    if ((A[63] != B[63]) && (result[63] != A[63])) begin\n      overflow = 1;\n    end else begin\n      overflow = 0;\n    end\n  end\n\nendmodule", "corrupted_code": "module sub_64bit(\n  input [63:0] A,\n  input [63:0] B,\n  output reg [63:0] result,\n  output reg overflow\n);\n  always @(*) begin\n    result = B - A;\n\n    // Overflow happens when the sign of A and B are different, but the sign of result matches B\n    if ((A[63] != B[63]) && (result[63] != A[63])) begin\n      overflow = 1;\n    end else begin\n      overflow = 0;\n    end\n  end\n\nendmodule", "corruption_explanation": "Swapped operands: 'A - B' -> 'B - A'", "modification_type": "swap_operands", "modification_line": 8, "original_snippet": "A - B", "modified_snippet": "B - A", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'A - B' -> 'B - A'\n   \u2022 Line 8: Original: A - B\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 8.\n   \u2022 Restore the original code: A - B\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["swap_operands"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.689398", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Substractor", "design_name": "sub_64bit", "module_name": "sub_64bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 64-bit subtractor with overflow checking for high-precision arithmetic operations. \n\nModule name:  \n    sub_64bit               \nInput ports:\n    A [63:0]: First 64-bit input operand (representing a large signed integer).\n    B [63:0]: Second 64-bit input operand (representing a large signed integer to be subtracted from A).\nOutput ports:\n    result [63:0]: 64-bit output representing the difference of the two operands (A - B).\n    overflow: 1-bit output indicating whether an overflow occurred during the subtraction operation.\n\nImplementation:\nSubtraction: The module performs binary subtraction of A and B to obtain the result.\nOverflow Detection: The module checks for overflow conditions by examining the sign bits of A, B, and the result. \n- Positive overflow occurs when a positive number (A) is subtracted by a negative number (B) and the result is negative.\n- Negative overflow occurs when a negative number (A) is subtracted by a positive number (B) and the result is positive.\n\nThe overflow flag is set to 1 if an overflow condition is detected; otherwise, it is set to 0.\n\nGive me the complete code."}, "clean_code": "module sub_64bit(\n  input [63:0] A,\n  input [63:0] B,\n  output reg [63:0] result,\n  output reg overflow\n);\n  always @(*) begin\n    result = A - B;\n\n    // Overflow happens when the sign of A and B are different, but the sign of result matches B\n    if ((A[63] != B[63]) && (result[63] != A[63])) begin\n      overflow = 1;\n    end else begin\n      overflow = 0;\n    end\n  end\n\nendmodule", "corrupted_code": "module sub_64bit(\n  input [63:0] A,\n  input [63:0] B,\n  output reg [63:0] result,\n  output reg overflow\n);\n  always @(a) begin\n    result = A - B;\n\n    // Overflow happens when the sign of A and B are different, but the sign of result matches B\n    if ((A[63] != B[63]) && (result[63] != A[63])) begin\n      overflow = 1;\n    end else begin\n      overflow = 0;\n    end\n  end\n\nendmodule", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 7, "original_snippet": "always @(*)", "modified_snippet": "always @(a)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 7: Original: always @(*)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 7.\n   \u2022 Restore the original code: always @(*)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["change_sensitivity_list"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.690009", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Substractor", "design_name": "sub_64bit", "module_name": "sub_64bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 64-bit subtractor with overflow checking for high-precision arithmetic operations. \n\nModule name:  \n    sub_64bit               \nInput ports:\n    A [63:0]: First 64-bit input operand (representing a large signed integer).\n    B [63:0]: Second 64-bit input operand (representing a large signed integer to be subtracted from A).\nOutput ports:\n    result [63:0]: 64-bit output representing the difference of the two operands (A - B).\n    overflow: 1-bit output indicating whether an overflow occurred during the subtraction operation.\n\nImplementation:\nSubtraction: The module performs binary subtraction of A and B to obtain the result.\nOverflow Detection: The module checks for overflow conditions by examining the sign bits of A, B, and the result. \n- Positive overflow occurs when a positive number (A) is subtracted by a negative number (B) and the result is negative.\n- Negative overflow occurs when a negative number (A) is subtracted by a positive number (B) and the result is positive.\n\nThe overflow flag is set to 1 if an overflow condition is detected; otherwise, it is set to 0.\n\nGive me the complete code."}, "clean_code": "module sub_64bit(\n  input [63:0] A,\n  input [63:0] B,\n  output reg [63:0] result,\n  output reg overflow\n);\n  always @(*) begin\n    result = A - B;\n\n    // Overflow happens when the sign of A and B are different, but the sign of result matches B\n    if ((A[63] != B[63]) && (result[63] != A[63])) begin\n      overflow = 1;\n    end else begin\n      overflow = 0;\n    end\n  end\n\nendmodule", "corrupted_code": "module sub_64bit(\n  input [63:0] A,\n  input [63:0] B,\n  output reg [63:0] result,\n  output reg overflow\n);\n  always @(*) begin\n    result = A - B;\n\n    // Overflow happens when the sign of A and B are different, but the sign of result matches B\n    if ((A[63] == B[63]) && (result[63] != A[63])) begin\n      overflow = 1;\n    end else begin\n      overflow = 0;\n    end\n  end\n\nendmodule", "corruption_explanation": "Changed operator from '!=' to '=='", "modification_type": "change_operator", "modification_line": 11, "original_snippet": "!=", "modified_snippet": "==", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '!=' to '=='\n   \u2022 Line 11: Original: !=\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 11.\n   \u2022 Restore the original code: !=\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.690664", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Substractor", "design_name": "sub_64bit", "module_name": "sub_64bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 64-bit subtractor with overflow checking for high-precision arithmetic operations. \n\nModule name:  \n    sub_64bit               \nInput ports:\n    A [63:0]: First 64-bit input operand (representing a large signed integer).\n    B [63:0]: Second 64-bit input operand (representing a large signed integer to be subtracted from A).\nOutput ports:\n    result [63:0]: 64-bit output representing the difference of the two operands (A - B).\n    overflow: 1-bit output indicating whether an overflow occurred during the subtraction operation.\n\nImplementation:\nSubtraction: The module performs binary subtraction of A and B to obtain the result.\nOverflow Detection: The module checks for overflow conditions by examining the sign bits of A, B, and the result. \n- Positive overflow occurs when a positive number (A) is subtracted by a negative number (B) and the result is negative.\n- Negative overflow occurs when a negative number (A) is subtracted by a positive number (B) and the result is positive.\n\nThe overflow flag is set to 1 if an overflow condition is detected; otherwise, it is set to 0.\n\nGive me the complete code."}, "clean_code": "module sub_64bit(\n  input [63:0] A,\n  input [63:0] B,\n  output reg [63:0] result,\n  output reg overflow\n);\n  always @(*) begin\n    result = A - B;\n\n    // Overflow happens when the sign of A and B are different, but the sign of result matches B\n    if ((A[63] != B[63]) && (result[63] != A[63])) begin\n      overflow = 1;\n    end else begin\n      overflow = 0;\n    end\n  end\n\nendmodule", "corrupted_code": "module sub_64bit(\n  input [63:0] A,\n  input [63:0] B,\n  output reg [63:0] result,\n  output reg overflow\n);\n  always @(*) begin\n    result = A - B;\n\n    // Overflow happens when the sign of A and B are different, but the sign of result matches B\n    if ((A[63] != B[63]) && (result[63] != A[63])) begin\n      overflow = 0;\n    end else begin\n      overflow = 0;\n    end\n  end\n\nendmodule", "corruption_explanation": "Changed constant from 1 to 0", "modification_type": "change_constant", "modification_line": 12, "original_snippet": "1", "modified_snippet": "0", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 1 to 0\n   \u2022 Line 12: Original: 1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 12.\n   \u2022 Restore the original code: 1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["change_constant"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.691268", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Substractor", "design_name": "sub_64bit", "module_name": "sub_64bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 64-bit subtractor with overflow checking for high-precision arithmetic operations. \n\nModule name:  \n    sub_64bit               \nInput ports:\n    A [63:0]: First 64-bit input operand (representing a large signed integer).\n    B [63:0]: Second 64-bit input operand (representing a large signed integer to be subtracted from A).\nOutput ports:\n    result [63:0]: 64-bit output representing the difference of the two operands (A - B).\n    overflow: 1-bit output indicating whether an overflow occurred during the subtraction operation.\n\nImplementation:\nSubtraction: The module performs binary subtraction of A and B to obtain the result.\nOverflow Detection: The module checks for overflow conditions by examining the sign bits of A, B, and the result. \n- Positive overflow occurs when a positive number (A) is subtracted by a negative number (B) and the result is negative.\n- Negative overflow occurs when a negative number (A) is subtracted by a positive number (B) and the result is positive.\n\nThe overflow flag is set to 1 if an overflow condition is detected; otherwise, it is set to 0.\n\nGive me the complete code."}, "clean_code": "module sub_64bit(\n  input [63:0] A,\n  input [63:0] B,\n  output reg [63:0] result,\n  output reg overflow\n);\n  always @(*) begin\n    result = A - B;\n\n    // Overflow happens when the sign of A and B are different, but the sign of result matches B\n    if ((A[63] != B[63]) && (result[63] != A[63])) begin\n      overflow = 1;\n    end else begin\n      overflow = 0;\n    end\n  end\n\nendmodule", "corrupted_code": "module sub_64bit(\n  input [63:0] A,\n  input [63:0] B,\n  output reg [63:0] result,\n  output reg overflow\n);\n  always @(*) begin\n    result = A - B;\n\n    // Overflow happens when the sign of A and B are different, but the sign of result matches B\n    if ((A[63] != B[63]) && (result[63] != A[63])) begin\n      overflow <= 1;\n    end else begin\n      overflow = 0;\n    end\n  end\n\nendmodule", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 12, "original_snippet": "overflow = 1;", "modified_snippet": "overflow <= 1;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.691950", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Substractor", "design_name": "sub_64bit", "module_name": "sub_64bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 64-bit subtractor with overflow checking for high-precision arithmetic operations. \n\nModule name:  \n    sub_64bit               \nInput ports:\n    A [63:0]: First 64-bit input operand (representing a large signed integer).\n    B [63:0]: Second 64-bit input operand (representing a large signed integer to be subtracted from A).\nOutput ports:\n    result [63:0]: 64-bit output representing the difference of the two operands (A - B).\n    overflow: 1-bit output indicating whether an overflow occurred during the subtraction operation.\n\nImplementation:\nSubtraction: The module performs binary subtraction of A and B to obtain the result.\nOverflow Detection: The module checks for overflow conditions by examining the sign bits of A, B, and the result. \n- Positive overflow occurs when a positive number (A) is subtracted by a negative number (B) and the result is negative.\n- Negative overflow occurs when a negative number (A) is subtracted by a positive number (B) and the result is positive.\n\nThe overflow flag is set to 1 if an overflow condition is detected; otherwise, it is set to 0.\n\nGive me the complete code."}, "clean_code": "module sub_64bit(\n  input [63:0] A,\n  input [63:0] B,\n  output reg [63:0] result,\n  output reg overflow\n);\n  always @(*) begin\n    result = A - B;\n\n    // Overflow happens when the sign of A and B are different, but the sign of result matches B\n    if ((A[63] != B[63]) && (result[63] != A[63])) begin\n      overflow = 1;\n    end else begin\n      overflow = 0;\n    end\n  end\n\nendmodule", "corrupted_code": "module sub_64bit(\n  input [63:0] A,\n  input [63:0] B,\n  output reg [63:0] result,\n  output reg overflow\n);\n  always @(*) begin\n    result = A - B;\n\n    // Overflow happens when the sign of A and B are different, but the sign of result matches B\n    if ((A[63] == B[63]) && (result[63] != A[63])) begin\n      overflow = 1;\n    end else begin\n      overflow = 0;\n    end\n  end\n\nendmodule", "corruption_explanation": "Changed operator from '!=' to '=='", "modification_type": "change_operator", "modification_line": 11, "original_snippet": "!=", "modified_snippet": "==", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '!=' to '=='\n   \u2022 Line 11: Original: !=\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 11.\n   \u2022 Restore the original code: !=\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.692594", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Substractor", "design_name": "sub_64bit", "module_name": "sub_64bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 64-bit subtractor with overflow checking for high-precision arithmetic operations. \n\nModule name:  \n    sub_64bit               \nInput ports:\n    A [63:0]: First 64-bit input operand (representing a large signed integer).\n    B [63:0]: Second 64-bit input operand (representing a large signed integer to be subtracted from A).\nOutput ports:\n    result [63:0]: 64-bit output representing the difference of the two operands (A - B).\n    overflow: 1-bit output indicating whether an overflow occurred during the subtraction operation.\n\nImplementation:\nSubtraction: The module performs binary subtraction of A and B to obtain the result.\nOverflow Detection: The module checks for overflow conditions by examining the sign bits of A, B, and the result. \n- Positive overflow occurs when a positive number (A) is subtracted by a negative number (B) and the result is negative.\n- Negative overflow occurs when a negative number (A) is subtracted by a positive number (B) and the result is positive.\n\nThe overflow flag is set to 1 if an overflow condition is detected; otherwise, it is set to 0.\n\nGive me the complete code."}, "clean_code": "module sub_64bit(\n  input [63:0] A,\n  input [63:0] B,\n  output reg [63:0] result,\n  output reg overflow\n);\n  always @(*) begin\n    result = A - B;\n\n    // Overflow happens when the sign of A and B are different, but the sign of result matches B\n    if ((A[63] != B[63]) && (result[63] != A[63])) begin\n      overflow = 1;\n    end else begin\n      overflow = 0;\n    end\n  end\n\nendmodule", "corrupted_code": "module sub_64bit(\n  input [63:0] A,\n  input [63:0] B,\n  output reg [63:0] result,\n  output reg overflow\n);\n   else begin\n      overflow = 0;\n    end\n  end\n\nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 7, "original_snippet": "always @(*) begin\n    result = A - B;\n\n    // Overflow happens when the sign of A and B are different, but the sign of result matches B\n    if ((A[63] != B[63]) && (result[63] != A[63])) begin\n      o", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 7: Original: always @(*) begin\n    result = A - B;\n\n    // Overflow happens when the sign of A and B are different, but the sign of result matches B\n    if ((A[63] != B[63]) && (result[63] != A[63])) begin\n      o\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 7.\n   \u2022 Restore the original code: always @(*) begin\n    result = A - B;\n\n    // Overflow happens when the sign of A and B are different, but the sign of result matches B\n    if ((A[63] != B[63]) && (result[63] != A[63])) begin\n      o\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.693181", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Substractor", "design_name": "sub_64bit", "module_name": "sub_64bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 64-bit subtractor with overflow checking for high-precision arithmetic operations. \n\nModule name:  \n    sub_64bit               \nInput ports:\n    A [63:0]: First 64-bit input operand (representing a large signed integer).\n    B [63:0]: Second 64-bit input operand (representing a large signed integer to be subtracted from A).\nOutput ports:\n    result [63:0]: 64-bit output representing the difference of the two operands (A - B).\n    overflow: 1-bit output indicating whether an overflow occurred during the subtraction operation.\n\nImplementation:\nSubtraction: The module performs binary subtraction of A and B to obtain the result.\nOverflow Detection: The module checks for overflow conditions by examining the sign bits of A, B, and the result. \n- Positive overflow occurs when a positive number (A) is subtracted by a negative number (B) and the result is negative.\n- Negative overflow occurs when a negative number (A) is subtracted by a positive number (B) and the result is positive.\n\nThe overflow flag is set to 1 if an overflow condition is detected; otherwise, it is set to 0.\n\nGive me the complete code."}, "clean_code": "module sub_64bit(\n  input [63:0] A,\n  input [63:0] B,\n  output reg [63:0] result,\n  output reg overflow\n);\n  always @(*) begin\n    result = A - B;\n\n    // Overflow happens when the sign of A and B are different, but the sign of result matches B\n    if ((A[63] != B[63]) && (result[63] != A[63])) begin\n      overflow = 1;\n    end else begin\n      overflow = 0;\n    end\n  end\n\nendmodule", "corrupted_code": "module sub_64bit(\n  input [63:0] A,\n  input [63:0] B,\n  output reg [63:0] result,\n  output reg overflow\n);\n  always @(*) begin\n    result = A - B;\n\n    // Overflow happens when the sign of A and B are different, but the sign of result matches B\n    if ((A[63] != B[63]) && (result[63] != A[63])) begin\n      overflow = 0;\n    end else begin\n      overflow = 0;\n    end\n  end\n\nendmodule", "corruption_explanation": "Changed constant from 1 to 0", "modification_type": "change_constant", "modification_line": 12, "original_snippet": "1", "modified_snippet": "0", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 1 to 0\n   \u2022 Line 12: Original: 1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 12.\n   \u2022 Restore the original code: 1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["change_constant"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.693772", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Arithmetic", "subcategory": "Substractor", "design_name": "sub_64bit", "module_name": "sub_64bit", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a 64-bit subtractor with overflow checking for high-precision arithmetic operations. \n\nModule name:  \n    sub_64bit               \nInput ports:\n    A [63:0]: First 64-bit input operand (representing a large signed integer).\n    B [63:0]: Second 64-bit input operand (representing a large signed integer to be subtracted from A).\nOutput ports:\n    result [63:0]: 64-bit output representing the difference of the two operands (A - B).\n    overflow: 1-bit output indicating whether an overflow occurred during the subtraction operation.\n\nImplementation:\nSubtraction: The module performs binary subtraction of A and B to obtain the result.\nOverflow Detection: The module checks for overflow conditions by examining the sign bits of A, B, and the result. \n- Positive overflow occurs when a positive number (A) is subtracted by a negative number (B) and the result is negative.\n- Negative overflow occurs when a negative number (A) is subtracted by a positive number (B) and the result is positive.\n\nThe overflow flag is set to 1 if an overflow condition is detected; otherwise, it is set to 0.\n\nGive me the complete code."}, "clean_code": "module sub_64bit(\n  input [63:0] A,\n  input [63:0] B,\n  output reg [63:0] result,\n  output reg overflow\n);\n  always @(*) begin\n    result = A - B;\n\n    // Overflow happens when the sign of A and B are different, but the sign of result matches B\n    if ((A[63] != B[63]) && (result[63] != A[63])) begin\n      overflow = 1;\n    end else begin\n      overflow = 0;\n    end\n  end\n\nendmodule", "corrupted_code": "module sub_64bit(\n  input [63:0] A,\n  input [63:0] B,\n  output reg [63:0] result,\n  output reg overflow\n);\n  always @(*) begin\n    result = A - B;\n\n    // Overflow happens when the sign of A and B are different, but the sign of result matches B\n    if ((A[63] != B[63]) && (result[63] != A[63])) begin\n      overflow = 0;\n    end else begin\n      overflow = 0;\n    end\n  end\n\nendmodule", "corruption_explanation": "Changed constant from 1 to 0", "modification_type": "change_constant", "modification_line": 12, "original_snippet": "1", "modified_snippet": "0", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 1 to 0\n   \u2022 Line 12: Original: 1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 12.\n   \u2022 Restore the original code: 1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["change_constant"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.694365", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "up_down_counter", "module_name": "up_down_counter", "description": "Please act as a professional Verilog designer.\n\nModule name: \n    up_down_counter\n\nFunction:\n    A 16-bit counter that can increment or decrement based on control signals.\n\nInput ports:\n    clk: Clock signal (1-bit), used to synchronize the counting process.\n    reset: Reset signal (1-bit), used to reset the counter to zero.\n    up_down: Control signal (1-bit), determines the counting direction. \n             If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\n    The module uses a synchronous process triggered by the rising edge of the clock signal (`clk`).\n    If the reset signal (`reset`) is active, the counter resets to zero.\n    If the `up_down` control signal is high, the counter increments on each clock cycle.\n    If the `up_down` control signal is low, the counter decrements on each clock cycle.\n    The `count` output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\n"}, "clean_code": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\nalways @(posedge clk or posedge reset)\nbegin\n    if (reset) begin\n        count <= 16'b0; \n    end else begin\n        if (up_down) begin\n            // Increment the counter if up_down is high\n            if (count == 16'b1111_1111_1111_1111) begin\n                count <= 16'b0; \n            end else begin\n                count <= count + 1; \n            end\n        end else begin\n            // Decrement the counter if up_down is low\n            if (count == 16'b0) begin\n                count <= 16'b1111_1111_1111_1111; \n            end else begin\n                count <= count - 1; \n            end\n        end\n    end\nend\n\nendmodule", "corrupted_code": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\nalways @(posedge clk or posedge reset)\nbegin\n    if (reset) begin\n        count <= 16'b0; \n    end else begin\n                count <= count + 1; \n            end\n        end else begin\n            // Decrement the counter if up_down is low\n            if (count == 16'b0) begin\n                count <= 16'b1111_1111_1111_1111; \n            end else begin\n                count <= count - 1; \n            end\n        end\n    end\nend\n\nendmodule", "corruption_explanation": "Removed else branch (may cause latch inference)", "modification_type": "remove_else_branch", "modification_line": 10, "original_snippet": "if (reset) begin\n        count <= 16'b0; \n    end else begin\n        if (up_down) begin\n            // Increment the counter if up_down is high\n            if (count == 16'b1111_1111_1111_1111) begin\n", "modified_snippet": "if (reset) begin\n        count <= 16'b0; \n    end", "issue_description": "The buggy code is missing an else branch in a conditional statement. In combinational logic (always_comb or always @*), this can cause latch inference because the output is not defined for all input conditions. In sequential logic, signals may retain old values unexpectedly. This violates RTL design best practices requiring complete conditional assignments.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module should provide a complete conditional assignment to avoid latch inference.\n   \u2022 Combinational logic must define outputs for all input conditions.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an if statement without an else branch.\n   \u2022 The assigned signal is not defined when the condition is false.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The else branch has been removed from the conditional.\n   \u2022 This creates an incomplete conditional assignment.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Missing else branch leaves the signal undefined in some cases.\n   \u2022 Impact: Latch inference in combinational blocks, or stale values in sequential blocks.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Add an else branch with appropriate default or alternative assignment.\n   \u2022 Ensure all signals are assigned in all branches of the conditional.\n\n6. RTL Design Principle Violated:\n   \u2022 Combinational logic must have complete assignments to avoid latch inference.\n   \u2022 All conditional blocks should have else clauses or default values.", "complexity": 14, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_else_branch"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.697534", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "up_down_counter", "module_name": "up_down_counter", "description": "Please act as a professional Verilog designer.\n\nModule name: \n    up_down_counter\n\nFunction:\n    A 16-bit counter that can increment or decrement based on control signals.\n\nInput ports:\n    clk: Clock signal (1-bit), used to synchronize the counting process.\n    reset: Reset signal (1-bit), used to reset the counter to zero.\n    up_down: Control signal (1-bit), determines the counting direction. \n             If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\n    The module uses a synchronous process triggered by the rising edge of the clock signal (`clk`).\n    If the reset signal (`reset`) is active, the counter resets to zero.\n    If the `up_down` control signal is high, the counter increments on each clock cycle.\n    If the `up_down` control signal is low, the counter decrements on each clock cycle.\n    The `count` output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\n"}, "clean_code": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\nalways @(posedge clk or posedge reset)\nbegin\n    if (reset) begin\n        count <= 16'b0; \n    end else begin\n        if (up_down) begin\n            // Increment the counter if up_down is high\n            if (count == 16'b1111_1111_1111_1111) begin\n                count <= 16'b0; \n            end else begin\n                count <= count + 1; \n            end\n        end else begin\n            // Decrement the counter if up_down is low\n            if (count == 16'b0) begin\n                count <= 16'b1111_1111_1111_1111; \n            end else begin\n                count <= count - 1; \n            end\n        end\n    end\nend\n\nendmodule", "corrupted_code": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\nalways @(posedge clk or posedge reset)\nbegin\n    if (reset) begin\n        count <= 16'b0; \n    end else begin\n        if (!(up_down)) begin\n            // Increment the counter if up_down is high\n            if (count == 16'b1111_1111_1111_1111) begin\n                count <= 16'b0; \n            end else begin\n                count <= count + 1; \n            end\n        end else begin\n            // Decrement the counter if up_down is low\n            if (count == 16'b0) begin\n                count <= 16'b1111_1111_1111_1111; \n            end else begin\n                count <= count - 1; \n            end\n        end\n    end\nend\n\nendmodule", "corruption_explanation": "Inverted condition: 'up_down' -> '!(up_down)'", "modification_type": "invert_condition", "modification_line": 13, "original_snippet": "if (up_down) begin", "modified_snippet": "if (!(up_down)) begin", "issue_description": "The buggy code has an inverted condition in an if statement. Instead of checking if(x), it checks if(!x), causing the logic to execute when it shouldn't and skip execution when it should. All conditional behavior is reversed from intended functionality.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_condition modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted condition: 'up_down' -> '!(up_down)'\n   \u2022 Line 13: Original: if (up_down) begin\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 13.\n   \u2022 Restore the original code: if (up_down) begin\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert condition.", "complexity": 14, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_condition"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.699389", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "up_down_counter", "module_name": "up_down_counter", "description": "Please act as a professional Verilog designer.\n\nModule name: \n    up_down_counter\n\nFunction:\n    A 16-bit counter that can increment or decrement based on control signals.\n\nInput ports:\n    clk: Clock signal (1-bit), used to synchronize the counting process.\n    reset: Reset signal (1-bit), used to reset the counter to zero.\n    up_down: Control signal (1-bit), determines the counting direction. \n             If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\n    The module uses a synchronous process triggered by the rising edge of the clock signal (`clk`).\n    If the reset signal (`reset`) is active, the counter resets to zero.\n    If the `up_down` control signal is high, the counter increments on each clock cycle.\n    If the `up_down` control signal is low, the counter decrements on each clock cycle.\n    The `count` output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\n"}, "clean_code": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\nalways @(posedge clk or posedge reset)\nbegin\n    if (reset) begin\n        count <= 16'b0; \n    end else begin\n        if (up_down) begin\n            // Increment the counter if up_down is high\n            if (count == 16'b1111_1111_1111_1111) begin\n                count <= 16'b0; \n            end else begin\n                count <= count + 1; \n            end\n        end else begin\n            // Decrement the counter if up_down is low\n            if (count == 16'b0) begin\n                count <= 16'b1111_1111_1111_1111; \n            end else begin\n                count <= count - 1; \n            end\n        end\n    end\nend\n\nendmodule", "corrupted_code": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\nalways @(posedge clk or posedge reset)\nbegin\n    if (reset) begin\n        count <= 16'b0; \n    end else begin\n        if (up_down) begin\n            // Increment the counter if up_down is high\n            if (count == 16'b1111_1111_1111_1111) begin\n                count <= 16'b0; \n            end else begin\n                count <= count + 1; \n            end\n        end else begin\n            // Decrement the counter if up_down is low\n            if (count == 16'b0) begin\n                count <= 16'b0111_1111_1111_1111; \n            end else begin\n                count <= count - 1; \n            end\n        end\n    end\nend\n\nendmodule", "corruption_explanation": "Changed constant from 16'b1111_1111_1111_1111 to 16'b0111_1111_1111_1111", "modification_type": "change_constant", "modification_line": 23, "original_snippet": "16'b1111_1111_1111_1111", "modified_snippet": "16'b0111_1111_1111_1111", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 16'b1111_1111_1111_1111 to 16'b0111_1111_1111_1111\n   \u2022 Line 23: Original: 16'b1111_1111_1111_1111\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 23.\n   \u2022 Restore the original code: 16'b1111_1111_1111_1111\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 14, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_constant"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.700418", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "up_down_counter", "module_name": "up_down_counter", "description": "Please act as a professional Verilog designer.\n\nModule name: \n    up_down_counter\n\nFunction:\n    A 16-bit counter that can increment or decrement based on control signals.\n\nInput ports:\n    clk: Clock signal (1-bit), used to synchronize the counting process.\n    reset: Reset signal (1-bit), used to reset the counter to zero.\n    up_down: Control signal (1-bit), determines the counting direction. \n             If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\n    The module uses a synchronous process triggered by the rising edge of the clock signal (`clk`).\n    If the reset signal (`reset`) is active, the counter resets to zero.\n    If the `up_down` control signal is high, the counter increments on each clock cycle.\n    If the `up_down` control signal is low, the counter decrements on each clock cycle.\n    The `count` output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\n"}, "clean_code": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\nalways @(posedge clk or posedge reset)\nbegin\n    if (reset) begin\n        count <= 16'b0; \n    end else begin\n        if (up_down) begin\n            // Increment the counter if up_down is high\n            if (count == 16'b1111_1111_1111_1111) begin\n                count <= 16'b0; \n            end else begin\n                count <= count + 1; \n            end\n        end else begin\n            // Decrement the counter if up_down is low\n            if (count == 16'b0) begin\n                count <= 16'b1111_1111_1111_1111; \n            end else begin\n                count <= count - 1; \n            end\n        end\n    end\nend\n\nendmodule", "corrupted_code": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\nalways @(posedge clk or posedge reset)\nbegin\n    if (reset) begin\n        count <= 16'b0; \n    end else begin\n        if (up_down) begin\n            // Increment the counter if up_down is high\n            if (count == 16'b1111_1111_1111_1111) begin\n                count <= 16'b0; \n            end else begin\n                count <= count + 1; \n            end\n        end else begin\n            // Decrement the counter if up_down is low\n            \n        end\n    end\nend\n\nendmodule", "corruption_explanation": "Removed a conditional block", "modification_type": "remove_conditional", "modification_line": 22, "original_snippet": "if (count == 16'b0) begin\n                count <= 16'b1111_1111_1111_1111; \n            end else begin\n                count <= count - 1; \n            end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing a conditional block. This removes important control logic, causing the design to skip necessary state transitions or data processing. Test cases that depend on the conditional behavior will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_conditional modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed a conditional block\n   \u2022 Line 22: Original: if (count == 16'b0) begin\n                count <= 16'b1111_1111_1111_1111; \n            end else begin\n                count <= count - 1; \n            end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 22.\n   \u2022 Restore the original code: if (count == 16'b0) begin\n                count <= 16'b1111_1111_1111_1111; \n            end else begin\n                count <= count - 1; \n            end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove conditional.", "complexity": 14, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_conditional"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.701434", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "up_down_counter", "module_name": "up_down_counter", "description": "Please act as a professional Verilog designer.\n\nModule name: \n    up_down_counter\n\nFunction:\n    A 16-bit counter that can increment or decrement based on control signals.\n\nInput ports:\n    clk: Clock signal (1-bit), used to synchronize the counting process.\n    reset: Reset signal (1-bit), used to reset the counter to zero.\n    up_down: Control signal (1-bit), determines the counting direction. \n             If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\n    The module uses a synchronous process triggered by the rising edge of the clock signal (`clk`).\n    If the reset signal (`reset`) is active, the counter resets to zero.\n    If the `up_down` control signal is high, the counter increments on each clock cycle.\n    If the `up_down` control signal is low, the counter decrements on each clock cycle.\n    The `count` output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\n"}, "clean_code": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\nalways @(posedge clk or posedge reset)\nbegin\n    if (reset) begin\n        count <= 16'b0; \n    end else begin\n        if (up_down) begin\n            // Increment the counter if up_down is high\n            if (count == 16'b1111_1111_1111_1111) begin\n                count <= 16'b0; \n            end else begin\n                count <= count + 1; \n            end\n        end else begin\n            // Decrement the counter if up_down is low\n            if (count == 16'b0) begin\n                count <= 16'b1111_1111_1111_1111; \n            end else begin\n                count <= count - 1; \n            end\n        end\n    end\nend\n\nendmodule", "corrupted_code": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\n else begin\n        if (up_down) begin\n            // Increment the counter if up_down is high\n            if (count == 16'b1111_1111_1111_1111) begin\n                count <= 16'b0; \n            end else begin\n                count <= count + 1; \n            end\n        end else begin\n            // Decrement the counter if up_down is low\n            if (count == 16'b0) begin\n                count <= 16'b1111_1111_1111_1111; \n            end else begin\n                count <= count - 1; \n            end\n        end\n    end\nend\n\nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 8, "original_snippet": "always @(posedge clk or posedge reset)\nbegin\n    if (reset) begin\n        count <= 16'b0; \n    end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 8: Original: always @(posedge clk or posedge reset)\nbegin\n    if (reset) begin\n        count <= 16'b0; \n    end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 8.\n   \u2022 Restore the original code: always @(posedge clk or posedge reset)\nbegin\n    if (reset) begin\n        count <= 16'b0; \n    end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 14, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.703274", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "up_down_counter", "module_name": "up_down_counter", "description": "Please act as a professional Verilog designer.\n\nModule name: \n    up_down_counter\n\nFunction:\n    A 16-bit counter that can increment or decrement based on control signals.\n\nInput ports:\n    clk: Clock signal (1-bit), used to synchronize the counting process.\n    reset: Reset signal (1-bit), used to reset the counter to zero.\n    up_down: Control signal (1-bit), determines the counting direction. \n             If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\n    The module uses a synchronous process triggered by the rising edge of the clock signal (`clk`).\n    If the reset signal (`reset`) is active, the counter resets to zero.\n    If the `up_down` control signal is high, the counter increments on each clock cycle.\n    If the `up_down` control signal is low, the counter decrements on each clock cycle.\n    The `count` output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\n"}, "clean_code": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\nalways @(posedge clk or posedge reset)\nbegin\n    if (reset) begin\n        count <= 16'b0; \n    end else begin\n        if (up_down) begin\n            // Increment the counter if up_down is high\n            if (count == 16'b1111_1111_1111_1111) begin\n                count <= 16'b0; \n            end else begin\n                count <= count + 1; \n            end\n        end else begin\n            // Decrement the counter if up_down is low\n            if (count == 16'b0) begin\n                count <= 16'b1111_1111_1111_1111; \n            end else begin\n                count <= count - 1; \n            end\n        end\n    end\nend\n\nendmodule", "corrupted_code": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\nalways @(posedge clk or posedge reset)\nbegin\n    if (!(reset)) begin\n        count <= 16'b0; \n    end else begin\n        if (up_down) begin\n            // Increment the counter if up_down is high\n            if (count == 16'b1111_1111_1111_1111) begin\n                count <= 16'b0; \n            end else begin\n                count <= count + 1; \n            end\n        end else begin\n            // Decrement the counter if up_down is low\n            if (count == 16'b0) begin\n                count <= 16'b1111_1111_1111_1111; \n            end else begin\n                count <= count - 1; \n            end\n        end\n    end\nend\n\nendmodule", "corruption_explanation": "Inverted condition: 'reset' -> '!(reset)'", "modification_type": "invert_condition", "modification_line": 10, "original_snippet": "if (reset) begin", "modified_snippet": "if (!(reset)) begin", "issue_description": "The buggy code has an inverted condition in an if statement. Instead of checking if(x), it checks if(!x), causing the logic to execute when it shouldn't and skip execution when it should. All conditional behavior is reversed from intended functionality.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_condition modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted condition: 'reset' -> '!(reset)'\n   \u2022 Line 10: Original: if (reset) begin\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 10.\n   \u2022 Restore the original code: if (reset) begin\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert condition.", "complexity": 14, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_condition"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.704272", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "counter_12", "module_name": "counter_12", "description": "Please act as a professional verilog designer.\n\nImplement a module of a counter design that requires counting from 4 'b0000 to 4' d11. The counting can be controlled by the input signal valid_count. That is, the count is paused if valid_count is 0. The counter increments on each clock cycle when the valid_count signal is active and resets to 0 when the reset signal (rst_n) is active.\n\nModule name:  \n    counter_12               \nInput ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\nOutput ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nIf the reset signal is active (!rst_n), the counter is reset to 0 by assigning the value 4'b0000 to the output register (out). If the valid_count signal is 1, the counter increments. It checks if the current count value (out) is equal to 4'd11 (maximum count value). If it is, the counter wraps around and resets to 0 by assigning the value 4'b0000 to the output register (out). Otherwise, it increments the output register by 1. If the valid_count = 0, the counter will stop, and the output register (out) remains unchanged.\n\nGive me the complete code.\n\n"}, "clean_code": "`timescale 1ns/1ps\nmodule counter_12 \n(\n  input rst_n,\n  input clk,\n  input valid_count,\n\n  output reg [3:0] out\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) \n\tbegin\n      out <= 4'b0000;\n    end \n\n\telse if (valid_count) \n\tbegin\n      if (out == 4'd11) \n\t  begin\n        out <= 4'b0000;\n      end \n\t  else begin\n        out <= out + 1;\n      end\n    end \n\t\n\telse begin\n      out <= out; // Pause the count when valid_count is invalid\n    end\n  end\n\nendmodule\n", "corrupted_code": "`timescale 1ns/1ps\nmodule counter_12 \n(\n  input rst_n,\n  input clk,\n  input valid_count,\n\n  output reg [3:0] out\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) \n\tbegin\n        out <= out + 1;\n      end \n\t  else begin\n      out <= 4'b0000;\n    end \n\n\telse if (valid_count) \n\tbegin\n      if (out == 4'd11) \n\t  begin\n        out <= 4'b0000;\n      end\n    end \n\t\n\telse begin\n      out <= out; // Pause the count when valid_count is invalid\n    end\n  end\n\nendmodule\n", "corruption_explanation": "Swapped if and else bodies", "modification_type": "invert_if_else", "modification_line": 12, "original_snippet": "if (!rst_n) \n\tbegin\n      out <= 4'b0000;\n    end \n\n\telse if (valid_count) \n\tbegin\n      if (out == 4'd11) \n\t  begin\n        out <= 4'b0000;\n      end \n\t  else begin\n        out <= out + 1;\n      end", "modified_snippet": "if (!rst_n) \n\tbegin\n        out <= out + 1;\n      end \n\t  else begin\n      out <= 4'b0000;\n    end \n\n\telse if (valid_count) \n\tbegin\n      if (out == 4'd11) \n\t  begin\n        out <= 4'b0000;\n      end", "issue_description": "The buggy code has swapped if and else bodies in a conditional block. This causes the logic to execute the opposite branch for each condition, leading to incorrect behavior when the condition is true vs false. Test cases that depend on the conditional logic will fail because the intended branch is not executed.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module contains conditional logic that should execute different code paths based on a condition.\n   \u2022 The if branch should handle the true case, and the else branch should handle the false case.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Identified a conditional block with both if and else branches.\n   \u2022 The branches contain different assignments or logic operations.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The if and else bodies have been swapped.\n   \u2022 Logic that should execute when condition is true now executes when false, and vice versa.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The conditional bodies are inverted.\n   \u2022 Impact: All conditional behavior is reversed, causing incorrect outputs for all test cases.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Swap the if and else bodies back to their correct positions.\n   \u2022 Verify that the condition evaluates correctly and executes the intended branch.\n\n6. RTL Design Principle Violated:\n   \u2022 Correct conditional logic requires matching the intended behavior with the branch bodies.", "complexity": 11, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_if_else"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.707303", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "counter_12", "module_name": "counter_12", "description": "Please act as a professional verilog designer.\n\nImplement a module of a counter design that requires counting from 4 'b0000 to 4' d11. The counting can be controlled by the input signal valid_count. That is, the count is paused if valid_count is 0. The counter increments on each clock cycle when the valid_count signal is active and resets to 0 when the reset signal (rst_n) is active.\n\nModule name:  \n    counter_12               \nInput ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\nOutput ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nIf the reset signal is active (!rst_n), the counter is reset to 0 by assigning the value 4'b0000 to the output register (out). If the valid_count signal is 1, the counter increments. It checks if the current count value (out) is equal to 4'd11 (maximum count value). If it is, the counter wraps around and resets to 0 by assigning the value 4'b0000 to the output register (out). Otherwise, it increments the output register by 1. If the valid_count = 0, the counter will stop, and the output register (out) remains unchanged.\n\nGive me the complete code.\n\n"}, "clean_code": "`timescale 1ns/1ps\nmodule counter_12 \n(\n  input rst_n,\n  input clk,\n  input valid_count,\n\n  output reg [3:0] out\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) \n\tbegin\n      out <= 4'b0000;\n    end \n\n\telse if (valid_count) \n\tbegin\n      if (out == 4'd11) \n\t  begin\n        out <= 4'b0000;\n      end \n\t  else begin\n        out <= out + 1;\n      end\n    end \n\t\n\telse begin\n      out <= out; // Pause the count when valid_count is invalid\n    end\n  end\n\nendmodule\n", "corrupted_code": "`timescale 1ns/1ps\nmodule counter_12 \n(\n  input rst_n,\n  input clk,\n  input valid_count,\n\n  output reg [3:0] out\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) \n\tbegin\n      out <= 4'b0000;\n    end \n\n\telse if (valid_count) \n\tbegin\n      if (out == 4'd11) \n\t  begin\n        out <= 4'b0000;\n      end \n\t  else begin\n        out >= out + 1;\n      end\n    end \n\t\n\telse begin\n      out <= out; // Pause the count when valid_count is invalid\n    end\n  end\n\nendmodule\n", "corruption_explanation": "Changed operator from '<=' to '>='", "modification_type": "change_operator", "modification_line": 24, "original_snippet": "t <= o", "modified_snippet": "t >= o", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '<=' to '>='\n   \u2022 Line 24: Original: t <= o\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 24.\n   \u2022 Restore the original code: t <= o\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 11, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.708126", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "counter_12", "module_name": "counter_12", "description": "Please act as a professional verilog designer.\n\nImplement a module of a counter design that requires counting from 4 'b0000 to 4' d11. The counting can be controlled by the input signal valid_count. That is, the count is paused if valid_count is 0. The counter increments on each clock cycle when the valid_count signal is active and resets to 0 when the reset signal (rst_n) is active.\n\nModule name:  \n    counter_12               \nInput ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\nOutput ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nIf the reset signal is active (!rst_n), the counter is reset to 0 by assigning the value 4'b0000 to the output register (out). If the valid_count signal is 1, the counter increments. It checks if the current count value (out) is equal to 4'd11 (maximum count value). If it is, the counter wraps around and resets to 0 by assigning the value 4'b0000 to the output register (out). Otherwise, it increments the output register by 1. If the valid_count = 0, the counter will stop, and the output register (out) remains unchanged.\n\nGive me the complete code.\n\n"}, "clean_code": "`timescale 1ns/1ps\nmodule counter_12 \n(\n  input rst_n,\n  input clk,\n  input valid_count,\n\n  output reg [3:0] out\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) \n\tbegin\n      out <= 4'b0000;\n    end \n\n\telse if (valid_count) \n\tbegin\n      if (out == 4'd11) \n\t  begin\n        out <= 4'b0000;\n      end \n\t  else begin\n        out <= out + 1;\n      end\n    end \n\t\n\telse begin\n      out <= out; // Pause the count when valid_count is invalid\n    end\n  end\n\nendmodule\n", "corrupted_code": "`timescale 1ns/1ps\nmodule counter_12 \n(\n  input rst_n,\n  input clk,\n  input valid_count,\n\n  output reg [3:0] out\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    \n    end \n\t\n\telse begin\n      out <= out; // Pause the count when valid_count is invalid\n    end\n  end\n\nendmodule\n", "corruption_explanation": "Removed a conditional block", "modification_type": "remove_conditional", "modification_line": 12, "original_snippet": "if (!rst_n) \n\tbegin\n      out <= 4'b0000;\n    end \n\n\telse if (valid_count) \n\tbegin\n      if (out == 4'd11) \n\t  begin\n        out <= 4'b0000;\n      end \n\t  else begin\n        out <= out + 1;\n      end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing a conditional block. This removes important control logic, causing the design to skip necessary state transitions or data processing. Test cases that depend on the conditional behavior will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_conditional modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed a conditional block\n   \u2022 Line 12: Original: if (!rst_n) \n\tbegin\n      out <= 4'b0000;\n    end \n\n\telse if (valid_count) \n\tbegin\n      if (out == 4'd11) \n\t  begin\n        out <= 4'b0000;\n      end \n\t  else begin\n        out <= out + 1;\n      end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 12.\n   \u2022 Restore the original code: if (!rst_n) \n\tbegin\n      out <= 4'b0000;\n    end \n\n\telse if (valid_count) \n\tbegin\n      if (out == 4'd11) \n\t  begin\n        out <= 4'b0000;\n      end \n\t  else begin\n        out <= out + 1;\n      end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove conditional.", "complexity": 11, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_conditional"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.708855", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "counter_12", "module_name": "counter_12", "description": "Please act as a professional verilog designer.\n\nImplement a module of a counter design that requires counting from 4 'b0000 to 4' d11. The counting can be controlled by the input signal valid_count. That is, the count is paused if valid_count is 0. The counter increments on each clock cycle when the valid_count signal is active and resets to 0 when the reset signal (rst_n) is active.\n\nModule name:  \n    counter_12               \nInput ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\nOutput ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nIf the reset signal is active (!rst_n), the counter is reset to 0 by assigning the value 4'b0000 to the output register (out). If the valid_count signal is 1, the counter increments. It checks if the current count value (out) is equal to 4'd11 (maximum count value). If it is, the counter wraps around and resets to 0 by assigning the value 4'b0000 to the output register (out). Otherwise, it increments the output register by 1. If the valid_count = 0, the counter will stop, and the output register (out) remains unchanged.\n\nGive me the complete code.\n\n"}, "clean_code": "`timescale 1ns/1ps\nmodule counter_12 \n(\n  input rst_n,\n  input clk,\n  input valid_count,\n\n  output reg [3:0] out\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) \n\tbegin\n      out <= 4'b0000;\n    end \n\n\telse if (valid_count) \n\tbegin\n      if (out == 4'd11) \n\t  begin\n        out <= 4'b0000;\n      end \n\t  else begin\n        out <= out + 1;\n      end\n    end \n\t\n\telse begin\n      out <= out; // Pause the count when valid_count is invalid\n    end\n  end\n\nendmodule\n", "corrupted_code": "`timescale 1ns/1ps\nmodule counter_12 \n(\n  input rst_n,\n  input clk,\n  input valid_count,\n\n  output reg [3:0] out\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) \n\tbegin\n      out <= 4'b0000;\n    end \n\n\telse if (valid_count) \n\tbegin\n      if (out == 4'd11) \n\t  begin\n        out <= 4'b0000;\n      end \n\t  else begin\n        out <= out + 1;\n      end\n    end \n\t\n\telse begin\n      ouhe count when valid_count is invalid\n    end\n  end\n\nendmodule\n", "corruption_explanation": "Removed CDC synchronizer stage", "modification_type": "modify_cdc", "modification_line": 29, "original_snippet": "t <= out; // Pause t", "modified_snippet": "(removed)", "issue_description": "The buggy code has a broken clock domain crossing synchronizer. A synchronizer flip-flop stage was removed, reducing metastability protection. This creates CDC violations that cause random data corruption in multi-clock domain designs.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a modify_cdc modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed CDC synchronizer stage\n   \u2022 Line 29: Original: t <= out; // Pause t\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 29.\n   \u2022 Restore the original code: t <= out; // Pause t\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to modify cdc.", "complexity": 11, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["modify_cdc"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.709674", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "counter_12", "module_name": "counter_12", "description": "Please act as a professional verilog designer.\n\nImplement a module of a counter design that requires counting from 4 'b0000 to 4' d11. The counting can be controlled by the input signal valid_count. That is, the count is paused if valid_count is 0. The counter increments on each clock cycle when the valid_count signal is active and resets to 0 when the reset signal (rst_n) is active.\n\nModule name:  \n    counter_12               \nInput ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\nOutput ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nIf the reset signal is active (!rst_n), the counter is reset to 0 by assigning the value 4'b0000 to the output register (out). If the valid_count signal is 1, the counter increments. It checks if the current count value (out) is equal to 4'd11 (maximum count value). If it is, the counter wraps around and resets to 0 by assigning the value 4'b0000 to the output register (out). Otherwise, it increments the output register by 1. If the valid_count = 0, the counter will stop, and the output register (out) remains unchanged.\n\nGive me the complete code.\n\n"}, "clean_code": "`timescale 1ns/1ps\nmodule counter_12 \n(\n  input rst_n,\n  input clk,\n  input valid_count,\n\n  output reg [3:0] out\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) \n\tbegin\n      out <= 4'b0000;\n    end \n\n\telse if (valid_count) \n\tbegin\n      if (out == 4'd11) \n\t  begin\n        out <= 4'b0000;\n      end \n\t  else begin\n        out <= out + 1;\n      end\n    end \n\t\n\telse begin\n      out <= out; // Pause the count when valid_count is invalid\n    end\n  end\n\nendmodule\n", "corrupted_code": "`timescale 1ns/1ps\nmodule counter_12 \n(\n  input rst_n,\n  input clk,\n  input valid_count,\n\n  output reg [3:0] out\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) \n\tbegin\n      \n    end \n\n\telse if (valid_count) \n\tbegin\n      if (out == 4'd11) \n\t  begin\n        out <= 4'b0000;\n      end \n\t  else begin\n        out <= out + 1;\n      end\n    end \n\t\n\telse begin\n      out <= out; // Pause the count when valid_count is invalid\n    end\n  end\n\nendmodule\n", "corruption_explanation": "Removed assignment from reset block", "modification_type": "remove_reset_assignment", "modification_line": 12, "original_snippet": "out <= 4'b0000;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing a signal initialization in the reset block. This leaves registers with undefined initial values after reset, causing unpredictable behavior on startup. Simulation may pass but hardware behavior will be incorrect.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_reset_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed assignment from reset block\n   \u2022 Line 12: Original: out <= 4'b0000;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 12.\n   \u2022 Restore the original code: out <= 4'b0000;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove reset assignment.", "complexity": 11, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_reset_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.710403", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "counter_12", "module_name": "counter_12", "description": "Please act as a professional verilog designer.\n\nImplement a module of a counter design that requires counting from 4 'b0000 to 4' d11. The counting can be controlled by the input signal valid_count. That is, the count is paused if valid_count is 0. The counter increments on each clock cycle when the valid_count signal is active and resets to 0 when the reset signal (rst_n) is active.\n\nModule name:  \n    counter_12               \nInput ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\nOutput ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nIf the reset signal is active (!rst_n), the counter is reset to 0 by assigning the value 4'b0000 to the output register (out). If the valid_count signal is 1, the counter increments. It checks if the current count value (out) is equal to 4'd11 (maximum count value). If it is, the counter wraps around and resets to 0 by assigning the value 4'b0000 to the output register (out). Otherwise, it increments the output register by 1. If the valid_count = 0, the counter will stop, and the output register (out) remains unchanged.\n\nGive me the complete code.\n\n"}, "clean_code": "`timescale 1ns/1ps\nmodule counter_12 \n(\n  input rst_n,\n  input clk,\n  input valid_count,\n\n  output reg [3:0] out\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) \n\tbegin\n      out <= 4'b0000;\n    end \n\n\telse if (valid_count) \n\tbegin\n      if (out == 4'd11) \n\t  begin\n        out <= 4'b0000;\n      end \n\t  else begin\n        out <= out + 1;\n      end\n    end \n\t\n\telse begin\n      out <= out; // Pause the count when valid_count is invalid\n    end\n  end\n\nendmodule\n", "corrupted_code": "`timescale 1ns/1ps\nmodule counter_12 \n(\n  input rst_n,\n  input clk,\n  input valid_count,\n\n  output reg [3:0] out\n);\n\n  always @(posedge clk or posedge rst_n) begin\n    if (!rst_n) \n\tbegin\n      out <= 4'b0000;\n    end \n\n\telse if (valid_count) \n\tbegin\n      if (out == 4'd11) \n\t  begin\n        out <= 4'b0000;\n      end \n\t  else begin\n        out <= out + 1;\n      end\n    end \n\t\n\telse begin\n      out <= out; // Pause the count when valid_count is invalid\n    end\n  end\n\nendmodule\n", "corruption_explanation": "Inverted reset polarity in sensitivity", "modification_type": "invert_reset_polarity", "modification_line": 11, "original_snippet": "always @(posedge clk or negedge rst_n)", "modified_snippet": "always @(posedge clk or posedge rst_n)", "issue_description": "The buggy code has inverted reset polarity. If the design expects active-low reset (!rst), it now uses active-high, or vice versa. This causes the reset logic to activate during normal operation and deactivate during actual reset, breaking initialization.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_reset_polarity modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted reset polarity in sensitivity\n   \u2022 Line 11: Original: always @(posedge clk or negedge rst_n)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 11.\n   \u2022 Restore the original code: always @(posedge clk or negedge rst_n)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert reset polarity.", "complexity": 11, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_reset_polarity"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.711122", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "counter_12", "module_name": "counter_12", "description": "Please act as a professional verilog designer.\n\nImplement a module of a counter design that requires counting from 4 'b0000 to 4' d11. The counting can be controlled by the input signal valid_count. That is, the count is paused if valid_count is 0. The counter increments on each clock cycle when the valid_count signal is active and resets to 0 when the reset signal (rst_n) is active.\n\nModule name:  \n    counter_12               \nInput ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\nOutput ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nIf the reset signal is active (!rst_n), the counter is reset to 0 by assigning the value 4'b0000 to the output register (out). If the valid_count signal is 1, the counter increments. It checks if the current count value (out) is equal to 4'd11 (maximum count value). If it is, the counter wraps around and resets to 0 by assigning the value 4'b0000 to the output register (out). Otherwise, it increments the output register by 1. If the valid_count = 0, the counter will stop, and the output register (out) remains unchanged.\n\nGive me the complete code.\n\n"}, "clean_code": "`timescale 1ns/1ps\nmodule counter_12 \n(\n  input rst_n,\n  input clk,\n  input valid_count,\n\n  output reg [3:0] out\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) \n\tbegin\n      out <= 4'b0000;\n    end \n\n\telse if (valid_count) \n\tbegin\n      if (out == 4'd11) \n\t  begin\n        out <= 4'b0000;\n      end \n\t  else begin\n        out <= out + 1;\n      end\n    end \n\t\n\telse begin\n      out <= out; // Pause the count when valid_count is invalid\n    end\n  end\n\nendmodule\n", "corrupted_code": "`timescale 1ns/1ps\nmodule counter_12 \n(\n  input rst_n,\n  input clk,\n  input valid_count,\n\n  output reg [3:0] out\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) \n\tbegin\n      out <= 4'b0000;\n    end \n\n\telse if (valid_count) \n\tbegin\n      if (out == 4'd11) \n\t  begin\n        out <= 4'b0000;\n      end\n    end \n\t\n\telse begin\n      out <= out; // Pause the count when valid_count is invalid\n    end\n  end\n\nendmodule\n", "corruption_explanation": "Removed else branch (may cause latch inference)", "modification_type": "remove_else_branch", "modification_line": 12, "original_snippet": "if (!rst_n) \n\tbegin\n      out <= 4'b0000;\n    end \n\n\telse if (valid_count) \n\tbegin\n      if (out == 4'd11) \n\t  begin\n        out <= 4'b0000;\n      end \n\t  else begin\n        out <= out + 1;\n      end", "modified_snippet": "if (!rst_n) \n\tbegin\n      out <= 4'b0000;\n    end \n\n\telse if (valid_count) \n\tbegin\n      if (out == 4'd11) \n\t  begin\n        out <= 4'b0000;\n      end", "issue_description": "The buggy code is missing an else branch in a conditional statement. In combinational logic (always_comb or always @*), this can cause latch inference because the output is not defined for all input conditions. In sequential logic, signals may retain old values unexpectedly. This violates RTL design best practices requiring complete conditional assignments.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module should provide a complete conditional assignment to avoid latch inference.\n   \u2022 Combinational logic must define outputs for all input conditions.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an if statement without an else branch.\n   \u2022 The assigned signal is not defined when the condition is false.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The else branch has been removed from the conditional.\n   \u2022 This creates an incomplete conditional assignment.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Missing else branch leaves the signal undefined in some cases.\n   \u2022 Impact: Latch inference in combinational blocks, or stale values in sequential blocks.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Add an else branch with appropriate default or alternative assignment.\n   \u2022 Ensure all signals are assigned in all branches of the conditional.\n\n6. RTL Design Principle Violated:\n   \u2022 Combinational logic must have complete assignments to avoid latch inference.\n   \u2022 All conditional blocks should have else clauses or default values.", "complexity": 11, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_else_branch"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.711830", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "counter_12", "module_name": "counter_12", "description": "Please act as a professional verilog designer.\n\nImplement a module of a counter design that requires counting from 4 'b0000 to 4' d11. The counting can be controlled by the input signal valid_count. That is, the count is paused if valid_count is 0. The counter increments on each clock cycle when the valid_count signal is active and resets to 0 when the reset signal (rst_n) is active.\n\nModule name:  \n    counter_12               \nInput ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\nOutput ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nIf the reset signal is active (!rst_n), the counter is reset to 0 by assigning the value 4'b0000 to the output register (out). If the valid_count signal is 1, the counter increments. It checks if the current count value (out) is equal to 4'd11 (maximum count value). If it is, the counter wraps around and resets to 0 by assigning the value 4'b0000 to the output register (out). Otherwise, it increments the output register by 1. If the valid_count = 0, the counter will stop, and the output register (out) remains unchanged.\n\nGive me the complete code.\n\n"}, "clean_code": "`timescale 1ns/1ps\nmodule counter_12 \n(\n  input rst_n,\n  input clk,\n  input valid_count,\n\n  output reg [3:0] out\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) \n\tbegin\n      out <= 4'b0000;\n    end \n\n\telse if (valid_count) \n\tbegin\n      if (out == 4'd11) \n\t  begin\n        out <= 4'b0000;\n      end \n\t  else begin\n        out <= out + 1;\n      end\n    end \n\t\n\telse begin\n      out <= out; // Pause the count when valid_count is invalid\n    end\n  end\n\nendmodule\n", "corrupted_code": "`timescale 1ns/1ps\nmodule counter_12 \n(\n  input rst_n,\n  input clk,\n  input valid_count,\n\n  output reg [3:0] out\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) \n\tbegin\n      out <= 4'b0000;\n    end \n\n\telse if (valid_count) \n\tbegin\n      if (out == 4'd11) \n\t  begin\n        out <= 4'b0000;\n      end \n\t  else begin\n        out <= out + 1;\n      end\n    end \n\t\n\telse begin\n      out <= out; // Pause the count when valid_count is invalid\n    end\n  end\n\n\n    wire clk_dup;\n    assign clk_dup = clk;\nendmodule\n", "corruption_explanation": "Added duplicate clock signal clk_dup", "modification_type": "duplicate_clock_signal", "modification_line": 10, "original_snippet": "(none)", "modified_snippet": "wire clk_dup;\n    assign clk_dup = clk;", "issue_description": "The buggy code has a duplicate clock signal. A phantom clock domain is created, which may confuse CDC analysis tools and create subtle timing issues in synthesis. This violates clock domain design best practices.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a duplicate_clock_signal modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added duplicate clock signal clk_dup\n   \u2022 Line 10: Original: (none)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 10.\n   \u2022 Restore the original code: (none)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to duplicate clock signal.", "complexity": 11, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["duplicate_clock_signal"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.712559", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "counter_12", "module_name": "counter_12", "description": "Please act as a professional verilog designer.\n\nImplement a module of a counter design that requires counting from 4 'b0000 to 4' d11. The counting can be controlled by the input signal valid_count. That is, the count is paused if valid_count is 0. The counter increments on each clock cycle when the valid_count signal is active and resets to 0 when the reset signal (rst_n) is active.\n\nModule name:  \n    counter_12               \nInput ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\nOutput ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nIf the reset signal is active (!rst_n), the counter is reset to 0 by assigning the value 4'b0000 to the output register (out). If the valid_count signal is 1, the counter increments. It checks if the current count value (out) is equal to 4'd11 (maximum count value). If it is, the counter wraps around and resets to 0 by assigning the value 4'b0000 to the output register (out). Otherwise, it increments the output register by 1. If the valid_count = 0, the counter will stop, and the output register (out) remains unchanged.\n\nGive me the complete code.\n\n"}, "clean_code": "`timescale 1ns/1ps\nmodule counter_12 \n(\n  input rst_n,\n  input clk,\n  input valid_count,\n\n  output reg [3:0] out\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) \n\tbegin\n      out <= 4'b0000;\n    end \n\n\telse if (valid_count) \n\tbegin\n      if (out == 4'd11) \n\t  begin\n        out <= 4'b0000;\n      end \n\t  else begin\n        out <= out + 1;\n      end\n    end \n\t\n\telse begin\n      out <= out; // Pause the count when valid_count is invalid\n    end\n  end\n\nendmodule\n", "corrupted_code": "`timescale 1ns/1ps\nmodule counter_12 \n(\n  input rst_n,\n  input clk,\n  input valid_count,\n\n  output reg [3:0] out\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) \n\tbegin\n      out <= 4'b0000;\n    end \n\n\telse if (valid_count) \n\tbegin\n      if (out == 4'd11) \n\t  begin\n        out <= 4'b0000;\n      end\n    end \n\t\n\telse begin\n      out <= out; // Pause the count when valid_count is invalid\n    end\n  end\n\nendmodule\n", "corruption_explanation": "Removed else branch (may cause latch inference)", "modification_type": "remove_else_branch", "modification_line": 12, "original_snippet": "if (!rst_n) \n\tbegin\n      out <= 4'b0000;\n    end \n\n\telse if (valid_count) \n\tbegin\n      if (out == 4'd11) \n\t  begin\n        out <= 4'b0000;\n      end \n\t  else begin\n        out <= out + 1;\n      end", "modified_snippet": "if (!rst_n) \n\tbegin\n      out <= 4'b0000;\n    end \n\n\telse if (valid_count) \n\tbegin\n      if (out == 4'd11) \n\t  begin\n        out <= 4'b0000;\n      end", "issue_description": "The buggy code is missing an else branch in a conditional statement. In combinational logic (always_comb or always @*), this can cause latch inference because the output is not defined for all input conditions. In sequential logic, signals may retain old values unexpectedly. This violates RTL design best practices requiring complete conditional assignments.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module should provide a complete conditional assignment to avoid latch inference.\n   \u2022 Combinational logic must define outputs for all input conditions.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an if statement without an else branch.\n   \u2022 The assigned signal is not defined when the condition is false.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The else branch has been removed from the conditional.\n   \u2022 This creates an incomplete conditional assignment.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Missing else branch leaves the signal undefined in some cases.\n   \u2022 Impact: Latch inference in combinational blocks, or stale values in sequential blocks.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Add an else branch with appropriate default or alternative assignment.\n   \u2022 Ensure all signals are assigned in all branches of the conditional.\n\n6. RTL Design Principle Violated:\n   \u2022 Combinational logic must have complete assignments to avoid latch inference.\n   \u2022 All conditional blocks should have else clauses or default values.", "complexity": 11, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_else_branch"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.713268", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "counter_12", "module_name": "counter_12", "description": "Please act as a professional verilog designer.\n\nImplement a module of a counter design that requires counting from 4 'b0000 to 4' d11. The counting can be controlled by the input signal valid_count. That is, the count is paused if valid_count is 0. The counter increments on each clock cycle when the valid_count signal is active and resets to 0 when the reset signal (rst_n) is active.\n\nModule name:  \n    counter_12               \nInput ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\nOutput ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nIf the reset signal is active (!rst_n), the counter is reset to 0 by assigning the value 4'b0000 to the output register (out). If the valid_count signal is 1, the counter increments. It checks if the current count value (out) is equal to 4'd11 (maximum count value). If it is, the counter wraps around and resets to 0 by assigning the value 4'b0000 to the output register (out). Otherwise, it increments the output register by 1. If the valid_count = 0, the counter will stop, and the output register (out) remains unchanged.\n\nGive me the complete code.\n\n"}, "clean_code": "`timescale 1ns/1ps\nmodule counter_12 \n(\n  input rst_n,\n  input clk,\n  input valid_count,\n\n  output reg [3:0] out\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) \n\tbegin\n      out <= 4'b0000;\n    end \n\n\telse if (valid_count) \n\tbegin\n      if (out == 4'd11) \n\t  begin\n        out <= 4'b0000;\n      end \n\t  else begin\n        out <= out + 1;\n      end\n    end \n\t\n\telse begin\n      out <= out; // Pause the count when valid_count is invalid\n    end\n  end\n\nendmodule\n", "corrupted_code": "`timescale 1ns/1ps\nmodule counter_12 \n(\n  input rst_n,\n  input clk,\n  input valid_count,\n\n  output reg [3:0] out\n);\n\n  always @(posedge clk or posedge rst_n) begin\n    if (!rst_n) \n\tbegin\n      out <= 4'b0000;\n    end \n\n\telse if (valid_count) \n\tbegin\n      if (out == 4'd11) \n\t  begin\n        out <= 4'b0000;\n      end \n\t  else begin\n        out <= out + 1;\n      end\n    end \n\t\n\telse begin\n      out <= out; // Pause the count when valid_count is invalid\n    end\n  end\n\nendmodule\n", "corruption_explanation": "Inverted reset polarity in sensitivity", "modification_type": "invert_reset_polarity", "modification_line": 11, "original_snippet": "always @(posedge clk or negedge rst_n)", "modified_snippet": "always @(posedge clk or posedge rst_n)", "issue_description": "The buggy code has inverted reset polarity. If the design expects active-low reset (!rst), it now uses active-high, or vice versa. This causes the reset logic to activate during normal operation and deactivate during actual reset, breaking initialization.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_reset_polarity modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted reset polarity in sensitivity\n   \u2022 Line 11: Original: always @(posedge clk or negedge rst_n)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 11.\n   \u2022 Restore the original code: always @(posedge clk or negedge rst_n)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert reset polarity.", "complexity": 11, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_reset_polarity"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.713986", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "ring_counter", "module_name": "ring_counter", "description": "Please act as a professional Verilog designer.\n\nImplement a module of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\nring_counter\n\nInput ports:\n        clk: Clock signal that drives the state transitions of the ring counter.\n        reset: Reset signal to initialize the counter to its starting state.\n\nOutput ports:\n        out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\n1. State Transition: The ring counter follows a cyclic pattern where exactly one bit is set to 1 in the output at any given time, and the 1 shifts to the next bit with each clock pulse.\n   \n2. Initialization: When the reset signal is high, the counter is initialized to its starting state, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\n\n3. Cycling Behavior: On each rising edge of the clock signal, the 1 shifts to the next bit in the sequence, and after reaching the most significant bit (MSB), it wraps around to the LSB, creating a cyclic sequence.\n\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code."}, "clean_code": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n\nreg [7:0] state;\n\n// State initialization\nalways @ (posedge clk or posedge reset)\nbegin\n    if (reset)\n        state <= 8'b0000_0001; \n    else\n        state <= {state[6:0], state[7]}; \nend\n\nassign out = state;\n\nendmodule\n\n\n", "corrupted_code": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n\nreg [7:0] state;\n\n// State initialization\n\n\nassign out = state;\n\nendmodule\n\n\n", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 11, "original_snippet": "always @ (posedge clk or posedge reset)\nbegin\n    if (reset)\n        state <= 8'b0000_0001; \n    else\n        state <= {state[6:0], state[7]}; \nend", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 11: Original: always @ (posedge clk or posedge reset)\nbegin\n    if (reset)\n        state <= 8'b0000_0001; \n    else\n        state <= {state[6:0], state[7]}; \nend\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 11.\n   \u2022 Restore the original code: always @ (posedge clk or posedge reset)\nbegin\n    if (reset)\n        state <= 8'b0000_0001; \n    else\n        state <= {state[6:0], state[7]}; \nend\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.715671", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "ring_counter", "module_name": "ring_counter", "description": "Please act as a professional Verilog designer.\n\nImplement a module of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\nring_counter\n\nInput ports:\n        clk: Clock signal that drives the state transitions of the ring counter.\n        reset: Reset signal to initialize the counter to its starting state.\n\nOutput ports:\n        out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\n1. State Transition: The ring counter follows a cyclic pattern where exactly one bit is set to 1 in the output at any given time, and the 1 shifts to the next bit with each clock pulse.\n   \n2. Initialization: When the reset signal is high, the counter is initialized to its starting state, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\n\n3. Cycling Behavior: On each rising edge of the clock signal, the 1 shifts to the next bit in the sequence, and after reaching the most significant bit (MSB), it wraps around to the LSB, creating a cyclic sequence.\n\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code."}, "clean_code": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n\nreg [7:0] state;\n\n// State initialization\nalways @ (posedge clk or posedge reset)\nbegin\n    if (reset)\n        state <= 8'b0000_0001; \n    else\n        state <= {state[6:0], state[7]}; \nend\n\nassign out = state;\n\nendmodule\n\n\n", "corrupted_code": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n\nreg [7:0] state;\n\n// State initialization\nalways @ (posedge clk or posedge reset)\nbegin\n    if (reset)\n        state <= 8'b0000_0001; \n    else\n        state <= {state[6:0], state[7]}; \nend\n\nassign out = state;\nassign out = 1'b0;  // Conflicting assignment\n\nendmodule\n\n\n", "corruption_explanation": "Added conflicting driver for signal 'out'", "modification_type": "add_multiple_driver", "modification_line": 18, "original_snippet": "assign out = state;", "modified_snippet": "assign out = state;\nassign out = 1'b0;  // Conflicting assignment", "issue_description": "The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_multiple_driver modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added conflicting driver for signal 'out'\n   \u2022 Line 18: Original: assign out = state;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 18.\n   \u2022 Restore the original code: assign out = state;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add multiple driver.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["add_multiple_driver"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.715996", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "ring_counter", "module_name": "ring_counter", "description": "Please act as a professional Verilog designer.\n\nImplement a module of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\nring_counter\n\nInput ports:\n        clk: Clock signal that drives the state transitions of the ring counter.\n        reset: Reset signal to initialize the counter to its starting state.\n\nOutput ports:\n        out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\n1. State Transition: The ring counter follows a cyclic pattern where exactly one bit is set to 1 in the output at any given time, and the 1 shifts to the next bit with each clock pulse.\n   \n2. Initialization: When the reset signal is high, the counter is initialized to its starting state, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\n\n3. Cycling Behavior: On each rising edge of the clock signal, the 1 shifts to the next bit in the sequence, and after reaching the most significant bit (MSB), it wraps around to the LSB, creating a cyclic sequence.\n\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code."}, "clean_code": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n\nreg [7:0] state;\n\n// State initialization\nalways @ (posedge clk or posedge reset)\nbegin\n    if (reset)\n        state <= 8'b0000_0001; \n    else\n        state <= {state[6:0], state[7]}; \nend\n\nassign out = state;\n\nendmodule\n\n\n", "corrupted_code": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n\nreg [7:0] state;\n\n// State initialization\nalways @ (posedge clk or posedge reset)\nbegin\n    if (reset)\n        state >= 8'b0000_0001; \n    else\n        state <= {state[6:0], state[7]}; \nend\n\nassign out = state;\n\nendmodule\n\n\n", "corruption_explanation": "Changed operator from '<=' to '>='", "modification_type": "change_operator", "modification_line": 14, "original_snippet": "e <= 8", "modified_snippet": "e >= 8", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '<=' to '>='\n   \u2022 Line 14: Original: e <= 8\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 14.\n   \u2022 Restore the original code: e <= 8\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.716799", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "ring_counter", "module_name": "ring_counter", "description": "Please act as a professional Verilog designer.\n\nImplement a module of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\nring_counter\n\nInput ports:\n        clk: Clock signal that drives the state transitions of the ring counter.\n        reset: Reset signal to initialize the counter to its starting state.\n\nOutput ports:\n        out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\n1. State Transition: The ring counter follows a cyclic pattern where exactly one bit is set to 1 in the output at any given time, and the 1 shifts to the next bit with each clock pulse.\n   \n2. Initialization: When the reset signal is high, the counter is initialized to its starting state, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\n\n3. Cycling Behavior: On each rising edge of the clock signal, the 1 shifts to the next bit in the sequence, and after reaching the most significant bit (MSB), it wraps around to the LSB, creating a cyclic sequence.\n\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code."}, "clean_code": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n\nreg [7:0] state;\n\n// State initialization\nalways @ (posedge clk or posedge reset)\nbegin\n    if (reset)\n        state <= 8'b0000_0001; \n    else\n        state <= {state[6:0], state[7]}; \nend\n\nassign out = state;\n\nendmodule\n\n\n", "corrupted_code": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n\nreg [7:0] state;\n\n// State initialization\nalways @ (posedge clk or posedge reset)\nbegin\n    if (reset)\n        state <= 8'b0000_0001; \n    else\n        state <= {state[6:0], state[7]}; \nend\n\nassign out = state;\nassign out = 1'b0;  // Conflicting assignment\n\nendmodule\n\n\n", "corruption_explanation": "Added conflicting driver for signal 'out'", "modification_type": "add_multiple_driver", "modification_line": 18, "original_snippet": "assign out = state;", "modified_snippet": "assign out = state;\nassign out = 1'b0;  // Conflicting assignment", "issue_description": "The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_multiple_driver modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added conflicting driver for signal 'out'\n   \u2022 Line 18: Original: assign out = state;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 18.\n   \u2022 Restore the original code: assign out = state;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add multiple driver.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["add_multiple_driver"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.717468", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "ring_counter", "module_name": "ring_counter", "description": "Please act as a professional Verilog designer.\n\nImplement a module of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\nring_counter\n\nInput ports:\n        clk: Clock signal that drives the state transitions of the ring counter.\n        reset: Reset signal to initialize the counter to its starting state.\n\nOutput ports:\n        out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\n1. State Transition: The ring counter follows a cyclic pattern where exactly one bit is set to 1 in the output at any given time, and the 1 shifts to the next bit with each clock pulse.\n   \n2. Initialization: When the reset signal is high, the counter is initialized to its starting state, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\n\n3. Cycling Behavior: On each rising edge of the clock signal, the 1 shifts to the next bit in the sequence, and after reaching the most significant bit (MSB), it wraps around to the LSB, creating a cyclic sequence.\n\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code."}, "clean_code": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n\nreg [7:0] state;\n\n// State initialization\nalways @ (posedge clk or posedge reset)\nbegin\n    if (reset)\n        state <= 8'b0000_0001; \n    else\n        state <= {state[6:0], state[7]}; \nend\n\nassign out = state;\n\nendmodule\n\n\n", "corrupted_code": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n\nreg [7:0] state;\n\n// State initialization\nalways @ (posedge clk or posedge reset)\nbegin\n    if (reset)\n        8 <= state'b0000_0001; \n    else\n        state <= {state[6:0], state[7]}; \nend\n\nassign out = state;\n\nendmodule\n\n\n", "corruption_explanation": "Swapped operands: 'state <= 8' -> '8 <= state'", "modification_type": "swap_operands", "modification_line": 14, "original_snippet": "state <= 8", "modified_snippet": "8 <= state", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'state <= 8' -> '8 <= state'\n   \u2022 Line 14: Original: state <= 8\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 14.\n   \u2022 Restore the original code: state <= 8\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_operands"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.717800", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "ring_counter", "module_name": "ring_counter", "description": "Please act as a professional Verilog designer.\n\nImplement a module of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\nring_counter\n\nInput ports:\n        clk: Clock signal that drives the state transitions of the ring counter.\n        reset: Reset signal to initialize the counter to its starting state.\n\nOutput ports:\n        out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\n1. State Transition: The ring counter follows a cyclic pattern where exactly one bit is set to 1 in the output at any given time, and the 1 shifts to the next bit with each clock pulse.\n   \n2. Initialization: When the reset signal is high, the counter is initialized to its starting state, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\n\n3. Cycling Behavior: On each rising edge of the clock signal, the 1 shifts to the next bit in the sequence, and after reaching the most significant bit (MSB), it wraps around to the LSB, creating a cyclic sequence.\n\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code."}, "clean_code": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n\nreg [7:0] state;\n\n// State initialization\nalways @ (posedge clk or posedge reset)\nbegin\n    if (reset)\n        state <= 8'b0000_0001; \n    else\n        state <= {state[6:0], state[7]}; \nend\n\nassign out = state;\n\nendmodule\n\n\n", "corrupted_code": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n\nreg [7:0] state;\n\n// State initialization\nalways @(posedge clk)\nbegin\n    if (reset)\n        state <= 8'b0000_0001; \n    else\n        state <= {state[6:0], state[7]}; \nend\n\nassign out = state;\n\nendmodule\n\n\n", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 11, "original_snippet": "always @ (posedge clk or posedge reset)", "modified_snippet": "always @(posedge clk)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 11: Original: always @ (posedge clk or posedge reset)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 11.\n   \u2022 Restore the original code: always @ (posedge clk or posedge reset)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_sensitivity_list"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.718109", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "ring_counter", "module_name": "ring_counter", "description": "Please act as a professional Verilog designer.\n\nImplement a module of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\nring_counter\n\nInput ports:\n        clk: Clock signal that drives the state transitions of the ring counter.\n        reset: Reset signal to initialize the counter to its starting state.\n\nOutput ports:\n        out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\n1. State Transition: The ring counter follows a cyclic pattern where exactly one bit is set to 1 in the output at any given time, and the 1 shifts to the next bit with each clock pulse.\n   \n2. Initialization: When the reset signal is high, the counter is initialized to its starting state, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\n\n3. Cycling Behavior: On each rising edge of the clock signal, the 1 shifts to the next bit in the sequence, and after reaching the most significant bit (MSB), it wraps around to the LSB, creating a cyclic sequence.\n\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code."}, "clean_code": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n\nreg [7:0] state;\n\n// State initialization\nalways @ (posedge clk or posedge reset)\nbegin\n    if (reset)\n        state <= 8'b0000_0001; \n    else\n        state <= {state[6:0], state[7]}; \nend\n\nassign out = state;\n\nendmodule\n\n\n", "corrupted_code": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n\nreg [7:0] state;\n\n// State initialization\nalways @ (posedge clk or posedge reset)\nbegin\n    if (reset)\n        8 <= state'b0000_0001; \n    else\n        state <= {state[6:0], state[7]}; \nend\n\nassign out = state;\n\nendmodule\n\n\n", "corruption_explanation": "Swapped operands: 'state <= 8' -> '8 <= state'", "modification_type": "swap_operands", "modification_line": 14, "original_snippet": "state <= 8", "modified_snippet": "8 <= state", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'state <= 8' -> '8 <= state'\n   \u2022 Line 14: Original: state <= 8\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 14.\n   \u2022 Restore the original code: state <= 8\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_operands"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.718441", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "ring_counter", "module_name": "ring_counter", "description": "Please act as a professional Verilog designer.\n\nImplement a module of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\nring_counter\n\nInput ports:\n        clk: Clock signal that drives the state transitions of the ring counter.\n        reset: Reset signal to initialize the counter to its starting state.\n\nOutput ports:\n        out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\n1. State Transition: The ring counter follows a cyclic pattern where exactly one bit is set to 1 in the output at any given time, and the 1 shifts to the next bit with each clock pulse.\n   \n2. Initialization: When the reset signal is high, the counter is initialized to its starting state, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\n\n3. Cycling Behavior: On each rising edge of the clock signal, the 1 shifts to the next bit in the sequence, and after reaching the most significant bit (MSB), it wraps around to the LSB, creating a cyclic sequence.\n\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code."}, "clean_code": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n\nreg [7:0] state;\n\n// State initialization\nalways @ (posedge clk or posedge reset)\nbegin\n    if (reset)\n        state <= 8'b0000_0001; \n    else\n        state <= {state[6:0], state[7]}; \nend\n\nassign out = state;\n\nendmodule\n\n\n", "corrupted_code": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n\n\nreg [7:0] state;\n\n// State initialization\nalways @ (posedge clk or posedge reset)\nbegin\n    if (reset)\n        state <= 8'b0000_0001; \n    else\n        state <= {state[6:0], state[7]}; \nend\n\nassign out = state;\n\n\n    wire clk_dup;\n    assign clk_dup = clk;\nendmodule\n\n\n", "corruption_explanation": "Added duplicate clock signal clk_dup", "modification_type": "duplicate_clock_signal", "modification_line": 7, "original_snippet": "(none)", "modified_snippet": "wire clk_dup;\n    assign clk_dup = clk;", "issue_description": "The buggy code has a duplicate clock signal. A phantom clock domain is created, which may confuse CDC analysis tools and create subtle timing issues in synthesis. This violates clock domain design best practices.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a duplicate_clock_signal modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added duplicate clock signal clk_dup\n   \u2022 Line 7: Original: (none)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 7.\n   \u2022 Restore the original code: (none)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to duplicate clock signal.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["duplicate_clock_signal"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.718752", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "JC_counter", "module_name": "JC_counter", "description": "Please act as a professional verilog designer.\n\nImplement a 64-bit Johnson counter (torsional ring counter), and the state of the similar 4-bit Johnson counter example is as follows: 0000, 1000, 1100, 1110, 1111, 0111, 0011, 0001, 0000.\n\nModule name:  \n    JC_counter               \nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal to initialize the counter.\nOutput port:\n    Q: 64-bit register representing the current count value.\n\nImplementation:\nOn every rising edge of the clock signal (clk) or the falling edge of the reset signal (rst_n), the counter value is updated.\nIf the reset signal (rst_n) is low, indicating a reset condition, the counter value (Q) is set to 0.\nOtherwise, if the least significant bit (Q[0]) is 0, the counter increments by shifting the current value (Q[63:1]) to the right and appending a 1 at the most significant bit position.\nIf the least significant bit (Q[0]) is 1, the counter decrements by shifting the current value (Q[63:1]) to the right and appending a 0 at the most significant bit position.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\nmodule JC_counter(\n   input                clk ,\n   input                rst_n,\n \n   output reg [63:0]     Q  \n);\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) Q <= 'd0;\n        else if(!Q[0]) Q <= {1'b1, Q[63 : 1]};\n        else Q <= {1'b0, Q[63 : 1]};\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns/1ns\n\nmodule JC_counter(\n   input                clk ,\n   input                rst_n,\n \n   output reg [63:0]     Q  \n);\n    always @(clk or negedge rst_n)begin\n        if(!rst_n) Q <= 'd0;\n        else if(!Q[0]) Q <= {1'b1, Q[63 : 1]};\n        else Q <= {1'b0, Q[63 : 1]};\n    end\nendmodule\n", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 9, "original_snippet": "always@(posedge clk or negedge rst_n)", "modified_snippet": "always @(clk or negedge rst_n)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 9: Original: always@(posedge clk or negedge rst_n)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 9.\n   \u2022 Restore the original code: always@(posedge clk or negedge rst_n)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_sensitivity_list"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.721144", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "JC_counter", "module_name": "JC_counter", "description": "Please act as a professional verilog designer.\n\nImplement a 64-bit Johnson counter (torsional ring counter), and the state of the similar 4-bit Johnson counter example is as follows: 0000, 1000, 1100, 1110, 1111, 0111, 0011, 0001, 0000.\n\nModule name:  \n    JC_counter               \nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal to initialize the counter.\nOutput port:\n    Q: 64-bit register representing the current count value.\n\nImplementation:\nOn every rising edge of the clock signal (clk) or the falling edge of the reset signal (rst_n), the counter value is updated.\nIf the reset signal (rst_n) is low, indicating a reset condition, the counter value (Q) is set to 0.\nOtherwise, if the least significant bit (Q[0]) is 0, the counter increments by shifting the current value (Q[63:1]) to the right and appending a 1 at the most significant bit position.\nIf the least significant bit (Q[0]) is 1, the counter decrements by shifting the current value (Q[63:1]) to the right and appending a 0 at the most significant bit position.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\nmodule JC_counter(\n   input                clk ,\n   input                rst_n,\n \n   output reg [63:0]     Q  \n);\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) Q <= 'd0;\n        else if(!Q[0]) Q <= {1'b1, Q[63 : 1]};\n        else Q <= {1'b0, Q[63 : 1]};\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns/1ns\n\nmodule JC_counter(\n   input                clk ,\n   input                rst_n,\n \n   output reg [63:0]     Q  \n);\n    \nendmodule\n", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 9, "original_snippet": "always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) Q <= 'd0;\n        else if(!Q[0]) Q <= {1'b1, Q[63 : 1]};\n        else Q <= {1'b0, Q[63 : 1]};\n    end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 9: Original: always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) Q <= 'd0;\n        else if(!Q[0]) Q <= {1'b1, Q[63 : 1]};\n        else Q <= {1'b0, Q[63 : 1]};\n    end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 9.\n   \u2022 Restore the original code: always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) Q <= 'd0;\n        else if(!Q[0]) Q <= {1'b1, Q[63 : 1]};\n        else Q <= {1'b0, Q[63 : 1]};\n    end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.721949", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "JC_counter", "module_name": "JC_counter", "description": "Please act as a professional verilog designer.\n\nImplement a 64-bit Johnson counter (torsional ring counter), and the state of the similar 4-bit Johnson counter example is as follows: 0000, 1000, 1100, 1110, 1111, 0111, 0011, 0001, 0000.\n\nModule name:  \n    JC_counter               \nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal to initialize the counter.\nOutput port:\n    Q: 64-bit register representing the current count value.\n\nImplementation:\nOn every rising edge of the clock signal (clk) or the falling edge of the reset signal (rst_n), the counter value is updated.\nIf the reset signal (rst_n) is low, indicating a reset condition, the counter value (Q) is set to 0.\nOtherwise, if the least significant bit (Q[0]) is 0, the counter increments by shifting the current value (Q[63:1]) to the right and appending a 1 at the most significant bit position.\nIf the least significant bit (Q[0]) is 1, the counter decrements by shifting the current value (Q[63:1]) to the right and appending a 0 at the most significant bit position.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\nmodule JC_counter(\n   input                clk ,\n   input                rst_n,\n \n   output reg [63:0]     Q  \n);\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) Q <= 'd0;\n        else if(!Q[0]) Q <= {1'b1, Q[63 : 1]};\n        else Q <= {1'b0, Q[63 : 1]};\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns/1ns\n\nmodule JC_counter(\n   input                clk ,\n   input                rst_n,\n \n   output reg [63:0]     Q  \n);\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) Q <= 'd0;\n        else if(!Q[0]) Q <= {1'b1, Q[63 : 1]};\n        else Q = {1'b0, Q[63 : 1]};\n    end\nendmodule\n", "corruption_explanation": "Changed non-blocking (<=) to blocking (=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 12, "original_snippet": "Q <= {1'b0, Q[63 : 1]};", "modified_snippet": "Q = {1'b0, Q[63 : 1]};", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.722460", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "JC_counter", "module_name": "JC_counter", "description": "Please act as a professional verilog designer.\n\nImplement a 64-bit Johnson counter (torsional ring counter), and the state of the similar 4-bit Johnson counter example is as follows: 0000, 1000, 1100, 1110, 1111, 0111, 0011, 0001, 0000.\n\nModule name:  \n    JC_counter               \nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal to initialize the counter.\nOutput port:\n    Q: 64-bit register representing the current count value.\n\nImplementation:\nOn every rising edge of the clock signal (clk) or the falling edge of the reset signal (rst_n), the counter value is updated.\nIf the reset signal (rst_n) is low, indicating a reset condition, the counter value (Q) is set to 0.\nOtherwise, if the least significant bit (Q[0]) is 0, the counter increments by shifting the current value (Q[63:1]) to the right and appending a 1 at the most significant bit position.\nIf the least significant bit (Q[0]) is 1, the counter decrements by shifting the current value (Q[63:1]) to the right and appending a 0 at the most significant bit position.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\nmodule JC_counter(\n   input                clk ,\n   input                rst_n,\n \n   output reg [63:0]     Q  \n);\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) Q <= 'd0;\n        else if(!Q[0]) Q <= {1'b1, Q[63 : 1]};\n        else Q <= {1'b0, Q[63 : 1]};\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns/1ns\n\nmodule JC_counter(\n   input                clk ,\n   input                rst_n,\n \n   output reg [63:0]     Q  \n);\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) Q <= 'd0;\n        else if(!Q[0]) Q = {1'b1, Q[63 : 1]};\n        else Q <= {1'b0, Q[63 : 1]};\n    end\nendmodule\n", "corruption_explanation": "Changed non-blocking (<=) to blocking (=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 11, "original_snippet": "Q <= {1'b1, Q[63 : 1]};", "modified_snippet": "Q = {1'b1, Q[63 : 1]};", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.723356", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "JC_counter", "module_name": "JC_counter", "description": "Please act as a professional verilog designer.\n\nImplement a 64-bit Johnson counter (torsional ring counter), and the state of the similar 4-bit Johnson counter example is as follows: 0000, 1000, 1100, 1110, 1111, 0111, 0011, 0001, 0000.\n\nModule name:  \n    JC_counter               \nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal to initialize the counter.\nOutput port:\n    Q: 64-bit register representing the current count value.\n\nImplementation:\nOn every rising edge of the clock signal (clk) or the falling edge of the reset signal (rst_n), the counter value is updated.\nIf the reset signal (rst_n) is low, indicating a reset condition, the counter value (Q) is set to 0.\nOtherwise, if the least significant bit (Q[0]) is 0, the counter increments by shifting the current value (Q[63:1]) to the right and appending a 1 at the most significant bit position.\nIf the least significant bit (Q[0]) is 1, the counter decrements by shifting the current value (Q[63:1]) to the right and appending a 0 at the most significant bit position.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\nmodule JC_counter(\n   input                clk ,\n   input                rst_n,\n \n   output reg [63:0]     Q  \n);\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) Q <= 'd0;\n        else if(!Q[0]) Q <= {1'b1, Q[63 : 1]};\n        else Q <= {1'b0, Q[63 : 1]};\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns/1ns\n\nmodule JC_counter(\n   input                clk ,\n   input                rst_n,\n \n   output reg [63:0]     Q  \n);\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) Q <= 'd0;\n        else if(!Q[0]) Q <= {1'b1, Q[63 : 1]};\n        else Q <= {1'b0, Q[63 : 1]};\n    end\n\n    wire clk_dup;\n    assign clk_dup = clk;\nendmodule\n", "corruption_explanation": "Added duplicate clock signal clk_dup", "modification_type": "duplicate_clock_signal", "modification_line": 7, "original_snippet": "(none)", "modified_snippet": "wire clk_dup;\n    assign clk_dup = clk;", "issue_description": "The buggy code has a duplicate clock signal. A phantom clock domain is created, which may confuse CDC analysis tools and create subtle timing issues in synthesis. This violates clock domain design best practices.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a duplicate_clock_signal modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added duplicate clock signal clk_dup\n   \u2022 Line 7: Original: (none)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 7.\n   \u2022 Restore the original code: (none)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to duplicate clock signal.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["duplicate_clock_signal"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.723808", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Counter", "design_name": "JC_counter", "module_name": "JC_counter", "description": "Please act as a professional verilog designer.\n\nImplement a 64-bit Johnson counter (torsional ring counter), and the state of the similar 4-bit Johnson counter example is as follows: 0000, 1000, 1100, 1110, 1111, 0111, 0011, 0001, 0000.\n\nModule name:  \n    JC_counter               \nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal to initialize the counter.\nOutput port:\n    Q: 64-bit register representing the current count value.\n\nImplementation:\nOn every rising edge of the clock signal (clk) or the falling edge of the reset signal (rst_n), the counter value is updated.\nIf the reset signal (rst_n) is low, indicating a reset condition, the counter value (Q) is set to 0.\nOtherwise, if the least significant bit (Q[0]) is 0, the counter increments by shifting the current value (Q[63:1]) to the right and appending a 1 at the most significant bit position.\nIf the least significant bit (Q[0]) is 1, the counter decrements by shifting the current value (Q[63:1]) to the right and appending a 0 at the most significant bit position.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\nmodule JC_counter(\n   input                clk ,\n   input                rst_n,\n \n   output reg [63:0]     Q  \n);\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) Q <= 'd0;\n        else if(!Q[0]) Q <= {1'b1, Q[63 : 1]};\n        else Q <= {1'b0, Q[63 : 1]};\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns / 1ns\n\nmodule JC_counter(\n   input                clk ,\n   input                rst_n,\n \n   output reg [63:0]     Q  \n);\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) Q <= 'd0;\n        else if(!Q[0]) Q <= {1'b1, Q[63 : 1]};\n        else Q <= {1'b0, Q[63 : 1]};\n    end\nendmodule\n", "corruption_explanation": "Swapped operands: '1ns / 1ns' -> '1ns / 1ns'", "modification_type": "swap_operands", "modification_line": 1, "original_snippet": "1ns/1ns", "modified_snippet": "1ns / 1ns", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: '1ns / 1ns' -> '1ns / 1ns'\n   \u2022 Line 1: Original: 1ns/1ns\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 1.\n   \u2022 Restore the original code: 1ns/1ns\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_operands"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.724285", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Finite State Machine", "design_name": "fsm", "module_name": "fsm", "description": "Please act as a professional verilog designer.\n\nImplement a Mealy FSM detection circuit that detects a single-bit input IN. When the input is 10011, output MATCH is 1, and MATCH is 0 in other cases. Support for continuous input and loop detection. \n\nModule name:  \n    fsm               \nInput ports:\n    IN: Input signal to the FSM.\n    CLK: Clock signal used for synchronous operation.\n    RST: Reset signal to initialize the FSM.\nOutput ports:\n    MATCH: Output signal indicating a match condition based on the FSM state.\n\nImplementation:\nThe module implements an FSM detection.\nOn every change in the input signal (IN) or positive edge of CLK or RST, if RST is active, the output signal MATCH is set to 0.\nIf the sequence of inputs IN is 1, 0, 0, 1, 1, the MATCH signal is 1 at the same time as the last occurrence of IN=1. If the sequence of inputs IN is 1, 0, 0, 1, 1, 0, 0, 1, 1, the MATCH signal becomes 1 at the fifth and ninth of IN; otherwise, it is set to 0.\n\nGive me the complete code.\n"}, "clean_code": "module fsm(IN,MATCH,CLK,RST);\ninput IN,CLK,RST;\noutput reg MATCH;\n\nreg [2:0] ST_cr,ST_nt;\n\nparameter s0 = 3'b000;\nparameter s1 = 3'b001;\nparameter s2 = 3'b010;\nparameter s3 = 3'b011;\nparameter s4 = 3'b100;\nparameter s5 = 3'b101;\n\nalways@(posedge CLK or posedge RST) begin\n\tif(RST)\n\t\tST_cr <= s0;\n\telse\n\t\tST_cr <= ST_nt;\nend\n\nalways@(*) begin\n\tcase(ST_cr)\n\t\ts0:begin\n\t\t\tif (IN==0)\n\t\t\t\tST_nt = s0;\n\t\t\telse\n\t\t\t\tST_nt = s1;\n\t\tend\n\t\t\n\t\ts1:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s1;\n                end\n\n                s2:begin\n                        if (IN==0)\n                                ST_nt = s3;\n                        else\n                                ST_nt = s1;\n                end\n\n                s3:begin\n                        if (IN==0)\n                                ST_nt = s0;\n                        else\n                                ST_nt = s4;\n                end\n\n                s4:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s5;\n                end\n\n                s5:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s1;\n                end\n\n\tendcase\nend\n\nalways@(*) begin\n        if(RST)\n                MATCH  <= 0;\n        else if (ST_cr == s4 && IN == 1)\n                MATCH  <= 1;\n\telse \n\t\tMATCH  <= 0;\nend\n\nendmodule", "corrupted_code": "module fsm(IN,MATCH,CLK,RST);\ninput IN,CLK,RST;\noutput reg MATCH;\n\nreg [2:0] ST_cr,ST_nt;\n\nparameter s0 = 3'b000;\nparameter s1 = 3'b001;\nparameter s2 = 3'b010;\nparameter s3 = 3'b011;\nparameter s4 = 3'b100;\nparameter s5 = 3'b101;\n\nalways@(posedge CLK or posedge RST) begin\n\tif(RST)\n\t\tST_cr <= s0;\n\telse\n\t\tST_cr <= ST_nt;\nend\n\nalways@(*) begin\n\tcase(ST_cr)\n\t\ts0:begin\n\t\t\tif (IN==0)\n\t\t\t\tST_nt = s0;\n\t\t\telse\n\t\t\t\tST_nt = s1;\n\t\tend\n\n                s2:begin\n                        if (IN==0)\n                                ST_nt = s3;\n                        else\n                                ST_nt = s1;\n                end\n\n                s4:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s5;\n                end\n\n                s5:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s1;\n                end\n\n\t\n\n                s3:begin\n                        if (IN==0)\n                                ST_nt = s0;\n                        else\n                                ST_nt = s4;\n                end\n\t\t\n\t\ts1:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s1;\n                endendcase\nend\n\nalways@(*) begin\n        if(RST)\n                MATCH  <= 0;\n        else if (ST_cr == s4 && IN == 1)\n                MATCH  <= 1;\n\telse \n\t\tMATCH  <= 0;\nend\n\nendmodule", "corruption_explanation": "Shuffled case items order", "modification_type": "shuffle_case_items", "modification_line": 22, "original_snippet": "case(ST_cr)\n\t\ts0:begin\n\t\t\tif (IN==0)\n\t\t\t\tST_nt = s0;\n\t\t\telse\n\t\t\t\tST_nt = s1;\n\t\tend\n\t\t\n\t\ts1:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        ", "modified_snippet": "case(ST_cr)\n\t\ts0:begin\n\t\t\tif (IN==0)\n\t\t\t\tST_nt = s0;\n\t\t\telse\n\t\t\t\tST_nt = s1;\n\t\tend\n\n                s2:begin\n                        if (IN==0)\n                                ST_nt = s3;\n            ", "issue_description": "The buggy code has reordered case items in a case statement. For priority-encoded case statements (casex, casez), the order matters. Reordering breaks the intended priority, causing incorrect item matching. Test cases may pass for some inputs but fail for overlapping patterns.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a shuffle_case_items modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Shuffled case items order\n   \u2022 Line 22: Original: case(ST_cr)\n\t\ts0:begin\n\t\t\tif (IN==0)\n\t\t\t\tST_nt = s0;\n\t\t\telse\n\t\t\t\tST_nt = s1;\n\t\tend\n\t\t\n\t\ts1:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        \n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 22.\n   \u2022 Restore the original code: case(ST_cr)\n\t\ts0:begin\n\t\t\tif (IN==0)\n\t\t\t\tST_nt = s0;\n\t\t\telse\n\t\t\t\tST_nt = s1;\n\t\tend\n\t\t\n\t\ts1:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        \n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to shuffle case items.", "complexity": 18, "applicable_modifications": ["remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["shuffle_case_items"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.727588", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Finite State Machine", "design_name": "fsm", "module_name": "fsm", "description": "Please act as a professional verilog designer.\n\nImplement a Mealy FSM detection circuit that detects a single-bit input IN. When the input is 10011, output MATCH is 1, and MATCH is 0 in other cases. Support for continuous input and loop detection. \n\nModule name:  \n    fsm               \nInput ports:\n    IN: Input signal to the FSM.\n    CLK: Clock signal used for synchronous operation.\n    RST: Reset signal to initialize the FSM.\nOutput ports:\n    MATCH: Output signal indicating a match condition based on the FSM state.\n\nImplementation:\nThe module implements an FSM detection.\nOn every change in the input signal (IN) or positive edge of CLK or RST, if RST is active, the output signal MATCH is set to 0.\nIf the sequence of inputs IN is 1, 0, 0, 1, 1, the MATCH signal is 1 at the same time as the last occurrence of IN=1. If the sequence of inputs IN is 1, 0, 0, 1, 1, 0, 0, 1, 1, the MATCH signal becomes 1 at the fifth and ninth of IN; otherwise, it is set to 0.\n\nGive me the complete code.\n"}, "clean_code": "module fsm(IN,MATCH,CLK,RST);\ninput IN,CLK,RST;\noutput reg MATCH;\n\nreg [2:0] ST_cr,ST_nt;\n\nparameter s0 = 3'b000;\nparameter s1 = 3'b001;\nparameter s2 = 3'b010;\nparameter s3 = 3'b011;\nparameter s4 = 3'b100;\nparameter s5 = 3'b101;\n\nalways@(posedge CLK or posedge RST) begin\n\tif(RST)\n\t\tST_cr <= s0;\n\telse\n\t\tST_cr <= ST_nt;\nend\n\nalways@(*) begin\n\tcase(ST_cr)\n\t\ts0:begin\n\t\t\tif (IN==0)\n\t\t\t\tST_nt = s0;\n\t\t\telse\n\t\t\t\tST_nt = s1;\n\t\tend\n\t\t\n\t\ts1:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s1;\n                end\n\n                s2:begin\n                        if (IN==0)\n                                ST_nt = s3;\n                        else\n                                ST_nt = s1;\n                end\n\n                s3:begin\n                        if (IN==0)\n                                ST_nt = s0;\n                        else\n                                ST_nt = s4;\n                end\n\n                s4:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s5;\n                end\n\n                s5:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s1;\n                end\n\n\tendcase\nend\n\nalways@(*) begin\n        if(RST)\n                MATCH  <= 0;\n        else if (ST_cr == s4 && IN == 1)\n                MATCH  <= 1;\n\telse \n\t\tMATCH  <= 0;\nend\n\nendmodule", "corrupted_code": "module fsm(IN,MATCH,CLK,RST);\ninput IN,CLK,RST;\noutput reg MATCH;\n\nreg [2:0] ST_cr,ST_nt;\n\nparameter s0 = 3'b001;\nparameter s1 = 3'b000;\nparameter s2 = 3'b010;\nparameter s3 = 3'b011;\nparameter s4 = 3'b100;\nparameter s5 = 3'b101;\n\nalways@(posedge CLK or posedge RST) begin\n\tif(RST)\n\t\tST_cr <= s0;\n\telse\n\t\tST_cr <= ST_nt;\nend\n\nalways@(*) begin\n\tcase(ST_cr)\n\t\ts0:begin\n\t\t\tif (IN==0)\n\t\t\t\tST_nt = s0;\n\t\t\telse\n\t\t\t\tST_nt = s1;\n\t\tend\n\t\t\n\t\ts1:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s1;\n                end\n\n                s2:begin\n                        if (IN==0)\n                                ST_nt = s3;\n                        else\n                                ST_nt = s1;\n                end\n\n                s3:begin\n                        if (IN==0)\n                                ST_nt = s0;\n                        else\n                                ST_nt = s4;\n                end\n\n                s4:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s5;\n                end\n\n                s5:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s1;\n                end\n\n\tendcase\nend\n\nalways@(*) begin\n        if(RST)\n                MATCH  <= 0;\n        else if (ST_cr == s4 && IN == 1)\n                MATCH  <= 1;\n\telse \n\t\tMATCH  <= 0;\nend\n\nendmodule", "corruption_explanation": "Swapped state encodings: s0=3'b000<->s1=3'b001", "modification_type": "swap_state_encoding", "modification_line": 7, "original_snippet": "parameter s0 = 3'b000, parameter s1 = 3'b001", "modified_snippet": "parameter s0 = 3'b001, parameter s1 = 3'b000", "issue_description": "The buggy code has swapped FSM state encoding values. Two states have exchanged their binary encodings, causing the FSM to enter the wrong state after transitions. This breaks the state machine behavior for all paths involving these states.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_state_encoding modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped state encodings: s0=3'b000<->s1=3'b001\n   \u2022 Line 7: Original: parameter s0 = 3'b000, parameter s1 = 3'b001\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 7.\n   \u2022 Restore the original code: parameter s0 = 3'b000, parameter s1 = 3'b001\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap state encoding.", "complexity": 18, "applicable_modifications": ["remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_state_encoding"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.733431", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Finite State Machine", "design_name": "fsm", "module_name": "fsm", "description": "Please act as a professional verilog designer.\n\nImplement a Mealy FSM detection circuit that detects a single-bit input IN. When the input is 10011, output MATCH is 1, and MATCH is 0 in other cases. Support for continuous input and loop detection. \n\nModule name:  \n    fsm               \nInput ports:\n    IN: Input signal to the FSM.\n    CLK: Clock signal used for synchronous operation.\n    RST: Reset signal to initialize the FSM.\nOutput ports:\n    MATCH: Output signal indicating a match condition based on the FSM state.\n\nImplementation:\nThe module implements an FSM detection.\nOn every change in the input signal (IN) or positive edge of CLK or RST, if RST is active, the output signal MATCH is set to 0.\nIf the sequence of inputs IN is 1, 0, 0, 1, 1, the MATCH signal is 1 at the same time as the last occurrence of IN=1. If the sequence of inputs IN is 1, 0, 0, 1, 1, 0, 0, 1, 1, the MATCH signal becomes 1 at the fifth and ninth of IN; otherwise, it is set to 0.\n\nGive me the complete code.\n"}, "clean_code": "module fsm(IN,MATCH,CLK,RST);\ninput IN,CLK,RST;\noutput reg MATCH;\n\nreg [2:0] ST_cr,ST_nt;\n\nparameter s0 = 3'b000;\nparameter s1 = 3'b001;\nparameter s2 = 3'b010;\nparameter s3 = 3'b011;\nparameter s4 = 3'b100;\nparameter s5 = 3'b101;\n\nalways@(posedge CLK or posedge RST) begin\n\tif(RST)\n\t\tST_cr <= s0;\n\telse\n\t\tST_cr <= ST_nt;\nend\n\nalways@(*) begin\n\tcase(ST_cr)\n\t\ts0:begin\n\t\t\tif (IN==0)\n\t\t\t\tST_nt = s0;\n\t\t\telse\n\t\t\t\tST_nt = s1;\n\t\tend\n\t\t\n\t\ts1:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s1;\n                end\n\n                s2:begin\n                        if (IN==0)\n                                ST_nt = s3;\n                        else\n                                ST_nt = s1;\n                end\n\n                s3:begin\n                        if (IN==0)\n                                ST_nt = s0;\n                        else\n                                ST_nt = s4;\n                end\n\n                s4:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s5;\n                end\n\n                s5:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s1;\n                end\n\n\tendcase\nend\n\nalways@(*) begin\n        if(RST)\n                MATCH  <= 0;\n        else if (ST_cr == s4 && IN == 1)\n                MATCH  <= 1;\n\telse \n\t\tMATCH  <= 0;\nend\n\nendmodule", "corrupted_code": "module fsm(IN,MATCH,CLK,RST);\ninput IN,CLK,RST;\noutput reg MATCH;\n\nreg [2:0] ST_cr,ST_nt;\n\nparameter s0 = 3'b000;\nparameter s1 = 3'b001;\nparameter s2 = 3'b010;\nparameter s3 = 3'b011;\nparameter s4 = 3'b100;\nparameter s5 = 3'b101;\n\nalways@(posedge CLK or posedge RST) begin\n\tif(RST)\n\t\tST_cr <= s0;\n\telse\n\t\tST_cr <= ST_nt;\nend\n\nalways@(*) begin\n\tcase(ST_cr)\n\t\ts0:begin\n\t\t\tif (IN==0)\n\t\t\t\tST_nt = s0;\n\t\t\telse\n\t\t\t\tST_nt = s1;\n\t\tend\n\t\t\n\t\ts1:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s1;\n                end\n\n                s2:begin\n                        if (IN==0)\n                                ST_nt = s3;\n                        else\n                                ST_nt = s1;\n                end\n\n                s3:begin\n                        if (IN==0)\n                                ST_nt = s0;\n                        else\n                                ST_nt = s4;\n                end\n\n                s4:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s5;\n                end\n\n                s5:begin\n                        if (IN==0)\n\n                        else\n                                ST_nt = s1;\n                end\n\n\tendcase\nend\n\nalways@(*) begin\n        if(RST)\n                MATCH  <= 0;\n        else if (ST_cr == s4 && IN == 1)\n                MATCH  <= 1;\n\telse \n\t\tMATCH  <= 0;\nend\n\nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 60, "original_snippet": "ST_nt = s2;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 60: Original: ST_nt = s2;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 60.\n   \u2022 Restore the original code: ST_nt = s2;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 18, "applicable_modifications": ["remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.735114", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Finite State Machine", "design_name": "fsm", "module_name": "fsm", "description": "Please act as a professional verilog designer.\n\nImplement a Mealy FSM detection circuit that detects a single-bit input IN. When the input is 10011, output MATCH is 1, and MATCH is 0 in other cases. Support for continuous input and loop detection. \n\nModule name:  \n    fsm               \nInput ports:\n    IN: Input signal to the FSM.\n    CLK: Clock signal used for synchronous operation.\n    RST: Reset signal to initialize the FSM.\nOutput ports:\n    MATCH: Output signal indicating a match condition based on the FSM state.\n\nImplementation:\nThe module implements an FSM detection.\nOn every change in the input signal (IN) or positive edge of CLK or RST, if RST is active, the output signal MATCH is set to 0.\nIf the sequence of inputs IN is 1, 0, 0, 1, 1, the MATCH signal is 1 at the same time as the last occurrence of IN=1. If the sequence of inputs IN is 1, 0, 0, 1, 1, 0, 0, 1, 1, the MATCH signal becomes 1 at the fifth and ninth of IN; otherwise, it is set to 0.\n\nGive me the complete code.\n"}, "clean_code": "module fsm(IN,MATCH,CLK,RST);\ninput IN,CLK,RST;\noutput reg MATCH;\n\nreg [2:0] ST_cr,ST_nt;\n\nparameter s0 = 3'b000;\nparameter s1 = 3'b001;\nparameter s2 = 3'b010;\nparameter s3 = 3'b011;\nparameter s4 = 3'b100;\nparameter s5 = 3'b101;\n\nalways@(posedge CLK or posedge RST) begin\n\tif(RST)\n\t\tST_cr <= s0;\n\telse\n\t\tST_cr <= ST_nt;\nend\n\nalways@(*) begin\n\tcase(ST_cr)\n\t\ts0:begin\n\t\t\tif (IN==0)\n\t\t\t\tST_nt = s0;\n\t\t\telse\n\t\t\t\tST_nt = s1;\n\t\tend\n\t\t\n\t\ts1:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s1;\n                end\n\n                s2:begin\n                        if (IN==0)\n                                ST_nt = s3;\n                        else\n                                ST_nt = s1;\n                end\n\n                s3:begin\n                        if (IN==0)\n                                ST_nt = s0;\n                        else\n                                ST_nt = s4;\n                end\n\n                s4:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s5;\n                end\n\n                s5:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s1;\n                end\n\n\tendcase\nend\n\nalways@(*) begin\n        if(RST)\n                MATCH  <= 0;\n        else if (ST_cr == s4 && IN == 1)\n                MATCH  <= 1;\n\telse \n\t\tMATCH  <= 0;\nend\n\nendmodule", "corrupted_code": "module fsm(IN,MATCH,CLK,RST);\ninput IN,CLK,RST;\noutput reg MATCH;\n\nreg [2:0] ST_cr,ST_nt;\n\nparameter s0 = 3'b000;\nparameter s1 = 3'b001;\nparameter s2 = 3'b010;\nparameter s3 = 3'b011;\nparameter s4 = 3'b100;\nparameter s5 = 3'b101;\n\nalways@(posedge CLK or posedge RST) begin\n\tif (!RST)\n\t\tST_cr <= s0;\n\telse\n\t\tST_cr <= ST_nt;\nend\n\nalways@(*) begin\n\tcase(ST_cr)\n\t\ts0:begin\n\t\t\tif (IN==0)\n\t\t\t\tST_nt = s0;\n\t\t\telse\n\t\t\t\tST_nt = s1;\n\t\tend\n\t\t\n\t\ts1:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s1;\n                end\n\n                s2:begin\n                        if (IN==0)\n                                ST_nt = s3;\n                        else\n                                ST_nt = s1;\n                end\n\n                s3:begin\n                        if (IN==0)\n                                ST_nt = s0;\n                        else\n                                ST_nt = s4;\n                end\n\n                s4:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s5;\n                end\n\n                s5:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s1;\n                end\n\n\tendcase\nend\n\nalways@(*) begin\n        if(RST)\n                MATCH  <= 0;\n        else if (ST_cr == s4 && IN == 1)\n                MATCH  <= 1;\n\telse \n\t\tMATCH  <= 0;\nend\n\nendmodule", "corruption_explanation": "Inverted reset polarity in condition", "modification_type": "invert_reset_polarity", "modification_line": 15, "original_snippet": "if(RST)", "modified_snippet": "if (!RST)", "issue_description": "The buggy code has inverted reset polarity. If the design expects active-low reset (!rst), it now uses active-high, or vice versa. This causes the reset logic to activate during normal operation and deactivate during actual reset, breaking initialization.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_reset_polarity modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted reset polarity in condition\n   \u2022 Line 15: Original: if(RST)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 15.\n   \u2022 Restore the original code: if(RST)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert reset polarity.", "complexity": 18, "applicable_modifications": ["remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_reset_polarity"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.758418", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Finite State Machine", "design_name": "fsm", "module_name": "fsm", "description": "Please act as a professional verilog designer.\n\nImplement a Mealy FSM detection circuit that detects a single-bit input IN. When the input is 10011, output MATCH is 1, and MATCH is 0 in other cases. Support for continuous input and loop detection. \n\nModule name:  \n    fsm               \nInput ports:\n    IN: Input signal to the FSM.\n    CLK: Clock signal used for synchronous operation.\n    RST: Reset signal to initialize the FSM.\nOutput ports:\n    MATCH: Output signal indicating a match condition based on the FSM state.\n\nImplementation:\nThe module implements an FSM detection.\nOn every change in the input signal (IN) or positive edge of CLK or RST, if RST is active, the output signal MATCH is set to 0.\nIf the sequence of inputs IN is 1, 0, 0, 1, 1, the MATCH signal is 1 at the same time as the last occurrence of IN=1. If the sequence of inputs IN is 1, 0, 0, 1, 1, 0, 0, 1, 1, the MATCH signal becomes 1 at the fifth and ninth of IN; otherwise, it is set to 0.\n\nGive me the complete code.\n"}, "clean_code": "module fsm(IN,MATCH,CLK,RST);\ninput IN,CLK,RST;\noutput reg MATCH;\n\nreg [2:0] ST_cr,ST_nt;\n\nparameter s0 = 3'b000;\nparameter s1 = 3'b001;\nparameter s2 = 3'b010;\nparameter s3 = 3'b011;\nparameter s4 = 3'b100;\nparameter s5 = 3'b101;\n\nalways@(posedge CLK or posedge RST) begin\n\tif(RST)\n\t\tST_cr <= s0;\n\telse\n\t\tST_cr <= ST_nt;\nend\n\nalways@(*) begin\n\tcase(ST_cr)\n\t\ts0:begin\n\t\t\tif (IN==0)\n\t\t\t\tST_nt = s0;\n\t\t\telse\n\t\t\t\tST_nt = s1;\n\t\tend\n\t\t\n\t\ts1:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s1;\n                end\n\n                s2:begin\n                        if (IN==0)\n                                ST_nt = s3;\n                        else\n                                ST_nt = s1;\n                end\n\n                s3:begin\n                        if (IN==0)\n                                ST_nt = s0;\n                        else\n                                ST_nt = s4;\n                end\n\n                s4:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s5;\n                end\n\n                s5:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s1;\n                end\n\n\tendcase\nend\n\nalways@(*) begin\n        if(RST)\n                MATCH  <= 0;\n        else if (ST_cr == s4 && IN == 1)\n                MATCH  <= 1;\n\telse \n\t\tMATCH  <= 0;\nend\n\nendmodule", "corrupted_code": "module fsm(IN,MATCH,CLK,RST);\ninput IN,CLK,RST;\noutput reg MATCH;\n\nreg [2:0] ST_cr,ST_nt;\n\nparameter s0 = 3'b000;\nparameter s1 = 3'b001;\nparameter s2 = 3'b010;\nparameter s3 = 3'b001;\nparameter s4 = 3'b100;\nparameter s5 = 3'b101;\n\nalways@(posedge CLK or posedge RST) begin\n\tif(RST)\n\t\tST_cr <= s0;\n\telse\n\t\tST_cr <= ST_nt;\nend\n\nalways@(*) begin\n\tcase(ST_cr)\n\t\ts0:begin\n\t\t\tif (IN==0)\n\t\t\t\tST_nt = s0;\n\t\t\telse\n\t\t\t\tST_nt = s1;\n\t\tend\n\t\t\n\t\ts1:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s1;\n                end\n\n                s2:begin\n                        if (IN==0)\n                                ST_nt = s3;\n                        else\n                                ST_nt = s1;\n                end\n\n                s3:begin\n                        if (IN==0)\n                                ST_nt = s0;\n                        else\n                                ST_nt = s4;\n                end\n\n                s4:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s5;\n                end\n\n                s5:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s1;\n                end\n\n\tendcase\nend\n\nalways@(*) begin\n        if(RST)\n                MATCH  <= 0;\n        else if (ST_cr == s4 && IN == 1)\n                MATCH  <= 1;\n\telse \n\t\tMATCH  <= 0;\nend\n\nendmodule", "corruption_explanation": "Changed constant from 3'b011 to 3'b001", "modification_type": "change_constant", "modification_line": 10, "original_snippet": "3'b011", "modified_snippet": "3'b001", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 3'b011 to 3'b001\n   \u2022 Line 10: Original: 3'b011\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 10.\n   \u2022 Restore the original code: 3'b011\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 18, "applicable_modifications": ["remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_constant"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.760837", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Finite State Machine", "design_name": "fsm", "module_name": "fsm", "description": "Please act as a professional verilog designer.\n\nImplement a Mealy FSM detection circuit that detects a single-bit input IN. When the input is 10011, output MATCH is 1, and MATCH is 0 in other cases. Support for continuous input and loop detection. \n\nModule name:  \n    fsm               \nInput ports:\n    IN: Input signal to the FSM.\n    CLK: Clock signal used for synchronous operation.\n    RST: Reset signal to initialize the FSM.\nOutput ports:\n    MATCH: Output signal indicating a match condition based on the FSM state.\n\nImplementation:\nThe module implements an FSM detection.\nOn every change in the input signal (IN) or positive edge of CLK or RST, if RST is active, the output signal MATCH is set to 0.\nIf the sequence of inputs IN is 1, 0, 0, 1, 1, the MATCH signal is 1 at the same time as the last occurrence of IN=1. If the sequence of inputs IN is 1, 0, 0, 1, 1, 0, 0, 1, 1, the MATCH signal becomes 1 at the fifth and ninth of IN; otherwise, it is set to 0.\n\nGive me the complete code.\n"}, "clean_code": "module fsm(IN,MATCH,CLK,RST);\ninput IN,CLK,RST;\noutput reg MATCH;\n\nreg [2:0] ST_cr,ST_nt;\n\nparameter s0 = 3'b000;\nparameter s1 = 3'b001;\nparameter s2 = 3'b010;\nparameter s3 = 3'b011;\nparameter s4 = 3'b100;\nparameter s5 = 3'b101;\n\nalways@(posedge CLK or posedge RST) begin\n\tif(RST)\n\t\tST_cr <= s0;\n\telse\n\t\tST_cr <= ST_nt;\nend\n\nalways@(*) begin\n\tcase(ST_cr)\n\t\ts0:begin\n\t\t\tif (IN==0)\n\t\t\t\tST_nt = s0;\n\t\t\telse\n\t\t\t\tST_nt = s1;\n\t\tend\n\t\t\n\t\ts1:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s1;\n                end\n\n                s2:begin\n                        if (IN==0)\n                                ST_nt = s3;\n                        else\n                                ST_nt = s1;\n                end\n\n                s3:begin\n                        if (IN==0)\n                                ST_nt = s0;\n                        else\n                                ST_nt = s4;\n                end\n\n                s4:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s5;\n                end\n\n                s5:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s1;\n                end\n\n\tendcase\nend\n\nalways@(*) begin\n        if(RST)\n                MATCH  <= 0;\n        else if (ST_cr == s4 && IN == 1)\n                MATCH  <= 1;\n\telse \n\t\tMATCH  <= 0;\nend\n\nendmodule", "corrupted_code": "module fsm(IN,MATCH,CLK,RST);\ninput IN,CLK,RST;\noutput reg MATCH;\n\nreg [2:0] ST_cr,ST_nt;\n\nparameter s0 = 3'b000;\nparameter s1 = 3'b001;\nparameter s2 = 3'b010;\nparameter s3 = 3'b011;\nparameter s4 = 3'b100;\nparameter s5 = 3'b101;\n\nalways@(posedge CLK or posedge RST) begin\n\tif(RST)\n\t\tST_cr <= s0;\n\telse\n\t\tST_cr <= ST_nt;\nend\n\nalways@(*) begin\n\tcase(ST_cr)\n\t\ts0:begin\n\t\t\tif (IN==0)\n\t\t\t\tST_nt = s0;\n\t\t\telse\n\t\t\t\tST_nt = s1;\n\t\tend\n\t\t\n\t\ts1:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s1;\n                end\n\n                s2:begin\n                        if (IN==0)\n                                ST_nt = s3;\n                        else\n                                ST_nt = s1;\n                end\n\n                s3:begin\n                        if (IN==0)\n                                ST_nt = s0;\n                        else\n                                ST_nt = s4;\n                end\n\n                s4:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s5;\n                end\n\n                s5:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s1;\n                end\n\n\tendcase\nend\n\nalways@(*) begin\n        if(RST)\n                MATCH  <= 0;\n        else if (ST_cr == s4 && IN == 1)\n                1 <= MATCH;\n\telse \n\t\tMATCH  <= 0;\nend\n\nendmodule", "corruption_explanation": "Swapped operands: 'MATCH <= 1' -> '1 <= MATCH'", "modification_type": "swap_operands", "modification_line": 72, "original_snippet": "MATCH  <= 1", "modified_snippet": "1 <= MATCH", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'MATCH <= 1' -> '1 <= MATCH'\n   \u2022 Line 72: Original: MATCH  <= 1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 72.\n   \u2022 Restore the original code: MATCH  <= 1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 18, "applicable_modifications": ["remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_operands"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.763237", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Finite State Machine", "design_name": "fsm", "module_name": "fsm", "description": "Please act as a professional verilog designer.\n\nImplement a Mealy FSM detection circuit that detects a single-bit input IN. When the input is 10011, output MATCH is 1, and MATCH is 0 in other cases. Support for continuous input and loop detection. \n\nModule name:  \n    fsm               \nInput ports:\n    IN: Input signal to the FSM.\n    CLK: Clock signal used for synchronous operation.\n    RST: Reset signal to initialize the FSM.\nOutput ports:\n    MATCH: Output signal indicating a match condition based on the FSM state.\n\nImplementation:\nThe module implements an FSM detection.\nOn every change in the input signal (IN) or positive edge of CLK or RST, if RST is active, the output signal MATCH is set to 0.\nIf the sequence of inputs IN is 1, 0, 0, 1, 1, the MATCH signal is 1 at the same time as the last occurrence of IN=1. If the sequence of inputs IN is 1, 0, 0, 1, 1, 0, 0, 1, 1, the MATCH signal becomes 1 at the fifth and ninth of IN; otherwise, it is set to 0.\n\nGive me the complete code.\n"}, "clean_code": "module fsm(IN,MATCH,CLK,RST);\ninput IN,CLK,RST;\noutput reg MATCH;\n\nreg [2:0] ST_cr,ST_nt;\n\nparameter s0 = 3'b000;\nparameter s1 = 3'b001;\nparameter s2 = 3'b010;\nparameter s3 = 3'b011;\nparameter s4 = 3'b100;\nparameter s5 = 3'b101;\n\nalways@(posedge CLK or posedge RST) begin\n\tif(RST)\n\t\tST_cr <= s0;\n\telse\n\t\tST_cr <= ST_nt;\nend\n\nalways@(*) begin\n\tcase(ST_cr)\n\t\ts0:begin\n\t\t\tif (IN==0)\n\t\t\t\tST_nt = s0;\n\t\t\telse\n\t\t\t\tST_nt = s1;\n\t\tend\n\t\t\n\t\ts1:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s1;\n                end\n\n                s2:begin\n                        if (IN==0)\n                                ST_nt = s3;\n                        else\n                                ST_nt = s1;\n                end\n\n                s3:begin\n                        if (IN==0)\n                                ST_nt = s0;\n                        else\n                                ST_nt = s4;\n                end\n\n                s4:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s5;\n                end\n\n                s5:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s1;\n                end\n\n\tendcase\nend\n\nalways@(*) begin\n        if(RST)\n                MATCH  <= 0;\n        else if (ST_cr == s4 && IN == 1)\n                MATCH  <= 1;\n\telse \n\t\tMATCH  <= 0;\nend\n\nendmodule", "corrupted_code": "module fsm(IN,MATCH,CLK,RST);\ninput IN,CLK,RST;\noutput reg MATCH;\n\nreg [2:0] ST_cr,ST_nt;\n\nparameter s0 = 3'b000;\nparameter s1 = 3'b001;\nparameter s2 = 3'b010;\nparameter s3 = 3'b011;\nparameter s4 = 3'b100;\nparameter s5 = 3'b101;\n\nalways@(posedge CLK or posedge RST) begin\n\tif(RST)\n\t\tST_cr <= s0;\n\telse\n\t\tST_cr >= ST_nt;\nend\n\nalways@(*) begin\n\tcase(ST_cr)\n\t\ts0:begin\n\t\t\tif (IN==0)\n\t\t\t\tST_nt = s0;\n\t\t\telse\n\t\t\t\tST_nt = s1;\n\t\tend\n\t\t\n\t\ts1:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s1;\n                end\n\n                s2:begin\n                        if (IN==0)\n                                ST_nt = s3;\n                        else\n                                ST_nt = s1;\n                end\n\n                s3:begin\n                        if (IN==0)\n                                ST_nt = s0;\n                        else\n                                ST_nt = s4;\n                end\n\n                s4:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s5;\n                end\n\n                s5:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s1;\n                end\n\n\tendcase\nend\n\nalways@(*) begin\n        if(RST)\n                MATCH  <= 0;\n        else if (ST_cr == s4 && IN == 1)\n                MATCH  <= 1;\n\telse \n\t\tMATCH  <= 0;\nend\n\nendmodule", "corruption_explanation": "Changed operator from '<=' to '>='", "modification_type": "change_operator", "modification_line": 18, "original_snippet": "r <= S", "modified_snippet": "r >= S", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '<=' to '>='\n   \u2022 Line 18: Original: r <= S\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 18.\n   \u2022 Restore the original code: r <= S\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 18, "applicable_modifications": ["remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.765622", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Finite State Machine", "design_name": "sequence_detector", "module_name": "sequence_detector", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a sequence detector to detect a specific 4-bit binary sequence 1001.\n\nModule name:\n    sequence_detector\n\nInput ports:\n    clk: Clock signal to synchronize the detector.\n    reset_n: Reset signal to initialize the state machine.\n    data_in: 1-bit binary input signal to feed the bitstream for sequence detection.\n\nOutput ports:\n    sequence_detected: 1-bit output signal that is set high when the specific sequence is detected.\n    \nInternal logic:\n    State Machine: The sequence detector uses a finite state machine (FSM) with the following states:\n    IDLE: Waiting for the start of the sequence.\n    S1: The first bit of the desired sequence is detected.\n    S2: The second bit of the desired sequence is detected.\n    S3: The third bit of the desired sequence is detected.\n    S4: The fourth and final bit of the desired sequence is detected, and the output sequence_detected is set high.\n\nImplementation:\n    -FSM Design: The FSM transitions through states based on the bitstream data_in. On each clock cycle, the detector checks for a match of the specific sequence.\n\n    -Sequence Detection: The module checks the input data_in and transitions between states. Once the complete sequence is detected, sequence_detected is asserted.\n\n    -Reset Behavior: When reset is high, the state machine returns to the IDLE state, resetting the detection process."}, "clean_code": "module sequence_detector(\n     input  clk, \n     input  rst_n,\n     input  data_in, \n     output sequence_detected\t\t\t\t\n     );\n\n       \nparameter        IDLE = 5'b00001;\nparameter        S1   = 5'b00010;\nparameter \t     S2   = 5'b00100;\nparameter        S3   = 5'b01000;\nparameter        S4   = 5'b10000; \n\n\nreg [4:0]\t\t curr_state;\nreg [4:0] \t\t next_state;\n\n\nalways@(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n\t    curr_state <= IDLE;\n    end\n    else begin\n\t    curr_state <= next_state;\n    end\nend\n\n\nalways@(*) begin\n    if(!rst_n) begin\n\t    next_state <= IDLE;\n    end\n    else begin\n\t    case(curr_state)\n\t        IDLE  :next_state = data_in?S1:IDLE;\n\t        S1\t  :next_state = data_in?S1:S2;\n\t        S2\t  :next_state = data_in?S1:S3;\n\t        S3\t  :next_state = data_in?S4:IDLE;\n\t        S4\t  :next_state = data_in?S1:S2;\n\t        default:next_state = IDLE;\t\n\t    endcase\n    end\nend\n\nassign sequence_detected = (curr_state ==S4) ? 1'b1 : 1'b0;\n\nendmodule", "corrupted_code": "module sequence_detector(\n     input  clk, \n     input  rst_n,\n     input  data_in, \n     output sequence_detected\t\t\t\t\n     );\n\n       \nparameter        IDLE = 5'b00001;\nparameter        S1   = 5'b00010;\nparameter \t     S2   = 5'b00100;\nparameter        S3   = 5'b01000;\nparameter        S4   = 5'b10000; \n\n\nreg [4:0]\t\t curr_state;\nreg [4:0] \t\t next_state;\n\n\nalways@(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n\t    curr_state <= IDLE;\n    end\n    else begin\n\t    curr_state <= next_state;\n    end\nend\n\n\nalways@(*) begin\n    if(!rst_n) begin\n\t    next_state <= IDLE;\n    endcase\n    end\nend\n\nassign sequence_detected = (curr_state ==S4) ? 1'b1 : 1'b0;\n\nendmodule", "corruption_explanation": "Removed else branch (may cause latch inference)", "modification_type": "remove_else_branch", "modification_line": 31, "original_snippet": "if(!rst_n) begin\n\t    next_state <= IDLE;\n    end\n    else begin\n\t    case(curr_state)\n\t        IDLE  :next_state = data_in?S1:IDLE;\n\t        S1\t  :next_state = data_in?S1:S2;\n\t        S2\t  :next_stat", "modified_snippet": "if(!rst_n) begin\n\t    next_state <= IDLE;\n    end", "issue_description": "The buggy code is missing an else branch in a conditional statement. In combinational logic (always_comb or always @*), this can cause latch inference because the output is not defined for all input conditions. In sequential logic, signals may retain old values unexpectedly. This violates RTL design best practices requiring complete conditional assignments.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module should provide a complete conditional assignment to avoid latch inference.\n   \u2022 Combinational logic must define outputs for all input conditions.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an if statement without an else branch.\n   \u2022 The assigned signal is not defined when the condition is false.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The else branch has been removed from the conditional.\n   \u2022 This creates an incomplete conditional assignment.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Missing else branch leaves the signal undefined in some cases.\n   \u2022 Impact: Latch inference in combinational blocks, or stale values in sequential blocks.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Add an else branch with appropriate default or alternative assignment.\n   \u2022 Ensure all signals are assigned in all branches of the conditional.\n\n6. RTL Design Principle Violated:\n   \u2022 Combinational logic must have complete assignments to avoid latch inference.\n   \u2022 All conditional blocks should have else clauses or default values.", "complexity": 9, "applicable_modifications": ["invert_if_else", "remove_else_branch", "remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_else_branch"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.768362", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Finite State Machine", "design_name": "sequence_detector", "module_name": "sequence_detector", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a sequence detector to detect a specific 4-bit binary sequence 1001.\n\nModule name:\n    sequence_detector\n\nInput ports:\n    clk: Clock signal to synchronize the detector.\n    reset_n: Reset signal to initialize the state machine.\n    data_in: 1-bit binary input signal to feed the bitstream for sequence detection.\n\nOutput ports:\n    sequence_detected: 1-bit output signal that is set high when the specific sequence is detected.\n    \nInternal logic:\n    State Machine: The sequence detector uses a finite state machine (FSM) with the following states:\n    IDLE: Waiting for the start of the sequence.\n    S1: The first bit of the desired sequence is detected.\n    S2: The second bit of the desired sequence is detected.\n    S3: The third bit of the desired sequence is detected.\n    S4: The fourth and final bit of the desired sequence is detected, and the output sequence_detected is set high.\n\nImplementation:\n    -FSM Design: The FSM transitions through states based on the bitstream data_in. On each clock cycle, the detector checks for a match of the specific sequence.\n\n    -Sequence Detection: The module checks the input data_in and transitions between states. Once the complete sequence is detected, sequence_detected is asserted.\n\n    -Reset Behavior: When reset is high, the state machine returns to the IDLE state, resetting the detection process."}, "clean_code": "module sequence_detector(\n     input  clk, \n     input  rst_n,\n     input  data_in, \n     output sequence_detected\t\t\t\t\n     );\n\n       \nparameter        IDLE = 5'b00001;\nparameter        S1   = 5'b00010;\nparameter \t     S2   = 5'b00100;\nparameter        S3   = 5'b01000;\nparameter        S4   = 5'b10000; \n\n\nreg [4:0]\t\t curr_state;\nreg [4:0] \t\t next_state;\n\n\nalways@(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n\t    curr_state <= IDLE;\n    end\n    else begin\n\t    curr_state <= next_state;\n    end\nend\n\n\nalways@(*) begin\n    if(!rst_n) begin\n\t    next_state <= IDLE;\n    end\n    else begin\n\t    case(curr_state)\n\t        IDLE  :next_state = data_in?S1:IDLE;\n\t        S1\t  :next_state = data_in?S1:S2;\n\t        S2\t  :next_state = data_in?S1:S3;\n\t        S3\t  :next_state = data_in?S4:IDLE;\n\t        S4\t  :next_state = data_in?S1:S2;\n\t        default:next_state = IDLE;\t\n\t    endcase\n    end\nend\n\nassign sequence_detected = (curr_state ==S4) ? 1'b1 : 1'b0;\n\nendmodule", "corrupted_code": "module sequence_detector(\n     input  clk, \n     input  rst_n,\n     input  data_in, \n     output sequence_detected\t\t\t\t\n     );\n\n       \nparameter        IDLE = 5'b00001;\nparameter        S1   = 5'b00010;\nparameter \t     S2   = 5'b00100;\nparameter        S3   = 5'b01000;\nparameter        S4   = 5'b10000; \n\n\nreg [4:0]\t\t curr_state;\nreg [4:0] \t\t next_state;\n\n\nalways@(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n\t    curr_state <= IDLE;\n    end\nend\n\n\nalways@(*) begin\n    if(!rst_n) begin\n\t    next_state <= IDLE;\n    end\n    else begin\n\t    case(curr_state)\n\t        IDLE  :next_state = data_in?S1:IDLE;\n\t        S1\t  :next_state = data_in?S1:S2;\n\t        S2\t  :next_state = data_in?S1:S3;\n\t        S3\t  :next_state = data_in?S4:IDLE;\n\t        S4\t  :next_state = data_in?S1:S2;\n\t        default:next_state = IDLE;\t\n\t    endcase\n    end\nend\n\nassign sequence_detected = (curr_state ==S4) ? 1'b1 : 1'b0;\n\nendmodule", "corruption_explanation": "Removed else branch (may cause latch inference)", "modification_type": "remove_else_branch", "modification_line": 21, "original_snippet": "if(!rst_n) begin\n\t    curr_state <= IDLE;\n    end\n    else begin\n\t    curr_state <= next_state;\n    end", "modified_snippet": "if(!rst_n) begin\n\t    curr_state <= IDLE;\n    end", "issue_description": "The buggy code is missing an else branch in a conditional statement. In combinational logic (always_comb or always @*), this can cause latch inference because the output is not defined for all input conditions. In sequential logic, signals may retain old values unexpectedly. This violates RTL design best practices requiring complete conditional assignments.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module should provide a complete conditional assignment to avoid latch inference.\n   \u2022 Combinational logic must define outputs for all input conditions.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an if statement without an else branch.\n   \u2022 The assigned signal is not defined when the condition is false.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The else branch has been removed from the conditional.\n   \u2022 This creates an incomplete conditional assignment.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Missing else branch leaves the signal undefined in some cases.\n   \u2022 Impact: Latch inference in combinational blocks, or stale values in sequential blocks.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Add an else branch with appropriate default or alternative assignment.\n   \u2022 Ensure all signals are assigned in all branches of the conditional.\n\n6. RTL Design Principle Violated:\n   \u2022 Combinational logic must have complete assignments to avoid latch inference.\n   \u2022 All conditional blocks should have else clauses or default values.", "complexity": 9, "applicable_modifications": ["invert_if_else", "remove_else_branch", "remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_else_branch"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.769409", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Finite State Machine", "design_name": "sequence_detector", "module_name": "sequence_detector", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a sequence detector to detect a specific 4-bit binary sequence 1001.\n\nModule name:\n    sequence_detector\n\nInput ports:\n    clk: Clock signal to synchronize the detector.\n    reset_n: Reset signal to initialize the state machine.\n    data_in: 1-bit binary input signal to feed the bitstream for sequence detection.\n\nOutput ports:\n    sequence_detected: 1-bit output signal that is set high when the specific sequence is detected.\n    \nInternal logic:\n    State Machine: The sequence detector uses a finite state machine (FSM) with the following states:\n    IDLE: Waiting for the start of the sequence.\n    S1: The first bit of the desired sequence is detected.\n    S2: The second bit of the desired sequence is detected.\n    S3: The third bit of the desired sequence is detected.\n    S4: The fourth and final bit of the desired sequence is detected, and the output sequence_detected is set high.\n\nImplementation:\n    -FSM Design: The FSM transitions through states based on the bitstream data_in. On each clock cycle, the detector checks for a match of the specific sequence.\n\n    -Sequence Detection: The module checks the input data_in and transitions between states. Once the complete sequence is detected, sequence_detected is asserted.\n\n    -Reset Behavior: When reset is high, the state machine returns to the IDLE state, resetting the detection process."}, "clean_code": "module sequence_detector(\n     input  clk, \n     input  rst_n,\n     input  data_in, \n     output sequence_detected\t\t\t\t\n     );\n\n       \nparameter        IDLE = 5'b00001;\nparameter        S1   = 5'b00010;\nparameter \t     S2   = 5'b00100;\nparameter        S3   = 5'b01000;\nparameter        S4   = 5'b10000; \n\n\nreg [4:0]\t\t curr_state;\nreg [4:0] \t\t next_state;\n\n\nalways@(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n\t    curr_state <= IDLE;\n    end\n    else begin\n\t    curr_state <= next_state;\n    end\nend\n\n\nalways@(*) begin\n    if(!rst_n) begin\n\t    next_state <= IDLE;\n    end\n    else begin\n\t    case(curr_state)\n\t        IDLE  :next_state = data_in?S1:IDLE;\n\t        S1\t  :next_state = data_in?S1:S2;\n\t        S2\t  :next_state = data_in?S1:S3;\n\t        S3\t  :next_state = data_in?S4:IDLE;\n\t        S4\t  :next_state = data_in?S1:S2;\n\t        default:next_state = IDLE;\t\n\t    endcase\n    end\nend\n\nassign sequence_detected = (curr_state ==S4) ? 1'b1 : 1'b0;\n\nendmodule", "corrupted_code": "module sequence_detector(\n     input  clk, \n     input  rst_n,\n     input  data_in, \n     output sequence_detected\t\t\t\t\n     );\n\n       \nparameter        IDLE = 5'b00001;\nparameter        S1   = 5'b00010;\nparameter \t     S2   = 5'b00100;\nparameter        S3   = 5'b01000;\nparameter        S4   = 5'b10000; \n\n\nreg [4:0]\t\t curr_state;\nreg [4:0] \t\t next_state;\n\n\nalways@(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n\t    curr_state <= IDLE;\n    end\n    else begin\n\t    curr_state <= next_state;\n    end\nend\n\n\nalways@(*) begin\n    if(rst_n) begin\n\t    next_state <= IDLE;\n    end\n    else begin\n\t    case(curr_state)\n\t        IDLE  :next_state = data_in?S1:IDLE;\n\t        S1\t  :next_state = data_in?S1:S2;\n\t        S2\t  :next_state = data_in?S1:S3;\n\t        S3\t  :next_state = data_in?S4:IDLE;\n\t        S4\t  :next_state = data_in?S1:S2;\n\t        default:next_state = IDLE;\t\n\t    endcase\n    end\nend\n\nassign sequence_detected = (curr_state ==S4) ? 1'b1 : 1'b0;\n\nendmodule", "corruption_explanation": "Inverted condition: '!rst_n' -> 'rst_n'", "modification_type": "invert_condition", "modification_line": 31, "original_snippet": "if(!rst_n) begin", "modified_snippet": "if(rst_n) begin", "issue_description": "The buggy code has an inverted condition in an if statement. Instead of checking if(x), it checks if(!x), causing the logic to execute when it shouldn't and skip execution when it should. All conditional behavior is reversed from intended functionality.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_condition modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted condition: '!rst_n' -> 'rst_n'\n   \u2022 Line 31: Original: if(!rst_n) begin\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 31.\n   \u2022 Restore the original code: if(!rst_n) begin\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert condition.", "complexity": 9, "applicable_modifications": ["invert_if_else", "remove_else_branch", "remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_condition"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.770445", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Finite State Machine", "design_name": "sequence_detector", "module_name": "sequence_detector", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a sequence detector to detect a specific 4-bit binary sequence 1001.\n\nModule name:\n    sequence_detector\n\nInput ports:\n    clk: Clock signal to synchronize the detector.\n    reset_n: Reset signal to initialize the state machine.\n    data_in: 1-bit binary input signal to feed the bitstream for sequence detection.\n\nOutput ports:\n    sequence_detected: 1-bit output signal that is set high when the specific sequence is detected.\n    \nInternal logic:\n    State Machine: The sequence detector uses a finite state machine (FSM) with the following states:\n    IDLE: Waiting for the start of the sequence.\n    S1: The first bit of the desired sequence is detected.\n    S2: The second bit of the desired sequence is detected.\n    S3: The third bit of the desired sequence is detected.\n    S4: The fourth and final bit of the desired sequence is detected, and the output sequence_detected is set high.\n\nImplementation:\n    -FSM Design: The FSM transitions through states based on the bitstream data_in. On each clock cycle, the detector checks for a match of the specific sequence.\n\n    -Sequence Detection: The module checks the input data_in and transitions between states. Once the complete sequence is detected, sequence_detected is asserted.\n\n    -Reset Behavior: When reset is high, the state machine returns to the IDLE state, resetting the detection process."}, "clean_code": "module sequence_detector(\n     input  clk, \n     input  rst_n,\n     input  data_in, \n     output sequence_detected\t\t\t\t\n     );\n\n       \nparameter        IDLE = 5'b00001;\nparameter        S1   = 5'b00010;\nparameter \t     S2   = 5'b00100;\nparameter        S3   = 5'b01000;\nparameter        S4   = 5'b10000; \n\n\nreg [4:0]\t\t curr_state;\nreg [4:0] \t\t next_state;\n\n\nalways@(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n\t    curr_state <= IDLE;\n    end\n    else begin\n\t    curr_state <= next_state;\n    end\nend\n\n\nalways@(*) begin\n    if(!rst_n) begin\n\t    next_state <= IDLE;\n    end\n    else begin\n\t    case(curr_state)\n\t        IDLE  :next_state = data_in?S1:IDLE;\n\t        S1\t  :next_state = data_in?S1:S2;\n\t        S2\t  :next_state = data_in?S1:S3;\n\t        S3\t  :next_state = data_in?S4:IDLE;\n\t        S4\t  :next_state = data_in?S1:S2;\n\t        default:next_state = IDLE;\t\n\t    endcase\n    end\nend\n\nassign sequence_detected = (curr_state ==S4) ? 1'b1 : 1'b0;\n\nendmodule", "corrupted_code": "module sequence_detector(\n     input  clk, \n     input  rst_n,\n     input  data_in, \n     output sequence_detected\t\t\t\t\n     );\n\n       \nparameter        IDLE = 5'b00001;\nparameter        S1   = 5'b00010;\nparameter \t     S2   = 5'b00100;\nparameter        S3   = 5'b01000;\nparameter        S4   = 5'b10000; \n\n\nreg [4:0]\t\t curr_state;\nreg [4:0] \t\t next_state;\n\n\nalways@(posedge clk or negedge rst_n) begin\n    if (rst_n) begin\n\t    curr_state <= IDLE;\n    end\n    else begin\n\t    curr_state <= next_state;\n    end\nend\n\n\nalways@(*) begin\n    if(!rst_n) begin\n\t    next_state <= IDLE;\n    end\n    else begin\n\t    case(curr_state)\n\t        IDLE  :next_state = data_in?S1:IDLE;\n\t        S1\t  :next_state = data_in?S1:S2;\n\t        S2\t  :next_state = data_in?S1:S3;\n\t        S3\t  :next_state = data_in?S4:IDLE;\n\t        S4\t  :next_state = data_in?S1:S2;\n\t        default:next_state = IDLE;\t\n\t    endcase\n    end\nend\n\nassign sequence_detected = (curr_state ==S4) ? 1'b1 : 1'b0;\n\nendmodule", "corruption_explanation": "Inverted reset polarity in condition", "modification_type": "invert_reset_polarity", "modification_line": 21, "original_snippet": "if(!rst_n)", "modified_snippet": "if (rst_n)", "issue_description": "The buggy code has inverted reset polarity. If the design expects active-low reset (!rst), it now uses active-high, or vice versa. This causes the reset logic to activate during normal operation and deactivate during actual reset, breaking initialization.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_reset_polarity modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted reset polarity in condition\n   \u2022 Line 21: Original: if(!rst_n)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 21.\n   \u2022 Restore the original code: if(!rst_n)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert reset polarity.", "complexity": 9, "applicable_modifications": ["invert_if_else", "remove_else_branch", "remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_reset_polarity"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.771471", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Finite State Machine", "design_name": "sequence_detector", "module_name": "sequence_detector", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a sequence detector to detect a specific 4-bit binary sequence 1001.\n\nModule name:\n    sequence_detector\n\nInput ports:\n    clk: Clock signal to synchronize the detector.\n    reset_n: Reset signal to initialize the state machine.\n    data_in: 1-bit binary input signal to feed the bitstream for sequence detection.\n\nOutput ports:\n    sequence_detected: 1-bit output signal that is set high when the specific sequence is detected.\n    \nInternal logic:\n    State Machine: The sequence detector uses a finite state machine (FSM) with the following states:\n    IDLE: Waiting for the start of the sequence.\n    S1: The first bit of the desired sequence is detected.\n    S2: The second bit of the desired sequence is detected.\n    S3: The third bit of the desired sequence is detected.\n    S4: The fourth and final bit of the desired sequence is detected, and the output sequence_detected is set high.\n\nImplementation:\n    -FSM Design: The FSM transitions through states based on the bitstream data_in. On each clock cycle, the detector checks for a match of the specific sequence.\n\n    -Sequence Detection: The module checks the input data_in and transitions between states. Once the complete sequence is detected, sequence_detected is asserted.\n\n    -Reset Behavior: When reset is high, the state machine returns to the IDLE state, resetting the detection process."}, "clean_code": "module sequence_detector(\n     input  clk, \n     input  rst_n,\n     input  data_in, \n     output sequence_detected\t\t\t\t\n     );\n\n       \nparameter        IDLE = 5'b00001;\nparameter        S1   = 5'b00010;\nparameter \t     S2   = 5'b00100;\nparameter        S3   = 5'b01000;\nparameter        S4   = 5'b10000; \n\n\nreg [4:0]\t\t curr_state;\nreg [4:0] \t\t next_state;\n\n\nalways@(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n\t    curr_state <= IDLE;\n    end\n    else begin\n\t    curr_state <= next_state;\n    end\nend\n\n\nalways@(*) begin\n    if(!rst_n) begin\n\t    next_state <= IDLE;\n    end\n    else begin\n\t    case(curr_state)\n\t        IDLE  :next_state = data_in?S1:IDLE;\n\t        S1\t  :next_state = data_in?S1:S2;\n\t        S2\t  :next_state = data_in?S1:S3;\n\t        S3\t  :next_state = data_in?S4:IDLE;\n\t        S4\t  :next_state = data_in?S1:S2;\n\t        default:next_state = IDLE;\t\n\t    endcase\n    end\nend\n\nassign sequence_detected = (curr_state ==S4) ? 1'b1 : 1'b0;\n\nendmodule", "corrupted_code": "module sequence_detector(\n     input  clk, \n     input  rst_n,\n     input  data_in, \n     output sequence_detected\t\t\t\t\n     );\n\n       \nparameter        IDLE = 5'b00001;\nparameter        S1   = 5'b00010;\nparameter \t     S2   = 5'b00100;\nparameter        S3   = 5'b01000;\nparameter        S4   = 5'b10000; \n\n\nreg [4:0]\t\t curr_state;\nreg [4:0] \t\t next_state;\n\n\nalways@(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n\t    curr_state <= IDLE;\n    end\n    else begin\n\t    curr_state <= next_state;\n    end\nend\n\n\nalways@(*) begin\n    if(!rst_n) begin\n\t    next_state <= IDLE;\n    end\n    else begin\n\t    case(curr_state)\n\t        IDLE  :next_state = data_in?S1:IDLE;\n\t        S1\t  :next_state = data_in?S1:S2;\n\t        S2\t  :next_state = data_in?S1:S3;\n\t        S3\t  :next_state = data_in?S4:IDLE;\n\t        S4\t  :next_state = data_in?S1:S2;\n\t        default:next_state = IDLE;\t\n\t    endcase\n    end\nend\n\nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 45, "original_snippet": "assign sequence_detected = (curr_state ==S4) ? 1'b1 : 1'b0;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 45: Original: assign sequence_detected = (curr_state ==S4) ? 1'b1 : 1'b0;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 45.\n   \u2022 Restore the original code: assign sequence_detected = (curr_state ==S4) ? 1'b1 : 1'b0;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 9, "applicable_modifications": ["invert_if_else", "remove_else_branch", "remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.772525", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Finite State Machine", "design_name": "sequence_detector", "module_name": "sequence_detector", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a sequence detector to detect a specific 4-bit binary sequence 1001.\n\nModule name:\n    sequence_detector\n\nInput ports:\n    clk: Clock signal to synchronize the detector.\n    reset_n: Reset signal to initialize the state machine.\n    data_in: 1-bit binary input signal to feed the bitstream for sequence detection.\n\nOutput ports:\n    sequence_detected: 1-bit output signal that is set high when the specific sequence is detected.\n    \nInternal logic:\n    State Machine: The sequence detector uses a finite state machine (FSM) with the following states:\n    IDLE: Waiting for the start of the sequence.\n    S1: The first bit of the desired sequence is detected.\n    S2: The second bit of the desired sequence is detected.\n    S3: The third bit of the desired sequence is detected.\n    S4: The fourth and final bit of the desired sequence is detected, and the output sequence_detected is set high.\n\nImplementation:\n    -FSM Design: The FSM transitions through states based on the bitstream data_in. On each clock cycle, the detector checks for a match of the specific sequence.\n\n    -Sequence Detection: The module checks the input data_in and transitions between states. Once the complete sequence is detected, sequence_detected is asserted.\n\n    -Reset Behavior: When reset is high, the state machine returns to the IDLE state, resetting the detection process."}, "clean_code": "module sequence_detector(\n     input  clk, \n     input  rst_n,\n     input  data_in, \n     output sequence_detected\t\t\t\t\n     );\n\n       \nparameter        IDLE = 5'b00001;\nparameter        S1   = 5'b00010;\nparameter \t     S2   = 5'b00100;\nparameter        S3   = 5'b01000;\nparameter        S4   = 5'b10000; \n\n\nreg [4:0]\t\t curr_state;\nreg [4:0] \t\t next_state;\n\n\nalways@(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n\t    curr_state <= IDLE;\n    end\n    else begin\n\t    curr_state <= next_state;\n    end\nend\n\n\nalways@(*) begin\n    if(!rst_n) begin\n\t    next_state <= IDLE;\n    end\n    else begin\n\t    case(curr_state)\n\t        IDLE  :next_state = data_in?S1:IDLE;\n\t        S1\t  :next_state = data_in?S1:S2;\n\t        S2\t  :next_state = data_in?S1:S3;\n\t        S3\t  :next_state = data_in?S4:IDLE;\n\t        S4\t  :next_state = data_in?S1:S2;\n\t        default:next_state = IDLE;\t\n\t    endcase\n    end\nend\n\nassign sequence_detected = (curr_state ==S4) ? 1'b1 : 1'b0;\n\nendmodule", "corrupted_code": "module sequence_detector(\n     input  clk, \n     input  rst_n,\n     input  data_in, \n     output sequence_detected\t\t\t\t\n     );\n\n       \nparameter        IDLE = 5'b00001;\nparameter        S1   = 5'b00010;\nparameter \t     S2   = 5'b00100;\nparameter        S3   = 5'b01000;\nparameter        S4   = 5'b10000; \n\n\nreg [4:0]\t\t curr_state;\nreg [4:0] \t\t next_state;\n\n\nalways@(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n\t    curr_state <= IDLE;\n    end\n    else begin\n\t    curr_state <= next_state;\n    end\nend\n\n\nalways@(*) begin\n    if(!rst_n) begin\n\t    next_state <= IDLE;\n    end\n    else begin\n\t    case(curr_state)\n\t        IDLE  :next_state = data_in?S1:IDLE;\n\t        S1\t  :next_state = data_in?S1:S2;\n\t        S2\t  :next_state = data_in?S1:S3;\n\t        S3\t  :next_state = data_in?S4:IDLE;\n\t        S4\t  :next_state = data_in?S1:S2;\n\t        endcase\n    end\nend\n\nassign sequence_detected = (curr_state ==S4) ? 1'b1 : 1'b0;\n\nendmodule", "corruption_explanation": "Removed default case (may cause incomplete case warning)", "modification_type": "remove_case_default", "modification_line": 35, "original_snippet": "case(curr_state)\n\t        IDLE  :next_state = data_in?S1:IDLE;\n\t        S1\t  :next_state = data_in?S1:S2;\n\t        S2\t  :next_state = data_in?S1:S3;\n\t        S3\t  :next_state = data_in?S4:IDLE;\n\t     ", "modified_snippet": "case(curr_state)\n\t        IDLE  :next_state = data_in?S1:IDLE;\n\t        S1\t  :next_state = data_in?S1:S2;\n\t        S2\t  :next_state = data_in?S1:S3;\n\t        S3\t  :next_state = data_in?S4:IDLE;\n\t     ", "issue_description": "The buggy code is missing the default case in a case statement. This creates an incomplete case statement that can infer latches in combinational blocks or cause undefined behavior for unhandled values. Linting tools will flag this as CASEINCOMPLETE or LATCH warning.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_case_default modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed default case (may cause incomplete case warning)\n   \u2022 Line 35: Original: case(curr_state)\n\t        IDLE  :next_state = data_in?S1:IDLE;\n\t        S1\t  :next_state = data_in?S1:S2;\n\t        S2\t  :next_state = data_in?S1:S3;\n\t        S3\t  :next_state = data_in?S4:IDLE;\n\t     \n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 35.\n   \u2022 Restore the original code: case(curr_state)\n\t        IDLE  :next_state = data_in?S1:IDLE;\n\t        S1\t  :next_state = data_in?S1:S2;\n\t        S2\t  :next_state = data_in?S1:S3;\n\t        S3\t  :next_state = data_in?S4:IDLE;\n\t     \n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove case default.", "complexity": 9, "applicable_modifications": ["invert_if_else", "remove_else_branch", "remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_case_default"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.773673", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Finite State Machine", "design_name": "sequence_detector", "module_name": "sequence_detector", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a sequence detector to detect a specific 4-bit binary sequence 1001.\n\nModule name:\n    sequence_detector\n\nInput ports:\n    clk: Clock signal to synchronize the detector.\n    reset_n: Reset signal to initialize the state machine.\n    data_in: 1-bit binary input signal to feed the bitstream for sequence detection.\n\nOutput ports:\n    sequence_detected: 1-bit output signal that is set high when the specific sequence is detected.\n    \nInternal logic:\n    State Machine: The sequence detector uses a finite state machine (FSM) with the following states:\n    IDLE: Waiting for the start of the sequence.\n    S1: The first bit of the desired sequence is detected.\n    S2: The second bit of the desired sequence is detected.\n    S3: The third bit of the desired sequence is detected.\n    S4: The fourth and final bit of the desired sequence is detected, and the output sequence_detected is set high.\n\nImplementation:\n    -FSM Design: The FSM transitions through states based on the bitstream data_in. On each clock cycle, the detector checks for a match of the specific sequence.\n\n    -Sequence Detection: The module checks the input data_in and transitions between states. Once the complete sequence is detected, sequence_detected is asserted.\n\n    -Reset Behavior: When reset is high, the state machine returns to the IDLE state, resetting the detection process."}, "clean_code": "module sequence_detector(\n     input  clk, \n     input  rst_n,\n     input  data_in, \n     output sequence_detected\t\t\t\t\n     );\n\n       \nparameter        IDLE = 5'b00001;\nparameter        S1   = 5'b00010;\nparameter \t     S2   = 5'b00100;\nparameter        S3   = 5'b01000;\nparameter        S4   = 5'b10000; \n\n\nreg [4:0]\t\t curr_state;\nreg [4:0] \t\t next_state;\n\n\nalways@(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n\t    curr_state <= IDLE;\n    end\n    else begin\n\t    curr_state <= next_state;\n    end\nend\n\n\nalways@(*) begin\n    if(!rst_n) begin\n\t    next_state <= IDLE;\n    end\n    else begin\n\t    case(curr_state)\n\t        IDLE  :next_state = data_in?S1:IDLE;\n\t        S1\t  :next_state = data_in?S1:S2;\n\t        S2\t  :next_state = data_in?S1:S3;\n\t        S3\t  :next_state = data_in?S4:IDLE;\n\t        S4\t  :next_state = data_in?S1:S2;\n\t        default:next_state = IDLE;\t\n\t    endcase\n    end\nend\n\nassign sequence_detected = (curr_state ==S4) ? 1'b1 : 1'b0;\n\nendmodule", "corrupted_code": "module sequence_detector(\n     input  clk, \n     input  rst_n,\n     input  data_in, \n     output sequence_detected\t\t\t\t\n     );\n\n       \nparameter        IDLE = 5'b00001;\nparameter        S1   = 5'b00010;\nparameter \t     S2   = 5'b00100;\nparameter        S3   = 5'b01000;\nparameter        S4   = 5'b10000; \n\n\nreg [4:0]\t\t curr_state;\nreg [4:0] \t\t next_state;\n\n\nalways@(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n\t    curr_state <= IDLE;\n    end\n    else begin\n\t    next_state <= curr_state;\n    end\nend\n\n\nalways@(*) begin\n    if(!rst_n) begin\n\t    next_state <= IDLE;\n    end\n    else begin\n\t    case(curr_state)\n\t        IDLE  :next_state = data_in?S1:IDLE;\n\t        S1\t  :next_state = data_in?S1:S2;\n\t        S2\t  :next_state = data_in?S1:S3;\n\t        S3\t  :next_state = data_in?S4:IDLE;\n\t        S4\t  :next_state = data_in?S1:S2;\n\t        default:next_state = IDLE;\t\n\t    endcase\n    end\nend\n\nassign sequence_detected = (curr_state ==S4) ? 1'b1 : 1'b0;\n\nendmodule", "corruption_explanation": "Swapped operands: 'curr_state <= next_state' -> 'next_state <= curr_state'", "modification_type": "swap_operands", "modification_line": 25, "original_snippet": "curr_state <= next_state", "modified_snippet": "next_state <= curr_state", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'curr_state <= next_state' -> 'next_state <= curr_state'\n   \u2022 Line 25: Original: curr_state <= next_state\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 25.\n   \u2022 Restore the original code: curr_state <= next_state\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 9, "applicable_modifications": ["invert_if_else", "remove_else_branch", "remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_operands"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.774798", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Finite State Machine", "design_name": "sequence_detector", "module_name": "sequence_detector", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a sequence detector to detect a specific 4-bit binary sequence 1001.\n\nModule name:\n    sequence_detector\n\nInput ports:\n    clk: Clock signal to synchronize the detector.\n    reset_n: Reset signal to initialize the state machine.\n    data_in: 1-bit binary input signal to feed the bitstream for sequence detection.\n\nOutput ports:\n    sequence_detected: 1-bit output signal that is set high when the specific sequence is detected.\n    \nInternal logic:\n    State Machine: The sequence detector uses a finite state machine (FSM) with the following states:\n    IDLE: Waiting for the start of the sequence.\n    S1: The first bit of the desired sequence is detected.\n    S2: The second bit of the desired sequence is detected.\n    S3: The third bit of the desired sequence is detected.\n    S4: The fourth and final bit of the desired sequence is detected, and the output sequence_detected is set high.\n\nImplementation:\n    -FSM Design: The FSM transitions through states based on the bitstream data_in. On each clock cycle, the detector checks for a match of the specific sequence.\n\n    -Sequence Detection: The module checks the input data_in and transitions between states. Once the complete sequence is detected, sequence_detected is asserted.\n\n    -Reset Behavior: When reset is high, the state machine returns to the IDLE state, resetting the detection process."}, "clean_code": "module sequence_detector(\n     input  clk, \n     input  rst_n,\n     input  data_in, \n     output sequence_detected\t\t\t\t\n     );\n\n       \nparameter        IDLE = 5'b00001;\nparameter        S1   = 5'b00010;\nparameter \t     S2   = 5'b00100;\nparameter        S3   = 5'b01000;\nparameter        S4   = 5'b10000; \n\n\nreg [4:0]\t\t curr_state;\nreg [4:0] \t\t next_state;\n\n\nalways@(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n\t    curr_state <= IDLE;\n    end\n    else begin\n\t    curr_state <= next_state;\n    end\nend\n\n\nalways@(*) begin\n    if(!rst_n) begin\n\t    next_state <= IDLE;\n    end\n    else begin\n\t    case(curr_state)\n\t        IDLE  :next_state = data_in?S1:IDLE;\n\t        S1\t  :next_state = data_in?S1:S2;\n\t        S2\t  :next_state = data_in?S1:S3;\n\t        S3\t  :next_state = data_in?S4:IDLE;\n\t        S4\t  :next_state = data_in?S1:S2;\n\t        default:next_state = IDLE;\t\n\t    endcase\n    end\nend\n\nassign sequence_detected = (curr_state ==S4) ? 1'b1 : 1'b0;\n\nendmodule", "corrupted_code": "module sequence_detector(\n     input  clk, \n     input  rst_n,\n     input  data_in, \n     output sequence_detected\t\t\t\t\n     );\n\n       \nparameter        IDLE = 5'b00001;\nparameter        S1   = 5'b00010;\nparameter \t     S2   = 5'b00100;\nparameter        S3   = 5'b01000;\nparameter        S4   = 5'b10000; \n\n\nreg [4:0]\t\t curr_state;\nreg [4:0] \t\t next_state;\n\n\nalways@(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n\t    curr_state <= IDLE;\n    end\n    else begin\n\t    curr_state <= next_state;\n    end\nend\n\n\nalways@(*) begin\n    if(!rst_n) begin\n\t    next_state <= IDLE;\n    end\n    else begin\n\t    case(curr_state)\n\t        IDLE  :next_state = data_in?S1:IDLE;\n\t        S1\t  :next_state = data_in?S1:S2;\n\t        S2\t  :next_state = data_in?S1:S3;\n\t        S3\t  :next_state = data_in?S4:IDLE;\n\t        S4\t  :next_state = data_in?S1:S2;\n\t        default:next_state = IDLE;\t\n\t    endcase\n    end\nend\n\nassign sequence_detected = (curr_state ==S4) ? 1'b1 : 1'b0;\n\n\n    wire clk_dup;\n    assign clk_dup = clk;\nendmodule", "corruption_explanation": "Added duplicate clock signal clk_dup", "modification_type": "duplicate_clock_signal", "modification_line": 20, "original_snippet": "(none)", "modified_snippet": "wire clk_dup;\n    assign clk_dup = clk;", "issue_description": "The buggy code has a duplicate clock signal. A phantom clock domain is created, which may confuse CDC analysis tools and create subtle timing issues in synthesis. This violates clock domain design best practices.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a duplicate_clock_signal modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added duplicate clock signal clk_dup\n   \u2022 Line 20: Original: (none)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 20.\n   \u2022 Restore the original code: (none)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to duplicate clock signal.", "complexity": 9, "applicable_modifications": ["invert_if_else", "remove_else_branch", "remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["duplicate_clock_signal"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.775835", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Finite State Machine", "design_name": "sequence_detector", "module_name": "sequence_detector", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a sequence detector to detect a specific 4-bit binary sequence 1001.\n\nModule name:\n    sequence_detector\n\nInput ports:\n    clk: Clock signal to synchronize the detector.\n    reset_n: Reset signal to initialize the state machine.\n    data_in: 1-bit binary input signal to feed the bitstream for sequence detection.\n\nOutput ports:\n    sequence_detected: 1-bit output signal that is set high when the specific sequence is detected.\n    \nInternal logic:\n    State Machine: The sequence detector uses a finite state machine (FSM) with the following states:\n    IDLE: Waiting for the start of the sequence.\n    S1: The first bit of the desired sequence is detected.\n    S2: The second bit of the desired sequence is detected.\n    S3: The third bit of the desired sequence is detected.\n    S4: The fourth and final bit of the desired sequence is detected, and the output sequence_detected is set high.\n\nImplementation:\n    -FSM Design: The FSM transitions through states based on the bitstream data_in. On each clock cycle, the detector checks for a match of the specific sequence.\n\n    -Sequence Detection: The module checks the input data_in and transitions between states. Once the complete sequence is detected, sequence_detected is asserted.\n\n    -Reset Behavior: When reset is high, the state machine returns to the IDLE state, resetting the detection process."}, "clean_code": "module sequence_detector(\n     input  clk, \n     input  rst_n,\n     input  data_in, \n     output sequence_detected\t\t\t\t\n     );\n\n       \nparameter        IDLE = 5'b00001;\nparameter        S1   = 5'b00010;\nparameter \t     S2   = 5'b00100;\nparameter        S3   = 5'b01000;\nparameter        S4   = 5'b10000; \n\n\nreg [4:0]\t\t curr_state;\nreg [4:0] \t\t next_state;\n\n\nalways@(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n\t    curr_state <= IDLE;\n    end\n    else begin\n\t    curr_state <= next_state;\n    end\nend\n\n\nalways@(*) begin\n    if(!rst_n) begin\n\t    next_state <= IDLE;\n    end\n    else begin\n\t    case(curr_state)\n\t        IDLE  :next_state = data_in?S1:IDLE;\n\t        S1\t  :next_state = data_in?S1:S2;\n\t        S2\t  :next_state = data_in?S1:S3;\n\t        S3\t  :next_state = data_in?S4:IDLE;\n\t        S4\t  :next_state = data_in?S1:S2;\n\t        default:next_state = IDLE;\t\n\t    endcase\n    end\nend\n\nassign sequence_detected = (curr_state ==S4) ? 1'b1 : 1'b0;\n\nendmodule", "corrupted_code": "module sequence_detector(\n     input  clk, \n     input  rst_n,\n     input  data_in, \n     output sequence_detected\t\t\t\t\n     );\n\n       \nparameter        IDLE = 5'b00001;\nparameter        S1   = 5'b00010;\nparameter \t     S2   = 5'b00100;\nparameter        S3   = 5'b01000;\nparameter        S4   = 5'b10000; \n\n\nreg [4:0]\t\t curr_state;\nreg [4:0] \t\t next_state;\n\n\nalways@(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n\t    curr_state <= IDLE;\n    end\n    else begin\n\t    curr_state <= next_state;\n    end\nend\n\n\nalways@(*) begin\n    if(!rst_n) begin\n\t    \n    end\n    else begin\n\t    case(curr_state)\n\t        IDLE  :next_state = data_in?S1:IDLE;\n\t        S1\t  :next_state = data_in?S1:S2;\n\t        S2\t  :next_state = data_in?S1:S3;\n\t        S3\t  :next_state = data_in?S4:IDLE;\n\t        S4\t  :next_state = data_in?S1:S2;\n\t        default:next_state = IDLE;\t\n\t    endcase\n    end\nend\n\nassign sequence_detected = (curr_state ==S4) ? 1'b1 : 1'b0;\n\nendmodule", "corruption_explanation": "Removed assignment from reset block", "modification_type": "remove_reset_assignment", "modification_line": 31, "original_snippet": "next_state <= IDLE;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing a signal initialization in the reset block. This leaves registers with undefined initial values after reset, causing unpredictable behavior on startup. Simulation may pass but hardware behavior will be incorrect.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_reset_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed assignment from reset block\n   \u2022 Line 31: Original: next_state <= IDLE;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 31.\n   \u2022 Restore the original code: next_state <= IDLE;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove reset assignment.", "complexity": 9, "applicable_modifications": ["invert_if_else", "remove_else_branch", "remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_reset_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.776872", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Control", "subcategory": "Finite State Machine", "design_name": "sequence_detector", "module_name": "sequence_detector", "description": "Please act as a professional Verilog designer.\n\nImplement a module of a sequence detector to detect a specific 4-bit binary sequence 1001.\n\nModule name:\n    sequence_detector\n\nInput ports:\n    clk: Clock signal to synchronize the detector.\n    reset_n: Reset signal to initialize the state machine.\n    data_in: 1-bit binary input signal to feed the bitstream for sequence detection.\n\nOutput ports:\n    sequence_detected: 1-bit output signal that is set high when the specific sequence is detected.\n    \nInternal logic:\n    State Machine: The sequence detector uses a finite state machine (FSM) with the following states:\n    IDLE: Waiting for the start of the sequence.\n    S1: The first bit of the desired sequence is detected.\n    S2: The second bit of the desired sequence is detected.\n    S3: The third bit of the desired sequence is detected.\n    S4: The fourth and final bit of the desired sequence is detected, and the output sequence_detected is set high.\n\nImplementation:\n    -FSM Design: The FSM transitions through states based on the bitstream data_in. On each clock cycle, the detector checks for a match of the specific sequence.\n\n    -Sequence Detection: The module checks the input data_in and transitions between states. Once the complete sequence is detected, sequence_detected is asserted.\n\n    -Reset Behavior: When reset is high, the state machine returns to the IDLE state, resetting the detection process."}, "clean_code": "module sequence_detector(\n     input  clk, \n     input  rst_n,\n     input  data_in, \n     output sequence_detected\t\t\t\t\n     );\n\n       \nparameter        IDLE = 5'b00001;\nparameter        S1   = 5'b00010;\nparameter \t     S2   = 5'b00100;\nparameter        S3   = 5'b01000;\nparameter        S4   = 5'b10000; \n\n\nreg [4:0]\t\t curr_state;\nreg [4:0] \t\t next_state;\n\n\nalways@(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n\t    curr_state <= IDLE;\n    end\n    else begin\n\t    curr_state <= next_state;\n    end\nend\n\n\nalways@(*) begin\n    if(!rst_n) begin\n\t    next_state <= IDLE;\n    end\n    else begin\n\t    case(curr_state)\n\t        IDLE  :next_state = data_in?S1:IDLE;\n\t        S1\t  :next_state = data_in?S1:S2;\n\t        S2\t  :next_state = data_in?S1:S3;\n\t        S3\t  :next_state = data_in?S4:IDLE;\n\t        S4\t  :next_state = data_in?S1:S2;\n\t        default:next_state = IDLE;\t\n\t    endcase\n    end\nend\n\nassign sequence_detected = (curr_state ==S4) ? 1'b1 : 1'b0;\n\nendmodule", "corrupted_code": "module sequence_detector(\n     input  clk, \n     input  rst_n,\n     input  data_in, \n     output sequence_detected\t\t\t\t\n     );\n\n       \nparameter        IDLE = 5'b00001;\nparameter        S1   = 5'b00010;\nparameter \t     S2   = 5'b00100;\nparameter        S3   = 5'b01000;\nparameter        S4   = 5'b10000; \n\n\nreg [4:0]\t\t curr_state;\nreg [4:0] \t\t next_state;\n\n\nalways@(posedge clk) begin\n    if(!rst_n) begin\n\t    curr_state <= IDLE;\n    end\n    else begin\n\t    curr_state <= next_state;\n    end\nend\n\n\nalways@(*) begin\n    if(!rst_n) begin\n\t    next_state <= IDLE;\n    end\n    else begin\n\t    case(curr_state)\n\t        IDLE  :next_state = data_in?S1:IDLE;\n\t        S1\t  :next_state = data_in?S1:S2;\n\t        S2\t  :next_state = data_in?S1:S3;\n\t        S3\t  :next_state = data_in?S4:IDLE;\n\t        S4\t  :next_state = data_in?S1:S2;\n\t        default:next_state = IDLE;\t\n\t    endcase\n    end\nend\n\nassign sequence_detected = (curr_state ==S4) ? 1'b1 : 1'b0;\n\nendmodule", "corruption_explanation": "Removed async reset from sensitivity list", "modification_type": "remove_async_reset", "modification_line": 20, "original_snippet": "always@(posedge clk or negedge rst_n)", "modified_snippet": "always@(posedge clk)", "issue_description": "The buggy code has removed async reset from the sensitivity list. The always block only triggers on clock edges, not reset. This causes metastability on power-up and removes the ability to asynchronously reset the design.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_async_reset modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed async reset from sensitivity list\n   \u2022 Line 20: Original: always@(posedge clk or negedge rst_n)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 20.\n   \u2022 Restore the original code: always@(posedge clk or negedge rst_n)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove async reset.", "complexity": 9, "applicable_modifications": ["invert_if_else", "remove_else_branch", "remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_async_reset"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.777909", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "LIFO", "design_name": "LIFObuffer", "module_name": "LIFObuffer", "description": "Please act as a professional Verilog designer.\n\nA Last-In-First-Out (LIFO) buffer for temporary data storage. This 4-bit wide buffer can hold up to 4 entries, allowing for push and pop operations controlled by read/write (RW) signals.\n\nModule name:\n    LIFObuffer\n\nInput ports:\n    dataIn [3:0]: 4-bit input data to be pushed onto the buffer.\n    RW: Read/Write control signal (1 for read, 0 for write).\n    EN: Enable signal to activate buffer operations.\n    Rst: Active high reset signal to initialize the buffer.\n    Clk: Clock signal for synchronous operations.\n\nOutput ports:\n    EMPTY: Flag indicating whether the buffer is empty.\n    FULL: Flag indicating whether the buffer is full.\n    dataOut [3:0]: 4-bit output data retrieved from the buffer.\n\nImplementation:\n    The buffer uses a stack memory array (stack_mem) to store the data. A stack pointer (SP) tracks the current position in the stack.\n    On the rising edge of the clock (Clk), if the enable (EN) signal is high:\n    If the reset (Rst) signal is high, the stack is cleared, the stack pointer is set to 4 (indicating an empty buffer), and all memory locations are initialized to 0.\n    If the reset signal is low, the buffer checks if it is full or empty and processes data accordingly:\n    If RW is low (write operation) and the buffer is not full, data from dataIn is pushed onto the stack, and the stack pointer is decremented.\n    If RW is high (read operation) and the buffer is not empty, data is popped from the stack into dataOut, the corresponding stack memory is cleared, and the stack pointer is incremented.\n    Flags for EMPTY and FULL are updated based on the stack pointer status.\n\nGive me the complete code."}, "clean_code": "module LIFObuffer (\n    input [3:0] dataIn,\n    input RW,\n    input EN,\n    input Rst,\n    input Clk,\n    output reg EMPTY,\n    output reg FULL,\n    output reg [3:0] dataOut\n);\n\n    reg [3:0] stack_mem[0:3];\n    reg [2:0] SP;\n    integer i;\n\n    always @ (posedge Clk) begin\n        if (EN == 0) begin\n            // Do nothing if EN is 0\n        end else begin\n            if (Rst == 1) begin\n                SP = 3'd4;\n                EMPTY = SP[2];\n                dataOut = 4'h0;\n                for (i = 0; i < 4; i = i + 1) begin\n                    stack_mem[i] = 0;\n                end\n            end else if (Rst == 0) begin\n                FULL = SP ? 0 : 1;\n                EMPTY = SP[2];\n                dataOut = 4'hx;\n                \n                if (FULL == 1'b0 && RW == 1'b0) begin\n                    SP = SP - 1'b1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                    stack_mem[SP] = dataIn;\n                end else if (EMPTY == 1'b0 && RW == 1'b1) begin\n                    dataOut = stack_mem[SP];\n                    stack_mem[SP] = 0;\n                    SP = SP + 1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                end else begin\n                    // Do nothing if neither condition is met\n                end\n            end else begin\n                // Do nothing if neither condition is met\n            end\n        end\n    end\nendmodule\n", "corrupted_code": "module LIFObuffer (\n    input [3:0] dataIn,\n    input RW,\n    input EN,\n    input Rst,\n    input Clk,\n    output reg EMPTY,\n    output reg FULL,\n    output reg [3:0] dataOut\n);\n\n    reg [3:0] stack_mem[0:3];\n    reg [2:0] SP;\n    integer i;\n\n    always @ (posedge Clk) begin\n        if (EN == 0) begin\n            // Do nothing if EN is 0\n        end else begin\n            if (Rst == 1) begin\n                SP = 3'd4;\n                EMPTY = SP[2];\n                dataOut = 4'h0;\n                for (i = 0; 4 < i; i = i + 1) begin\n                    stack_mem[i] = 0;\n                end\n            end else if (Rst == 0) begin\n                FULL = SP ? 0 : 1;\n                EMPTY = SP[2];\n                dataOut = 4'hx;\n                \n                if (FULL == 1'b0 && RW == 1'b0) begin\n                    SP = SP - 1'b1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                    stack_mem[SP] = dataIn;\n                end else if (EMPTY == 1'b0 && RW == 1'b1) begin\n                    dataOut = stack_mem[SP];\n                    stack_mem[SP] = 0;\n                    SP = SP + 1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                end else begin\n                    // Do nothing if neither condition is met\n                end\n            end else begin\n                // Do nothing if neither condition is met\n            end\n        end\n    end\nendmodule\n", "corruption_explanation": "Swapped operands: 'i < 4' -> '4 < i'", "modification_type": "swap_operands", "modification_line": 24, "original_snippet": "i < 4", "modified_snippet": "4 < i", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'i < 4' -> '4 < i'\n   \u2022 Line 24: Original: i < 4\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 24.\n   \u2022 Restore the original code: i < 4\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 20, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_operands"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.781943", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "LIFO", "design_name": "LIFObuffer", "module_name": "LIFObuffer", "description": "Please act as a professional Verilog designer.\n\nA Last-In-First-Out (LIFO) buffer for temporary data storage. This 4-bit wide buffer can hold up to 4 entries, allowing for push and pop operations controlled by read/write (RW) signals.\n\nModule name:\n    LIFObuffer\n\nInput ports:\n    dataIn [3:0]: 4-bit input data to be pushed onto the buffer.\n    RW: Read/Write control signal (1 for read, 0 for write).\n    EN: Enable signal to activate buffer operations.\n    Rst: Active high reset signal to initialize the buffer.\n    Clk: Clock signal for synchronous operations.\n\nOutput ports:\n    EMPTY: Flag indicating whether the buffer is empty.\n    FULL: Flag indicating whether the buffer is full.\n    dataOut [3:0]: 4-bit output data retrieved from the buffer.\n\nImplementation:\n    The buffer uses a stack memory array (stack_mem) to store the data. A stack pointer (SP) tracks the current position in the stack.\n    On the rising edge of the clock (Clk), if the enable (EN) signal is high:\n    If the reset (Rst) signal is high, the stack is cleared, the stack pointer is set to 4 (indicating an empty buffer), and all memory locations are initialized to 0.\n    If the reset signal is low, the buffer checks if it is full or empty and processes data accordingly:\n    If RW is low (write operation) and the buffer is not full, data from dataIn is pushed onto the stack, and the stack pointer is decremented.\n    If RW is high (read operation) and the buffer is not empty, data is popped from the stack into dataOut, the corresponding stack memory is cleared, and the stack pointer is incremented.\n    Flags for EMPTY and FULL are updated based on the stack pointer status.\n\nGive me the complete code."}, "clean_code": "module LIFObuffer (\n    input [3:0] dataIn,\n    input RW,\n    input EN,\n    input Rst,\n    input Clk,\n    output reg EMPTY,\n    output reg FULL,\n    output reg [3:0] dataOut\n);\n\n    reg [3:0] stack_mem[0:3];\n    reg [2:0] SP;\n    integer i;\n\n    always @ (posedge Clk) begin\n        if (EN == 0) begin\n            // Do nothing if EN is 0\n        end else begin\n            if (Rst == 1) begin\n                SP = 3'd4;\n                EMPTY = SP[2];\n                dataOut = 4'h0;\n                for (i = 0; i < 4; i = i + 1) begin\n                    stack_mem[i] = 0;\n                end\n            end else if (Rst == 0) begin\n                FULL = SP ? 0 : 1;\n                EMPTY = SP[2];\n                dataOut = 4'hx;\n                \n                if (FULL == 1'b0 && RW == 1'b0) begin\n                    SP = SP - 1'b1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                    stack_mem[SP] = dataIn;\n                end else if (EMPTY == 1'b0 && RW == 1'b1) begin\n                    dataOut = stack_mem[SP];\n                    stack_mem[SP] = 0;\n                    SP = SP + 1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                end else begin\n                    // Do nothing if neither condition is met\n                end\n            end else begin\n                // Do nothing if neither condition is met\n            end\n        end\n    end\nendmodule\n", "corrupted_code": "module LIFObuffer (\n    input [3:0] dataIn,\n    input RW,\n    input EN,\n    input Rst,\n    input Clk,\n    output reg EMPTY,\n    output reg FULL,\n    output reg [3:0] dataOut\n);\n\n    reg [3:0] stack_mem[0:3];\n    reg [2:0] SP;\n    integer i;\n\n    always @ (posedge Clk) begin\n        if (EN == 0) begin\n            // Do nothing if EN is 0\n        end\n            end else if (Rst == 0) begin\n                FULL = SP ? 0 : 1;\n                EMPTY = SP[2];\n                dataOut = 4'hx;\n                \n                if (FULL == 1'b0 && RW == 1'b0) begin\n                    SP = SP - 1'b1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                    stack_mem[SP] = dataIn;\n                end else if (EMPTY == 1'b0 && RW == 1'b1) begin\n                    dataOut = stack_mem[SP];\n                    stack_mem[SP] = 0;\n                    SP = SP + 1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                end else begin\n                    // Do nothing if neither condition is met\n                end\n            end else begin\n                // Do nothing if neither condition is met\n            end\n        end\n    end\nendmodule\n", "corruption_explanation": "Removed else branch (may cause latch inference)", "modification_type": "remove_else_branch", "modification_line": 17, "original_snippet": "if (EN == 0) begin\n            // Do nothing if EN is 0\n        end else begin\n            if (Rst == 1) begin\n                SP = 3'd4;\n                EMPTY = SP[2];\n                dataOut = 4'h0;", "modified_snippet": "if (EN == 0) begin\n            // Do nothing if EN is 0\n        end", "issue_description": "The buggy code is missing an else branch in a conditional statement. In combinational logic (always_comb or always @*), this can cause latch inference because the output is not defined for all input conditions. In sequential logic, signals may retain old values unexpectedly. This violates RTL design best practices requiring complete conditional assignments.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module should provide a complete conditional assignment to avoid latch inference.\n   \u2022 Combinational logic must define outputs for all input conditions.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an if statement without an else branch.\n   \u2022 The assigned signal is not defined when the condition is false.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The else branch has been removed from the conditional.\n   \u2022 This creates an incomplete conditional assignment.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Missing else branch leaves the signal undefined in some cases.\n   \u2022 Impact: Latch inference in combinational blocks, or stale values in sequential blocks.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Add an else branch with appropriate default or alternative assignment.\n   \u2022 Ensure all signals are assigned in all branches of the conditional.\n\n6. RTL Design Principle Violated:\n   \u2022 Combinational logic must have complete assignments to avoid latch inference.\n   \u2022 All conditional blocks should have else clauses or default values.", "complexity": 20, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_else_branch"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.783709", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "LIFO", "design_name": "LIFObuffer", "module_name": "LIFObuffer", "description": "Please act as a professional Verilog designer.\n\nA Last-In-First-Out (LIFO) buffer for temporary data storage. This 4-bit wide buffer can hold up to 4 entries, allowing for push and pop operations controlled by read/write (RW) signals.\n\nModule name:\n    LIFObuffer\n\nInput ports:\n    dataIn [3:0]: 4-bit input data to be pushed onto the buffer.\n    RW: Read/Write control signal (1 for read, 0 for write).\n    EN: Enable signal to activate buffer operations.\n    Rst: Active high reset signal to initialize the buffer.\n    Clk: Clock signal for synchronous operations.\n\nOutput ports:\n    EMPTY: Flag indicating whether the buffer is empty.\n    FULL: Flag indicating whether the buffer is full.\n    dataOut [3:0]: 4-bit output data retrieved from the buffer.\n\nImplementation:\n    The buffer uses a stack memory array (stack_mem) to store the data. A stack pointer (SP) tracks the current position in the stack.\n    On the rising edge of the clock (Clk), if the enable (EN) signal is high:\n    If the reset (Rst) signal is high, the stack is cleared, the stack pointer is set to 4 (indicating an empty buffer), and all memory locations are initialized to 0.\n    If the reset signal is low, the buffer checks if it is full or empty and processes data accordingly:\n    If RW is low (write operation) and the buffer is not full, data from dataIn is pushed onto the stack, and the stack pointer is decremented.\n    If RW is high (read operation) and the buffer is not empty, data is popped from the stack into dataOut, the corresponding stack memory is cleared, and the stack pointer is incremented.\n    Flags for EMPTY and FULL are updated based on the stack pointer status.\n\nGive me the complete code."}, "clean_code": "module LIFObuffer (\n    input [3:0] dataIn,\n    input RW,\n    input EN,\n    input Rst,\n    input Clk,\n    output reg EMPTY,\n    output reg FULL,\n    output reg [3:0] dataOut\n);\n\n    reg [3:0] stack_mem[0:3];\n    reg [2:0] SP;\n    integer i;\n\n    always @ (posedge Clk) begin\n        if (EN == 0) begin\n            // Do nothing if EN is 0\n        end else begin\n            if (Rst == 1) begin\n                SP = 3'd4;\n                EMPTY = SP[2];\n                dataOut = 4'h0;\n                for (i = 0; i < 4; i = i + 1) begin\n                    stack_mem[i] = 0;\n                end\n            end else if (Rst == 0) begin\n                FULL = SP ? 0 : 1;\n                EMPTY = SP[2];\n                dataOut = 4'hx;\n                \n                if (FULL == 1'b0 && RW == 1'b0) begin\n                    SP = SP - 1'b1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                    stack_mem[SP] = dataIn;\n                end else if (EMPTY == 1'b0 && RW == 1'b1) begin\n                    dataOut = stack_mem[SP];\n                    stack_mem[SP] = 0;\n                    SP = SP + 1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                end else begin\n                    // Do nothing if neither condition is met\n                end\n            end else begin\n                // Do nothing if neither condition is met\n            end\n        end\n    end\nendmodule\n", "corrupted_code": "module LIFObuffer (\n    input [3:0] dataIn,\n    input RW,\n    input EN,\n    input Rst,\n    input Clk,\n    output reg EMPTY,\n    output reg FULL,\n    output reg [3:0] dataOut\n);\n\n    reg [3:0] stack_mem[0:3];\n    reg [2:0] SP;\n    integer i;\n\n    always @(Clk) begin\n        if (EN == 0) begin\n            // Do nothing if EN is 0\n        end else begin\n            if (Rst == 1) begin\n                SP = 3'd4;\n                EMPTY = SP[2];\n                dataOut = 4'h0;\n                for (i = 0; i < 4; i = i + 1) begin\n                    stack_mem[i] = 0;\n                end\n            end else if (Rst == 0) begin\n                FULL = SP ? 0 : 1;\n                EMPTY = SP[2];\n                dataOut = 4'hx;\n                \n                if (FULL == 1'b0 && RW == 1'b0) begin\n                    SP = SP - 1'b1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                    stack_mem[SP] = dataIn;\n                end else if (EMPTY == 1'b0 && RW == 1'b1) begin\n                    dataOut = stack_mem[SP];\n                    stack_mem[SP] = 0;\n                    SP = SP + 1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                end else begin\n                    // Do nothing if neither condition is met\n                end\n            end else begin\n                // Do nothing if neither condition is met\n            end\n        end\n    end\nendmodule\n", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 16, "original_snippet": "always @ (posedge Clk)", "modified_snippet": "always @(Clk)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 16: Original: always @ (posedge Clk)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 16.\n   \u2022 Restore the original code: always @ (posedge Clk)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 20, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_sensitivity_list"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.785400", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "LIFO", "design_name": "LIFObuffer", "module_name": "LIFObuffer", "description": "Please act as a professional Verilog designer.\n\nA Last-In-First-Out (LIFO) buffer for temporary data storage. This 4-bit wide buffer can hold up to 4 entries, allowing for push and pop operations controlled by read/write (RW) signals.\n\nModule name:\n    LIFObuffer\n\nInput ports:\n    dataIn [3:0]: 4-bit input data to be pushed onto the buffer.\n    RW: Read/Write control signal (1 for read, 0 for write).\n    EN: Enable signal to activate buffer operations.\n    Rst: Active high reset signal to initialize the buffer.\n    Clk: Clock signal for synchronous operations.\n\nOutput ports:\n    EMPTY: Flag indicating whether the buffer is empty.\n    FULL: Flag indicating whether the buffer is full.\n    dataOut [3:0]: 4-bit output data retrieved from the buffer.\n\nImplementation:\n    The buffer uses a stack memory array (stack_mem) to store the data. A stack pointer (SP) tracks the current position in the stack.\n    On the rising edge of the clock (Clk), if the enable (EN) signal is high:\n    If the reset (Rst) signal is high, the stack is cleared, the stack pointer is set to 4 (indicating an empty buffer), and all memory locations are initialized to 0.\n    If the reset signal is low, the buffer checks if it is full or empty and processes data accordingly:\n    If RW is low (write operation) and the buffer is not full, data from dataIn is pushed onto the stack, and the stack pointer is decremented.\n    If RW is high (read operation) and the buffer is not empty, data is popped from the stack into dataOut, the corresponding stack memory is cleared, and the stack pointer is incremented.\n    Flags for EMPTY and FULL are updated based on the stack pointer status.\n\nGive me the complete code."}, "clean_code": "module LIFObuffer (\n    input [3:0] dataIn,\n    input RW,\n    input EN,\n    input Rst,\n    input Clk,\n    output reg EMPTY,\n    output reg FULL,\n    output reg [3:0] dataOut\n);\n\n    reg [3:0] stack_mem[0:3];\n    reg [2:0] SP;\n    integer i;\n\n    always @ (posedge Clk) begin\n        if (EN == 0) begin\n            // Do nothing if EN is 0\n        end else begin\n            if (Rst == 1) begin\n                SP = 3'd4;\n                EMPTY = SP[2];\n                dataOut = 4'h0;\n                for (i = 0; i < 4; i = i + 1) begin\n                    stack_mem[i] = 0;\n                end\n            end else if (Rst == 0) begin\n                FULL = SP ? 0 : 1;\n                EMPTY = SP[2];\n                dataOut = 4'hx;\n                \n                if (FULL == 1'b0 && RW == 1'b0) begin\n                    SP = SP - 1'b1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                    stack_mem[SP] = dataIn;\n                end else if (EMPTY == 1'b0 && RW == 1'b1) begin\n                    dataOut = stack_mem[SP];\n                    stack_mem[SP] = 0;\n                    SP = SP + 1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                end else begin\n                    // Do nothing if neither condition is met\n                end\n            end else begin\n                // Do nothing if neither condition is met\n            end\n        end\n    end\nendmodule\n", "corrupted_code": "module LIFObuffer (\n    input [3:0] dataIn,\n    input RW,\n    input EN,\n    input Rst,\n    input Clk,\n    output reg EMPTY,\n    output reg FULL,\n    output reg [3:0] dataOut\n);\n\n    reg [3:0] stack_mem[0:3];\n    reg [2:0] SP;\n    integer i;\n\n    always @ (posedge Clk) begin\n        if (EN == 0) begin\n            // Do nothing if EN is 0\n        end else begin\n            if (Rst == 1) begin\n                SP = 3'd4;\n                EMPTY = SP[2];\n                dataOut = 4'h0;\n                \n            end else if (Rst == 0) begin\n                FULL = SP ? 0 : 1;\n                EMPTY = SP[2];\n                dataOut = 4'hx;\n                \n                if (FULL == 1'b0 && RW == 1'b0) begin\n                    SP = SP - 1'b1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                    stack_mem[SP] = dataIn;\n                end else if (EMPTY == 1'b0 && RW == 1'b1) begin\n                    dataOut = stack_mem[SP];\n                    stack_mem[SP] = 0;\n                    SP = SP + 1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                end else begin\n                    // Do nothing if neither condition is met\n                end\n            end else begin\n                // Do nothing if neither condition is met\n            end\n        end\n    end\nendmodule\n", "corruption_explanation": "Removed a loop block", "modification_type": "remove_loop", "modification_line": 24, "original_snippet": "for (i = 0; i < 4; i = i + 1) begin\n                    stack_mem[i] = 0;\n                end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing a loop construct. This removes iterative logic that may be essential for initialization, array operations, or repetitive computations. Functionality that depends on the loop will be broken.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_loop modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed a loop block\n   \u2022 Line 24: Original: for (i = 0; i < 4; i = i + 1) begin\n                    stack_mem[i] = 0;\n                end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 24.\n   \u2022 Restore the original code: for (i = 0; i < 4; i = i + 1) begin\n                    stack_mem[i] = 0;\n                end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove loop.", "complexity": 20, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_loop"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.787100", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "LIFO", "design_name": "LIFObuffer", "module_name": "LIFObuffer", "description": "Please act as a professional Verilog designer.\n\nA Last-In-First-Out (LIFO) buffer for temporary data storage. This 4-bit wide buffer can hold up to 4 entries, allowing for push and pop operations controlled by read/write (RW) signals.\n\nModule name:\n    LIFObuffer\n\nInput ports:\n    dataIn [3:0]: 4-bit input data to be pushed onto the buffer.\n    RW: Read/Write control signal (1 for read, 0 for write).\n    EN: Enable signal to activate buffer operations.\n    Rst: Active high reset signal to initialize the buffer.\n    Clk: Clock signal for synchronous operations.\n\nOutput ports:\n    EMPTY: Flag indicating whether the buffer is empty.\n    FULL: Flag indicating whether the buffer is full.\n    dataOut [3:0]: 4-bit output data retrieved from the buffer.\n\nImplementation:\n    The buffer uses a stack memory array (stack_mem) to store the data. A stack pointer (SP) tracks the current position in the stack.\n    On the rising edge of the clock (Clk), if the enable (EN) signal is high:\n    If the reset (Rst) signal is high, the stack is cleared, the stack pointer is set to 4 (indicating an empty buffer), and all memory locations are initialized to 0.\n    If the reset signal is low, the buffer checks if it is full or empty and processes data accordingly:\n    If RW is low (write operation) and the buffer is not full, data from dataIn is pushed onto the stack, and the stack pointer is decremented.\n    If RW is high (read operation) and the buffer is not empty, data is popped from the stack into dataOut, the corresponding stack memory is cleared, and the stack pointer is incremented.\n    Flags for EMPTY and FULL are updated based on the stack pointer status.\n\nGive me the complete code."}, "clean_code": "module LIFObuffer (\n    input [3:0] dataIn,\n    input RW,\n    input EN,\n    input Rst,\n    input Clk,\n    output reg EMPTY,\n    output reg FULL,\n    output reg [3:0] dataOut\n);\n\n    reg [3:0] stack_mem[0:3];\n    reg [2:0] SP;\n    integer i;\n\n    always @ (posedge Clk) begin\n        if (EN == 0) begin\n            // Do nothing if EN is 0\n        end else begin\n            if (Rst == 1) begin\n                SP = 3'd4;\n                EMPTY = SP[2];\n                dataOut = 4'h0;\n                for (i = 0; i < 4; i = i + 1) begin\n                    stack_mem[i] = 0;\n                end\n            end else if (Rst == 0) begin\n                FULL = SP ? 0 : 1;\n                EMPTY = SP[2];\n                dataOut = 4'hx;\n                \n                if (FULL == 1'b0 && RW == 1'b0) begin\n                    SP = SP - 1'b1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                    stack_mem[SP] = dataIn;\n                end else if (EMPTY == 1'b0 && RW == 1'b1) begin\n                    dataOut = stack_mem[SP];\n                    stack_mem[SP] = 0;\n                    SP = SP + 1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                end else begin\n                    // Do nothing if neither condition is met\n                end\n            end else begin\n                // Do nothing if neither condition is met\n            end\n        end\n    end\nendmodule\n", "corrupted_code": "module LIFObuffer (\n    input [3:0] dataIn,\n    input RW,\n    input EN,\n    input Rst,\n    input Clk,\n    output reg EMPTY,\n    output reg FULL,\n    output reg [3:0] dataOut\n);\n\n    reg [3:0] stack_mem[0:3];\n    reg [2:0] SP;\n    integer i;\n\n    always @ (posedge Clk) begin\n        \n            end else if (Rst == 0) begin\n                FULL = SP ? 0 : 1;\n                EMPTY = SP[2];\n                dataOut = 4'hx;\n                \n                if (FULL == 1'b0 && RW == 1'b0) begin\n                    SP = SP - 1'b1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                    stack_mem[SP] = dataIn;\n                end else if (EMPTY == 1'b0 && RW == 1'b1) begin\n                    dataOut = stack_mem[SP];\n                    stack_mem[SP] = 0;\n                    SP = SP + 1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                end else begin\n                    // Do nothing if neither condition is met\n                end\n            end else begin\n                // Do nothing if neither condition is met\n            end\n        end\n    end\nendmodule\n", "corruption_explanation": "Removed a conditional block", "modification_type": "remove_conditional", "modification_line": 17, "original_snippet": "if (EN == 0) begin\n            // Do nothing if EN is 0\n        end else begin\n            if (Rst == 1) begin\n                SP = 3'd4;\n                EMPTY = SP[2];\n                dataOut = 4'h0;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing a conditional block. This removes important control logic, causing the design to skip necessary state transitions or data processing. Test cases that depend on the conditional behavior will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_conditional modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed a conditional block\n   \u2022 Line 17: Original: if (EN == 0) begin\n            // Do nothing if EN is 0\n        end else begin\n            if (Rst == 1) begin\n                SP = 3'd4;\n                EMPTY = SP[2];\n                dataOut = 4'h0;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 17.\n   \u2022 Restore the original code: if (EN == 0) begin\n            // Do nothing if EN is 0\n        end else begin\n            if (Rst == 1) begin\n                SP = 3'd4;\n                EMPTY = SP[2];\n                dataOut = 4'h0;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove conditional.", "complexity": 20, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_conditional"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.788790", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "LIFO", "design_name": "LIFObuffer", "module_name": "LIFObuffer", "description": "Please act as a professional Verilog designer.\n\nA Last-In-First-Out (LIFO) buffer for temporary data storage. This 4-bit wide buffer can hold up to 4 entries, allowing for push and pop operations controlled by read/write (RW) signals.\n\nModule name:\n    LIFObuffer\n\nInput ports:\n    dataIn [3:0]: 4-bit input data to be pushed onto the buffer.\n    RW: Read/Write control signal (1 for read, 0 for write).\n    EN: Enable signal to activate buffer operations.\n    Rst: Active high reset signal to initialize the buffer.\n    Clk: Clock signal for synchronous operations.\n\nOutput ports:\n    EMPTY: Flag indicating whether the buffer is empty.\n    FULL: Flag indicating whether the buffer is full.\n    dataOut [3:0]: 4-bit output data retrieved from the buffer.\n\nImplementation:\n    The buffer uses a stack memory array (stack_mem) to store the data. A stack pointer (SP) tracks the current position in the stack.\n    On the rising edge of the clock (Clk), if the enable (EN) signal is high:\n    If the reset (Rst) signal is high, the stack is cleared, the stack pointer is set to 4 (indicating an empty buffer), and all memory locations are initialized to 0.\n    If the reset signal is low, the buffer checks if it is full or empty and processes data accordingly:\n    If RW is low (write operation) and the buffer is not full, data from dataIn is pushed onto the stack, and the stack pointer is decremented.\n    If RW is high (read operation) and the buffer is not empty, data is popped from the stack into dataOut, the corresponding stack memory is cleared, and the stack pointer is incremented.\n    Flags for EMPTY and FULL are updated based on the stack pointer status.\n\nGive me the complete code."}, "clean_code": "module LIFObuffer (\n    input [3:0] dataIn,\n    input RW,\n    input EN,\n    input Rst,\n    input Clk,\n    output reg EMPTY,\n    output reg FULL,\n    output reg [3:0] dataOut\n);\n\n    reg [3:0] stack_mem[0:3];\n    reg [2:0] SP;\n    integer i;\n\n    always @ (posedge Clk) begin\n        if (EN == 0) begin\n            // Do nothing if EN is 0\n        end else begin\n            if (Rst == 1) begin\n                SP = 3'd4;\n                EMPTY = SP[2];\n                dataOut = 4'h0;\n                for (i = 0; i < 4; i = i + 1) begin\n                    stack_mem[i] = 0;\n                end\n            end else if (Rst == 0) begin\n                FULL = SP ? 0 : 1;\n                EMPTY = SP[2];\n                dataOut = 4'hx;\n                \n                if (FULL == 1'b0 && RW == 1'b0) begin\n                    SP = SP - 1'b1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                    stack_mem[SP] = dataIn;\n                end else if (EMPTY == 1'b0 && RW == 1'b1) begin\n                    dataOut = stack_mem[SP];\n                    stack_mem[SP] = 0;\n                    SP = SP + 1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                end else begin\n                    // Do nothing if neither condition is met\n                end\n            end else begin\n                // Do nothing if neither condition is met\n            end\n        end\n    end\nendmodule\n", "corrupted_code": "module LIFObuffer (\n    input [3:0] dataIn,\n    input RW,\n    input EN,\n    input Rst,\n    input Clk,\n    output reg EMPTY,\n    output reg FULL,\n    output reg [3:0] dataOut\n);\n\n    reg [2:0] stack_mem[0:3];\n    reg [2:0] SP;\n    integer i;\n\n    always @ (posedge Clk) begin\n        if (EN == 0) begin\n            // Do nothing if EN is 0\n        end else begin\n            if (Rst == 1) begin\n                SP = 3'd4;\n                EMPTY = SP[2];\n                dataOut = 4'h0;\n                for (i = 0; i < 4; i = i + 1) begin\n                    stack_mem[i] = 0;\n                end\n            end else if (Rst == 0) begin\n                FULL = SP ? 0 : 1;\n                EMPTY = SP[2];\n                dataOut = 4'hx;\n                \n                if (FULL == 1'b0 && RW == 1'b0) begin\n                    SP = SP - 1'b1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                    stack_mem[SP] = dataIn;\n                end else if (EMPTY == 1'b0 && RW == 1'b1) begin\n                    dataOut = stack_mem[SP];\n                    stack_mem[SP] = 0;\n                    SP = SP + 1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                end else begin\n                    // Do nothing if neither condition is met\n                end\n            end else begin\n                // Do nothing if neither condition is met\n            end\n        end\n    end\nendmodule\n", "corruption_explanation": "Changed bit width from [3:0] to [2:0]", "modification_type": "change_bit_width", "modification_line": 12, "original_snippet": "[3:0]", "modified_snippet": "[2:0]", "issue_description": "The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_bit_width modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed bit width from [3:0] to [2:0]\n   \u2022 Line 12: Original: [3:0]\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 12.\n   \u2022 Restore the original code: [3:0]\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change bit width.", "complexity": 20, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_bit_width"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.790449", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "LIFO", "design_name": "LIFObuffer", "module_name": "LIFObuffer", "description": "Please act as a professional Verilog designer.\n\nA Last-In-First-Out (LIFO) buffer for temporary data storage. This 4-bit wide buffer can hold up to 4 entries, allowing for push and pop operations controlled by read/write (RW) signals.\n\nModule name:\n    LIFObuffer\n\nInput ports:\n    dataIn [3:0]: 4-bit input data to be pushed onto the buffer.\n    RW: Read/Write control signal (1 for read, 0 for write).\n    EN: Enable signal to activate buffer operations.\n    Rst: Active high reset signal to initialize the buffer.\n    Clk: Clock signal for synchronous operations.\n\nOutput ports:\n    EMPTY: Flag indicating whether the buffer is empty.\n    FULL: Flag indicating whether the buffer is full.\n    dataOut [3:0]: 4-bit output data retrieved from the buffer.\n\nImplementation:\n    The buffer uses a stack memory array (stack_mem) to store the data. A stack pointer (SP) tracks the current position in the stack.\n    On the rising edge of the clock (Clk), if the enable (EN) signal is high:\n    If the reset (Rst) signal is high, the stack is cleared, the stack pointer is set to 4 (indicating an empty buffer), and all memory locations are initialized to 0.\n    If the reset signal is low, the buffer checks if it is full or empty and processes data accordingly:\n    If RW is low (write operation) and the buffer is not full, data from dataIn is pushed onto the stack, and the stack pointer is decremented.\n    If RW is high (read operation) and the buffer is not empty, data is popped from the stack into dataOut, the corresponding stack memory is cleared, and the stack pointer is incremented.\n    Flags for EMPTY and FULL are updated based on the stack pointer status.\n\nGive me the complete code."}, "clean_code": "module LIFObuffer (\n    input [3:0] dataIn,\n    input RW,\n    input EN,\n    input Rst,\n    input Clk,\n    output reg EMPTY,\n    output reg FULL,\n    output reg [3:0] dataOut\n);\n\n    reg [3:0] stack_mem[0:3];\n    reg [2:0] SP;\n    integer i;\n\n    always @ (posedge Clk) begin\n        if (EN == 0) begin\n            // Do nothing if EN is 0\n        end else begin\n            if (Rst == 1) begin\n                SP = 3'd4;\n                EMPTY = SP[2];\n                dataOut = 4'h0;\n                for (i = 0; i < 4; i = i + 1) begin\n                    stack_mem[i] = 0;\n                end\n            end else if (Rst == 0) begin\n                FULL = SP ? 0 : 1;\n                EMPTY = SP[2];\n                dataOut = 4'hx;\n                \n                if (FULL == 1'b0 && RW == 1'b0) begin\n                    SP = SP - 1'b1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                    stack_mem[SP] = dataIn;\n                end else if (EMPTY == 1'b0 && RW == 1'b1) begin\n                    dataOut = stack_mem[SP];\n                    stack_mem[SP] = 0;\n                    SP = SP + 1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                end else begin\n                    // Do nothing if neither condition is met\n                end\n            end else begin\n                // Do nothing if neither condition is met\n            end\n        end\n    end\nendmodule\n", "corrupted_code": "module LIFObuffer (\n    input [3:0] dataIn,\n    input RW,\n    input EN,\n    input Rst,\n    input Clk,\n    output reg EMPTY,\n    output reg FULL,\n    output reg [3:0] dataOut\n);\n\n    reg [3:0] stack_mem[0:3];\n    reg [2:0] SP;\n    integer i;\n\n    always @ (posedge Clk) begin\n        if (EN == 0) begin\n            // Do nothing if EN is 0\n        end else begin\n            if (Rst == 1) begin\n                SP = 3'd4;\n                EMPTY = SP[2];\n                dataOut = 4'h0;\n                for (i = 0; i < 4; i = i + 1) begin\n                    stack_mem[i] = 0;\n                end\n            end else if (Rst == 0) begin\n                FULL = SP ? 0 : 1;\n                EMPTY = SP[2];\n                dataOut = 4'hx;\n                \n                if (!(FULL == 1'b0 && RW == 1'b0)) begin\n                    SP = SP - 1'b1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                    stack_mem[SP] = dataIn;\n                end else if (EMPTY == 1'b0 && RW == 1'b1) begin\n                    dataOut = stack_mem[SP];\n                    stack_mem[SP] = 0;\n                    SP = SP + 1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                end else begin\n                    // Do nothing if neither condition is met\n                end\n            end else begin\n                // Do nothing if neither condition is met\n            end\n        end\n    end\nendmodule\n", "corruption_explanation": "Inverted condition: 'FULL == 1'b0 && RW == 1'b0' -> '!(FULL == 1'b0 && RW == 1'b0)'", "modification_type": "invert_condition", "modification_line": 32, "original_snippet": "if (FULL == 1'b0 && RW == 1'b0) begin", "modified_snippet": "if (!(FULL == 1'b0 && RW == 1'b0)) begin", "issue_description": "The buggy code has an inverted condition in an if statement. Instead of checking if(x), it checks if(!x), causing the logic to execute when it shouldn't and skip execution when it should. All conditional behavior is reversed from intended functionality.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_condition modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted condition: 'FULL == 1'b0 && RW == 1'b0' -> '!(FULL == 1'b0 && RW == 1'b0)'\n   \u2022 Line 32: Original: if (FULL == 1'b0 && RW == 1'b0) begin\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 32.\n   \u2022 Restore the original code: if (FULL == 1'b0 && RW == 1'b0) begin\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert condition.", "complexity": 20, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_condition"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.792134", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "LIFO", "design_name": "LIFObuffer", "module_name": "LIFObuffer", "description": "Please act as a professional Verilog designer.\n\nA Last-In-First-Out (LIFO) buffer for temporary data storage. This 4-bit wide buffer can hold up to 4 entries, allowing for push and pop operations controlled by read/write (RW) signals.\n\nModule name:\n    LIFObuffer\n\nInput ports:\n    dataIn [3:0]: 4-bit input data to be pushed onto the buffer.\n    RW: Read/Write control signal (1 for read, 0 for write).\n    EN: Enable signal to activate buffer operations.\n    Rst: Active high reset signal to initialize the buffer.\n    Clk: Clock signal for synchronous operations.\n\nOutput ports:\n    EMPTY: Flag indicating whether the buffer is empty.\n    FULL: Flag indicating whether the buffer is full.\n    dataOut [3:0]: 4-bit output data retrieved from the buffer.\n\nImplementation:\n    The buffer uses a stack memory array (stack_mem) to store the data. A stack pointer (SP) tracks the current position in the stack.\n    On the rising edge of the clock (Clk), if the enable (EN) signal is high:\n    If the reset (Rst) signal is high, the stack is cleared, the stack pointer is set to 4 (indicating an empty buffer), and all memory locations are initialized to 0.\n    If the reset signal is low, the buffer checks if it is full or empty and processes data accordingly:\n    If RW is low (write operation) and the buffer is not full, data from dataIn is pushed onto the stack, and the stack pointer is decremented.\n    If RW is high (read operation) and the buffer is not empty, data is popped from the stack into dataOut, the corresponding stack memory is cleared, and the stack pointer is incremented.\n    Flags for EMPTY and FULL are updated based on the stack pointer status.\n\nGive me the complete code."}, "clean_code": "module LIFObuffer (\n    input [3:0] dataIn,\n    input RW,\n    input EN,\n    input Rst,\n    input Clk,\n    output reg EMPTY,\n    output reg FULL,\n    output reg [3:0] dataOut\n);\n\n    reg [3:0] stack_mem[0:3];\n    reg [2:0] SP;\n    integer i;\n\n    always @ (posedge Clk) begin\n        if (EN == 0) begin\n            // Do nothing if EN is 0\n        end else begin\n            if (Rst == 1) begin\n                SP = 3'd4;\n                EMPTY = SP[2];\n                dataOut = 4'h0;\n                for (i = 0; i < 4; i = i + 1) begin\n                    stack_mem[i] = 0;\n                end\n            end else if (Rst == 0) begin\n                FULL = SP ? 0 : 1;\n                EMPTY = SP[2];\n                dataOut = 4'hx;\n                \n                if (FULL == 1'b0 && RW == 1'b0) begin\n                    SP = SP - 1'b1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                    stack_mem[SP] = dataIn;\n                end else if (EMPTY == 1'b0 && RW == 1'b1) begin\n                    dataOut = stack_mem[SP];\n                    stack_mem[SP] = 0;\n                    SP = SP + 1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                end else begin\n                    // Do nothing if neither condition is met\n                end\n            end else begin\n                // Do nothing if neither condition is met\n            end\n        end\n    end\nendmodule\n", "corrupted_code": "module LIFObuffer (\n    input [3:0] dataIn,\n    input RW,\n    input EN,\n    input Rst,\n    input Clk,\n    output reg EMPTY,\n    output reg FULL,\n    output reg [3:0] dataOut\n);\n\n    reg [3:0] stack_mem[0:3];\n    reg [2:0] SP;\n    integer i;\n\n    always @ (posedge Clk) begin\n        if (EN == 0) begin\n            // Do nothing if EN is 0\n        end else begin\n            if (Rst == 1) begin\n                SP = 3'd4;\n                EMPTY = SP[2];\n                dataOut = 4'h0;\n                for (i = 0; i < 4; i = i + 1) begin\n                    stack_mem[i] <= 0;\n                end\n            end else if (Rst == 0) begin\n                FULL = SP ? 0 : 1;\n                EMPTY = SP[2];\n                dataOut = 4'hx;\n                \n                if (FULL == 1'b0 && RW == 1'b0) begin\n                    SP = SP - 1'b1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                    stack_mem[SP] = dataIn;\n                end else if (EMPTY == 1'b0 && RW == 1'b1) begin\n                    dataOut = stack_mem[SP];\n                    stack_mem[SP] = 0;\n                    SP = SP + 1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                end else begin\n                    // Do nothing if neither condition is met\n                end\n            end else begin\n                // Do nothing if neither condition is met\n            end\n        end\n    end\nendmodule\n", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 25, "original_snippet": "stack_mem[i] = 0;", "modified_snippet": "stack_mem[i] <= 0;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 20, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.794003", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "LIFO", "design_name": "LIFObuffer", "module_name": "LIFObuffer", "description": "Please act as a professional Verilog designer.\n\nA Last-In-First-Out (LIFO) buffer for temporary data storage. This 4-bit wide buffer can hold up to 4 entries, allowing for push and pop operations controlled by read/write (RW) signals.\n\nModule name:\n    LIFObuffer\n\nInput ports:\n    dataIn [3:0]: 4-bit input data to be pushed onto the buffer.\n    RW: Read/Write control signal (1 for read, 0 for write).\n    EN: Enable signal to activate buffer operations.\n    Rst: Active high reset signal to initialize the buffer.\n    Clk: Clock signal for synchronous operations.\n\nOutput ports:\n    EMPTY: Flag indicating whether the buffer is empty.\n    FULL: Flag indicating whether the buffer is full.\n    dataOut [3:0]: 4-bit output data retrieved from the buffer.\n\nImplementation:\n    The buffer uses a stack memory array (stack_mem) to store the data. A stack pointer (SP) tracks the current position in the stack.\n    On the rising edge of the clock (Clk), if the enable (EN) signal is high:\n    If the reset (Rst) signal is high, the stack is cleared, the stack pointer is set to 4 (indicating an empty buffer), and all memory locations are initialized to 0.\n    If the reset signal is low, the buffer checks if it is full or empty and processes data accordingly:\n    If RW is low (write operation) and the buffer is not full, data from dataIn is pushed onto the stack, and the stack pointer is decremented.\n    If RW is high (read operation) and the buffer is not empty, data is popped from the stack into dataOut, the corresponding stack memory is cleared, and the stack pointer is incremented.\n    Flags for EMPTY and FULL are updated based on the stack pointer status.\n\nGive me the complete code."}, "clean_code": "module LIFObuffer (\n    input [3:0] dataIn,\n    input RW,\n    input EN,\n    input Rst,\n    input Clk,\n    output reg EMPTY,\n    output reg FULL,\n    output reg [3:0] dataOut\n);\n\n    reg [3:0] stack_mem[0:3];\n    reg [2:0] SP;\n    integer i;\n\n    always @ (posedge Clk) begin\n        if (EN == 0) begin\n            // Do nothing if EN is 0\n        end else begin\n            if (Rst == 1) begin\n                SP = 3'd4;\n                EMPTY = SP[2];\n                dataOut = 4'h0;\n                for (i = 0; i < 4; i = i + 1) begin\n                    stack_mem[i] = 0;\n                end\n            end else if (Rst == 0) begin\n                FULL = SP ? 0 : 1;\n                EMPTY = SP[2];\n                dataOut = 4'hx;\n                \n                if (FULL == 1'b0 && RW == 1'b0) begin\n                    SP = SP - 1'b1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                    stack_mem[SP] = dataIn;\n                end else if (EMPTY == 1'b0 && RW == 1'b1) begin\n                    dataOut = stack_mem[SP];\n                    stack_mem[SP] = 0;\n                    SP = SP + 1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                end else begin\n                    // Do nothing if neither condition is met\n                end\n            end else begin\n                // Do nothing if neither condition is met\n            end\n        end\n    end\nendmodule\n", "corrupted_code": "module LIFObuffer (\n    input [3:0] dataIn,\n    input RW,\n    input EN,\n    input Rst,\n    input Clk,\n    output reg EMPTY,\n    output reg FULL,\n    output reg [3:0] dataOut\n);\n\n    reg [4:0] stack_mem[0:3];\n    reg [2:0] SP;\n    integer i;\n\n    always @ (posedge Clk) begin\n        if (EN == 0) begin\n            // Do nothing if EN is 0\n        end else begin\n            if (Rst == 1) begin\n                SP = 3'd4;\n                EMPTY = SP[2];\n                dataOut = 4'h0;\n                for (i = 0; i < 4; i = i + 1) begin\n                    stack_mem[i] = 0;\n                end\n            end else if (Rst == 0) begin\n                FULL = SP ? 0 : 1;\n                EMPTY = SP[2];\n                dataOut = 4'hx;\n                \n                if (FULL == 1'b0 && RW == 1'b0) begin\n                    SP = SP - 1'b1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                    stack_mem[SP] = dataIn;\n                end else if (EMPTY == 1'b0 && RW == 1'b1) begin\n                    dataOut = stack_mem[SP];\n                    stack_mem[SP] = 0;\n                    SP = SP + 1;\n                    FULL = SP ? 0 : 1;\n                    EMPTY = SP[2];\n                end else begin\n                    // Do nothing if neither condition is met\n                end\n            end else begin\n                // Do nothing if neither condition is met\n            end\n        end\n    end\nendmodule\n", "corruption_explanation": "Changed bit width from [3:0] to [4:0]", "modification_type": "change_bit_width", "modification_line": 12, "original_snippet": "[3:0]", "modified_snippet": "[4:0]", "issue_description": "The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_bit_width modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed bit width from [3:0] to [4:0]\n   \u2022 Line 12: Original: [3:0]\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 12.\n   \u2022 Restore the original code: [3:0]\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change bit width.", "complexity": 20, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_bit_width"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.797230", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "FIFO", "design_name": "asyn_fifo", "module_name": "asyn_fifo", "description": "Please act as a professional verilog designer.\n\nImplement an asynchronous FIFO, FIFO bit width and depth can be configured(parameter DEPTH = 16, parameter WIDTH = 8). The asynchronous FIFO structure is divided into several parts. The first part is dual-port RAM, which is used for data storage. Instantiate dual-port RAM as a submodule, The RAM ports are input wclk, input wenc, input [$clog2(DEPTH)-1:0] waddr, input [WIDTH-1:0] wdata, input rclk, input renc, input [$clog2(DEPTH)-1:0] raddr, output reg [WIDTH-1:0] rdata. The second part is the data write controller. The third part is the data read controller. The fourth part is the read pointer synchronizer. The read pointer is collected using the two-stage trigger of the write clock and output to the data write controller. The fifth part is the write pointer synchronizer, which uses the two-stage trigger of the read clock to collect the write pointer and output it to the data read controller.\nThe method of empty and full judgment is to generate empty and full signals by comparing the Gray code. Use 4-bit Gray code as a read/write pointer for a FIFO with depth 8. The gray code is converted to a four-digit binary number, using the lower three digits of the binary number as the address to access RAM. When the read and write Pointers are equal, the FIFO is null.\nWhen the write pointer has one more cycle RAM than the read pointer, the highest and second-highest bits of the read and write pointer are opposite, the remaining bits are the same, and the FIFO is full.\n\nModule name:  \n    asyn_fifo  \n\nInput ports:\n\twclk: Write clock signal used for synchronous write operations.\n\trclk: Read clock signal used for synchronous read operations.\n\twrstn: Write reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\trrstn: Read reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\twinc: Write increment signal. Used to trigger write operations.\n\trinc: Read increment signal. Used to trigger read operations.\n\twdata: Write data input. The width [WIDTH-1:0] is configurable and represents the data to be written into the FIFO.\n\nOutput ports:\nwfull: Write full signal. Indicates if the FIFO is full and cannot accept further write operations.\nrempty: Read empty signal. Indicates if the FIFO is empty and cannot provide any data for read operations.\nrdata: Read data output. The width [WIDTH-1:0] is configurable and represents the data read from the FIFO.\n\nParameter:\n\tWIDTH = 8\n\tDEPTH = 16\n\nImplementation:\nThe module implements an asynchronous FIFO using a dual-port RAM module and additional logic for managing read and write pointers.\nDual-port RAM:\nThe module instantiates a dual-port RAM module named \"dual_port_RAM\" with configurable depth and width.\nThe RAM module has separate clock inputs for write (wclk) and read (rclk) operations.\nThe RAM module has separate address inputs for write (waddr) and read (raddr) operations.\nThe RAM module has a write enable input (wenc) and a write data input (wdata).\nThe RAM module has a read enable input (renc) and a read data output (rdata).\nThe RAM module stores data in a two-dimensional array, RAM_MEM, with a size of DEPTH by WIDTH.\nWrite and Read Pointers:\nThe module includes logic to manage write and read pointers for asynchronous operation.\nThe write and read pointers are represented by binary registers, waddr_bin and raddr_bin, respectively.\nThe write and read pointers are incremented based on the write and read increment signals (winc and rinc), respectively.\nThe write pointer is incremented on the positive edge of the write clock (posedge wclk) and reset to 0 on write reset (~wrstn).\nThe read pointer is incremented on the positive edge of the read clock (posedge rclk) and reset to 0 on read reset (~rrstn).\nGray Code Conversion:\nThe write and read pointers are converted to Gray code using XOR operations with right-shifted values.\nThe converted write and read pointers are stored in registers wptr and rptr, respectively.\nThe Gray code conversion reduces glitches and ensures proper synchronization of the write and read pointers.\nPointer Buffers:\nThe module includes buffer registers (wptr_buff and rptr_buff) to hold the previous values of the write and read pointers.\nThe buffer registers are updated on the positive edge of the respective clocks and reset to 0 on the respective resets (~wrstn and ~rrstn).\nThe buffer registers are used to synchronize the write and read pointers for determining the full and empty conditions.\nFull and Empty Signals:\nThe module compares the current write and read pointers (wptr and rptr_syn) to determine if the FIFO is full or empty.\nThe wfull output is set to 1 when the write pointer is equal to the bitwise negation of the most significant bit of the read pointer concatenated with the remaining bits of the read pointer.\nThe rempty output is set to 1 when the read pointer is equal to the write pointer.\nInput and Output Connections:\nThe module connects the input and output signals to the dual-port RAM module based on the control signals and pointer values.\nThe wen and ren signals control the write and read enable signals of the RAM module, respectively.\nThe wdata input is connected to the write data input (wdata) of the RAM module.\nThe rdata output is connected to the read data output (rdata) of the RAM module.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\n/***************************************RAM*****************************************/\nmodule dual_port_RAM #(parameter DEPTH = 16,  parameter WIDTH = 8)\n(\n\t input wclk\t,\n\t input wenc\t,\n\t input [$clog2(DEPTH)-1:0] waddr  ,\n\t input [WIDTH-1:0] wdata ,\n\t input rclk\t,\n\t input renc\t,\n\t input [$clog2(DEPTH)-1:0] raddr ,\n\t output reg [WIDTH-1:0] rdata \t\t\n);\n\nreg [WIDTH-1:0] RAM_MEM [0:DEPTH-1];\n\nalways @(posedge wclk) begin\n\tif(wenc)\n\t\tRAM_MEM[waddr] <= wdata;\nend \n\nalways @(posedge rclk) begin\n\tif(renc)\n\t\trdata <= RAM_MEM[raddr];\nend \n\nendmodule  \n\n\n/**************************************AFIFO*****************************************/\nmodule asyn_fifo#(\n\tparameter\tWIDTH = 8,\n\tparameter \tDEPTH = 16\n)(\n\tinput \t\t\t\t\twclk\t, \n\tinput \t\t\t\t\trclk\t,   \n\tinput \t\t\t\t\twrstn\t,\n\tinput\t\t\t\t\trrstn\t,\n\tinput \t\t\t\t\twinc\t,\n\tinput \t\t\t \t\trinc\t,\n\tinput \t\t[WIDTH-1:0]\twdata\t,\n\n\toutput wire\t\t\t\twfull\t,\n\toutput wire\t\t\t\trempty\t,\n\toutput wire [WIDTH-1:0]\trdata\n);\n\nparameter ADDR_WIDTH = $clog2(DEPTH);\n\n\nreg \t[ADDR_WIDTH:0]\twaddr_bin;\nreg \t[ADDR_WIDTH:0]\traddr_bin;\n\nalways @(posedge wclk or negedge wrstn) begin\n\tif(~wrstn) begin\n\t\twaddr_bin <= 'd0;\n\tend \n\telse if(!wfull && winc)begin\n\t\twaddr_bin <= waddr_bin + 1'd1;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin\n\tif(~rrstn) begin\n\t\traddr_bin <= 'd0;\n\tend \n\telse if(!rempty && rinc)begin\n\t\traddr_bin <= raddr_bin + 1'd1;\n\tend\nend\n\nwire \t[ADDR_WIDTH:0]\twaddr_gray;\nwire \t[ADDR_WIDTH:0]\traddr_gray;\nreg \t[ADDR_WIDTH:0]\twptr;\nreg \t[ADDR_WIDTH:0]\trptr;\nassign waddr_gray = waddr_bin ^ (waddr_bin>>1);\nassign raddr_gray = raddr_bin ^ (raddr_bin>>1);\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\twptr <= 'd0;\n\tend \n\telse begin\n\t\twptr <= waddr_gray;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\trptr <= 'd0;\n\tend \n\telse begin\n\t\trptr <= raddr_gray;\n\tend\nend\n\nreg\t\t[ADDR_WIDTH:0]\twptr_buff;\nreg\t\t[ADDR_WIDTH:0]\twptr_syn;\nreg\t\t[ADDR_WIDTH:0]\trptr_buff;\nreg\t\t[ADDR_WIDTH:0]\trptr_syn;\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\trptr_buff <= 'd0;\n\t\trptr_syn <= 'd0;\n\tend \n\telse begin\n\t\trptr_buff <= rptr;\n\t\trptr_syn <= rptr_buff;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\twptr_buff <= 'd0;\n\t\twptr_syn <= 'd0;\n\tend \n\telse begin\n\t\twptr_buff <= wptr;\n\t\twptr_syn <= wptr_buff;\n\tend\nend\n\nassign wfull = (wptr == {~rptr_syn[ADDR_WIDTH:ADDR_WIDTH-1],rptr_syn[ADDR_WIDTH-2:0]});\nassign rempty = (rptr == wptr_syn);\n\n/***********RAM*********/\nwire \twen\t;\nwire\tren\t;\nwire \twren;//high write\nwire [ADDR_WIDTH-1:0]\twaddr;\nwire [ADDR_WIDTH-1:0]\traddr;\nassign wen = winc & !wfull;\nassign ren = rinc & !rempty;\nassign waddr = waddr_bin[ADDR_WIDTH-1:0];\nassign raddr = raddr_bin[ADDR_WIDTH-1:0];\n\ndual_port_RAM #(.DEPTH(DEPTH),\n\t\t\t\t.WIDTH(WIDTH)\n)dual_port_RAM(\n\t.wclk (wclk),  \n\t.wenc (wen),  \n\t.waddr(waddr[ADDR_WIDTH-1:0]),  //The depth is logarithmic to 2 to get the bit width of the address\n\t.wdata(wdata),       \t//data_write\n\t.rclk (rclk), \n\t.renc (ren), \n\t.raddr(raddr[ADDR_WIDTH-1:0]),   \n\t.rdata(rdata)  \t\t\n);\n\nendmodule", "corrupted_code": "`timescale 1ns/1ns\n\n/***************************************RAM*****************************************/\nmodule dual_port_RAM #(parameter DEPTH = 16,  parameter WIDTH = 8)\n(\n\t input wclk\t,\n\t input wenc\t,\n\t input [$clog2(DEPTH)-1:0] waddr  ,\n\t input [WIDTH-1:0] wdata ,\n\t input rclk\t,\n\t input renc\t,\n\t input [$clog2(DEPTH)-1:0] raddr ,\n\t output reg [WIDTH-1:0] rdata \t\t\n);\n\nreg [WIDTH-1:0] RAM_MEM [0:DEPTH-1];\n\nalways @(posedge wclk) begin\n\tif(wenc)\n\t\tRAM_MEM[waddr] <= wdata;\nend \n\nalways @(posedge rclk) begin\n\tif(renc)\n\t\trdata <= RAM_MEM[raddr];\nend \n\nendmodule  \n\n\n/**************************************AFIFO*****************************************/\nmodule asyn_fifo#(\n\tparameter\tWIDTH = 8,\n\tparameter \tDEPTH = 16\n)(\n\tinput \t\t\t\t\twclk\t, \n\tinput \t\t\t\t\trclk\t,   \n\tinput \t\t\t\t\twrstn\t,\n\tinput\t\t\t\t\trrstn\t,\n\tinput \t\t\t\t\twinc\t,\n\tinput \t\t\t \t\trinc\t,\n\tinput \t\t[WIDTH-1:0]\twdata\t,\n\n\toutput wire\t\t\t\twfull\t,\n\toutput wire\t\t\t\trempty\t,\n\toutput wire [WIDTH-1:0]\trdata\n);\n\nparameter ADDR_WIDTH = $clog2(DEPTH);\n\n\nreg \t[ADDR_WIDTH:0]\twaddr_bin;\nreg \t[ADDR_WIDTH:0]\traddr_bin;\n\nalways @(posedge wclk or negedge wrstn) begin\n\tif(~wrstn) begin\n\t\twaddr_bin <= 'd0;\n\tend \n\telse if(!wfull && winc)begin\n\t\twaddr_bin <= waddr_bin + 1'd1;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin\n\tif(~rrstn) begin\n\t\traddr_bin <= 'd0;\n\tend \n\telse if(!rempty && rinc)begin\n\t\traddr_bin <= raddr_bin + 1'd1;\n\tend\nend\n\nwire \t[ADDR_WIDTH:0]\twaddr_gray;\nwire \t[ADDR_WIDTH:0]\traddr_gray;\nreg \t[ADDR_WIDTH:0]\twptr;\nreg \t[ADDR_WIDTH:0]\trptr;\nassign waddr_gray = waddr_bin ^ (waddr_bin>>1);\nassign raddr_gray = raddr_bin ^ (raddr_bin>>1);\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\twptr <= 'd0;\n\tend \n\telse begin\n\t\twptr <= waddr_gray;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\trptr <= 'd0;\n\tend \n\telse begin\n\t\trptr <= raddr_gray;\n\tend\nend\n\nreg\t\t[ADDR_WIDTH:0]\twptr_buff;\nreg\t\t[ADDR_WIDTH:0]\twptr_syn;\nreg\t\t[ADDR_WIDTH:0]\trptr_buff;\nreg\t\t[ADDR_WIDTH:0]\trptr_syn;\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\trptr_buff <= 'd0;\n\t\trptr_syn <= 'd0;\n\tend \n\telse begin\n\t\trptr_buff <= rptr;\n\t\trptr_syn <= rptr_buff;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\twptr_buff <= 'd0;\n\t\twptr_syn <= 'd0;\n\tend \n\telse begin\n\t\twptr_buff <= wptr;\n\t\twptr_syn <= wptr_buff;\n\tend\nend\n\nassign wfull = (wptr == {~rptr_syn[ADDR_WIDTH:ADDR_WIDTH-1],rptr_syn[ADDR_WIDTH-2:0]});\nassign wfull = 1'b0;  // Conflicting assignment\nassign rempty = (rptr == wptr_syn);\n\n/***********RAM*********/\nwire \twen\t;\nwire\tren\t;\nwire \twren;//high write\nwire [ADDR_WIDTH-1:0]\twaddr;\nwire [ADDR_WIDTH-1:0]\traddr;\nassign wen = winc & !wfull;\nassign ren = rinc & !rempty;\nassign waddr = waddr_bin[ADDR_WIDTH-1:0];\nassign raddr = raddr_bin[ADDR_WIDTH-1:0];\n\ndual_port_RAM #(.DEPTH(DEPTH),\n\t\t\t\t.WIDTH(WIDTH)\n)dual_port_RAM(\n\t.wclk (wclk),  \n\t.wenc (wen),  \n\t.waddr(waddr[ADDR_WIDTH-1:0]),  //The depth is logarithmic to 2 to get the bit width of the address\n\t.wdata(wdata),       \t//data_write\n\t.rclk (rclk), \n\t.renc (ren), \n\t.raddr(raddr[ADDR_WIDTH-1:0]),   \n\t.rdata(rdata)  \t\t\n);\n\nendmodule", "corruption_explanation": "Added conflicting driver for signal 'wfull'", "modification_type": "add_multiple_driver", "modification_line": 119, "original_snippet": "assign wfull = (wptr == {~rptr_syn[ADDR_WIDTH:ADDR_WIDTH-1],rptr_syn[ADDR_WIDTH-2:0]});", "modified_snippet": "assign wfull = (wptr == {~rptr_syn[ADDR_WIDTH:ADDR_WIDTH-1],rptr_syn[ADDR_WIDTH-2:0]});\nassign wfull = 1'b0;  // Conflicting assignment", "issue_description": "The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_multiple_driver modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added conflicting driver for signal 'wfull'\n   \u2022 Line 119: Original: assign wfull = (wptr == {~rptr_syn[ADDR_WIDTH:ADDR_WIDTH-1],rptr_syn[ADDR_WIDTH-2:0]});\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 119.\n   \u2022 Restore the original code: assign wfull = (wptr == {~rptr_syn[ADDR_WIDTH:ADDR_WIDTH-1],rptr_syn[ADDR_WIDTH-2:0]});\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add multiple driver.", "complexity": 47, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["add_multiple_driver"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.802978", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "FIFO", "design_name": "asyn_fifo", "module_name": "asyn_fifo", "description": "Please act as a professional verilog designer.\n\nImplement an asynchronous FIFO, FIFO bit width and depth can be configured(parameter DEPTH = 16, parameter WIDTH = 8). The asynchronous FIFO structure is divided into several parts. The first part is dual-port RAM, which is used for data storage. Instantiate dual-port RAM as a submodule, The RAM ports are input wclk, input wenc, input [$clog2(DEPTH)-1:0] waddr, input [WIDTH-1:0] wdata, input rclk, input renc, input [$clog2(DEPTH)-1:0] raddr, output reg [WIDTH-1:0] rdata. The second part is the data write controller. The third part is the data read controller. The fourth part is the read pointer synchronizer. The read pointer is collected using the two-stage trigger of the write clock and output to the data write controller. The fifth part is the write pointer synchronizer, which uses the two-stage trigger of the read clock to collect the write pointer and output it to the data read controller.\nThe method of empty and full judgment is to generate empty and full signals by comparing the Gray code. Use 4-bit Gray code as a read/write pointer for a FIFO with depth 8. The gray code is converted to a four-digit binary number, using the lower three digits of the binary number as the address to access RAM. When the read and write Pointers are equal, the FIFO is null.\nWhen the write pointer has one more cycle RAM than the read pointer, the highest and second-highest bits of the read and write pointer are opposite, the remaining bits are the same, and the FIFO is full.\n\nModule name:  \n    asyn_fifo  \n\nInput ports:\n\twclk: Write clock signal used for synchronous write operations.\n\trclk: Read clock signal used for synchronous read operations.\n\twrstn: Write reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\trrstn: Read reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\twinc: Write increment signal. Used to trigger write operations.\n\trinc: Read increment signal. Used to trigger read operations.\n\twdata: Write data input. The width [WIDTH-1:0] is configurable and represents the data to be written into the FIFO.\n\nOutput ports:\nwfull: Write full signal. Indicates if the FIFO is full and cannot accept further write operations.\nrempty: Read empty signal. Indicates if the FIFO is empty and cannot provide any data for read operations.\nrdata: Read data output. The width [WIDTH-1:0] is configurable and represents the data read from the FIFO.\n\nParameter:\n\tWIDTH = 8\n\tDEPTH = 16\n\nImplementation:\nThe module implements an asynchronous FIFO using a dual-port RAM module and additional logic for managing read and write pointers.\nDual-port RAM:\nThe module instantiates a dual-port RAM module named \"dual_port_RAM\" with configurable depth and width.\nThe RAM module has separate clock inputs for write (wclk) and read (rclk) operations.\nThe RAM module has separate address inputs for write (waddr) and read (raddr) operations.\nThe RAM module has a write enable input (wenc) and a write data input (wdata).\nThe RAM module has a read enable input (renc) and a read data output (rdata).\nThe RAM module stores data in a two-dimensional array, RAM_MEM, with a size of DEPTH by WIDTH.\nWrite and Read Pointers:\nThe module includes logic to manage write and read pointers for asynchronous operation.\nThe write and read pointers are represented by binary registers, waddr_bin and raddr_bin, respectively.\nThe write and read pointers are incremented based on the write and read increment signals (winc and rinc), respectively.\nThe write pointer is incremented on the positive edge of the write clock (posedge wclk) and reset to 0 on write reset (~wrstn).\nThe read pointer is incremented on the positive edge of the read clock (posedge rclk) and reset to 0 on read reset (~rrstn).\nGray Code Conversion:\nThe write and read pointers are converted to Gray code using XOR operations with right-shifted values.\nThe converted write and read pointers are stored in registers wptr and rptr, respectively.\nThe Gray code conversion reduces glitches and ensures proper synchronization of the write and read pointers.\nPointer Buffers:\nThe module includes buffer registers (wptr_buff and rptr_buff) to hold the previous values of the write and read pointers.\nThe buffer registers are updated on the positive edge of the respective clocks and reset to 0 on the respective resets (~wrstn and ~rrstn).\nThe buffer registers are used to synchronize the write and read pointers for determining the full and empty conditions.\nFull and Empty Signals:\nThe module compares the current write and read pointers (wptr and rptr_syn) to determine if the FIFO is full or empty.\nThe wfull output is set to 1 when the write pointer is equal to the bitwise negation of the most significant bit of the read pointer concatenated with the remaining bits of the read pointer.\nThe rempty output is set to 1 when the read pointer is equal to the write pointer.\nInput and Output Connections:\nThe module connects the input and output signals to the dual-port RAM module based on the control signals and pointer values.\nThe wen and ren signals control the write and read enable signals of the RAM module, respectively.\nThe wdata input is connected to the write data input (wdata) of the RAM module.\nThe rdata output is connected to the read data output (rdata) of the RAM module.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\n/***************************************RAM*****************************************/\nmodule dual_port_RAM #(parameter DEPTH = 16,  parameter WIDTH = 8)\n(\n\t input wclk\t,\n\t input wenc\t,\n\t input [$clog2(DEPTH)-1:0] waddr  ,\n\t input [WIDTH-1:0] wdata ,\n\t input rclk\t,\n\t input renc\t,\n\t input [$clog2(DEPTH)-1:0] raddr ,\n\t output reg [WIDTH-1:0] rdata \t\t\n);\n\nreg [WIDTH-1:0] RAM_MEM [0:DEPTH-1];\n\nalways @(posedge wclk) begin\n\tif(wenc)\n\t\tRAM_MEM[waddr] <= wdata;\nend \n\nalways @(posedge rclk) begin\n\tif(renc)\n\t\trdata <= RAM_MEM[raddr];\nend \n\nendmodule  \n\n\n/**************************************AFIFO*****************************************/\nmodule asyn_fifo#(\n\tparameter\tWIDTH = 8,\n\tparameter \tDEPTH = 16\n)(\n\tinput \t\t\t\t\twclk\t, \n\tinput \t\t\t\t\trclk\t,   \n\tinput \t\t\t\t\twrstn\t,\n\tinput\t\t\t\t\trrstn\t,\n\tinput \t\t\t\t\twinc\t,\n\tinput \t\t\t \t\trinc\t,\n\tinput \t\t[WIDTH-1:0]\twdata\t,\n\n\toutput wire\t\t\t\twfull\t,\n\toutput wire\t\t\t\trempty\t,\n\toutput wire [WIDTH-1:0]\trdata\n);\n\nparameter ADDR_WIDTH = $clog2(DEPTH);\n\n\nreg \t[ADDR_WIDTH:0]\twaddr_bin;\nreg \t[ADDR_WIDTH:0]\traddr_bin;\n\nalways @(posedge wclk or negedge wrstn) begin\n\tif(~wrstn) begin\n\t\twaddr_bin <= 'd0;\n\tend \n\telse if(!wfull && winc)begin\n\t\twaddr_bin <= waddr_bin + 1'd1;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin\n\tif(~rrstn) begin\n\t\traddr_bin <= 'd0;\n\tend \n\telse if(!rempty && rinc)begin\n\t\traddr_bin <= raddr_bin + 1'd1;\n\tend\nend\n\nwire \t[ADDR_WIDTH:0]\twaddr_gray;\nwire \t[ADDR_WIDTH:0]\traddr_gray;\nreg \t[ADDR_WIDTH:0]\twptr;\nreg \t[ADDR_WIDTH:0]\trptr;\nassign waddr_gray = waddr_bin ^ (waddr_bin>>1);\nassign raddr_gray = raddr_bin ^ (raddr_bin>>1);\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\twptr <= 'd0;\n\tend \n\telse begin\n\t\twptr <= waddr_gray;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\trptr <= 'd0;\n\tend \n\telse begin\n\t\trptr <= raddr_gray;\n\tend\nend\n\nreg\t\t[ADDR_WIDTH:0]\twptr_buff;\nreg\t\t[ADDR_WIDTH:0]\twptr_syn;\nreg\t\t[ADDR_WIDTH:0]\trptr_buff;\nreg\t\t[ADDR_WIDTH:0]\trptr_syn;\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\trptr_buff <= 'd0;\n\t\trptr_syn <= 'd0;\n\tend \n\telse begin\n\t\trptr_buff <= rptr;\n\t\trptr_syn <= rptr_buff;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\twptr_buff <= 'd0;\n\t\twptr_syn <= 'd0;\n\tend \n\telse begin\n\t\twptr_buff <= wptr;\n\t\twptr_syn <= wptr_buff;\n\tend\nend\n\nassign wfull = (wptr == {~rptr_syn[ADDR_WIDTH:ADDR_WIDTH-1],rptr_syn[ADDR_WIDTH-2:0]});\nassign rempty = (rptr == wptr_syn);\n\n/***********RAM*********/\nwire \twen\t;\nwire\tren\t;\nwire \twren;//high write\nwire [ADDR_WIDTH-1:0]\twaddr;\nwire [ADDR_WIDTH-1:0]\traddr;\nassign wen = winc & !wfull;\nassign ren = rinc & !rempty;\nassign waddr = waddr_bin[ADDR_WIDTH-1:0];\nassign raddr = raddr_bin[ADDR_WIDTH-1:0];\n\ndual_port_RAM #(.DEPTH(DEPTH),\n\t\t\t\t.WIDTH(WIDTH)\n)dual_port_RAM(\n\t.wclk (wclk),  \n\t.wenc (wen),  \n\t.waddr(waddr[ADDR_WIDTH-1:0]),  //The depth is logarithmic to 2 to get the bit width of the address\n\t.wdata(wdata),       \t//data_write\n\t.rclk (rclk), \n\t.renc (ren), \n\t.raddr(raddr[ADDR_WIDTH-1:0]),   \n\t.rdata(rdata)  \t\t\n);\n\nendmodule", "corrupted_code": "`timescale 1ns/1ns\n\n/***************************************RAM*****************************************/\nmodule dual_port_RAM #(parameter DEPTH = 16,  parameter WIDTH = 8)\n(\n\t input wclk\t,\n\t input wenc\t,\n\t input [$clog2(DEPTH)-1:0] waddr  ,\n\t input [WIDTH-1:0] wdata ,\n\t input rclk\t,\n\t input renc\t,\n\t input [$clog2(DEPTH)-1:0] raddr ,\n\t output reg [WIDTH-1:0] rdata \t\t\n);\n\nreg [WIDTH-1:0] RAM_MEM [0:DEPTH-1];\n\nalways @(posedge wclk) begin\n\tif(wenc)\n\t\tRAM_MEM[waddr] <= wdata;\nend \n\nalways @(posedge rclk) begin\n\tif(renc)\n\t\trdata <= RAM_MEM[raddr];\nend \n\nendmodule  \n\n\n/**************************************AFIFO*****************************************/\nmodule asyn_fifo#(\n\tparameter\tWIDTH = 8,\n\tparameter \tDEPTH = 16\n)(\n\tinput \t\t\t\t\twclk\t, \n\tinput \t\t\t\t\trclk\t,   \n\tinput \t\t\t\t\twrstn\t,\n\tinput\t\t\t\t\trrstn\t,\n\tinput \t\t\t\t\twinc\t,\n\tinput \t\t\t \t\trinc\t,\n\tinput \t\t[WIDTH-1:0]\twdata\t,\n\n\toutput wire\t\t\t\twfull\t,\n\toutput wire\t\t\t\trempty\t,\n\toutput wire [WIDTH-1:0]\trdata\n);\n\nparameter ADDR_WIDTH = $clog2(DEPTH);\n\n\nreg \t[ADDR_WIDTH:0]\twaddr_bin;\nreg \t[ADDR_WIDTH:0]\traddr_bin;\n\nalways @(posedge wclk or negedge wrstn) begin\n\tif(~wrstn) begin\n\t\twaddr_bin <= 'd0;\n\tend \n\telse if(!wfull && winc)begin\n\t\twaddr_bin <= waddr_bin + 1'd1;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin\n\tif(~rrstn) begin\n\t\traddr_bin <= 'd0;\n\tend \n\telse if(!rempty && rinc)begin\n\t\traddr_bin <= raddr_bin + 1'd1;\n\tend\nend\n\nwire \t[ADDR_WIDTH:0]\twaddr_gray;\nwire \t[ADDR_WIDTH:0]\traddr_gray;\nreg \t[ADDR_WIDTH:0]\twptr;\nreg \t[ADDR_WIDTH:0]\trptr;\nassign waddr_gray = waddr_bin ^ (waddr_bin>>1);\nassign raddr_gray = raddr_bin ^ (raddr_bin>>1);\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\twptr <= 'd0;\n\tend \n\telse begin\n\t\twptr <= waddr_gray;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\trptr <= raddr_gray;\n\tend \n\telse begin\n\t\trptr <= 'd0;\n\tend\nend\n\nreg\t\t[ADDR_WIDTH:0]\twptr_buff;\nreg\t\t[ADDR_WIDTH:0]\twptr_syn;\nreg\t\t[ADDR_WIDTH:0]\trptr_buff;\nreg\t\t[ADDR_WIDTH:0]\trptr_syn;\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\trptr_buff <= 'd0;\n\t\trptr_syn <= 'd0;\n\tend \n\telse begin\n\t\trptr_buff <= rptr;\n\t\trptr_syn <= rptr_buff;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\twptr_buff <= 'd0;\n\t\twptr_syn <= 'd0;\n\tend \n\telse begin\n\t\twptr_buff <= wptr;\n\t\twptr_syn <= wptr_buff;\n\tend\nend\n\nassign wfull = (wptr == {~rptr_syn[ADDR_WIDTH:ADDR_WIDTH-1],rptr_syn[ADDR_WIDTH-2:0]});\nassign rempty = (rptr == wptr_syn);\n\n/***********RAM*********/\nwire \twen\t;\nwire\tren\t;\nwire \twren;//high write\nwire [ADDR_WIDTH-1:0]\twaddr;\nwire [ADDR_WIDTH-1:0]\traddr;\nassign wen = winc & !wfull;\nassign ren = rinc & !rempty;\nassign waddr = waddr_bin[ADDR_WIDTH-1:0];\nassign raddr = raddr_bin[ADDR_WIDTH-1:0];\n\ndual_port_RAM #(.DEPTH(DEPTH),\n\t\t\t\t.WIDTH(WIDTH)\n)dual_port_RAM(\n\t.wclk (wclk),  \n\t.wenc (wen),  \n\t.waddr(waddr[ADDR_WIDTH-1:0]),  //The depth is logarithmic to 2 to get the bit width of the address\n\t.wdata(wdata),       \t//data_write\n\t.rclk (rclk), \n\t.renc (ren), \n\t.raddr(raddr[ADDR_WIDTH-1:0]),   \n\t.rdata(rdata)  \t\t\n);\n\nendmodule", "corruption_explanation": "Swapped if and else bodies", "modification_type": "invert_if_else", "modification_line": 87, "original_snippet": "if(~rrstn) begin\n\t\trptr <= 'd0;\n\tend \n\telse begin\n\t\trptr <= raddr_gray;\n\tend", "modified_snippet": "if(~rrstn) begin\n\t\trptr <= raddr_gray;\n\tend \n\telse begin\n\t\trptr <= 'd0;\n\tend", "issue_description": "The buggy code has swapped if and else bodies in a conditional block. This causes the logic to execute the opposite branch for each condition, leading to incorrect behavior when the condition is true vs false. Test cases that depend on the conditional logic will fail because the intended branch is not executed.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module contains conditional logic that should execute different code paths based on a condition.\n   \u2022 The if branch should handle the true case, and the else branch should handle the false case.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Identified a conditional block with both if and else branches.\n   \u2022 The branches contain different assignments or logic operations.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The if and else bodies have been swapped.\n   \u2022 Logic that should execute when condition is true now executes when false, and vice versa.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The conditional bodies are inverted.\n   \u2022 Impact: All conditional behavior is reversed, causing incorrect outputs for all test cases.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Swap the if and else bodies back to their correct positions.\n   \u2022 Verify that the condition evaluates correctly and executes the intended branch.\n\n6. RTL Design Principle Violated:\n   \u2022 Correct conditional logic requires matching the intended behavior with the branch bodies.", "complexity": 47, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_if_else"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.860723", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "FIFO", "design_name": "asyn_fifo", "module_name": "asyn_fifo", "description": "Please act as a professional verilog designer.\n\nImplement an asynchronous FIFO, FIFO bit width and depth can be configured(parameter DEPTH = 16, parameter WIDTH = 8). The asynchronous FIFO structure is divided into several parts. The first part is dual-port RAM, which is used for data storage. Instantiate dual-port RAM as a submodule, The RAM ports are input wclk, input wenc, input [$clog2(DEPTH)-1:0] waddr, input [WIDTH-1:0] wdata, input rclk, input renc, input [$clog2(DEPTH)-1:0] raddr, output reg [WIDTH-1:0] rdata. The second part is the data write controller. The third part is the data read controller. The fourth part is the read pointer synchronizer. The read pointer is collected using the two-stage trigger of the write clock and output to the data write controller. The fifth part is the write pointer synchronizer, which uses the two-stage trigger of the read clock to collect the write pointer and output it to the data read controller.\nThe method of empty and full judgment is to generate empty and full signals by comparing the Gray code. Use 4-bit Gray code as a read/write pointer for a FIFO with depth 8. The gray code is converted to a four-digit binary number, using the lower three digits of the binary number as the address to access RAM. When the read and write Pointers are equal, the FIFO is null.\nWhen the write pointer has one more cycle RAM than the read pointer, the highest and second-highest bits of the read and write pointer are opposite, the remaining bits are the same, and the FIFO is full.\n\nModule name:  \n    asyn_fifo  \n\nInput ports:\n\twclk: Write clock signal used for synchronous write operations.\n\trclk: Read clock signal used for synchronous read operations.\n\twrstn: Write reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\trrstn: Read reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\twinc: Write increment signal. Used to trigger write operations.\n\trinc: Read increment signal. Used to trigger read operations.\n\twdata: Write data input. The width [WIDTH-1:0] is configurable and represents the data to be written into the FIFO.\n\nOutput ports:\nwfull: Write full signal. Indicates if the FIFO is full and cannot accept further write operations.\nrempty: Read empty signal. Indicates if the FIFO is empty and cannot provide any data for read operations.\nrdata: Read data output. The width [WIDTH-1:0] is configurable and represents the data read from the FIFO.\n\nParameter:\n\tWIDTH = 8\n\tDEPTH = 16\n\nImplementation:\nThe module implements an asynchronous FIFO using a dual-port RAM module and additional logic for managing read and write pointers.\nDual-port RAM:\nThe module instantiates a dual-port RAM module named \"dual_port_RAM\" with configurable depth and width.\nThe RAM module has separate clock inputs for write (wclk) and read (rclk) operations.\nThe RAM module has separate address inputs for write (waddr) and read (raddr) operations.\nThe RAM module has a write enable input (wenc) and a write data input (wdata).\nThe RAM module has a read enable input (renc) and a read data output (rdata).\nThe RAM module stores data in a two-dimensional array, RAM_MEM, with a size of DEPTH by WIDTH.\nWrite and Read Pointers:\nThe module includes logic to manage write and read pointers for asynchronous operation.\nThe write and read pointers are represented by binary registers, waddr_bin and raddr_bin, respectively.\nThe write and read pointers are incremented based on the write and read increment signals (winc and rinc), respectively.\nThe write pointer is incremented on the positive edge of the write clock (posedge wclk) and reset to 0 on write reset (~wrstn).\nThe read pointer is incremented on the positive edge of the read clock (posedge rclk) and reset to 0 on read reset (~rrstn).\nGray Code Conversion:\nThe write and read pointers are converted to Gray code using XOR operations with right-shifted values.\nThe converted write and read pointers are stored in registers wptr and rptr, respectively.\nThe Gray code conversion reduces glitches and ensures proper synchronization of the write and read pointers.\nPointer Buffers:\nThe module includes buffer registers (wptr_buff and rptr_buff) to hold the previous values of the write and read pointers.\nThe buffer registers are updated on the positive edge of the respective clocks and reset to 0 on the respective resets (~wrstn and ~rrstn).\nThe buffer registers are used to synchronize the write and read pointers for determining the full and empty conditions.\nFull and Empty Signals:\nThe module compares the current write and read pointers (wptr and rptr_syn) to determine if the FIFO is full or empty.\nThe wfull output is set to 1 when the write pointer is equal to the bitwise negation of the most significant bit of the read pointer concatenated with the remaining bits of the read pointer.\nThe rempty output is set to 1 when the read pointer is equal to the write pointer.\nInput and Output Connections:\nThe module connects the input and output signals to the dual-port RAM module based on the control signals and pointer values.\nThe wen and ren signals control the write and read enable signals of the RAM module, respectively.\nThe wdata input is connected to the write data input (wdata) of the RAM module.\nThe rdata output is connected to the read data output (rdata) of the RAM module.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\n/***************************************RAM*****************************************/\nmodule dual_port_RAM #(parameter DEPTH = 16,  parameter WIDTH = 8)\n(\n\t input wclk\t,\n\t input wenc\t,\n\t input [$clog2(DEPTH)-1:0] waddr  ,\n\t input [WIDTH-1:0] wdata ,\n\t input rclk\t,\n\t input renc\t,\n\t input [$clog2(DEPTH)-1:0] raddr ,\n\t output reg [WIDTH-1:0] rdata \t\t\n);\n\nreg [WIDTH-1:0] RAM_MEM [0:DEPTH-1];\n\nalways @(posedge wclk) begin\n\tif(wenc)\n\t\tRAM_MEM[waddr] <= wdata;\nend \n\nalways @(posedge rclk) begin\n\tif(renc)\n\t\trdata <= RAM_MEM[raddr];\nend \n\nendmodule  \n\n\n/**************************************AFIFO*****************************************/\nmodule asyn_fifo#(\n\tparameter\tWIDTH = 8,\n\tparameter \tDEPTH = 16\n)(\n\tinput \t\t\t\t\twclk\t, \n\tinput \t\t\t\t\trclk\t,   \n\tinput \t\t\t\t\twrstn\t,\n\tinput\t\t\t\t\trrstn\t,\n\tinput \t\t\t\t\twinc\t,\n\tinput \t\t\t \t\trinc\t,\n\tinput \t\t[WIDTH-1:0]\twdata\t,\n\n\toutput wire\t\t\t\twfull\t,\n\toutput wire\t\t\t\trempty\t,\n\toutput wire [WIDTH-1:0]\trdata\n);\n\nparameter ADDR_WIDTH = $clog2(DEPTH);\n\n\nreg \t[ADDR_WIDTH:0]\twaddr_bin;\nreg \t[ADDR_WIDTH:0]\traddr_bin;\n\nalways @(posedge wclk or negedge wrstn) begin\n\tif(~wrstn) begin\n\t\twaddr_bin <= 'd0;\n\tend \n\telse if(!wfull && winc)begin\n\t\twaddr_bin <= waddr_bin + 1'd1;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin\n\tif(~rrstn) begin\n\t\traddr_bin <= 'd0;\n\tend \n\telse if(!rempty && rinc)begin\n\t\traddr_bin <= raddr_bin + 1'd1;\n\tend\nend\n\nwire \t[ADDR_WIDTH:0]\twaddr_gray;\nwire \t[ADDR_WIDTH:0]\traddr_gray;\nreg \t[ADDR_WIDTH:0]\twptr;\nreg \t[ADDR_WIDTH:0]\trptr;\nassign waddr_gray = waddr_bin ^ (waddr_bin>>1);\nassign raddr_gray = raddr_bin ^ (raddr_bin>>1);\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\twptr <= 'd0;\n\tend \n\telse begin\n\t\twptr <= waddr_gray;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\trptr <= 'd0;\n\tend \n\telse begin\n\t\trptr <= raddr_gray;\n\tend\nend\n\nreg\t\t[ADDR_WIDTH:0]\twptr_buff;\nreg\t\t[ADDR_WIDTH:0]\twptr_syn;\nreg\t\t[ADDR_WIDTH:0]\trptr_buff;\nreg\t\t[ADDR_WIDTH:0]\trptr_syn;\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\trptr_buff <= 'd0;\n\t\trptr_syn <= 'd0;\n\tend \n\telse begin\n\t\trptr_buff <= rptr;\n\t\trptr_syn <= rptr_buff;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\twptr_buff <= 'd0;\n\t\twptr_syn <= 'd0;\n\tend \n\telse begin\n\t\twptr_buff <= wptr;\n\t\twptr_syn <= wptr_buff;\n\tend\nend\n\nassign wfull = (wptr == {~rptr_syn[ADDR_WIDTH:ADDR_WIDTH-1],rptr_syn[ADDR_WIDTH-2:0]});\nassign rempty = (rptr == wptr_syn);\n\n/***********RAM*********/\nwire \twen\t;\nwire\tren\t;\nwire \twren;//high write\nwire [ADDR_WIDTH-1:0]\twaddr;\nwire [ADDR_WIDTH-1:0]\traddr;\nassign wen = winc & !wfull;\nassign ren = rinc & !rempty;\nassign waddr = waddr_bin[ADDR_WIDTH-1:0];\nassign raddr = raddr_bin[ADDR_WIDTH-1:0];\n\ndual_port_RAM #(.DEPTH(DEPTH),\n\t\t\t\t.WIDTH(WIDTH)\n)dual_port_RAM(\n\t.wclk (wclk),  \n\t.wenc (wen),  \n\t.waddr(waddr[ADDR_WIDTH-1:0]),  //The depth is logarithmic to 2 to get the bit width of the address\n\t.wdata(wdata),       \t//data_write\n\t.rclk (rclk), \n\t.renc (ren), \n\t.raddr(raddr[ADDR_WIDTH-1:0]),   \n\t.rdata(rdata)  \t\t\n);\n\nendmodule", "corrupted_code": "`timescale 1ns/1ns\n\n/***************************************RAM*****************************************/\nmodule dual_port_RAM #(parameter DEPTH = 16,  parameter WIDTH = 8)\n(\n\t input wclk\t,\n\t input wenc\t,\n\t input [$clog2(DEPTH)-1:0] waddr  ,\n\t input [WIDTH-1:0] wdata ,\n\t input rclk\t,\n\t input renc\t,\n\t input [$clog2(DEPTH)-1:0] raddr ,\n\t output reg [WIDTH-1:0] rdata \t\t\n);\n\nreg [WIDTH-1:0] RAM_MEM [0:DEPTH-1];\n\nalways @(posedge wclk) begin\n\tif(wenc)\n\t\tRAM_MEM[waddr] <= wdata;\nend \n\nalways @(posedge rclk) begin\n\tif(renc)\n\t\trdata <= RAM_MEM[raddr];\nend \n\nendmodule  \n\n\n/**************************************AFIFO*****************************************/\nmodule asyn_fifo#(\n\tparameter\tWIDTH = 8,\n\tparameter \tDEPTH = 16\n)(\n\tinput \t\t\t\t\twclk\t, \n\tinput \t\t\t\t\trclk\t,   \n\tinput \t\t\t\t\twrstn\t,\n\tinput\t\t\t\t\trrstn\t,\n\tinput \t\t\t\t\twinc\t,\n\tinput \t\t\t \t\trinc\t,\n\tinput \t\t[WIDTH-1:0]\twdata\t,\n\n\toutput wire\t\t\t\twfull\t,\n\toutput wire\t\t\t\trempty\t,\n\toutput wire [WIDTH-1:0]\trdata\n);\n\nparameter ADDR_WIDTH = $clog2(DEPTH);\n\n\nreg \t[ADDR_WIDTH:0]\twaddr_bin;\nreg \t[ADDR_WIDTH:0]\traddr_bin;\n\nalways @(posedge wclk or negedge wrstn) begin\n\tif(~wrstn) begin\n\t\twaddr_bin <= 'd0;\n\tend \n\telse if(!wfull && winc)begin\n\t\twaddr_bin <= waddr_bin + 1'd1;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin\n\tif(~rrstn) begin\n\t\traddr_bin <= 'd0;\n\tend \n\telse if(!rempty && rinc)begin\n\t\traddr_bin <= raddr_bin + 1'd1;\n\tend\nend\n\nwire \t[ADDR_WIDTH:0]\twaddr_gray;\nwire \t[ADDR_WIDTH:0]\traddr_gray;\nreg \t[ADDR_WIDTH:0]\twptr;\nreg \t[ADDR_WIDTH:0]\trptr;\nassign waddr_gray = waddr_bin ^ (waddr_bin>>1);\nassign raddr_gray = raddr_bin ^ (raddr_bin>>1);\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\twptr <= 'd0;\n\tend \n\telse begin\n\t\twptr <= waddr_gray;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\trptr <= 'd0;\n\tend \n\telse begin\n\t\trptr <= raddr_gray;\n\tend\nend\n\nreg\t\t[ADDR_WIDTH:0]\twptr_buff;\nreg\t\t[ADDR_WIDTH:0]\twptr_syn;\nreg\t\t[ADDR_WIDTH:0]\trptr_buff;\nreg\t\t[ADDR_WIDTH:0]\trptr_syn;\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\trptr_buff <= 'd0;\n\t\trptr_syn <= 'd0;\n\tend \n\telse begin\n\t\trptr_buff <= rptr;\n\t\trptr_syn <= rptr_buff;\n\tend\nend\nalways @(posedge rclk) begin \n\tif(~rrstn) begin\n\t\twptr_buff <= 'd0;\n\t\twptr_syn <= 'd0;\n\tend \n\telse begin\n\t\twptr_buff <= wptr;\n\t\twptr_syn <= wptr_buff;\n\tend\nend\n\nassign wfull = (wptr == {~rptr_syn[ADDR_WIDTH:ADDR_WIDTH-1],rptr_syn[ADDR_WIDTH-2:0]});\nassign rempty = (rptr == wptr_syn);\n\n/***********RAM*********/\nwire \twen\t;\nwire\tren\t;\nwire \twren;//high write\nwire [ADDR_WIDTH-1:0]\twaddr;\nwire [ADDR_WIDTH-1:0]\traddr;\nassign wen = winc & !wfull;\nassign ren = rinc & !rempty;\nassign waddr = waddr_bin[ADDR_WIDTH-1:0];\nassign raddr = raddr_bin[ADDR_WIDTH-1:0];\n\ndual_port_RAM #(.DEPTH(DEPTH),\n\t\t\t\t.WIDTH(WIDTH)\n)dual_port_RAM(\n\t.wclk (wclk),  \n\t.wenc (wen),  \n\t.waddr(waddr[ADDR_WIDTH-1:0]),  //The depth is logarithmic to 2 to get the bit width of the address\n\t.wdata(wdata),       \t//data_write\n\t.rclk (rclk), \n\t.renc (ren), \n\t.raddr(raddr[ADDR_WIDTH-1:0]),   \n\t.rdata(rdata)  \t\t\n);\n\nendmodule", "corruption_explanation": "Removed async reset from sensitivity list", "modification_type": "remove_async_reset", "modification_line": 109, "original_snippet": "always @(posedge rclk or negedge rrstn)", "modified_snippet": "always @(posedge rclk)", "issue_description": "The buggy code has removed async reset from the sensitivity list. The always block only triggers on clock edges, not reset. This causes metastability on power-up and removes the ability to asynchronously reset the design.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_async_reset modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed async reset from sensitivity list\n   \u2022 Line 109: Original: always @(posedge rclk or negedge rrstn)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 109.\n   \u2022 Restore the original code: always @(posedge rclk or negedge rrstn)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove async reset.", "complexity": 47, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_async_reset"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.865103", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "FIFO", "design_name": "asyn_fifo", "module_name": "asyn_fifo", "description": "Please act as a professional verilog designer.\n\nImplement an asynchronous FIFO, FIFO bit width and depth can be configured(parameter DEPTH = 16, parameter WIDTH = 8). The asynchronous FIFO structure is divided into several parts. The first part is dual-port RAM, which is used for data storage. Instantiate dual-port RAM as a submodule, The RAM ports are input wclk, input wenc, input [$clog2(DEPTH)-1:0] waddr, input [WIDTH-1:0] wdata, input rclk, input renc, input [$clog2(DEPTH)-1:0] raddr, output reg [WIDTH-1:0] rdata. The second part is the data write controller. The third part is the data read controller. The fourth part is the read pointer synchronizer. The read pointer is collected using the two-stage trigger of the write clock and output to the data write controller. The fifth part is the write pointer synchronizer, which uses the two-stage trigger of the read clock to collect the write pointer and output it to the data read controller.\nThe method of empty and full judgment is to generate empty and full signals by comparing the Gray code. Use 4-bit Gray code as a read/write pointer for a FIFO with depth 8. The gray code is converted to a four-digit binary number, using the lower three digits of the binary number as the address to access RAM. When the read and write Pointers are equal, the FIFO is null.\nWhen the write pointer has one more cycle RAM than the read pointer, the highest and second-highest bits of the read and write pointer are opposite, the remaining bits are the same, and the FIFO is full.\n\nModule name:  \n    asyn_fifo  \n\nInput ports:\n\twclk: Write clock signal used for synchronous write operations.\n\trclk: Read clock signal used for synchronous read operations.\n\twrstn: Write reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\trrstn: Read reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\twinc: Write increment signal. Used to trigger write operations.\n\trinc: Read increment signal. Used to trigger read operations.\n\twdata: Write data input. The width [WIDTH-1:0] is configurable and represents the data to be written into the FIFO.\n\nOutput ports:\nwfull: Write full signal. Indicates if the FIFO is full and cannot accept further write operations.\nrempty: Read empty signal. Indicates if the FIFO is empty and cannot provide any data for read operations.\nrdata: Read data output. The width [WIDTH-1:0] is configurable and represents the data read from the FIFO.\n\nParameter:\n\tWIDTH = 8\n\tDEPTH = 16\n\nImplementation:\nThe module implements an asynchronous FIFO using a dual-port RAM module and additional logic for managing read and write pointers.\nDual-port RAM:\nThe module instantiates a dual-port RAM module named \"dual_port_RAM\" with configurable depth and width.\nThe RAM module has separate clock inputs for write (wclk) and read (rclk) operations.\nThe RAM module has separate address inputs for write (waddr) and read (raddr) operations.\nThe RAM module has a write enable input (wenc) and a write data input (wdata).\nThe RAM module has a read enable input (renc) and a read data output (rdata).\nThe RAM module stores data in a two-dimensional array, RAM_MEM, with a size of DEPTH by WIDTH.\nWrite and Read Pointers:\nThe module includes logic to manage write and read pointers for asynchronous operation.\nThe write and read pointers are represented by binary registers, waddr_bin and raddr_bin, respectively.\nThe write and read pointers are incremented based on the write and read increment signals (winc and rinc), respectively.\nThe write pointer is incremented on the positive edge of the write clock (posedge wclk) and reset to 0 on write reset (~wrstn).\nThe read pointer is incremented on the positive edge of the read clock (posedge rclk) and reset to 0 on read reset (~rrstn).\nGray Code Conversion:\nThe write and read pointers are converted to Gray code using XOR operations with right-shifted values.\nThe converted write and read pointers are stored in registers wptr and rptr, respectively.\nThe Gray code conversion reduces glitches and ensures proper synchronization of the write and read pointers.\nPointer Buffers:\nThe module includes buffer registers (wptr_buff and rptr_buff) to hold the previous values of the write and read pointers.\nThe buffer registers are updated on the positive edge of the respective clocks and reset to 0 on the respective resets (~wrstn and ~rrstn).\nThe buffer registers are used to synchronize the write and read pointers for determining the full and empty conditions.\nFull and Empty Signals:\nThe module compares the current write and read pointers (wptr and rptr_syn) to determine if the FIFO is full or empty.\nThe wfull output is set to 1 when the write pointer is equal to the bitwise negation of the most significant bit of the read pointer concatenated with the remaining bits of the read pointer.\nThe rempty output is set to 1 when the read pointer is equal to the write pointer.\nInput and Output Connections:\nThe module connects the input and output signals to the dual-port RAM module based on the control signals and pointer values.\nThe wen and ren signals control the write and read enable signals of the RAM module, respectively.\nThe wdata input is connected to the write data input (wdata) of the RAM module.\nThe rdata output is connected to the read data output (rdata) of the RAM module.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\n/***************************************RAM*****************************************/\nmodule dual_port_RAM #(parameter DEPTH = 16,  parameter WIDTH = 8)\n(\n\t input wclk\t,\n\t input wenc\t,\n\t input [$clog2(DEPTH)-1:0] waddr  ,\n\t input [WIDTH-1:0] wdata ,\n\t input rclk\t,\n\t input renc\t,\n\t input [$clog2(DEPTH)-1:0] raddr ,\n\t output reg [WIDTH-1:0] rdata \t\t\n);\n\nreg [WIDTH-1:0] RAM_MEM [0:DEPTH-1];\n\nalways @(posedge wclk) begin\n\tif(wenc)\n\t\tRAM_MEM[waddr] <= wdata;\nend \n\nalways @(posedge rclk) begin\n\tif(renc)\n\t\trdata <= RAM_MEM[raddr];\nend \n\nendmodule  \n\n\n/**************************************AFIFO*****************************************/\nmodule asyn_fifo#(\n\tparameter\tWIDTH = 8,\n\tparameter \tDEPTH = 16\n)(\n\tinput \t\t\t\t\twclk\t, \n\tinput \t\t\t\t\trclk\t,   \n\tinput \t\t\t\t\twrstn\t,\n\tinput\t\t\t\t\trrstn\t,\n\tinput \t\t\t\t\twinc\t,\n\tinput \t\t\t \t\trinc\t,\n\tinput \t\t[WIDTH-1:0]\twdata\t,\n\n\toutput wire\t\t\t\twfull\t,\n\toutput wire\t\t\t\trempty\t,\n\toutput wire [WIDTH-1:0]\trdata\n);\n\nparameter ADDR_WIDTH = $clog2(DEPTH);\n\n\nreg \t[ADDR_WIDTH:0]\twaddr_bin;\nreg \t[ADDR_WIDTH:0]\traddr_bin;\n\nalways @(posedge wclk or negedge wrstn) begin\n\tif(~wrstn) begin\n\t\twaddr_bin <= 'd0;\n\tend \n\telse if(!wfull && winc)begin\n\t\twaddr_bin <= waddr_bin + 1'd1;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin\n\tif(~rrstn) begin\n\t\traddr_bin <= 'd0;\n\tend \n\telse if(!rempty && rinc)begin\n\t\traddr_bin <= raddr_bin + 1'd1;\n\tend\nend\n\nwire \t[ADDR_WIDTH:0]\twaddr_gray;\nwire \t[ADDR_WIDTH:0]\traddr_gray;\nreg \t[ADDR_WIDTH:0]\twptr;\nreg \t[ADDR_WIDTH:0]\trptr;\nassign waddr_gray = waddr_bin ^ (waddr_bin>>1);\nassign raddr_gray = raddr_bin ^ (raddr_bin>>1);\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\twptr <= 'd0;\n\tend \n\telse begin\n\t\twptr <= waddr_gray;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\trptr <= 'd0;\n\tend \n\telse begin\n\t\trptr <= raddr_gray;\n\tend\nend\n\nreg\t\t[ADDR_WIDTH:0]\twptr_buff;\nreg\t\t[ADDR_WIDTH:0]\twptr_syn;\nreg\t\t[ADDR_WIDTH:0]\trptr_buff;\nreg\t\t[ADDR_WIDTH:0]\trptr_syn;\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\trptr_buff <= 'd0;\n\t\trptr_syn <= 'd0;\n\tend \n\telse begin\n\t\trptr_buff <= rptr;\n\t\trptr_syn <= rptr_buff;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\twptr_buff <= 'd0;\n\t\twptr_syn <= 'd0;\n\tend \n\telse begin\n\t\twptr_buff <= wptr;\n\t\twptr_syn <= wptr_buff;\n\tend\nend\n\nassign wfull = (wptr == {~rptr_syn[ADDR_WIDTH:ADDR_WIDTH-1],rptr_syn[ADDR_WIDTH-2:0]});\nassign rempty = (rptr == wptr_syn);\n\n/***********RAM*********/\nwire \twen\t;\nwire\tren\t;\nwire \twren;//high write\nwire [ADDR_WIDTH-1:0]\twaddr;\nwire [ADDR_WIDTH-1:0]\traddr;\nassign wen = winc & !wfull;\nassign ren = rinc & !rempty;\nassign waddr = waddr_bin[ADDR_WIDTH-1:0];\nassign raddr = raddr_bin[ADDR_WIDTH-1:0];\n\ndual_port_RAM #(.DEPTH(DEPTH),\n\t\t\t\t.WIDTH(WIDTH)\n)dual_port_RAM(\n\t.wclk (wclk),  \n\t.wenc (wen),  \n\t.waddr(waddr[ADDR_WIDTH-1:0]),  //The depth is logarithmic to 2 to get the bit width of the address\n\t.wdata(wdata),       \t//data_write\n\t.rclk (rclk), \n\t.renc (ren), \n\t.raddr(raddr[ADDR_WIDTH-1:0]),   \n\t.rdata(rdata)  \t\t\n);\n\nendmodule", "corrupted_code": "`timescale 1ns/1ns\n\n/***************************************RAM*****************************************/\nmodule dual_port_RAM #(parameter DEPTH = 16,  parameter WIDTH = 8)\n(\n\t input wclk\t,\n\t input wenc\t,\n\t input [$clog2(DEPTH)-1:0] waddr  ,\n\t input [WIDTH-1:0] wdata ,\n\t input rclk\t,\n\t input renc\t,\n\t input [$clog2(DEPTH)-1:0] raddr ,\n\t output reg [WIDTH-1:0] rdata \t\t\n);\n\nreg [WIDTH-1:0] RAM_MEM [0:DEPTH-1];\n\nalways @(posedge wclk) begin\n\tif(wenc)\n\t\tRAM_MEM[waddr] <= wdata;\nend \n\nalways @(posedge rclk) begin\n\tif(renc)\n\t\trdata <= RAM_MEM[raddr];\nend \n\nendmodule  \n\n\n/**************************************AFIFO*****************************************/\nmodule asyn_fifo#(\n\tparameter\tWIDTH = 8,\n\tparameter \tDEPTH = 16\n)(\n\tinput \t\t\t\t\twclk\t, \n\tinput \t\t\t\t\trclk\t,   \n\tinput \t\t\t\t\twrstn\t,\n\tinput\t\t\t\t\trrstn\t,\n\tinput \t\t\t\t\twinc\t,\n\tinput \t\t\t \t\trinc\t,\n\tinput \t\t[WIDTH-1:0]\twdata\t,\n\n\toutput wire\t\t\t\twfull\t,\n\toutput wire\t\t\t\trempty\t,\n\toutput wire [WIDTH-1:0]\trdata\n);\n\nparameter ADDR_WIDTH = $clog2(DEPTH);\n\n\nreg \t[ADDR_WIDTH:0]\twaddr_bin;\nreg \t[ADDR_WIDTH:0]\traddr_bin;\n\nalways @(posedge wclk or negedge wrstn) begin\n\tif(~wrstn) begin\n\t\twaddr_bin <= 'd0;\n\tend \n\telse if(!wfull && winc)begin\n\t\twaddr_bin <= waddr_bin + 1'd1;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin\n\t\nend\n\nwire \t[ADDR_WIDTH:0]\twaddr_gray;\nwire \t[ADDR_WIDTH:0]\traddr_gray;\nreg \t[ADDR_WIDTH:0]\twptr;\nreg \t[ADDR_WIDTH:0]\trptr;\nassign waddr_gray = waddr_bin ^ (waddr_bin>>1);\nassign raddr_gray = raddr_bin ^ (raddr_bin>>1);\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\twptr <= 'd0;\n\tend \n\telse begin\n\t\twptr <= waddr_gray;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\trptr <= 'd0;\n\tend \n\telse begin\n\t\trptr <= raddr_gray;\n\tend\nend\n\nreg\t\t[ADDR_WIDTH:0]\twptr_buff;\nreg\t\t[ADDR_WIDTH:0]\twptr_syn;\nreg\t\t[ADDR_WIDTH:0]\trptr_buff;\nreg\t\t[ADDR_WIDTH:0]\trptr_syn;\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\trptr_buff <= 'd0;\n\t\trptr_syn <= 'd0;\n\tend \n\telse begin\n\t\trptr_buff <= rptr;\n\t\trptr_syn <= rptr_buff;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\twptr_buff <= 'd0;\n\t\twptr_syn <= 'd0;\n\tend \n\telse begin\n\t\twptr_buff <= wptr;\n\t\twptr_syn <= wptr_buff;\n\tend\nend\n\nassign wfull = (wptr == {~rptr_syn[ADDR_WIDTH:ADDR_WIDTH-1],rptr_syn[ADDR_WIDTH-2:0]});\nassign rempty = (rptr == wptr_syn);\n\n/***********RAM*********/\nwire \twen\t;\nwire\tren\t;\nwire \twren;//high write\nwire [ADDR_WIDTH-1:0]\twaddr;\nwire [ADDR_WIDTH-1:0]\traddr;\nassign wen = winc & !wfull;\nassign ren = rinc & !rempty;\nassign waddr = waddr_bin[ADDR_WIDTH-1:0];\nassign raddr = raddr_bin[ADDR_WIDTH-1:0];\n\ndual_port_RAM #(.DEPTH(DEPTH),\n\t\t\t\t.WIDTH(WIDTH)\n)dual_port_RAM(\n\t.wclk (wclk),  \n\t.wenc (wen),  \n\t.waddr(waddr[ADDR_WIDTH-1:0]),  //The depth is logarithmic to 2 to get the bit width of the address\n\t.wdata(wdata),       \t//data_write\n\t.rclk (rclk), \n\t.renc (ren), \n\t.raddr(raddr[ADDR_WIDTH-1:0]),   \n\t.rdata(rdata)  \t\t\n);\n\nendmodule", "corruption_explanation": "Removed a conditional block", "modification_type": "remove_conditional", "modification_line": 64, "original_snippet": "if(~rrstn) begin\n\t\traddr_bin <= 'd0;\n\tend \n\telse if(!rempty && rinc)begin\n\t\traddr_bin <= raddr_bin + 1'd1;\n\tend", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing a conditional block. This removes important control logic, causing the design to skip necessary state transitions or data processing. Test cases that depend on the conditional behavior will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_conditional modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed a conditional block\n   \u2022 Line 64: Original: if(~rrstn) begin\n\t\traddr_bin <= 'd0;\n\tend \n\telse if(!rempty && rinc)begin\n\t\traddr_bin <= raddr_bin + 1'd1;\n\tend\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 64.\n   \u2022 Restore the original code: if(~rrstn) begin\n\t\traddr_bin <= 'd0;\n\tend \n\telse if(!rempty && rinc)begin\n\t\traddr_bin <= raddr_bin + 1'd1;\n\tend\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove conditional.", "complexity": 47, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_conditional"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.869771", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "FIFO", "design_name": "asyn_fifo", "module_name": "asyn_fifo", "description": "Please act as a professional verilog designer.\n\nImplement an asynchronous FIFO, FIFO bit width and depth can be configured(parameter DEPTH = 16, parameter WIDTH = 8). The asynchronous FIFO structure is divided into several parts. The first part is dual-port RAM, which is used for data storage. Instantiate dual-port RAM as a submodule, The RAM ports are input wclk, input wenc, input [$clog2(DEPTH)-1:0] waddr, input [WIDTH-1:0] wdata, input rclk, input renc, input [$clog2(DEPTH)-1:0] raddr, output reg [WIDTH-1:0] rdata. The second part is the data write controller. The third part is the data read controller. The fourth part is the read pointer synchronizer. The read pointer is collected using the two-stage trigger of the write clock and output to the data write controller. The fifth part is the write pointer synchronizer, which uses the two-stage trigger of the read clock to collect the write pointer and output it to the data read controller.\nThe method of empty and full judgment is to generate empty and full signals by comparing the Gray code. Use 4-bit Gray code as a read/write pointer for a FIFO with depth 8. The gray code is converted to a four-digit binary number, using the lower three digits of the binary number as the address to access RAM. When the read and write Pointers are equal, the FIFO is null.\nWhen the write pointer has one more cycle RAM than the read pointer, the highest and second-highest bits of the read and write pointer are opposite, the remaining bits are the same, and the FIFO is full.\n\nModule name:  \n    asyn_fifo  \n\nInput ports:\n\twclk: Write clock signal used for synchronous write operations.\n\trclk: Read clock signal used for synchronous read operations.\n\twrstn: Write reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\trrstn: Read reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\twinc: Write increment signal. Used to trigger write operations.\n\trinc: Read increment signal. Used to trigger read operations.\n\twdata: Write data input. The width [WIDTH-1:0] is configurable and represents the data to be written into the FIFO.\n\nOutput ports:\nwfull: Write full signal. Indicates if the FIFO is full and cannot accept further write operations.\nrempty: Read empty signal. Indicates if the FIFO is empty and cannot provide any data for read operations.\nrdata: Read data output. The width [WIDTH-1:0] is configurable and represents the data read from the FIFO.\n\nParameter:\n\tWIDTH = 8\n\tDEPTH = 16\n\nImplementation:\nThe module implements an asynchronous FIFO using a dual-port RAM module and additional logic for managing read and write pointers.\nDual-port RAM:\nThe module instantiates a dual-port RAM module named \"dual_port_RAM\" with configurable depth and width.\nThe RAM module has separate clock inputs for write (wclk) and read (rclk) operations.\nThe RAM module has separate address inputs for write (waddr) and read (raddr) operations.\nThe RAM module has a write enable input (wenc) and a write data input (wdata).\nThe RAM module has a read enable input (renc) and a read data output (rdata).\nThe RAM module stores data in a two-dimensional array, RAM_MEM, with a size of DEPTH by WIDTH.\nWrite and Read Pointers:\nThe module includes logic to manage write and read pointers for asynchronous operation.\nThe write and read pointers are represented by binary registers, waddr_bin and raddr_bin, respectively.\nThe write and read pointers are incremented based on the write and read increment signals (winc and rinc), respectively.\nThe write pointer is incremented on the positive edge of the write clock (posedge wclk) and reset to 0 on write reset (~wrstn).\nThe read pointer is incremented on the positive edge of the read clock (posedge rclk) and reset to 0 on read reset (~rrstn).\nGray Code Conversion:\nThe write and read pointers are converted to Gray code using XOR operations with right-shifted values.\nThe converted write and read pointers are stored in registers wptr and rptr, respectively.\nThe Gray code conversion reduces glitches and ensures proper synchronization of the write and read pointers.\nPointer Buffers:\nThe module includes buffer registers (wptr_buff and rptr_buff) to hold the previous values of the write and read pointers.\nThe buffer registers are updated on the positive edge of the respective clocks and reset to 0 on the respective resets (~wrstn and ~rrstn).\nThe buffer registers are used to synchronize the write and read pointers for determining the full and empty conditions.\nFull and Empty Signals:\nThe module compares the current write and read pointers (wptr and rptr_syn) to determine if the FIFO is full or empty.\nThe wfull output is set to 1 when the write pointer is equal to the bitwise negation of the most significant bit of the read pointer concatenated with the remaining bits of the read pointer.\nThe rempty output is set to 1 when the read pointer is equal to the write pointer.\nInput and Output Connections:\nThe module connects the input and output signals to the dual-port RAM module based on the control signals and pointer values.\nThe wen and ren signals control the write and read enable signals of the RAM module, respectively.\nThe wdata input is connected to the write data input (wdata) of the RAM module.\nThe rdata output is connected to the read data output (rdata) of the RAM module.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\n/***************************************RAM*****************************************/\nmodule dual_port_RAM #(parameter DEPTH = 16,  parameter WIDTH = 8)\n(\n\t input wclk\t,\n\t input wenc\t,\n\t input [$clog2(DEPTH)-1:0] waddr  ,\n\t input [WIDTH-1:0] wdata ,\n\t input rclk\t,\n\t input renc\t,\n\t input [$clog2(DEPTH)-1:0] raddr ,\n\t output reg [WIDTH-1:0] rdata \t\t\n);\n\nreg [WIDTH-1:0] RAM_MEM [0:DEPTH-1];\n\nalways @(posedge wclk) begin\n\tif(wenc)\n\t\tRAM_MEM[waddr] <= wdata;\nend \n\nalways @(posedge rclk) begin\n\tif(renc)\n\t\trdata <= RAM_MEM[raddr];\nend \n\nendmodule  \n\n\n/**************************************AFIFO*****************************************/\nmodule asyn_fifo#(\n\tparameter\tWIDTH = 8,\n\tparameter \tDEPTH = 16\n)(\n\tinput \t\t\t\t\twclk\t, \n\tinput \t\t\t\t\trclk\t,   \n\tinput \t\t\t\t\twrstn\t,\n\tinput\t\t\t\t\trrstn\t,\n\tinput \t\t\t\t\twinc\t,\n\tinput \t\t\t \t\trinc\t,\n\tinput \t\t[WIDTH-1:0]\twdata\t,\n\n\toutput wire\t\t\t\twfull\t,\n\toutput wire\t\t\t\trempty\t,\n\toutput wire [WIDTH-1:0]\trdata\n);\n\nparameter ADDR_WIDTH = $clog2(DEPTH);\n\n\nreg \t[ADDR_WIDTH:0]\twaddr_bin;\nreg \t[ADDR_WIDTH:0]\traddr_bin;\n\nalways @(posedge wclk or negedge wrstn) begin\n\tif(~wrstn) begin\n\t\twaddr_bin <= 'd0;\n\tend \n\telse if(!wfull && winc)begin\n\t\twaddr_bin <= waddr_bin + 1'd1;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin\n\tif(~rrstn) begin\n\t\traddr_bin <= 'd0;\n\tend \n\telse if(!rempty && rinc)begin\n\t\traddr_bin <= raddr_bin + 1'd1;\n\tend\nend\n\nwire \t[ADDR_WIDTH:0]\twaddr_gray;\nwire \t[ADDR_WIDTH:0]\traddr_gray;\nreg \t[ADDR_WIDTH:0]\twptr;\nreg \t[ADDR_WIDTH:0]\trptr;\nassign waddr_gray = waddr_bin ^ (waddr_bin>>1);\nassign raddr_gray = raddr_bin ^ (raddr_bin>>1);\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\twptr <= 'd0;\n\tend \n\telse begin\n\t\twptr <= waddr_gray;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\trptr <= 'd0;\n\tend \n\telse begin\n\t\trptr <= raddr_gray;\n\tend\nend\n\nreg\t\t[ADDR_WIDTH:0]\twptr_buff;\nreg\t\t[ADDR_WIDTH:0]\twptr_syn;\nreg\t\t[ADDR_WIDTH:0]\trptr_buff;\nreg\t\t[ADDR_WIDTH:0]\trptr_syn;\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\trptr_buff <= 'd0;\n\t\trptr_syn <= 'd0;\n\tend \n\telse begin\n\t\trptr_buff <= rptr;\n\t\trptr_syn <= rptr_buff;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\twptr_buff <= 'd0;\n\t\twptr_syn <= 'd0;\n\tend \n\telse begin\n\t\twptr_buff <= wptr;\n\t\twptr_syn <= wptr_buff;\n\tend\nend\n\nassign wfull = (wptr == {~rptr_syn[ADDR_WIDTH:ADDR_WIDTH-1],rptr_syn[ADDR_WIDTH-2:0]});\nassign rempty = (rptr == wptr_syn);\n\n/***********RAM*********/\nwire \twen\t;\nwire\tren\t;\nwire \twren;//high write\nwire [ADDR_WIDTH-1:0]\twaddr;\nwire [ADDR_WIDTH-1:0]\traddr;\nassign wen = winc & !wfull;\nassign ren = rinc & !rempty;\nassign waddr = waddr_bin[ADDR_WIDTH-1:0];\nassign raddr = raddr_bin[ADDR_WIDTH-1:0];\n\ndual_port_RAM #(.DEPTH(DEPTH),\n\t\t\t\t.WIDTH(WIDTH)\n)dual_port_RAM(\n\t.wclk (wclk),  \n\t.wenc (wen),  \n\t.waddr(waddr[ADDR_WIDTH-1:0]),  //The depth is logarithmic to 2 to get the bit width of the address\n\t.wdata(wdata),       \t//data_write\n\t.rclk (rclk), \n\t.renc (ren), \n\t.raddr(raddr[ADDR_WIDTH-1:0]),   \n\t.rdata(rdata)  \t\t\n);\n\nendmodule", "corrupted_code": "`timescale 1ns/1ns\n\n/***************************************RAM*****************************************/\nmodule dual_port_RAM #(parameter DEPTH = 16,  parameter WIDTH = 8)\n(\n\t input wclk\t,\n\t input wenc\t,\n\t input [$clog2(DEPTH)-1:0] waddr  ,\n\t input [WIDTH-1:0] wdata ,\n\t input rclk\t,\n\t input renc\t,\n\t input [$clog2(DEPTH)-1:0] raddr ,\n\t output reg [WIDTH-1:0] rdata \t\t\n);\n\nreg [WIDTH-1:0] RAM_MEM [0:DEPTH-1];\n\n \n\nalways @(posedge rclk) begin\n\tif(renc)\n\t\trdata <= RAM_MEM[raddr];\nend \n\nendmodule  \n\n\n/**************************************AFIFO*****************************************/\nmodule asyn_fifo#(\n\tparameter\tWIDTH = 8,\n\tparameter \tDEPTH = 16\n)(\n\tinput \t\t\t\t\twclk\t, \n\tinput \t\t\t\t\trclk\t,   \n\tinput \t\t\t\t\twrstn\t,\n\tinput\t\t\t\t\trrstn\t,\n\tinput \t\t\t\t\twinc\t,\n\tinput \t\t\t \t\trinc\t,\n\tinput \t\t[WIDTH-1:0]\twdata\t,\n\n\toutput wire\t\t\t\twfull\t,\n\toutput wire\t\t\t\trempty\t,\n\toutput wire [WIDTH-1:0]\trdata\n);\n\nparameter ADDR_WIDTH = $clog2(DEPTH);\n\n\nreg \t[ADDR_WIDTH:0]\twaddr_bin;\nreg \t[ADDR_WIDTH:0]\traddr_bin;\n\nalways @(posedge wclk or negedge wrstn) begin\n\tif(~wrstn) begin\n\t\twaddr_bin <= 'd0;\n\tend \n\telse if(!wfull && winc)begin\n\t\twaddr_bin <= waddr_bin + 1'd1;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin\n\tif(~rrstn) begin\n\t\traddr_bin <= 'd0;\n\tend \n\telse if(!rempty && rinc)begin\n\t\traddr_bin <= raddr_bin + 1'd1;\n\tend\nend\n\nwire \t[ADDR_WIDTH:0]\twaddr_gray;\nwire \t[ADDR_WIDTH:0]\traddr_gray;\nreg \t[ADDR_WIDTH:0]\twptr;\nreg \t[ADDR_WIDTH:0]\trptr;\nassign waddr_gray = waddr_bin ^ (waddr_bin>>1);\nassign raddr_gray = raddr_bin ^ (raddr_bin>>1);\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\twptr <= 'd0;\n\tend \n\telse begin\n\t\twptr <= waddr_gray;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\trptr <= 'd0;\n\tend \n\telse begin\n\t\trptr <= raddr_gray;\n\tend\nend\n\nreg\t\t[ADDR_WIDTH:0]\twptr_buff;\nreg\t\t[ADDR_WIDTH:0]\twptr_syn;\nreg\t\t[ADDR_WIDTH:0]\trptr_buff;\nreg\t\t[ADDR_WIDTH:0]\trptr_syn;\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\trptr_buff <= 'd0;\n\t\trptr_syn <= 'd0;\n\tend \n\telse begin\n\t\trptr_buff <= rptr;\n\t\trptr_syn <= rptr_buff;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\twptr_buff <= 'd0;\n\t\twptr_syn <= 'd0;\n\tend \n\telse begin\n\t\twptr_buff <= wptr;\n\t\twptr_syn <= wptr_buff;\n\tend\nend\n\nassign wfull = (wptr == {~rptr_syn[ADDR_WIDTH:ADDR_WIDTH-1],rptr_syn[ADDR_WIDTH-2:0]});\nassign rempty = (rptr == wptr_syn);\n\n/***********RAM*********/\nwire \twen\t;\nwire\tren\t;\nwire \twren;//high write\nwire [ADDR_WIDTH-1:0]\twaddr;\nwire [ADDR_WIDTH-1:0]\traddr;\nassign wen = winc & !wfull;\nassign ren = rinc & !rempty;\nassign waddr = waddr_bin[ADDR_WIDTH-1:0];\nassign raddr = raddr_bin[ADDR_WIDTH-1:0];\n\ndual_port_RAM #(.DEPTH(DEPTH),\n\t\t\t\t.WIDTH(WIDTH)\n)dual_port_RAM(\n\t.wclk (wclk),  \n\t.wenc (wen),  \n\t.waddr(waddr[ADDR_WIDTH-1:0]),  //The depth is logarithmic to 2 to get the bit width of the address\n\t.wdata(wdata),       \t//data_write\n\t.rclk (rclk), \n\t.renc (ren), \n\t.raddr(raddr[ADDR_WIDTH-1:0]),   \n\t.rdata(rdata)  \t\t\n);\n\nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 18, "original_snippet": "always @(posedge wclk) begin\n\tif(wenc)\n\t\tRAM_MEM[waddr] <= wdata;\nend", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 18: Original: always @(posedge wclk) begin\n\tif(wenc)\n\t\tRAM_MEM[waddr] <= wdata;\nend\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 18.\n   \u2022 Restore the original code: always @(posedge wclk) begin\n\tif(wenc)\n\t\tRAM_MEM[waddr] <= wdata;\nend\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 47, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.878275", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "FIFO", "design_name": "asyn_fifo", "module_name": "asyn_fifo", "description": "Please act as a professional verilog designer.\n\nImplement an asynchronous FIFO, FIFO bit width and depth can be configured(parameter DEPTH = 16, parameter WIDTH = 8). The asynchronous FIFO structure is divided into several parts. The first part is dual-port RAM, which is used for data storage. Instantiate dual-port RAM as a submodule, The RAM ports are input wclk, input wenc, input [$clog2(DEPTH)-1:0] waddr, input [WIDTH-1:0] wdata, input rclk, input renc, input [$clog2(DEPTH)-1:0] raddr, output reg [WIDTH-1:0] rdata. The second part is the data write controller. The third part is the data read controller. The fourth part is the read pointer synchronizer. The read pointer is collected using the two-stage trigger of the write clock and output to the data write controller. The fifth part is the write pointer synchronizer, which uses the two-stage trigger of the read clock to collect the write pointer and output it to the data read controller.\nThe method of empty and full judgment is to generate empty and full signals by comparing the Gray code. Use 4-bit Gray code as a read/write pointer for a FIFO with depth 8. The gray code is converted to a four-digit binary number, using the lower three digits of the binary number as the address to access RAM. When the read and write Pointers are equal, the FIFO is null.\nWhen the write pointer has one more cycle RAM than the read pointer, the highest and second-highest bits of the read and write pointer are opposite, the remaining bits are the same, and the FIFO is full.\n\nModule name:  \n    asyn_fifo  \n\nInput ports:\n\twclk: Write clock signal used for synchronous write operations.\n\trclk: Read clock signal used for synchronous read operations.\n\twrstn: Write reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\trrstn: Read reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\twinc: Write increment signal. Used to trigger write operations.\n\trinc: Read increment signal. Used to trigger read operations.\n\twdata: Write data input. The width [WIDTH-1:0] is configurable and represents the data to be written into the FIFO.\n\nOutput ports:\nwfull: Write full signal. Indicates if the FIFO is full and cannot accept further write operations.\nrempty: Read empty signal. Indicates if the FIFO is empty and cannot provide any data for read operations.\nrdata: Read data output. The width [WIDTH-1:0] is configurable and represents the data read from the FIFO.\n\nParameter:\n\tWIDTH = 8\n\tDEPTH = 16\n\nImplementation:\nThe module implements an asynchronous FIFO using a dual-port RAM module and additional logic for managing read and write pointers.\nDual-port RAM:\nThe module instantiates a dual-port RAM module named \"dual_port_RAM\" with configurable depth and width.\nThe RAM module has separate clock inputs for write (wclk) and read (rclk) operations.\nThe RAM module has separate address inputs for write (waddr) and read (raddr) operations.\nThe RAM module has a write enable input (wenc) and a write data input (wdata).\nThe RAM module has a read enable input (renc) and a read data output (rdata).\nThe RAM module stores data in a two-dimensional array, RAM_MEM, with a size of DEPTH by WIDTH.\nWrite and Read Pointers:\nThe module includes logic to manage write and read pointers for asynchronous operation.\nThe write and read pointers are represented by binary registers, waddr_bin and raddr_bin, respectively.\nThe write and read pointers are incremented based on the write and read increment signals (winc and rinc), respectively.\nThe write pointer is incremented on the positive edge of the write clock (posedge wclk) and reset to 0 on write reset (~wrstn).\nThe read pointer is incremented on the positive edge of the read clock (posedge rclk) and reset to 0 on read reset (~rrstn).\nGray Code Conversion:\nThe write and read pointers are converted to Gray code using XOR operations with right-shifted values.\nThe converted write and read pointers are stored in registers wptr and rptr, respectively.\nThe Gray code conversion reduces glitches and ensures proper synchronization of the write and read pointers.\nPointer Buffers:\nThe module includes buffer registers (wptr_buff and rptr_buff) to hold the previous values of the write and read pointers.\nThe buffer registers are updated on the positive edge of the respective clocks and reset to 0 on the respective resets (~wrstn and ~rrstn).\nThe buffer registers are used to synchronize the write and read pointers for determining the full and empty conditions.\nFull and Empty Signals:\nThe module compares the current write and read pointers (wptr and rptr_syn) to determine if the FIFO is full or empty.\nThe wfull output is set to 1 when the write pointer is equal to the bitwise negation of the most significant bit of the read pointer concatenated with the remaining bits of the read pointer.\nThe rempty output is set to 1 when the read pointer is equal to the write pointer.\nInput and Output Connections:\nThe module connects the input and output signals to the dual-port RAM module based on the control signals and pointer values.\nThe wen and ren signals control the write and read enable signals of the RAM module, respectively.\nThe wdata input is connected to the write data input (wdata) of the RAM module.\nThe rdata output is connected to the read data output (rdata) of the RAM module.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\n/***************************************RAM*****************************************/\nmodule dual_port_RAM #(parameter DEPTH = 16,  parameter WIDTH = 8)\n(\n\t input wclk\t,\n\t input wenc\t,\n\t input [$clog2(DEPTH)-1:0] waddr  ,\n\t input [WIDTH-1:0] wdata ,\n\t input rclk\t,\n\t input renc\t,\n\t input [$clog2(DEPTH)-1:0] raddr ,\n\t output reg [WIDTH-1:0] rdata \t\t\n);\n\nreg [WIDTH-1:0] RAM_MEM [0:DEPTH-1];\n\nalways @(posedge wclk) begin\n\tif(wenc)\n\t\tRAM_MEM[waddr] <= wdata;\nend \n\nalways @(posedge rclk) begin\n\tif(renc)\n\t\trdata <= RAM_MEM[raddr];\nend \n\nendmodule  \n\n\n/**************************************AFIFO*****************************************/\nmodule asyn_fifo#(\n\tparameter\tWIDTH = 8,\n\tparameter \tDEPTH = 16\n)(\n\tinput \t\t\t\t\twclk\t, \n\tinput \t\t\t\t\trclk\t,   \n\tinput \t\t\t\t\twrstn\t,\n\tinput\t\t\t\t\trrstn\t,\n\tinput \t\t\t\t\twinc\t,\n\tinput \t\t\t \t\trinc\t,\n\tinput \t\t[WIDTH-1:0]\twdata\t,\n\n\toutput wire\t\t\t\twfull\t,\n\toutput wire\t\t\t\trempty\t,\n\toutput wire [WIDTH-1:0]\trdata\n);\n\nparameter ADDR_WIDTH = $clog2(DEPTH);\n\n\nreg \t[ADDR_WIDTH:0]\twaddr_bin;\nreg \t[ADDR_WIDTH:0]\traddr_bin;\n\nalways @(posedge wclk or negedge wrstn) begin\n\tif(~wrstn) begin\n\t\twaddr_bin <= 'd0;\n\tend \n\telse if(!wfull && winc)begin\n\t\twaddr_bin <= waddr_bin + 1'd1;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin\n\tif(~rrstn) begin\n\t\traddr_bin <= 'd0;\n\tend \n\telse if(!rempty && rinc)begin\n\t\traddr_bin <= raddr_bin + 1'd1;\n\tend\nend\n\nwire \t[ADDR_WIDTH:0]\twaddr_gray;\nwire \t[ADDR_WIDTH:0]\traddr_gray;\nreg \t[ADDR_WIDTH:0]\twptr;\nreg \t[ADDR_WIDTH:0]\trptr;\nassign waddr_gray = waddr_bin ^ (waddr_bin>>1);\nassign raddr_gray = raddr_bin ^ (raddr_bin>>1);\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\twptr <= 'd0;\n\tend \n\telse begin\n\t\twptr <= waddr_gray;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\trptr <= 'd0;\n\tend \n\telse begin\n\t\trptr <= raddr_gray;\n\tend\nend\n\nreg\t\t[ADDR_WIDTH:0]\twptr_buff;\nreg\t\t[ADDR_WIDTH:0]\twptr_syn;\nreg\t\t[ADDR_WIDTH:0]\trptr_buff;\nreg\t\t[ADDR_WIDTH:0]\trptr_syn;\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\trptr_buff <= 'd0;\n\t\trptr_syn <= 'd0;\n\tend \n\telse begin\n\t\trptr_buff <= rptr;\n\t\trptr_syn <= rptr_buff;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\twptr_buff <= 'd0;\n\t\twptr_syn <= 'd0;\n\tend \n\telse begin\n\t\twptr_buff <= wptr;\n\t\twptr_syn <= wptr_buff;\n\tend\nend\n\nassign wfull = (wptr == {~rptr_syn[ADDR_WIDTH:ADDR_WIDTH-1],rptr_syn[ADDR_WIDTH-2:0]});\nassign rempty = (rptr == wptr_syn);\n\n/***********RAM*********/\nwire \twen\t;\nwire\tren\t;\nwire \twren;//high write\nwire [ADDR_WIDTH-1:0]\twaddr;\nwire [ADDR_WIDTH-1:0]\traddr;\nassign wen = winc & !wfull;\nassign ren = rinc & !rempty;\nassign waddr = waddr_bin[ADDR_WIDTH-1:0];\nassign raddr = raddr_bin[ADDR_WIDTH-1:0];\n\ndual_port_RAM #(.DEPTH(DEPTH),\n\t\t\t\t.WIDTH(WIDTH)\n)dual_port_RAM(\n\t.wclk (wclk),  \n\t.wenc (wen),  \n\t.waddr(waddr[ADDR_WIDTH-1:0]),  //The depth is logarithmic to 2 to get the bit width of the address\n\t.wdata(wdata),       \t//data_write\n\t.rclk (rclk), \n\t.renc (ren), \n\t.raddr(raddr[ADDR_WIDTH-1:0]),   \n\t.rdata(rdata)  \t\t\n);\n\nendmodule", "corrupted_code": "`timescale 1ns/1ns\n\n/***************************************RAM*****************************************/\nmodule dual_port_RAM #(parameter DEPTH = 16,  parameter WIDTH = 8)\n(\n\t input wclk\t,\n\t input wenc\t,\n\t input [$clog2(DEPTH)-1:0] waddr  ,\n\t input [WIDTH-1:0] wdata ,\n\t input rclk\t,\n\t input renc\t,\n\t input [$clog2(DEPTH)-1:0] raddr ,\n\t output reg [WIDTH-1:0] rdata \t\t\n);\n\nreg [WIDTH-1:0] RAM_MEM [0:DEPTH-1];\n\nalways @(posedge wclk) begin\n\tif(wenc)\n\t\tRAM_MEM[waddr] <= wdata;\nend \n\nalways @(posedge rclk) begin\n\tif(renc)\n\t\trdata <= RAM_MEM[raddr];\nend \n\nendmodule  \n\n\n/**************************************AFIFO*****************************************/\nmodule asyn_fifo#(\n\tparameter\tWIDTH = 8,\n\tparameter \tDEPTH = 16\n)(\n\tinput \t\t\t\t\twclk\t, \n\tinput \t\t\t\t\trclk\t,   \n\tinput \t\t\t\t\twrstn\t,\n\tinput\t\t\t\t\trrstn\t,\n\tinput \t\t\t\t\twinc\t,\n\tinput \t\t\t \t\trinc\t,\n\tinput \t\t[WIDTH-1:0]\twdata\t,\n\n\toutput wire\t\t\t\twfull\t,\n\toutput wire\t\t\t\trempty\t,\n\toutput wire [WIDTH-1:0]\trdata\n);\n\nparameter ADDR_WIDTH = $clog2(DEPTH);\n\n\nreg \t[ADDR_WIDTH:0]\twaddr_bin;\nreg \t[ADDR_WIDTH:0]\traddr_bin;\n\nalways @(posedge wclk or negedge wrstn) begin\n\tif(~wrstn) begin\n\t\twaddr_bin <= 'd0;\n\tend \n\telse if(!wfull && winc)begin\n\t\twaddr_bin <= waddr_bin + 1'd1;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin\n\tif(~rrstn) begin\n\t\traddr_bin <= 'd0;\n\tend \n\telse if(!rempty && rinc)begin\n\t\traddr_bin <= raddr_bin + 1'd1;\n\tend\nend\n\nwire \t[ADDR_WIDTH:0]\twaddr_gray;\nwire \t[ADDR_WIDTH:0]\traddr_gray;\nreg \t[ADDR_WIDTH:0]\twptr;\nreg \t[ADDR_WIDTH:0]\trptr;\nassign waddr_gray = waddr_bin ^ (waddr_bin>>1);\nassign raddr_gray = raddr_bin ^ (raddr_bin>>1);\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\twptr <= 'd0;\n\tend \n\telse begin\n\t\twptr <= waddr_gray;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\trptr <= 'd0;\n\tend \n\telse begin\n\t\trptr <= raddr_gray;\n\tend\nend\n\nreg\t\t[ADDR_WIDTH:0]\twptr_buff;\nreg\t\t[ADDR_WIDTH:0]\twptr_syn;\nreg\t\t[ADDR_WIDTH:0]\trptr_buff;\nreg\t\t[ADDR_WIDTH:0]\trptr_syn;\nalways @(posedge wclk) begin \n\tif(~wrstn) begin\n\t\trptr_buff <= 'd0;\n\t\trptr_syn <= 'd0;\n\tend \n\telse begin\n\t\trptr_buff <= rptr;\n\t\trptr_syn <= rptr_buff;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\twptr_buff <= 'd0;\n\t\twptr_syn <= 'd0;\n\tend \n\telse begin\n\t\twptr_buff <= wptr;\n\t\twptr_syn <= wptr_buff;\n\tend\nend\n\nassign wfull = (wptr == {~rptr_syn[ADDR_WIDTH:ADDR_WIDTH-1],rptr_syn[ADDR_WIDTH-2:0]});\nassign rempty = (rptr == wptr_syn);\n\n/***********RAM*********/\nwire \twen\t;\nwire\tren\t;\nwire \twren;//high write\nwire [ADDR_WIDTH-1:0]\twaddr;\nwire [ADDR_WIDTH-1:0]\traddr;\nassign wen = winc & !wfull;\nassign ren = rinc & !rempty;\nassign waddr = waddr_bin[ADDR_WIDTH-1:0];\nassign raddr = raddr_bin[ADDR_WIDTH-1:0];\n\ndual_port_RAM #(.DEPTH(DEPTH),\n\t\t\t\t.WIDTH(WIDTH)\n)dual_port_RAM(\n\t.wclk (wclk),  \n\t.wenc (wen),  \n\t.waddr(waddr[ADDR_WIDTH-1:0]),  //The depth is logarithmic to 2 to get the bit width of the address\n\t.wdata(wdata),       \t//data_write\n\t.rclk (rclk), \n\t.renc (ren), \n\t.raddr(raddr[ADDR_WIDTH-1:0]),   \n\t.rdata(rdata)  \t\t\n);\n\nendmodule", "corruption_explanation": "Removed async reset from sensitivity list", "modification_type": "remove_async_reset", "modification_line": 99, "original_snippet": "always @(posedge wclk or negedge wrstn)", "modified_snippet": "always @(posedge wclk)", "issue_description": "The buggy code has removed async reset from the sensitivity list. The always block only triggers on clock edges, not reset. This causes metastability on power-up and removes the ability to asynchronously reset the design.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_async_reset modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed async reset from sensitivity list\n   \u2022 Line 99: Original: always @(posedge wclk or negedge wrstn)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 99.\n   \u2022 Restore the original code: always @(posedge wclk or negedge wrstn)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove async reset.", "complexity": 47, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_async_reset"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.882849", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "FIFO", "design_name": "asyn_fifo", "module_name": "asyn_fifo", "description": "Please act as a professional verilog designer.\n\nImplement an asynchronous FIFO, FIFO bit width and depth can be configured(parameter DEPTH = 16, parameter WIDTH = 8). The asynchronous FIFO structure is divided into several parts. The first part is dual-port RAM, which is used for data storage. Instantiate dual-port RAM as a submodule, The RAM ports are input wclk, input wenc, input [$clog2(DEPTH)-1:0] waddr, input [WIDTH-1:0] wdata, input rclk, input renc, input [$clog2(DEPTH)-1:0] raddr, output reg [WIDTH-1:0] rdata. The second part is the data write controller. The third part is the data read controller. The fourth part is the read pointer synchronizer. The read pointer is collected using the two-stage trigger of the write clock and output to the data write controller. The fifth part is the write pointer synchronizer, which uses the two-stage trigger of the read clock to collect the write pointer and output it to the data read controller.\nThe method of empty and full judgment is to generate empty and full signals by comparing the Gray code. Use 4-bit Gray code as a read/write pointer for a FIFO with depth 8. The gray code is converted to a four-digit binary number, using the lower three digits of the binary number as the address to access RAM. When the read and write Pointers are equal, the FIFO is null.\nWhen the write pointer has one more cycle RAM than the read pointer, the highest and second-highest bits of the read and write pointer are opposite, the remaining bits are the same, and the FIFO is full.\n\nModule name:  \n    asyn_fifo  \n\nInput ports:\n\twclk: Write clock signal used for synchronous write operations.\n\trclk: Read clock signal used for synchronous read operations.\n\twrstn: Write reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\trrstn: Read reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\twinc: Write increment signal. Used to trigger write operations.\n\trinc: Read increment signal. Used to trigger read operations.\n\twdata: Write data input. The width [WIDTH-1:0] is configurable and represents the data to be written into the FIFO.\n\nOutput ports:\nwfull: Write full signal. Indicates if the FIFO is full and cannot accept further write operations.\nrempty: Read empty signal. Indicates if the FIFO is empty and cannot provide any data for read operations.\nrdata: Read data output. The width [WIDTH-1:0] is configurable and represents the data read from the FIFO.\n\nParameter:\n\tWIDTH = 8\n\tDEPTH = 16\n\nImplementation:\nThe module implements an asynchronous FIFO using a dual-port RAM module and additional logic for managing read and write pointers.\nDual-port RAM:\nThe module instantiates a dual-port RAM module named \"dual_port_RAM\" with configurable depth and width.\nThe RAM module has separate clock inputs for write (wclk) and read (rclk) operations.\nThe RAM module has separate address inputs for write (waddr) and read (raddr) operations.\nThe RAM module has a write enable input (wenc) and a write data input (wdata).\nThe RAM module has a read enable input (renc) and a read data output (rdata).\nThe RAM module stores data in a two-dimensional array, RAM_MEM, with a size of DEPTH by WIDTH.\nWrite and Read Pointers:\nThe module includes logic to manage write and read pointers for asynchronous operation.\nThe write and read pointers are represented by binary registers, waddr_bin and raddr_bin, respectively.\nThe write and read pointers are incremented based on the write and read increment signals (winc and rinc), respectively.\nThe write pointer is incremented on the positive edge of the write clock (posedge wclk) and reset to 0 on write reset (~wrstn).\nThe read pointer is incremented on the positive edge of the read clock (posedge rclk) and reset to 0 on read reset (~rrstn).\nGray Code Conversion:\nThe write and read pointers are converted to Gray code using XOR operations with right-shifted values.\nThe converted write and read pointers are stored in registers wptr and rptr, respectively.\nThe Gray code conversion reduces glitches and ensures proper synchronization of the write and read pointers.\nPointer Buffers:\nThe module includes buffer registers (wptr_buff and rptr_buff) to hold the previous values of the write and read pointers.\nThe buffer registers are updated on the positive edge of the respective clocks and reset to 0 on the respective resets (~wrstn and ~rrstn).\nThe buffer registers are used to synchronize the write and read pointers for determining the full and empty conditions.\nFull and Empty Signals:\nThe module compares the current write and read pointers (wptr and rptr_syn) to determine if the FIFO is full or empty.\nThe wfull output is set to 1 when the write pointer is equal to the bitwise negation of the most significant bit of the read pointer concatenated with the remaining bits of the read pointer.\nThe rempty output is set to 1 when the read pointer is equal to the write pointer.\nInput and Output Connections:\nThe module connects the input and output signals to the dual-port RAM module based on the control signals and pointer values.\nThe wen and ren signals control the write and read enable signals of the RAM module, respectively.\nThe wdata input is connected to the write data input (wdata) of the RAM module.\nThe rdata output is connected to the read data output (rdata) of the RAM module.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\n/***************************************RAM*****************************************/\nmodule dual_port_RAM #(parameter DEPTH = 16,  parameter WIDTH = 8)\n(\n\t input wclk\t,\n\t input wenc\t,\n\t input [$clog2(DEPTH)-1:0] waddr  ,\n\t input [WIDTH-1:0] wdata ,\n\t input rclk\t,\n\t input renc\t,\n\t input [$clog2(DEPTH)-1:0] raddr ,\n\t output reg [WIDTH-1:0] rdata \t\t\n);\n\nreg [WIDTH-1:0] RAM_MEM [0:DEPTH-1];\n\nalways @(posedge wclk) begin\n\tif(wenc)\n\t\tRAM_MEM[waddr] <= wdata;\nend \n\nalways @(posedge rclk) begin\n\tif(renc)\n\t\trdata <= RAM_MEM[raddr];\nend \n\nendmodule  \n\n\n/**************************************AFIFO*****************************************/\nmodule asyn_fifo#(\n\tparameter\tWIDTH = 8,\n\tparameter \tDEPTH = 16\n)(\n\tinput \t\t\t\t\twclk\t, \n\tinput \t\t\t\t\trclk\t,   \n\tinput \t\t\t\t\twrstn\t,\n\tinput\t\t\t\t\trrstn\t,\n\tinput \t\t\t\t\twinc\t,\n\tinput \t\t\t \t\trinc\t,\n\tinput \t\t[WIDTH-1:0]\twdata\t,\n\n\toutput wire\t\t\t\twfull\t,\n\toutput wire\t\t\t\trempty\t,\n\toutput wire [WIDTH-1:0]\trdata\n);\n\nparameter ADDR_WIDTH = $clog2(DEPTH);\n\n\nreg \t[ADDR_WIDTH:0]\twaddr_bin;\nreg \t[ADDR_WIDTH:0]\traddr_bin;\n\nalways @(posedge wclk or negedge wrstn) begin\n\tif(~wrstn) begin\n\t\twaddr_bin <= 'd0;\n\tend \n\telse if(!wfull && winc)begin\n\t\twaddr_bin <= waddr_bin + 1'd1;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin\n\tif(~rrstn) begin\n\t\traddr_bin <= 'd0;\n\tend \n\telse if(!rempty && rinc)begin\n\t\traddr_bin <= raddr_bin + 1'd1;\n\tend\nend\n\nwire \t[ADDR_WIDTH:0]\twaddr_gray;\nwire \t[ADDR_WIDTH:0]\traddr_gray;\nreg \t[ADDR_WIDTH:0]\twptr;\nreg \t[ADDR_WIDTH:0]\trptr;\nassign waddr_gray = waddr_bin ^ (waddr_bin>>1);\nassign raddr_gray = raddr_bin ^ (raddr_bin>>1);\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\twptr <= 'd0;\n\tend \n\telse begin\n\t\twptr <= waddr_gray;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\trptr <= 'd0;\n\tend \n\telse begin\n\t\trptr <= raddr_gray;\n\tend\nend\n\nreg\t\t[ADDR_WIDTH:0]\twptr_buff;\nreg\t\t[ADDR_WIDTH:0]\twptr_syn;\nreg\t\t[ADDR_WIDTH:0]\trptr_buff;\nreg\t\t[ADDR_WIDTH:0]\trptr_syn;\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\trptr_buff <= 'd0;\n\t\trptr_syn <= 'd0;\n\tend \n\telse begin\n\t\trptr_buff <= rptr;\n\t\trptr_syn <= rptr_buff;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\twptr_buff <= 'd0;\n\t\twptr_syn <= 'd0;\n\tend \n\telse begin\n\t\twptr_buff <= wptr;\n\t\twptr_syn <= wptr_buff;\n\tend\nend\n\nassign wfull = (wptr == {~rptr_syn[ADDR_WIDTH:ADDR_WIDTH-1],rptr_syn[ADDR_WIDTH-2:0]});\nassign rempty = (rptr == wptr_syn);\n\n/***********RAM*********/\nwire \twen\t;\nwire\tren\t;\nwire \twren;//high write\nwire [ADDR_WIDTH-1:0]\twaddr;\nwire [ADDR_WIDTH-1:0]\traddr;\nassign wen = winc & !wfull;\nassign ren = rinc & !rempty;\nassign waddr = waddr_bin[ADDR_WIDTH-1:0];\nassign raddr = raddr_bin[ADDR_WIDTH-1:0];\n\ndual_port_RAM #(.DEPTH(DEPTH),\n\t\t\t\t.WIDTH(WIDTH)\n)dual_port_RAM(\n\t.wclk (wclk),  \n\t.wenc (wen),  \n\t.waddr(waddr[ADDR_WIDTH-1:0]),  //The depth is logarithmic to 2 to get the bit width of the address\n\t.wdata(wdata),       \t//data_write\n\t.rclk (rclk), \n\t.renc (ren), \n\t.raddr(raddr[ADDR_WIDTH-1:0]),   \n\t.rdata(rdata)  \t\t\n);\n\nendmodule", "corrupted_code": "`timescale 1ns/1ns\n\n/***************************************RAM*****************************************/\nmodule dual_port_RAM #(parameter DEPTH = 16,  parameter WIDTH = 8)\n(\n\t input wclk\t,\n\t input wenc\t,\n\t input [$clog2(DEPTH)-1:0] waddr  ,\n\t input [WIDTH-1:0] wdata ,\n\t input rclk\t,\n\t input renc\t,\n\t input [$clog2(DEPTH)-1:0] raddr ,\n\t output reg [WIDTH-1:0] rdata \t\t\n);\n\nreg [WIDTH-1:0] RAM_MEM [0:DEPTH-1];\n\nalways @(posedge wclk) begin\n\tif(wenc)\n\t\tRAM_MEM[waddr] <= wdata;\nend \n\nalways @(posedge rclk) begin\n\tif(renc)\n\t\trdata <= RAM_MEM[raddr];\nend \n\nendmodule  \n\n\n/**************************************AFIFO*****************************************/\nmodule asyn_fifo#(\n\tparameter\tWIDTH = 8,\n\tparameter \tDEPTH = 16\n)(\n\tinput \t\t\t\t\twclk\t, \n\tinput \t\t\t\t\trclk\t,   \n\tinput \t\t\t\t\twrstn\t,\n\tinput\t\t\t\t\trrstn\t,\n\tinput \t\t\t\t\twinc\t,\n\tinput \t\t\t \t\trinc\t,\n\tinput \t\t[WIDTH-1:0]\twdata\t,\n\n\toutput wire\t\t\t\twfull\t,\n\toutput wire\t\t\t\trempty\t,\n\toutput wire [WIDTH-1:0]\trdata\n);\n\nparameter ADDR_WIDTH = $clog2(DEPTH);\n\n\nreg \t[ADDR_WIDTH:0]\twaddr_bin;\nreg \t[ADDR_WIDTH:0]\traddr_bin;\n\nalways @(posedge wclk or negedge wrstn) begin\n\tif(~wrstn) begin\n\t\twaddr_bin <= 'd0;\n\tend \n\telse if(!wfull && winc)begin\n\t\twaddr_bin <= waddr_bin + 1'd1;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin\n\tif(~rrstn) begin\n\t\traddr_bin <= 'd0;\n\tend \n\telse if(!rempty && rinc)begin\n\t\traddr_bin <= raddr_bin + 1'd1;\n\tend\nend\n\nwire \t[ADDR_WIDTH:0]\twaddr_gray;\nwire \t[ADDR_WIDTH:0]\traddr_gray;\nreg \t[ADDR_WIDTH:0]\twptr;\nreg \t[ADDR_WIDTH:0]\trptr;\nassign waddr_gray = waddr_bin ^ (waddr_bin>>1);\nassign raddr_gray = raddr_bin ^ (raddr_bin>>1);\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\twptr <= 'd0;\n\tend \n\telse begin\n\t\twptr <= waddr_gray;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\trptr <= 'd0;\n\tend \n\telse begin\n\t\trptr <= raddr_gray;\n\tend\nend\n\nreg\t\t[ADDR_WIDTH:0]\twptr_buff;\nreg\t\t[ADDR_WIDTH:0]\twptr_syn;\nreg\t\t[ADDR_WIDTH:0]\trptr_buff;\nreg\t\t[ADDR_WIDTH:0]\trptr_syn;\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\trptr_buff <= 'd0;\n\t\trptr_syn <= 'd0;\n\tend \n\telse begin\n\t\trptr_buff <= rptr;\n\t\trptr_syn <= rptr_buff;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\twptr_buff <= 'd0;\n\t\twptr_syn <= 'd0;\n\tend \n\telse begin\n\t\twptr_buff <= wptr;\n\t\twptr_syn <= wptr_buff;\n\tend\nend\n\nassign wfull = (wptr == {~rptr_syn[ADDR_WIDTH:ADDR_WIDTH-1],rptr_syn[ADDR_WIDTH-2:0]});\nassign rempty = (rptr == wptr_syn);\n\n/***********RAM*********/\nwire \twen\t;\nwire\tren\t;\nwire \twren;//high write\nwire [ADDR_WIDTH-1:0]\twaddr;\nwire [ADDR_WIDTH-1:0]\traddr;\nassign wen = winc & !wfull;\nassign ren = rinc & !rempty;\nassign waddr = waddr_bin[ADDR_WIDTH-1:0];\nassign raddr = raddr_bin[ADDR_WIDTH-1:0];\n\ndual_port_RAM #(.DEPTH(DEPTH),\n\t\t\t\t.WIDTH(WIDTH)\n)dual_port_RAM(\n\t.wclk (wclk),  \n\t.wenc (wen),  \n\t.waddr(waddr[ADDR_WIDTH-1:0]),  //The depth is logarithmic to 2 to get the bit width of the address\n\t.wdata(wdata),       \t//data_write\n\t.rclk (rclk), \n\t.renc (ren), \n\t.raddr(raddr[ADDR_WIDTH-1:0]),   \n\t.rdata(rdata)  \t\t\n);\n\n\n    wire clk_dup;\n    assign clk_dup = wclk;\nendmodule", "corruption_explanation": "Added duplicate clock signal clk_dup", "modification_type": "duplicate_clock_signal", "modification_line": 62, "original_snippet": "(none)", "modified_snippet": "wire clk_dup;\n    assign clk_dup = wclk;", "issue_description": "The buggy code has a duplicate clock signal. A phantom clock domain is created, which may confuse CDC analysis tools and create subtle timing issues in synthesis. This violates clock domain design best practices.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a duplicate_clock_signal modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added duplicate clock signal clk_dup\n   \u2022 Line 62: Original: (none)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 62.\n   \u2022 Restore the original code: (none)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to duplicate clock signal.", "complexity": 47, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["duplicate_clock_signal"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.887229", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "FIFO", "design_name": "asyn_fifo", "module_name": "asyn_fifo", "description": "Please act as a professional verilog designer.\n\nImplement an asynchronous FIFO, FIFO bit width and depth can be configured(parameter DEPTH = 16, parameter WIDTH = 8). The asynchronous FIFO structure is divided into several parts. The first part is dual-port RAM, which is used for data storage. Instantiate dual-port RAM as a submodule, The RAM ports are input wclk, input wenc, input [$clog2(DEPTH)-1:0] waddr, input [WIDTH-1:0] wdata, input rclk, input renc, input [$clog2(DEPTH)-1:0] raddr, output reg [WIDTH-1:0] rdata. The second part is the data write controller. The third part is the data read controller. The fourth part is the read pointer synchronizer. The read pointer is collected using the two-stage trigger of the write clock and output to the data write controller. The fifth part is the write pointer synchronizer, which uses the two-stage trigger of the read clock to collect the write pointer and output it to the data read controller.\nThe method of empty and full judgment is to generate empty and full signals by comparing the Gray code. Use 4-bit Gray code as a read/write pointer for a FIFO with depth 8. The gray code is converted to a four-digit binary number, using the lower three digits of the binary number as the address to access RAM. When the read and write Pointers are equal, the FIFO is null.\nWhen the write pointer has one more cycle RAM than the read pointer, the highest and second-highest bits of the read and write pointer are opposite, the remaining bits are the same, and the FIFO is full.\n\nModule name:  \n    asyn_fifo  \n\nInput ports:\n\twclk: Write clock signal used for synchronous write operations.\n\trclk: Read clock signal used for synchronous read operations.\n\twrstn: Write reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\trrstn: Read reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\twinc: Write increment signal. Used to trigger write operations.\n\trinc: Read increment signal. Used to trigger read operations.\n\twdata: Write data input. The width [WIDTH-1:0] is configurable and represents the data to be written into the FIFO.\n\nOutput ports:\nwfull: Write full signal. Indicates if the FIFO is full and cannot accept further write operations.\nrempty: Read empty signal. Indicates if the FIFO is empty and cannot provide any data for read operations.\nrdata: Read data output. The width [WIDTH-1:0] is configurable and represents the data read from the FIFO.\n\nParameter:\n\tWIDTH = 8\n\tDEPTH = 16\n\nImplementation:\nThe module implements an asynchronous FIFO using a dual-port RAM module and additional logic for managing read and write pointers.\nDual-port RAM:\nThe module instantiates a dual-port RAM module named \"dual_port_RAM\" with configurable depth and width.\nThe RAM module has separate clock inputs for write (wclk) and read (rclk) operations.\nThe RAM module has separate address inputs for write (waddr) and read (raddr) operations.\nThe RAM module has a write enable input (wenc) and a write data input (wdata).\nThe RAM module has a read enable input (renc) and a read data output (rdata).\nThe RAM module stores data in a two-dimensional array, RAM_MEM, with a size of DEPTH by WIDTH.\nWrite and Read Pointers:\nThe module includes logic to manage write and read pointers for asynchronous operation.\nThe write and read pointers are represented by binary registers, waddr_bin and raddr_bin, respectively.\nThe write and read pointers are incremented based on the write and read increment signals (winc and rinc), respectively.\nThe write pointer is incremented on the positive edge of the write clock (posedge wclk) and reset to 0 on write reset (~wrstn).\nThe read pointer is incremented on the positive edge of the read clock (posedge rclk) and reset to 0 on read reset (~rrstn).\nGray Code Conversion:\nThe write and read pointers are converted to Gray code using XOR operations with right-shifted values.\nThe converted write and read pointers are stored in registers wptr and rptr, respectively.\nThe Gray code conversion reduces glitches and ensures proper synchronization of the write and read pointers.\nPointer Buffers:\nThe module includes buffer registers (wptr_buff and rptr_buff) to hold the previous values of the write and read pointers.\nThe buffer registers are updated on the positive edge of the respective clocks and reset to 0 on the respective resets (~wrstn and ~rrstn).\nThe buffer registers are used to synchronize the write and read pointers for determining the full and empty conditions.\nFull and Empty Signals:\nThe module compares the current write and read pointers (wptr and rptr_syn) to determine if the FIFO is full or empty.\nThe wfull output is set to 1 when the write pointer is equal to the bitwise negation of the most significant bit of the read pointer concatenated with the remaining bits of the read pointer.\nThe rempty output is set to 1 when the read pointer is equal to the write pointer.\nInput and Output Connections:\nThe module connects the input and output signals to the dual-port RAM module based on the control signals and pointer values.\nThe wen and ren signals control the write and read enable signals of the RAM module, respectively.\nThe wdata input is connected to the write data input (wdata) of the RAM module.\nThe rdata output is connected to the read data output (rdata) of the RAM module.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\n/***************************************RAM*****************************************/\nmodule dual_port_RAM #(parameter DEPTH = 16,  parameter WIDTH = 8)\n(\n\t input wclk\t,\n\t input wenc\t,\n\t input [$clog2(DEPTH)-1:0] waddr  ,\n\t input [WIDTH-1:0] wdata ,\n\t input rclk\t,\n\t input renc\t,\n\t input [$clog2(DEPTH)-1:0] raddr ,\n\t output reg [WIDTH-1:0] rdata \t\t\n);\n\nreg [WIDTH-1:0] RAM_MEM [0:DEPTH-1];\n\nalways @(posedge wclk) begin\n\tif(wenc)\n\t\tRAM_MEM[waddr] <= wdata;\nend \n\nalways @(posedge rclk) begin\n\tif(renc)\n\t\trdata <= RAM_MEM[raddr];\nend \n\nendmodule  \n\n\n/**************************************AFIFO*****************************************/\nmodule asyn_fifo#(\n\tparameter\tWIDTH = 8,\n\tparameter \tDEPTH = 16\n)(\n\tinput \t\t\t\t\twclk\t, \n\tinput \t\t\t\t\trclk\t,   \n\tinput \t\t\t\t\twrstn\t,\n\tinput\t\t\t\t\trrstn\t,\n\tinput \t\t\t\t\twinc\t,\n\tinput \t\t\t \t\trinc\t,\n\tinput \t\t[WIDTH-1:0]\twdata\t,\n\n\toutput wire\t\t\t\twfull\t,\n\toutput wire\t\t\t\trempty\t,\n\toutput wire [WIDTH-1:0]\trdata\n);\n\nparameter ADDR_WIDTH = $clog2(DEPTH);\n\n\nreg \t[ADDR_WIDTH:0]\twaddr_bin;\nreg \t[ADDR_WIDTH:0]\traddr_bin;\n\nalways @(posedge wclk or negedge wrstn) begin\n\tif(~wrstn) begin\n\t\twaddr_bin <= 'd0;\n\tend \n\telse if(!wfull && winc)begin\n\t\twaddr_bin <= waddr_bin + 1'd1;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin\n\tif(~rrstn) begin\n\t\traddr_bin <= 'd0;\n\tend \n\telse if(!rempty && rinc)begin\n\t\traddr_bin <= raddr_bin + 1'd1;\n\tend\nend\n\nwire \t[ADDR_WIDTH:0]\twaddr_gray;\nwire \t[ADDR_WIDTH:0]\traddr_gray;\nreg \t[ADDR_WIDTH:0]\twptr;\nreg \t[ADDR_WIDTH:0]\trptr;\nassign waddr_gray = waddr_bin ^ (waddr_bin>>1);\nassign raddr_gray = raddr_bin ^ (raddr_bin>>1);\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\twptr <= 'd0;\n\tend \n\telse begin\n\t\twptr <= waddr_gray;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\trptr <= 'd0;\n\tend \n\telse begin\n\t\trptr <= raddr_gray;\n\tend\nend\n\nreg\t\t[ADDR_WIDTH:0]\twptr_buff;\nreg\t\t[ADDR_WIDTH:0]\twptr_syn;\nreg\t\t[ADDR_WIDTH:0]\trptr_buff;\nreg\t\t[ADDR_WIDTH:0]\trptr_syn;\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\trptr_buff <= 'd0;\n\t\trptr_syn <= 'd0;\n\tend \n\telse begin\n\t\trptr_buff <= rptr;\n\t\trptr_syn <= rptr_buff;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\twptr_buff <= 'd0;\n\t\twptr_syn <= 'd0;\n\tend \n\telse begin\n\t\twptr_buff <= wptr;\n\t\twptr_syn <= wptr_buff;\n\tend\nend\n\nassign wfull = (wptr == {~rptr_syn[ADDR_WIDTH:ADDR_WIDTH-1],rptr_syn[ADDR_WIDTH-2:0]});\nassign rempty = (rptr == wptr_syn);\n\n/***********RAM*********/\nwire \twen\t;\nwire\tren\t;\nwire \twren;//high write\nwire [ADDR_WIDTH-1:0]\twaddr;\nwire [ADDR_WIDTH-1:0]\traddr;\nassign wen = winc & !wfull;\nassign ren = rinc & !rempty;\nassign waddr = waddr_bin[ADDR_WIDTH-1:0];\nassign raddr = raddr_bin[ADDR_WIDTH-1:0];\n\ndual_port_RAM #(.DEPTH(DEPTH),\n\t\t\t\t.WIDTH(WIDTH)\n)dual_port_RAM(\n\t.wclk (wclk),  \n\t.wenc (wen),  \n\t.waddr(waddr[ADDR_WIDTH-1:0]),  //The depth is logarithmic to 2 to get the bit width of the address\n\t.wdata(wdata),       \t//data_write\n\t.rclk (rclk), \n\t.renc (ren), \n\t.raddr(raddr[ADDR_WIDTH-1:0]),   \n\t.rdata(rdata)  \t\t\n);\n\nendmodule", "corrupted_code": "`timescale 1ns/1ns\n\n/***************************************RAM*****************************************/\nmodule dual_port_RAM #(parameter DEPTH = 16,  parameter WIDTH = 8)\n(\n\t input wclk\t,\n\t input wenc\t,\n\t input [$clog2(DEPTH)-1:0] waddr  ,\n\t input [WIDTH-1:0] wdata ,\n\t input rclk\t,\n\t input renc\t,\n\t input [$clog2(DEPTH)-1:0] raddr ,\n\t output reg [WIDTH-1:0] rdata \t\t\n);\n\nreg [WIDTH-1:0] RAM_MEM [0:DEPTH-1];\n\nalways @(posedge wclk) begin\n\tif(wenc)\n\t\tRAM_MEM[waddr] <= wdata;\nend \n\nalways @(posedge rclk) begin\n\tif(renc)\n\t\trdata <= RAM_MEM[raddr];\nend \n\nendmodule  \n\n\n/**************************************AFIFO*****************************************/\nmodule asyn_fifo#(\n\tparameter\tWIDTH = 8,\n\tparameter \tDEPTH = 16\n)(\n\tinput \t\t\t\t\twclk\t, \n\tinput \t\t\t\t\trclk\t,   \n\tinput \t\t\t\t\twrstn\t,\n\tinput\t\t\t\t\trrstn\t,\n\tinput \t\t\t\t\twinc\t,\n\tinput \t\t\t \t\trinc\t,\n\tinput \t\t[WIDTH-1:0]\twdata\t,\n\n\toutput wire\t\t\t\twfull\t,\n\toutput wire\t\t\t\trempty\t,\n\toutput wire [WIDTH-1:0]\trdata\n);\n\nparameter ADDR_WIDTH = $clog2(DEPTH);\n\n\nreg \t[ADDR_WIDTH:0]\twaddr_bin;\nreg \t[ADDR_WIDTH:0]\traddr_bin;\n\nalways @(posedge wclk or negedge wrstn) begin\n\tif(~wrstn) begin\n\t\twaddr_bin <= 'd0;\n\tend \n\telse if(!wfull && winc)begin\n\t\twaddr_bin <= waddr_bin + 1'd1;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin\n\tif(~rrstn) begin\n\t\traddr_bin <= 'd0;\n\tend \n\telse if(!rempty && rinc)begin\n\t\traddr_bin <= raddr_bin + 1'd1;\n\tend\nend\n\nwire \t[ADDR_WIDTH:0]\twaddr_gray;\nwire \t[ADDR_WIDTH:0]\traddr_gray;\nreg \t[ADDR_WIDTH:0]\twptr;\nreg \t[ADDR_WIDTH:0]\trptr;\nassign waddr_gray = waddr_bin ^ (waddr_bin>>1);\nassign raddr_gray = raddr_bin ^ (raddr_bin>>1);\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\twptr <= 'd0;\n\tend \n\telse begin\n\t\twptr <= waddr_gray;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\trptr <= 'd0;\n\tend \n\telse begin\n\t\trptr <= raddr_gray;\n\tend\nend\n\nreg\t\t[ADDR_WIDTH:0]\twptr_buff;\nreg\t\t[ADDR_WIDTH:0]\twptr_syn;\nreg\t\t[ADDR_WIDTH:0]\trptr_buff;\nreg\t\t[ADDR_WIDTH:0]\trptr_syn;\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\trptr_buff <= 'd0;\n\t\trptr_syn <= 'd0;\n\tend \n\telse begin\n\t\trptr_buff <= rptr;\n\t\trptr_syn <= rptr_buff;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\twptr_buff <= 'd0;\n\t\twptr_syn <= 'd0;\n\tend \n\telse begin\n\t\twptr_buff <= wptr;\n\t\twptr_syn <= wptr_buff;\n\tend\nend\n\nassign wfull = (wptr == {~rptr_syn[ADDR_WIDTH:ADDR_WIDTH-1],rptr_syn[ADDR_WIDTH-2:0]});\nassign rempty = (rptr == wptr_syn);\n\n/***********RAM*********/\nwire \twen\t;\nwire\tren\t;\nwire \twren;//high write\nwire [ADDR_WIDTH-1:0]\twaddr;\nwire [1 - ADDR_WIDTH:0]\traddr;\nassign wen = winc & !wfull;\nassign ren = rinc & !rempty;\nassign waddr = waddr_bin[ADDR_WIDTH-1:0];\nassign raddr = raddr_bin[ADDR_WIDTH-1:0];\n\ndual_port_RAM #(.DEPTH(DEPTH),\n\t\t\t\t.WIDTH(WIDTH)\n)dual_port_RAM(\n\t.wclk (wclk),  \n\t.wenc (wen),  \n\t.waddr(waddr[ADDR_WIDTH-1:0]),  //The depth is logarithmic to 2 to get the bit width of the address\n\t.wdata(wdata),       \t//data_write\n\t.rclk (rclk), \n\t.renc (ren), \n\t.raddr(raddr[ADDR_WIDTH-1:0]),   \n\t.rdata(rdata)  \t\t\n);\n\nendmodule", "corruption_explanation": "Swapped operands: 'ADDR_WIDTH - 1' -> '1 - ADDR_WIDTH'", "modification_type": "swap_operands", "modification_line": 128, "original_snippet": "ADDR_WIDTH-1", "modified_snippet": "1 - ADDR_WIDTH", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'ADDR_WIDTH - 1' -> '1 - ADDR_WIDTH'\n   \u2022 Line 128: Original: ADDR_WIDTH-1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 128.\n   \u2022 Restore the original code: ADDR_WIDTH-1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 47, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_operands"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.892064", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "Shifter", "design_name": "barrel_shifter", "module_name": "barrel_shifter", "description": "Please act as a professional verilog designer.\n\nModule name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code."}, "clean_code": "module barrel_shifter (in, ctrl, out);\n  input  [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n  wire [7:0] x,y;\n \n//4bit shift right\nmux2X1  ins_17 (.in0(in[7]),.in1(1'b0),.sel(ctrl[2]),.out(x[7]));\nmux2X1  ins_16 (.in0(in[6]),.in1(1'b0),.sel(ctrl[2]),.out(x[6]));\nmux2X1  ins_15 (.in0(in[5]),.in1(1'b0),.sel(ctrl[2]),.out(x[5]));\nmux2X1  ins_14 (.in0(in[4]),.in1(1'b0),.sel(ctrl[2]),.out(x[4]));\nmux2X1  ins_13 (.in0(in[3]),.in1(in[7]),.sel(ctrl[2]),.out(x[3]));\nmux2X1  ins_12 (.in0(in[2]),.in1(in[6]),.sel(ctrl[2]),.out(x[2]));\nmux2X1  ins_11 (.in0(in[1]),.in1(in[5]),.sel(ctrl[2]),.out(x[1]));\nmux2X1  ins_10 (.in0(in[0]),.in1(in[4]),.sel(ctrl[2]),.out(x[0]));\n \n//2 bit shift right\n \nmux2X1  ins_27 (.in0(x[7]),.in1(1'b0),.sel(ctrl[1]),.out(y[7]));\nmux2X1  ins_26 (.in0(x[6]),.in1(1'b0),.sel(ctrl[1]),.out(y[6]));\nmux2X1  ins_25 (.in0(x[5]),.in1(x[7]),.sel(ctrl[1]),.out(y[5]));\nmux2X1  ins_24 (.in0(x[4]),.in1(x[6]),.sel(ctrl[1]),.out(y[4]));\nmux2X1  ins_23 (.in0(x[3]),.in1(x[5]),.sel(ctrl[1]),.out(y[3]));\nmux2X1  ins_22 (.in0(x[2]),.in1(x[4]),.sel(ctrl[1]),.out(y[2]));\nmux2X1  ins_21 (.in0(x[1]),.in1(x[3]),.sel(ctrl[1]),.out(y[1]));\nmux2X1  ins_20 (.in0(x[0]),.in1(x[2]),.sel(ctrl[1]),.out(y[0]));\n \n//1 bit shift right\nmux2X1  ins_07 (.in0(y[7]),.in1(1'b0),.sel(ctrl[0]),.out(out[7]));\nmux2X1  ins_06 (.in0(y[6]),.in1(y[7]),.sel(ctrl[0]),.out(out[6]));\nmux2X1  ins_05 (.in0(y[5]),.in1(y[6]),.sel(ctrl[0]),.out(out[5]));\nmux2X1  ins_04 (.in0(y[4]),.in1(y[5]),.sel(ctrl[0]),.out(out[4]));\nmux2X1  ins_03 (.in0(y[3]),.in1(y[4]),.sel(ctrl[0]),.out(out[3]));\nmux2X1  ins_02 (.in0(y[2]),.in1(y[3]),.sel(ctrl[0]),.out(out[2]));\nmux2X1  ins_01 (.in0(y[1]),.in1(y[2]),.sel(ctrl[0]),.out(out[1]));\nmux2X1  ins_00 (.in0(y[0]),.in1(y[1]),.sel(ctrl[0]),.out(out[0]));\n\nendmodule\n\nmodule mux2X1( in0,in1,sel,out);\ninput in0,in1;\ninput sel;\noutput out;\nassign out=(sel)?in1:in0;\nendmodule", "corrupted_code": "module barrel_shifter (in, ctrl, out);\n  input  [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n  wire [7:0] x,y;\n \n//4bit shift right\nmux2X1  ins_17 (.in0(in[7]),.in1(1'b0),.sel(ctrl[2]),.out(x[7]));\nmux2X1  ins_16 (.in0(in[6]),.in1(1'b0),.sel(ctrl[2]),.out(x[6]));\nmux2X1  ins_15 (.in0(in[5]),.in1(1'b0),.sel(ctrl[2]),.out(x[5]));\nmux2X1  ins_14 (.in0(in[4]),.in1(1'b0),.sel(ctrl[2]),.out(x[4]));\nmux2X1  ins_13 (.in0(in[3]),.in1(in[7]),.sel(ctrl[2]),.out(x[3]));\nmux2X1  ins_12 (.in0(in[2]),.in1(in[6]),.sel(ctrl[2]),.out(x[2]));\nmux2X1  ins_11 (.in0(in[1]),.in1(in[5]),.sel(ctrl[2]),.out(x[1]));\nmux2X1  ins_10 (.in0(in[0]),.in1(in[4]),.sel(ctrl[2]),.out(x[0]));\n \n//2 bit shift right\n \nmux2X1  ins_27 (.in0(x[7]),.in1(1'b0),.sel(ctrl[1]),.out(y[7]));\nmux2X1  ins_26 (.in0(x[6]),.in1(1'b0),.sel(ctrl[1]),.out(y[6]));\nmux2X1  ins_25 (.in0(x[5]),.in1(x[7]),.sel(ctrl[1]),.out(y[5]));\nmux2X1  ins_24 (.in0(x[4]),.in1(x[6]),.sel(ctrl[1]),.out(y[4]));\nmux2X1  ins_23 (.in0(x[3]),.in1(x[5]),.sel(ctrl[1]),.out(y[3]));\nmux2X1  ins_22 (.in0(x[2]),.in1(x[4]),.sel(ctrl[1]),.out(y[2]));\nmux2X1  ins_21 (.in0(x[1]),.in1(x[3]),.sel(ctrl[1]),.out(y[1]));\nmux2X1  ins_20 (.in0(x[0]),.in1(x[2]),.sel(ctrl[1]),.out(y[0]));\n \n//1 bit shift right\nmux2X1  ins_07 (.in0(y[7]),.in1(1'b0),.sel(ctrl[0]),.out(out[7]));\nmux2X1  ins_06 (.in0(y[6]),.in1(y[7]),.sel(ctrl[0]),.out(out[6]));\nmux2X1  ins_05 (.in0(y[5]),.in1(y[6]),.sel(ctrl[0]),.out(out[5]));\nmux2X1  ins_04 (.in0(y[4]),.in1(y[5]),.sel(ctrl[0]),.out(out[4]));\nmux2X1  ins_03 (.in0(y[3]),.in1(y[4]),.sel(ctrl[0]),.out(out[3]));\nmux2X1  ins_02 (.in0(y[2]),.in1(y[3]),.sel(ctrl[0]),.out(out[2]));\nmux2X1  ins_01 (.in0(y[1]),.in1(y[2]),.sel(ctrl[0]),.out(out[1]));\nmux2X1  ins_00 (.in0(y[0]),.in1(y[1]),.sel(ctrl[0]),.out(out[0]));\n\nendmodule\n\nmodule mux2X1( in0,in1,sel,out);\ninput in0,in1;\ninput sel;\noutput out;\nassign out <= (sel)?in1:in0;\nendmodule", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 44, "original_snippet": "ut=(sel)?in1:in0;", "modified_snippet": "ut <= (sel)?in1:in0;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 0, "applicable_modifications": ["change_constant", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.958548", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "Shifter", "design_name": "barrel_shifter", "module_name": "barrel_shifter", "description": "Please act as a professional verilog designer.\n\nModule name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code."}, "clean_code": "module barrel_shifter (in, ctrl, out);\n  input  [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n  wire [7:0] x,y;\n \n//4bit shift right\nmux2X1  ins_17 (.in0(in[7]),.in1(1'b0),.sel(ctrl[2]),.out(x[7]));\nmux2X1  ins_16 (.in0(in[6]),.in1(1'b0),.sel(ctrl[2]),.out(x[6]));\nmux2X1  ins_15 (.in0(in[5]),.in1(1'b0),.sel(ctrl[2]),.out(x[5]));\nmux2X1  ins_14 (.in0(in[4]),.in1(1'b0),.sel(ctrl[2]),.out(x[4]));\nmux2X1  ins_13 (.in0(in[3]),.in1(in[7]),.sel(ctrl[2]),.out(x[3]));\nmux2X1  ins_12 (.in0(in[2]),.in1(in[6]),.sel(ctrl[2]),.out(x[2]));\nmux2X1  ins_11 (.in0(in[1]),.in1(in[5]),.sel(ctrl[2]),.out(x[1]));\nmux2X1  ins_10 (.in0(in[0]),.in1(in[4]),.sel(ctrl[2]),.out(x[0]));\n \n//2 bit shift right\n \nmux2X1  ins_27 (.in0(x[7]),.in1(1'b0),.sel(ctrl[1]),.out(y[7]));\nmux2X1  ins_26 (.in0(x[6]),.in1(1'b0),.sel(ctrl[1]),.out(y[6]));\nmux2X1  ins_25 (.in0(x[5]),.in1(x[7]),.sel(ctrl[1]),.out(y[5]));\nmux2X1  ins_24 (.in0(x[4]),.in1(x[6]),.sel(ctrl[1]),.out(y[4]));\nmux2X1  ins_23 (.in0(x[3]),.in1(x[5]),.sel(ctrl[1]),.out(y[3]));\nmux2X1  ins_22 (.in0(x[2]),.in1(x[4]),.sel(ctrl[1]),.out(y[2]));\nmux2X1  ins_21 (.in0(x[1]),.in1(x[3]),.sel(ctrl[1]),.out(y[1]));\nmux2X1  ins_20 (.in0(x[0]),.in1(x[2]),.sel(ctrl[1]),.out(y[0]));\n \n//1 bit shift right\nmux2X1  ins_07 (.in0(y[7]),.in1(1'b0),.sel(ctrl[0]),.out(out[7]));\nmux2X1  ins_06 (.in0(y[6]),.in1(y[7]),.sel(ctrl[0]),.out(out[6]));\nmux2X1  ins_05 (.in0(y[5]),.in1(y[6]),.sel(ctrl[0]),.out(out[5]));\nmux2X1  ins_04 (.in0(y[4]),.in1(y[5]),.sel(ctrl[0]),.out(out[4]));\nmux2X1  ins_03 (.in0(y[3]),.in1(y[4]),.sel(ctrl[0]),.out(out[3]));\nmux2X1  ins_02 (.in0(y[2]),.in1(y[3]),.sel(ctrl[0]),.out(out[2]));\nmux2X1  ins_01 (.in0(y[1]),.in1(y[2]),.sel(ctrl[0]),.out(out[1]));\nmux2X1  ins_00 (.in0(y[0]),.in1(y[1]),.sel(ctrl[0]),.out(out[0]));\n\nendmodule\n\nmodule mux2X1( in0,in1,sel,out);\ninput in0,in1;\ninput sel;\noutput out;\nassign out=(sel)?in1:in0;\nendmodule", "corrupted_code": "module barrel_shifter (in, ctrl, out);\n  input  [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n  wire [7:0] x,y;\n \n//4bit shift right\nmux2X1  ins_17 (.in0(in[7]),.in1(1'b0),.sel(ctrl[2]),.out(x[7]));\nmux2X1  ins_16 (.in0(in[6]),.in1(1'b0),.sel(ctrl[2]),.out(x[6]));\nmux2X1  ins_15 (.in0(in[5]),.in1(1'b0),.sel(ctrl[2]),.out(x[5]));\nmux2X1  ins_14 (.in0(in[4]),.in1(1'b0),.sel(ctrl[2]),.out(x[4]));\nmux2X1  ins_13 (.in0(in[3]),.in1(in[7]),.sel(ctrl[2]),.out(x[3]));\nmux2X1  ins_12 (.in0(in[2]),.in1(in[6]),.sel(ctrl[2]),.out(x[2]));\nmux2X1  ins_11 (.in0(in[1]),.in1(in[5]),.sel(ctrl[2]),.out(x[1]));\nmux2X1  ins_10 (.in0(in[0]),.in1(in[4]),.sel(ctrl[2]),.out(x[0]));\n \n//2 bit shift right\n \nmux2X1  ins_27 (.in0(x[7]),.in1(1'b0),.sel(ctrl[1]),.out(y[7]));\nmux2X1  ins_26 (.in0(x[6]),.in1(1'b0),.sel(ctrl[1]),.out(y[6]));\nmux2X1  ins_25 (.in0(x[5]),.in1(x[7]),.sel(ctrl[1]),.out(y[5]));\nmux2X1  ins_24 (.in0(x[4]),.in1(x[6]),.sel(ctrl[1]),.out(y[4]));\nmux2X1  ins_23 (.in0(x[3]),.in1(x[5]),.sel(ctrl[1]),.out(y[3]));\nmux2X1  ins_22 (.in0(x[2]),.in1(x[4]),.sel(ctrl[1]),.out(y[2]));\nmux2X1  ins_21 (.in0(x[1]),.in1(x[3]),.sel(ctrl[1]),.out(y[1]));\nmux2X1  ins_20 (.in0(x[0]),.in1(x[2]),.sel(ctrl[1]),.out(y[0]));\n \n//1 bit shift right\nmux2X1  ins_07 (.in0(y[7]),.in1(1'b0),.sel(ctrl[0]),.out(out[7]));\nmux2X1  ins_06 (.in0(y[6]),.in1(y[7]),.sel(ctrl[0]),.out(out[6]));\nmux2X1  ins_05 (.in0(y[5]),.in1(y[6]),.sel(ctrl[0]),.out(out[5]));\nmux2X1  ins_04 (.in0(y[4]),.in1(y[5]),.sel(ctrl[0]),.out(out[4]));\nmux2X1  ins_03 (.in0(y[3]),.in1(y[4]),.sel(ctrl[0]),.out(out[3]));\nmux2X1  ins_02 (.in0(y[2]),.in1(y[3]),.sel(ctrl[0]),.out(out[2]));\nmux2X1  ins_01 (.in0(y[1]),.in1(y[2]),.sel(ctrl[0]),.out(out[1]));\nmux2X1  ins_00 (.in0(y[0]),.in1(y[1]),.sel(ctrl[0]),.out(out[0]));\n\nendmodule\n\nmodule mux2X1( in0,in1,sel,out);\ninput in0,in1;\ninput sel;\noutput out;\n\nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 44, "original_snippet": "assign out=(sel)?in1:in0;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 44: Original: assign out=(sel)?in1:in0;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 44.\n   \u2022 Restore the original code: assign out=(sel)?in1:in0;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 0, "applicable_modifications": ["change_constant", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["remove_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.961873", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "Shifter", "design_name": "barrel_shifter", "module_name": "barrel_shifter", "description": "Please act as a professional verilog designer.\n\nModule name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code."}, "clean_code": "module barrel_shifter (in, ctrl, out);\n  input  [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n  wire [7:0] x,y;\n \n//4bit shift right\nmux2X1  ins_17 (.in0(in[7]),.in1(1'b0),.sel(ctrl[2]),.out(x[7]));\nmux2X1  ins_16 (.in0(in[6]),.in1(1'b0),.sel(ctrl[2]),.out(x[6]));\nmux2X1  ins_15 (.in0(in[5]),.in1(1'b0),.sel(ctrl[2]),.out(x[5]));\nmux2X1  ins_14 (.in0(in[4]),.in1(1'b0),.sel(ctrl[2]),.out(x[4]));\nmux2X1  ins_13 (.in0(in[3]),.in1(in[7]),.sel(ctrl[2]),.out(x[3]));\nmux2X1  ins_12 (.in0(in[2]),.in1(in[6]),.sel(ctrl[2]),.out(x[2]));\nmux2X1  ins_11 (.in0(in[1]),.in1(in[5]),.sel(ctrl[2]),.out(x[1]));\nmux2X1  ins_10 (.in0(in[0]),.in1(in[4]),.sel(ctrl[2]),.out(x[0]));\n \n//2 bit shift right\n \nmux2X1  ins_27 (.in0(x[7]),.in1(1'b0),.sel(ctrl[1]),.out(y[7]));\nmux2X1  ins_26 (.in0(x[6]),.in1(1'b0),.sel(ctrl[1]),.out(y[6]));\nmux2X1  ins_25 (.in0(x[5]),.in1(x[7]),.sel(ctrl[1]),.out(y[5]));\nmux2X1  ins_24 (.in0(x[4]),.in1(x[6]),.sel(ctrl[1]),.out(y[4]));\nmux2X1  ins_23 (.in0(x[3]),.in1(x[5]),.sel(ctrl[1]),.out(y[3]));\nmux2X1  ins_22 (.in0(x[2]),.in1(x[4]),.sel(ctrl[1]),.out(y[2]));\nmux2X1  ins_21 (.in0(x[1]),.in1(x[3]),.sel(ctrl[1]),.out(y[1]));\nmux2X1  ins_20 (.in0(x[0]),.in1(x[2]),.sel(ctrl[1]),.out(y[0]));\n \n//1 bit shift right\nmux2X1  ins_07 (.in0(y[7]),.in1(1'b0),.sel(ctrl[0]),.out(out[7]));\nmux2X1  ins_06 (.in0(y[6]),.in1(y[7]),.sel(ctrl[0]),.out(out[6]));\nmux2X1  ins_05 (.in0(y[5]),.in1(y[6]),.sel(ctrl[0]),.out(out[5]));\nmux2X1  ins_04 (.in0(y[4]),.in1(y[5]),.sel(ctrl[0]),.out(out[4]));\nmux2X1  ins_03 (.in0(y[3]),.in1(y[4]),.sel(ctrl[0]),.out(out[3]));\nmux2X1  ins_02 (.in0(y[2]),.in1(y[3]),.sel(ctrl[0]),.out(out[2]));\nmux2X1  ins_01 (.in0(y[1]),.in1(y[2]),.sel(ctrl[0]),.out(out[1]));\nmux2X1  ins_00 (.in0(y[0]),.in1(y[1]),.sel(ctrl[0]),.out(out[0]));\n\nendmodule\n\nmodule mux2X1( in0,in1,sel,out);\ninput in0,in1;\ninput sel;\noutput out;\nassign out=(sel)?in1:in0;\nendmodule", "corrupted_code": "module barrel_shifter (in, ctrl, out);\n  input  [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n  wire [7:0] x,y;\n \n//4bit shift right\nmux2X1  ins_17 (.in0(in[7]),.in1(1'b0),.sel(ctrl[2]),.out(x[7]));\nmux2X1  ins_16 (.in0(in[6]),.in1(1'b0),.sel(ctrl[2]),.out(x[6]));\nmux2X1  ins_15 (.in0(in[5]),.in1(1'b0),.sel(ctrl[2]),.out(x[5]));\nmux2X1  ins_14 (.in0(in[4]),.in1(1'b0),.sel(ctrl[2]),.out(x[4]));\nmux2X1  ins_13 (.in0(in[3]),.in1(in[7]),.sel(ctrl[2]),.out(x[3]));\nmux2X1  ins_12 (.in0(in[2]),.in1(in[6]),.sel(ctrl[2]),.out(x[2]));\nmux2X1  ins_11 (.in0(in[1]),.in1(in[5]),.sel(ctrl[2]),.out(x[1]));\nmux2X1  ins_10 (.in0(in[0]),.in1(in[4]),.sel(ctrl[2]),.out(x[0]));\n \n//2 bit shift right\n \nmux2X1  ins_27 (.in0(x[7]),.in1(1'b0),.sel(ctrl[1]),.out(y[7]));\nmux2X1  ins_26 (.in0(x[6]),.in1(1'b0),.sel(ctrl[1]),.out(y[6]));\nmux2X1  ins_25 (.in0(x[5]),.in1(x[7]),.sel(ctrl[1]),.out(y[5]));\nmux2X1  ins_24 (.in0(x[4]),.in1(x[6]),.sel(ctrl[1]),.out(y[4]));\nmux2X1  ins_23 (.in0(x[3]),.in1(x[5]),.sel(ctrl[1]),.out(y[3]));\nmux2X1  ins_22 (.in0(x[2]),.in1(x[4]),.sel(ctrl[1]),.out(y[2]));\nmux2X1  ins_21 (.in0(x[1]),.in1(x[3]),.sel(ctrl[1]),.out(y[1]));\nmux2X1  ins_20 (.in0(x[0]),.in1(x[2]),.sel(ctrl[1]),.out(y[0]));\n \n//1 bit shift right\nmux2X1  ins_07 (.in0(y[7]),.in1(1'b0),.sel(ctrl[0]),.out(out[7]));\nmux2X1  ins_06 (.in0(y[6]),.in1(y[7]),.sel(ctrl[0]),.out(out[6]));\nmux2X1  ins_05 (.in0(y[5]),.in1(y[6]),.sel(ctrl[0]),.out(out[5]));\nmux2X1  ins_04 (.in0(y[4]),.in1(y[5]),.sel(ctrl[0]),.out(out[4]));\nmux2X1  ins_03 (.in0(y[3]),.in1(y[4]),.sel(ctrl[0]),.out(out[3]));\nmux2X1  ins_02 (.in0(y[2]),.in1(y[3]),.sel(ctrl[0]),.out(out[2]));\nmux2X1  ins_01 (.in0(y[1]),.in1(y[2]),.sel(ctrl[0]),.out(out[1]));\nmux2X1  ins_00 (.in0(y[0]),.in1(y[1]),.sel(ctrl[0]),.out(out[0]));\n\nendmodule\n\nmodule mux2X1( in0,in1,sel,out);\ninput in0,in1;\ninput sel;\noutput out;\nassign out <= (sel)?in1:in0;\nendmodule", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 44, "original_snippet": "ut=(sel)?in1:in0;", "modified_snippet": "ut <= (sel)?in1:in0;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 0, "applicable_modifications": ["change_constant", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.965532", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "Shifter", "design_name": "barrel_shifter", "module_name": "barrel_shifter", "description": "Please act as a professional verilog designer.\n\nModule name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code."}, "clean_code": "module barrel_shifter (in, ctrl, out);\n  input  [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n  wire [7:0] x,y;\n \n//4bit shift right\nmux2X1  ins_17 (.in0(in[7]),.in1(1'b0),.sel(ctrl[2]),.out(x[7]));\nmux2X1  ins_16 (.in0(in[6]),.in1(1'b0),.sel(ctrl[2]),.out(x[6]));\nmux2X1  ins_15 (.in0(in[5]),.in1(1'b0),.sel(ctrl[2]),.out(x[5]));\nmux2X1  ins_14 (.in0(in[4]),.in1(1'b0),.sel(ctrl[2]),.out(x[4]));\nmux2X1  ins_13 (.in0(in[3]),.in1(in[7]),.sel(ctrl[2]),.out(x[3]));\nmux2X1  ins_12 (.in0(in[2]),.in1(in[6]),.sel(ctrl[2]),.out(x[2]));\nmux2X1  ins_11 (.in0(in[1]),.in1(in[5]),.sel(ctrl[2]),.out(x[1]));\nmux2X1  ins_10 (.in0(in[0]),.in1(in[4]),.sel(ctrl[2]),.out(x[0]));\n \n//2 bit shift right\n \nmux2X1  ins_27 (.in0(x[7]),.in1(1'b0),.sel(ctrl[1]),.out(y[7]));\nmux2X1  ins_26 (.in0(x[6]),.in1(1'b0),.sel(ctrl[1]),.out(y[6]));\nmux2X1  ins_25 (.in0(x[5]),.in1(x[7]),.sel(ctrl[1]),.out(y[5]));\nmux2X1  ins_24 (.in0(x[4]),.in1(x[6]),.sel(ctrl[1]),.out(y[4]));\nmux2X1  ins_23 (.in0(x[3]),.in1(x[5]),.sel(ctrl[1]),.out(y[3]));\nmux2X1  ins_22 (.in0(x[2]),.in1(x[4]),.sel(ctrl[1]),.out(y[2]));\nmux2X1  ins_21 (.in0(x[1]),.in1(x[3]),.sel(ctrl[1]),.out(y[1]));\nmux2X1  ins_20 (.in0(x[0]),.in1(x[2]),.sel(ctrl[1]),.out(y[0]));\n \n//1 bit shift right\nmux2X1  ins_07 (.in0(y[7]),.in1(1'b0),.sel(ctrl[0]),.out(out[7]));\nmux2X1  ins_06 (.in0(y[6]),.in1(y[7]),.sel(ctrl[0]),.out(out[6]));\nmux2X1  ins_05 (.in0(y[5]),.in1(y[6]),.sel(ctrl[0]),.out(out[5]));\nmux2X1  ins_04 (.in0(y[4]),.in1(y[5]),.sel(ctrl[0]),.out(out[4]));\nmux2X1  ins_03 (.in0(y[3]),.in1(y[4]),.sel(ctrl[0]),.out(out[3]));\nmux2X1  ins_02 (.in0(y[2]),.in1(y[3]),.sel(ctrl[0]),.out(out[2]));\nmux2X1  ins_01 (.in0(y[1]),.in1(y[2]),.sel(ctrl[0]),.out(out[1]));\nmux2X1  ins_00 (.in0(y[0]),.in1(y[1]),.sel(ctrl[0]),.out(out[0]));\n\nendmodule\n\nmodule mux2X1( in0,in1,sel,out);\ninput in0,in1;\ninput sel;\noutput out;\nassign out=(sel)?in1:in0;\nendmodule", "corrupted_code": "module barrel_shifter (in, ctrl, out);\n  input  [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n  wire [7:0] x,y;\n \n//4bit shift right\nmux2X1  ins_17 (.in0(in[7]),.in1(1'b0),.sel(ctrl[2]),.out(x[7]));\nmux2X1  ins_16 (.in0(in[6]),.in1(1'b0),.sel(ctrl[2]),.out(x[6]));\nmux2X1  ins_15 (.in0(in[5]),.in1(1'b0),.sel(ctrl[2]),.out(x[5]));\nmux2X1  ins_14 (.in0(in[4]),.in1(1'b0),.sel(ctrl[2]),.out(x[4]));\nmux2X1 ins_13(.in0(in[3]),.in1(ctrl[2]),.sel(in[7]),.out(x[3]));\nmux2X1  ins_12 (.in0(in[2]),.in1(in[6]),.sel(ctrl[2]),.out(x[2]));\nmux2X1  ins_11 (.in0(in[1]),.in1(in[5]),.sel(ctrl[2]),.out(x[1]));\nmux2X1  ins_10 (.in0(in[0]),.in1(in[4]),.sel(ctrl[2]),.out(x[0]));\n \n//2 bit shift right\n \nmux2X1  ins_27 (.in0(x[7]),.in1(1'b0),.sel(ctrl[1]),.out(y[7]));\nmux2X1  ins_26 (.in0(x[6]),.in1(1'b0),.sel(ctrl[1]),.out(y[6]));\nmux2X1  ins_25 (.in0(x[5]),.in1(x[7]),.sel(ctrl[1]),.out(y[5]));\nmux2X1  ins_24 (.in0(x[4]),.in1(x[6]),.sel(ctrl[1]),.out(y[4]));\nmux2X1  ins_23 (.in0(x[3]),.in1(x[5]),.sel(ctrl[1]),.out(y[3]));\nmux2X1  ins_22 (.in0(x[2]),.in1(x[4]),.sel(ctrl[1]),.out(y[2]));\nmux2X1  ins_21 (.in0(x[1]),.in1(x[3]),.sel(ctrl[1]),.out(y[1]));\nmux2X1  ins_20 (.in0(x[0]),.in1(x[2]),.sel(ctrl[1]),.out(y[0]));\n \n//1 bit shift right\nmux2X1  ins_07 (.in0(y[7]),.in1(1'b0),.sel(ctrl[0]),.out(out[7]));\nmux2X1  ins_06 (.in0(y[6]),.in1(y[7]),.sel(ctrl[0]),.out(out[6]));\nmux2X1  ins_05 (.in0(y[5]),.in1(y[6]),.sel(ctrl[0]),.out(out[5]));\nmux2X1  ins_04 (.in0(y[4]),.in1(y[5]),.sel(ctrl[0]),.out(out[4]));\nmux2X1  ins_03 (.in0(y[3]),.in1(y[4]),.sel(ctrl[0]),.out(out[3]));\nmux2X1  ins_02 (.in0(y[2]),.in1(y[3]),.sel(ctrl[0]),.out(out[2]));\nmux2X1  ins_01 (.in0(y[1]),.in1(y[2]),.sel(ctrl[0]),.out(out[1]));\nmux2X1  ins_00 (.in0(y[0]),.in1(y[1]),.sel(ctrl[0]),.out(out[0]));\n\nendmodule\n\nmodule mux2X1( in0,in1,sel,out);\ninput in0,in1;\ninput sel;\noutput out;\nassign out=(sel)?in1:in0;\nendmodule", "corruption_explanation": "Swapped signals: .in1(in[7]) <-> .sel(ctrl[2])", "modification_type": "swap_port_signals", "modification_line": 12, "original_snippet": "mux2X1  ins_13 (.in0(in[3]),.in1(in[7]),.sel(ctrl[2]),.out(x[3]));", "modified_snippet": "mux2X1 ins_13(.in0(in[3]),.in1(ctrl[2]),.sel(in[7]),.out(x[3]));", "issue_description": "The buggy code has swapped signal connections in a module instantiation. Signals are connected to the wrong ports, causing data to flow incorrectly between modules. This is a classic integration bug that causes functional failures in hierarchical designs.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_port_signals modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped signals: .in1(in[7]) <-> .sel(ctrl[2])\n   \u2022 Line 12: Original: mux2X1  ins_13 (.in0(in[3]),.in1(in[7]),.sel(ctrl[2]),.out(x[3]));\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 12.\n   \u2022 Restore the original code: mux2X1  ins_13 (.in0(in[3]),.in1(in[7]),.sel(ctrl[2]),.out(x[3]));\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap port signals.", "complexity": 0, "applicable_modifications": ["change_constant", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["swap_port_signals"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.968908", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "Shifter", "design_name": "barrel_shifter", "module_name": "barrel_shifter", "description": "Please act as a professional verilog designer.\n\nModule name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code."}, "clean_code": "module barrel_shifter (in, ctrl, out);\n  input  [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n  wire [7:0] x,y;\n \n//4bit shift right\nmux2X1  ins_17 (.in0(in[7]),.in1(1'b0),.sel(ctrl[2]),.out(x[7]));\nmux2X1  ins_16 (.in0(in[6]),.in1(1'b0),.sel(ctrl[2]),.out(x[6]));\nmux2X1  ins_15 (.in0(in[5]),.in1(1'b0),.sel(ctrl[2]),.out(x[5]));\nmux2X1  ins_14 (.in0(in[4]),.in1(1'b0),.sel(ctrl[2]),.out(x[4]));\nmux2X1  ins_13 (.in0(in[3]),.in1(in[7]),.sel(ctrl[2]),.out(x[3]));\nmux2X1  ins_12 (.in0(in[2]),.in1(in[6]),.sel(ctrl[2]),.out(x[2]));\nmux2X1  ins_11 (.in0(in[1]),.in1(in[5]),.sel(ctrl[2]),.out(x[1]));\nmux2X1  ins_10 (.in0(in[0]),.in1(in[4]),.sel(ctrl[2]),.out(x[0]));\n \n//2 bit shift right\n \nmux2X1  ins_27 (.in0(x[7]),.in1(1'b0),.sel(ctrl[1]),.out(y[7]));\nmux2X1  ins_26 (.in0(x[6]),.in1(1'b0),.sel(ctrl[1]),.out(y[6]));\nmux2X1  ins_25 (.in0(x[5]),.in1(x[7]),.sel(ctrl[1]),.out(y[5]));\nmux2X1  ins_24 (.in0(x[4]),.in1(x[6]),.sel(ctrl[1]),.out(y[4]));\nmux2X1  ins_23 (.in0(x[3]),.in1(x[5]),.sel(ctrl[1]),.out(y[3]));\nmux2X1  ins_22 (.in0(x[2]),.in1(x[4]),.sel(ctrl[1]),.out(y[2]));\nmux2X1  ins_21 (.in0(x[1]),.in1(x[3]),.sel(ctrl[1]),.out(y[1]));\nmux2X1  ins_20 (.in0(x[0]),.in1(x[2]),.sel(ctrl[1]),.out(y[0]));\n \n//1 bit shift right\nmux2X1  ins_07 (.in0(y[7]),.in1(1'b0),.sel(ctrl[0]),.out(out[7]));\nmux2X1  ins_06 (.in0(y[6]),.in1(y[7]),.sel(ctrl[0]),.out(out[6]));\nmux2X1  ins_05 (.in0(y[5]),.in1(y[6]),.sel(ctrl[0]),.out(out[5]));\nmux2X1  ins_04 (.in0(y[4]),.in1(y[5]),.sel(ctrl[0]),.out(out[4]));\nmux2X1  ins_03 (.in0(y[3]),.in1(y[4]),.sel(ctrl[0]),.out(out[3]));\nmux2X1  ins_02 (.in0(y[2]),.in1(y[3]),.sel(ctrl[0]),.out(out[2]));\nmux2X1  ins_01 (.in0(y[1]),.in1(y[2]),.sel(ctrl[0]),.out(out[1]));\nmux2X1  ins_00 (.in0(y[0]),.in1(y[1]),.sel(ctrl[0]),.out(out[0]));\n\nendmodule\n\nmodule mux2X1( in0,in1,sel,out);\ninput in0,in1;\ninput sel;\noutput out;\nassign out=(sel)?in1:in0;\nendmodule", "corrupted_code": "module barrel_shifter (in, ctrl, out);\n  input  [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n  wire [7:0] x,y;\n \n//4bit shift right\nmux2X1  ins_17 (.in0(in[7]),.in1(1'b0),.sel(ctrl[2]),.out(x[7]));\nmux2X1  ins_16 (.in0(in[6]),.in1(1'b0),.sel(ctrl[2]),.out(x[6]));\nmux2X1  ins_15 (.in0(in[5]),.in1(1'b0),.sel(ctrl[2]),.out(x[5]));\nmux2X1  ins_14 (.in0(in[4]),.in1(1'b0),.sel(ctrl[2]),.out(x[4]));\nmux2X1  ins_13 (.in0(in[3]),.in1(in[7]),.sel(ctrl[2]),.out(x[3]));\nmux2X1  ins_12 (.in0(in[2]),.in1(in[6]),.sel(ctrl[2]),.out(x[2]));\nmux2X1  ins_11 (.in0(in[1]),.in1(in[5]),.sel(ctrl[2]),.out(x[1]));\nmux2X1  ins_10 (.in0(in[0]),.in1(in[4]),.sel(ctrl[2]),.out(x[0]));\n \n//2 bit shift right\n \nmux2X1 ins_27(.in0(x[7]),.in1(1'b0),.sel(y[7]),.out(ctrl[1]));\nmux2X1  ins_26 (.in0(x[6]),.in1(1'b0),.sel(ctrl[1]),.out(y[6]));\nmux2X1  ins_25 (.in0(x[5]),.in1(x[7]),.sel(ctrl[1]),.out(y[5]));\nmux2X1  ins_24 (.in0(x[4]),.in1(x[6]),.sel(ctrl[1]),.out(y[4]));\nmux2X1  ins_23 (.in0(x[3]),.in1(x[5]),.sel(ctrl[1]),.out(y[3]));\nmux2X1  ins_22 (.in0(x[2]),.in1(x[4]),.sel(ctrl[1]),.out(y[2]));\nmux2X1  ins_21 (.in0(x[1]),.in1(x[3]),.sel(ctrl[1]),.out(y[1]));\nmux2X1  ins_20 (.in0(x[0]),.in1(x[2]),.sel(ctrl[1]),.out(y[0]));\n \n//1 bit shift right\nmux2X1  ins_07 (.in0(y[7]),.in1(1'b0),.sel(ctrl[0]),.out(out[7]));\nmux2X1  ins_06 (.in0(y[6]),.in1(y[7]),.sel(ctrl[0]),.out(out[6]));\nmux2X1  ins_05 (.in0(y[5]),.in1(y[6]),.sel(ctrl[0]),.out(out[5]));\nmux2X1  ins_04 (.in0(y[4]),.in1(y[5]),.sel(ctrl[0]),.out(out[4]));\nmux2X1  ins_03 (.in0(y[3]),.in1(y[4]),.sel(ctrl[0]),.out(out[3]));\nmux2X1  ins_02 (.in0(y[2]),.in1(y[3]),.sel(ctrl[0]),.out(out[2]));\nmux2X1  ins_01 (.in0(y[1]),.in1(y[2]),.sel(ctrl[0]),.out(out[1]));\nmux2X1  ins_00 (.in0(y[0]),.in1(y[1]),.sel(ctrl[0]),.out(out[0]));\n\nendmodule\n\nmodule mux2X1( in0,in1,sel,out);\ninput in0,in1;\ninput sel;\noutput out;\nassign out=(sel)?in1:in0;\nendmodule", "corruption_explanation": "Swapped signals: .out(y[7]) <-> .sel(ctrl[1])", "modification_type": "swap_port_signals", "modification_line": 19, "original_snippet": "mux2X1  ins_27 (.in0(x[7]),.in1(1'b0),.sel(ctrl[1]),.out(y[7]));", "modified_snippet": "mux2X1 ins_27(.in0(x[7]),.in1(1'b0),.sel(y[7]),.out(ctrl[1]));", "issue_description": "The buggy code has swapped signal connections in a module instantiation. Signals are connected to the wrong ports, causing data to flow incorrectly between modules. This is a classic integration bug that causes functional failures in hierarchical designs.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_port_signals modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped signals: .out(y[7]) <-> .sel(ctrl[1])\n   \u2022 Line 19: Original: mux2X1  ins_27 (.in0(x[7]),.in1(1'b0),.sel(ctrl[1]),.out(y[7]));\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 19.\n   \u2022 Restore the original code: mux2X1  ins_27 (.in0(x[7]),.in1(1'b0),.sel(ctrl[1]),.out(y[7]));\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap port signals.", "complexity": 0, "applicable_modifications": ["change_constant", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["swap_port_signals"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.974889", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "Shifter", "design_name": "barrel_shifter", "module_name": "barrel_shifter", "description": "Please act as a professional verilog designer.\n\nModule name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code."}, "clean_code": "module barrel_shifter (in, ctrl, out);\n  input  [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n  wire [7:0] x,y;\n \n//4bit shift right\nmux2X1  ins_17 (.in0(in[7]),.in1(1'b0),.sel(ctrl[2]),.out(x[7]));\nmux2X1  ins_16 (.in0(in[6]),.in1(1'b0),.sel(ctrl[2]),.out(x[6]));\nmux2X1  ins_15 (.in0(in[5]),.in1(1'b0),.sel(ctrl[2]),.out(x[5]));\nmux2X1  ins_14 (.in0(in[4]),.in1(1'b0),.sel(ctrl[2]),.out(x[4]));\nmux2X1  ins_13 (.in0(in[3]),.in1(in[7]),.sel(ctrl[2]),.out(x[3]));\nmux2X1  ins_12 (.in0(in[2]),.in1(in[6]),.sel(ctrl[2]),.out(x[2]));\nmux2X1  ins_11 (.in0(in[1]),.in1(in[5]),.sel(ctrl[2]),.out(x[1]));\nmux2X1  ins_10 (.in0(in[0]),.in1(in[4]),.sel(ctrl[2]),.out(x[0]));\n \n//2 bit shift right\n \nmux2X1  ins_27 (.in0(x[7]),.in1(1'b0),.sel(ctrl[1]),.out(y[7]));\nmux2X1  ins_26 (.in0(x[6]),.in1(1'b0),.sel(ctrl[1]),.out(y[6]));\nmux2X1  ins_25 (.in0(x[5]),.in1(x[7]),.sel(ctrl[1]),.out(y[5]));\nmux2X1  ins_24 (.in0(x[4]),.in1(x[6]),.sel(ctrl[1]),.out(y[4]));\nmux2X1  ins_23 (.in0(x[3]),.in1(x[5]),.sel(ctrl[1]),.out(y[3]));\nmux2X1  ins_22 (.in0(x[2]),.in1(x[4]),.sel(ctrl[1]),.out(y[2]));\nmux2X1  ins_21 (.in0(x[1]),.in1(x[3]),.sel(ctrl[1]),.out(y[1]));\nmux2X1  ins_20 (.in0(x[0]),.in1(x[2]),.sel(ctrl[1]),.out(y[0]));\n \n//1 bit shift right\nmux2X1  ins_07 (.in0(y[7]),.in1(1'b0),.sel(ctrl[0]),.out(out[7]));\nmux2X1  ins_06 (.in0(y[6]),.in1(y[7]),.sel(ctrl[0]),.out(out[6]));\nmux2X1  ins_05 (.in0(y[5]),.in1(y[6]),.sel(ctrl[0]),.out(out[5]));\nmux2X1  ins_04 (.in0(y[4]),.in1(y[5]),.sel(ctrl[0]),.out(out[4]));\nmux2X1  ins_03 (.in0(y[3]),.in1(y[4]),.sel(ctrl[0]),.out(out[3]));\nmux2X1  ins_02 (.in0(y[2]),.in1(y[3]),.sel(ctrl[0]),.out(out[2]));\nmux2X1  ins_01 (.in0(y[1]),.in1(y[2]),.sel(ctrl[0]),.out(out[1]));\nmux2X1  ins_00 (.in0(y[0]),.in1(y[1]),.sel(ctrl[0]),.out(out[0]));\n\nendmodule\n\nmodule mux2X1( in0,in1,sel,out);\ninput in0,in1;\ninput sel;\noutput out;\nassign out=(sel)?in1:in0;\nendmodule", "corrupted_code": "module barrel_shifter (in, ctrl, out);\n  input  [7:0] in;\n  input [2:0] ctrl;\n  output [7:1] out;\n  wire [7:0] x,y;\n \n//4bit shift right\nmux2X1  ins_17 (.in0(in[7]),.in1(1'b0),.sel(ctrl[2]),.out(x[7]));\nmux2X1  ins_16 (.in0(in[6]),.in1(1'b0),.sel(ctrl[2]),.out(x[6]));\nmux2X1  ins_15 (.in0(in[5]),.in1(1'b0),.sel(ctrl[2]),.out(x[5]));\nmux2X1  ins_14 (.in0(in[4]),.in1(1'b0),.sel(ctrl[2]),.out(x[4]));\nmux2X1  ins_13 (.in0(in[3]),.in1(in[7]),.sel(ctrl[2]),.out(x[3]));\nmux2X1  ins_12 (.in0(in[2]),.in1(in[6]),.sel(ctrl[2]),.out(x[2]));\nmux2X1  ins_11 (.in0(in[1]),.in1(in[5]),.sel(ctrl[2]),.out(x[1]));\nmux2X1  ins_10 (.in0(in[0]),.in1(in[4]),.sel(ctrl[2]),.out(x[0]));\n \n//2 bit shift right\n \nmux2X1  ins_27 (.in0(x[7]),.in1(1'b0),.sel(ctrl[1]),.out(y[7]));\nmux2X1  ins_26 (.in0(x[6]),.in1(1'b0),.sel(ctrl[1]),.out(y[6]));\nmux2X1  ins_25 (.in0(x[5]),.in1(x[7]),.sel(ctrl[1]),.out(y[5]));\nmux2X1  ins_24 (.in0(x[4]),.in1(x[6]),.sel(ctrl[1]),.out(y[4]));\nmux2X1  ins_23 (.in0(x[3]),.in1(x[5]),.sel(ctrl[1]),.out(y[3]));\nmux2X1  ins_22 (.in0(x[2]),.in1(x[4]),.sel(ctrl[1]),.out(y[2]));\nmux2X1  ins_21 (.in0(x[1]),.in1(x[3]),.sel(ctrl[1]),.out(y[1]));\nmux2X1  ins_20 (.in0(x[0]),.in1(x[2]),.sel(ctrl[1]),.out(y[0]));\n \n//1 bit shift right\nmux2X1  ins_07 (.in0(y[7]),.in1(1'b0),.sel(ctrl[0]),.out(out[7]));\nmux2X1  ins_06 (.in0(y[6]),.in1(y[7]),.sel(ctrl[0]),.out(out[6]));\nmux2X1  ins_05 (.in0(y[5]),.in1(y[6]),.sel(ctrl[0]),.out(out[5]));\nmux2X1  ins_04 (.in0(y[4]),.in1(y[5]),.sel(ctrl[0]),.out(out[4]));\nmux2X1  ins_03 (.in0(y[3]),.in1(y[4]),.sel(ctrl[0]),.out(out[3]));\nmux2X1  ins_02 (.in0(y[2]),.in1(y[3]),.sel(ctrl[0]),.out(out[2]));\nmux2X1  ins_01 (.in0(y[1]),.in1(y[2]),.sel(ctrl[0]),.out(out[1]));\nmux2X1  ins_00 (.in0(y[0]),.in1(y[1]),.sel(ctrl[0]),.out(out[0]));\n\nendmodule\n\nmodule mux2X1( in0,in1,sel,out);\ninput in0,in1;\ninput sel;\noutput out;\nassign out=(sel)?in1:in0;\nendmodule", "corruption_explanation": "Changed bit width from [7:0] to [7:1]", "modification_type": "change_bit_width", "modification_line": 4, "original_snippet": "[7:0]", "modified_snippet": "[7:1]", "issue_description": "The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_bit_width modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed bit width from [7:0] to [7:1]\n   \u2022 Line 4: Original: [7:0]\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 4.\n   \u2022 Restore the original code: [7:0]\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change bit width.", "complexity": 0, "applicable_modifications": ["change_constant", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["change_bit_width"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.978158", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "Shifter", "design_name": "barrel_shifter", "module_name": "barrel_shifter", "description": "Please act as a professional verilog designer.\n\nModule name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code."}, "clean_code": "module barrel_shifter (in, ctrl, out);\n  input  [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n  wire [7:0] x,y;\n \n//4bit shift right\nmux2X1  ins_17 (.in0(in[7]),.in1(1'b0),.sel(ctrl[2]),.out(x[7]));\nmux2X1  ins_16 (.in0(in[6]),.in1(1'b0),.sel(ctrl[2]),.out(x[6]));\nmux2X1  ins_15 (.in0(in[5]),.in1(1'b0),.sel(ctrl[2]),.out(x[5]));\nmux2X1  ins_14 (.in0(in[4]),.in1(1'b0),.sel(ctrl[2]),.out(x[4]));\nmux2X1  ins_13 (.in0(in[3]),.in1(in[7]),.sel(ctrl[2]),.out(x[3]));\nmux2X1  ins_12 (.in0(in[2]),.in1(in[6]),.sel(ctrl[2]),.out(x[2]));\nmux2X1  ins_11 (.in0(in[1]),.in1(in[5]),.sel(ctrl[2]),.out(x[1]));\nmux2X1  ins_10 (.in0(in[0]),.in1(in[4]),.sel(ctrl[2]),.out(x[0]));\n \n//2 bit shift right\n \nmux2X1  ins_27 (.in0(x[7]),.in1(1'b0),.sel(ctrl[1]),.out(y[7]));\nmux2X1  ins_26 (.in0(x[6]),.in1(1'b0),.sel(ctrl[1]),.out(y[6]));\nmux2X1  ins_25 (.in0(x[5]),.in1(x[7]),.sel(ctrl[1]),.out(y[5]));\nmux2X1  ins_24 (.in0(x[4]),.in1(x[6]),.sel(ctrl[1]),.out(y[4]));\nmux2X1  ins_23 (.in0(x[3]),.in1(x[5]),.sel(ctrl[1]),.out(y[3]));\nmux2X1  ins_22 (.in0(x[2]),.in1(x[4]),.sel(ctrl[1]),.out(y[2]));\nmux2X1  ins_21 (.in0(x[1]),.in1(x[3]),.sel(ctrl[1]),.out(y[1]));\nmux2X1  ins_20 (.in0(x[0]),.in1(x[2]),.sel(ctrl[1]),.out(y[0]));\n \n//1 bit shift right\nmux2X1  ins_07 (.in0(y[7]),.in1(1'b0),.sel(ctrl[0]),.out(out[7]));\nmux2X1  ins_06 (.in0(y[6]),.in1(y[7]),.sel(ctrl[0]),.out(out[6]));\nmux2X1  ins_05 (.in0(y[5]),.in1(y[6]),.sel(ctrl[0]),.out(out[5]));\nmux2X1  ins_04 (.in0(y[4]),.in1(y[5]),.sel(ctrl[0]),.out(out[4]));\nmux2X1  ins_03 (.in0(y[3]),.in1(y[4]),.sel(ctrl[0]),.out(out[3]));\nmux2X1  ins_02 (.in0(y[2]),.in1(y[3]),.sel(ctrl[0]),.out(out[2]));\nmux2X1  ins_01 (.in0(y[1]),.in1(y[2]),.sel(ctrl[0]),.out(out[1]));\nmux2X1  ins_00 (.in0(y[0]),.in1(y[1]),.sel(ctrl[0]),.out(out[0]));\n\nendmodule\n\nmodule mux2X1( in0,in1,sel,out);\ninput in0,in1;\ninput sel;\noutput out;\nassign out=(sel)?in1:in0;\nendmodule", "corrupted_code": "module barrel_shifter (in, ctrl, out);\n  input  [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n  wire [7:0] x,y;\n \n//4bit shift right\nmux2X1  ins_17 (.in0(in[7]),.in1(1'b0),.sel(ctrl[2]),.out(x[7]));\nmux2X1  ins_16 (.in0(in[6]),.in1(1'b0),.sel(ctrl[2]),.out(x[6]));\nmux2X1  ins_15 (.in0(in[5]),.in1(1'b0),.sel(ctrl[2]),.out(x[5]));\nmux2X1  ins_14 (.in0(in[4]),.in1(1'b0),.sel(ctrl[2]),.out(x[4]));\nmux2X1  ins_13 (.in0(in[3]),.in1(in[7]),.sel(ctrl[2]),.out(x[3]));\nmux2X1  ins_12 (.in0(in[2]),.in1(in[6]),.sel(ctrl[2]),.out(x[2]));\nmux2X1  ins_11 (.in0(in[1]),.in1(in[5]),.sel(ctrl[2]),.out(x[1]));\nmux2X1  ins_10 (.in0(in[0]),.in1(in[4]),.sel(ctrl[2]),.out(x[0]));\n \n//2 bit shift right\n \nmux2X1  ins_27 (.in0(x[7]),.in1(1'b1),.sel(ctrl[1]),.out(y[7]));\nmux2X1  ins_26 (.in0(x[6]),.in1(1'b0),.sel(ctrl[1]),.out(y[6]));\nmux2X1  ins_25 (.in0(x[5]),.in1(x[7]),.sel(ctrl[1]),.out(y[5]));\nmux2X1  ins_24 (.in0(x[4]),.in1(x[6]),.sel(ctrl[1]),.out(y[4]));\nmux2X1  ins_23 (.in0(x[3]),.in1(x[5]),.sel(ctrl[1]),.out(y[3]));\nmux2X1  ins_22 (.in0(x[2]),.in1(x[4]),.sel(ctrl[1]),.out(y[2]));\nmux2X1  ins_21 (.in0(x[1]),.in1(x[3]),.sel(ctrl[1]),.out(y[1]));\nmux2X1  ins_20 (.in0(x[0]),.in1(x[2]),.sel(ctrl[1]),.out(y[0]));\n \n//1 bit shift right\nmux2X1  ins_07 (.in0(y[7]),.in1(1'b0),.sel(ctrl[0]),.out(out[7]));\nmux2X1  ins_06 (.in0(y[6]),.in1(y[7]),.sel(ctrl[0]),.out(out[6]));\nmux2X1  ins_05 (.in0(y[5]),.in1(y[6]),.sel(ctrl[0]),.out(out[5]));\nmux2X1  ins_04 (.in0(y[4]),.in1(y[5]),.sel(ctrl[0]),.out(out[4]));\nmux2X1  ins_03 (.in0(y[3]),.in1(y[4]),.sel(ctrl[0]),.out(out[3]));\nmux2X1  ins_02 (.in0(y[2]),.in1(y[3]),.sel(ctrl[0]),.out(out[2]));\nmux2X1  ins_01 (.in0(y[1]),.in1(y[2]),.sel(ctrl[0]),.out(out[1]));\nmux2X1  ins_00 (.in0(y[0]),.in1(y[1]),.sel(ctrl[0]),.out(out[0]));\n\nendmodule\n\nmodule mux2X1( in0,in1,sel,out);\ninput in0,in1;\ninput sel;\noutput out;\nassign out=(sel)?in1:in0;\nendmodule", "corruption_explanation": "Changed constant from 1'b0 to 1'b1", "modification_type": "change_constant", "modification_line": 19, "original_snippet": "1'b0", "modified_snippet": "1'b1", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 1'b0 to 1'b1\n   \u2022 Line 19: Original: 1'b0\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 19.\n   \u2022 Restore the original code: 1'b0\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 0, "applicable_modifications": ["change_constant", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["change_constant"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.981527", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "Shifter", "design_name": "barrel_shifter", "module_name": "barrel_shifter", "description": "Please act as a professional verilog designer.\n\nModule name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code."}, "clean_code": "module barrel_shifter (in, ctrl, out);\n  input  [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n  wire [7:0] x,y;\n \n//4bit shift right\nmux2X1  ins_17 (.in0(in[7]),.in1(1'b0),.sel(ctrl[2]),.out(x[7]));\nmux2X1  ins_16 (.in0(in[6]),.in1(1'b0),.sel(ctrl[2]),.out(x[6]));\nmux2X1  ins_15 (.in0(in[5]),.in1(1'b0),.sel(ctrl[2]),.out(x[5]));\nmux2X1  ins_14 (.in0(in[4]),.in1(1'b0),.sel(ctrl[2]),.out(x[4]));\nmux2X1  ins_13 (.in0(in[3]),.in1(in[7]),.sel(ctrl[2]),.out(x[3]));\nmux2X1  ins_12 (.in0(in[2]),.in1(in[6]),.sel(ctrl[2]),.out(x[2]));\nmux2X1  ins_11 (.in0(in[1]),.in1(in[5]),.sel(ctrl[2]),.out(x[1]));\nmux2X1  ins_10 (.in0(in[0]),.in1(in[4]),.sel(ctrl[2]),.out(x[0]));\n \n//2 bit shift right\n \nmux2X1  ins_27 (.in0(x[7]),.in1(1'b0),.sel(ctrl[1]),.out(y[7]));\nmux2X1  ins_26 (.in0(x[6]),.in1(1'b0),.sel(ctrl[1]),.out(y[6]));\nmux2X1  ins_25 (.in0(x[5]),.in1(x[7]),.sel(ctrl[1]),.out(y[5]));\nmux2X1  ins_24 (.in0(x[4]),.in1(x[6]),.sel(ctrl[1]),.out(y[4]));\nmux2X1  ins_23 (.in0(x[3]),.in1(x[5]),.sel(ctrl[1]),.out(y[3]));\nmux2X1  ins_22 (.in0(x[2]),.in1(x[4]),.sel(ctrl[1]),.out(y[2]));\nmux2X1  ins_21 (.in0(x[1]),.in1(x[3]),.sel(ctrl[1]),.out(y[1]));\nmux2X1  ins_20 (.in0(x[0]),.in1(x[2]),.sel(ctrl[1]),.out(y[0]));\n \n//1 bit shift right\nmux2X1  ins_07 (.in0(y[7]),.in1(1'b0),.sel(ctrl[0]),.out(out[7]));\nmux2X1  ins_06 (.in0(y[6]),.in1(y[7]),.sel(ctrl[0]),.out(out[6]));\nmux2X1  ins_05 (.in0(y[5]),.in1(y[6]),.sel(ctrl[0]),.out(out[5]));\nmux2X1  ins_04 (.in0(y[4]),.in1(y[5]),.sel(ctrl[0]),.out(out[4]));\nmux2X1  ins_03 (.in0(y[3]),.in1(y[4]),.sel(ctrl[0]),.out(out[3]));\nmux2X1  ins_02 (.in0(y[2]),.in1(y[3]),.sel(ctrl[0]),.out(out[2]));\nmux2X1  ins_01 (.in0(y[1]),.in1(y[2]),.sel(ctrl[0]),.out(out[1]));\nmux2X1  ins_00 (.in0(y[0]),.in1(y[1]),.sel(ctrl[0]),.out(out[0]));\n\nendmodule\n\nmodule mux2X1( in0,in1,sel,out);\ninput in0,in1;\ninput sel;\noutput out;\nassign out=(sel)?in1:in0;\nendmodule", "corrupted_code": "module barrel_shifter (in, ctrl, out);\n  input  [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n  wire [7:0] x,y;\n \n//4bit shift right\nmux2X1  ins_17 (.in0(in[7]),.in1(1'b0),.sel(ctrl[2]),.out(x[7]));\nmux2X1  ins_16 (.in0(in[6]),.in1(1'b0),.sel(ctrl[2]),.out(x[6]));\nmux2X1  ins_15 (.in0(in[5]),.in1(1'b0),.sel(ctrl[2]),.out(x[5]));\nmux2X1  ins_14 (.in0(in[4]),.in1(1'b0),.sel(ctrl[2]),.out(x[4]));\nmux2X1  ins_13 (.in0(in[3]),.in1(in[7]),.sel(ctrl[2]),.out(x[3]));\nmux2X1 ins_12(.in0(ctrl[2]),.in1(in[6]),.sel(in[2]),.out(x[2]));\nmux2X1  ins_11 (.in0(in[1]),.in1(in[5]),.sel(ctrl[2]),.out(x[1]));\nmux2X1  ins_10 (.in0(in[0]),.in1(in[4]),.sel(ctrl[2]),.out(x[0]));\n \n//2 bit shift right\n \nmux2X1  ins_27 (.in0(x[7]),.in1(1'b0),.sel(ctrl[1]),.out(y[7]));\nmux2X1  ins_26 (.in0(x[6]),.in1(1'b0),.sel(ctrl[1]),.out(y[6]));\nmux2X1  ins_25 (.in0(x[5]),.in1(x[7]),.sel(ctrl[1]),.out(y[5]));\nmux2X1  ins_24 (.in0(x[4]),.in1(x[6]),.sel(ctrl[1]),.out(y[4]));\nmux2X1  ins_23 (.in0(x[3]),.in1(x[5]),.sel(ctrl[1]),.out(y[3]));\nmux2X1  ins_22 (.in0(x[2]),.in1(x[4]),.sel(ctrl[1]),.out(y[2]));\nmux2X1  ins_21 (.in0(x[1]),.in1(x[3]),.sel(ctrl[1]),.out(y[1]));\nmux2X1  ins_20 (.in0(x[0]),.in1(x[2]),.sel(ctrl[1]),.out(y[0]));\n \n//1 bit shift right\nmux2X1  ins_07 (.in0(y[7]),.in1(1'b0),.sel(ctrl[0]),.out(out[7]));\nmux2X1  ins_06 (.in0(y[6]),.in1(y[7]),.sel(ctrl[0]),.out(out[6]));\nmux2X1  ins_05 (.in0(y[5]),.in1(y[6]),.sel(ctrl[0]),.out(out[5]));\nmux2X1  ins_04 (.in0(y[4]),.in1(y[5]),.sel(ctrl[0]),.out(out[4]));\nmux2X1  ins_03 (.in0(y[3]),.in1(y[4]),.sel(ctrl[0]),.out(out[3]));\nmux2X1  ins_02 (.in0(y[2]),.in1(y[3]),.sel(ctrl[0]),.out(out[2]));\nmux2X1  ins_01 (.in0(y[1]),.in1(y[2]),.sel(ctrl[0]),.out(out[1]));\nmux2X1  ins_00 (.in0(y[0]),.in1(y[1]),.sel(ctrl[0]),.out(out[0]));\n\nendmodule\n\nmodule mux2X1( in0,in1,sel,out);\ninput in0,in1;\ninput sel;\noutput out;\nassign out=(sel)?in1:in0;\nendmodule", "corruption_explanation": "Swapped signals: .sel(ctrl[2]) <-> .in0(in[2])", "modification_type": "swap_port_signals", "modification_line": 13, "original_snippet": "mux2X1  ins_12 (.in0(in[2]),.in1(in[6]),.sel(ctrl[2]),.out(x[2]));", "modified_snippet": "mux2X1 ins_12(.in0(ctrl[2]),.in1(in[6]),.sel(in[2]),.out(x[2]));", "issue_description": "The buggy code has swapped signal connections in a module instantiation. Signals are connected to the wrong ports, causing data to flow incorrectly between modules. This is a classic integration bug that causes functional failures in hierarchical designs.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_port_signals modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped signals: .sel(ctrl[2]) <-> .in0(in[2])\n   \u2022 Line 13: Original: mux2X1  ins_12 (.in0(in[2]),.in1(in[6]),.sel(ctrl[2]),.out(x[2]));\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 13.\n   \u2022 Restore the original code: mux2X1  ins_12 (.in0(in[2]),.in1(in[6]),.sel(ctrl[2]),.out(x[2]));\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap port signals.", "complexity": 0, "applicable_modifications": ["change_constant", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["swap_port_signals"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.984773", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "Shifter", "design_name": "barrel_shifter", "module_name": "barrel_shifter", "description": "Please act as a professional verilog designer.\n\nModule name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code."}, "clean_code": "module barrel_shifter (in, ctrl, out);\n  input  [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n  wire [7:0] x,y;\n \n//4bit shift right\nmux2X1  ins_17 (.in0(in[7]),.in1(1'b0),.sel(ctrl[2]),.out(x[7]));\nmux2X1  ins_16 (.in0(in[6]),.in1(1'b0),.sel(ctrl[2]),.out(x[6]));\nmux2X1  ins_15 (.in0(in[5]),.in1(1'b0),.sel(ctrl[2]),.out(x[5]));\nmux2X1  ins_14 (.in0(in[4]),.in1(1'b0),.sel(ctrl[2]),.out(x[4]));\nmux2X1  ins_13 (.in0(in[3]),.in1(in[7]),.sel(ctrl[2]),.out(x[3]));\nmux2X1  ins_12 (.in0(in[2]),.in1(in[6]),.sel(ctrl[2]),.out(x[2]));\nmux2X1  ins_11 (.in0(in[1]),.in1(in[5]),.sel(ctrl[2]),.out(x[1]));\nmux2X1  ins_10 (.in0(in[0]),.in1(in[4]),.sel(ctrl[2]),.out(x[0]));\n \n//2 bit shift right\n \nmux2X1  ins_27 (.in0(x[7]),.in1(1'b0),.sel(ctrl[1]),.out(y[7]));\nmux2X1  ins_26 (.in0(x[6]),.in1(1'b0),.sel(ctrl[1]),.out(y[6]));\nmux2X1  ins_25 (.in0(x[5]),.in1(x[7]),.sel(ctrl[1]),.out(y[5]));\nmux2X1  ins_24 (.in0(x[4]),.in1(x[6]),.sel(ctrl[1]),.out(y[4]));\nmux2X1  ins_23 (.in0(x[3]),.in1(x[5]),.sel(ctrl[1]),.out(y[3]));\nmux2X1  ins_22 (.in0(x[2]),.in1(x[4]),.sel(ctrl[1]),.out(y[2]));\nmux2X1  ins_21 (.in0(x[1]),.in1(x[3]),.sel(ctrl[1]),.out(y[1]));\nmux2X1  ins_20 (.in0(x[0]),.in1(x[2]),.sel(ctrl[1]),.out(y[0]));\n \n//1 bit shift right\nmux2X1  ins_07 (.in0(y[7]),.in1(1'b0),.sel(ctrl[0]),.out(out[7]));\nmux2X1  ins_06 (.in0(y[6]),.in1(y[7]),.sel(ctrl[0]),.out(out[6]));\nmux2X1  ins_05 (.in0(y[5]),.in1(y[6]),.sel(ctrl[0]),.out(out[5]));\nmux2X1  ins_04 (.in0(y[4]),.in1(y[5]),.sel(ctrl[0]),.out(out[4]));\nmux2X1  ins_03 (.in0(y[3]),.in1(y[4]),.sel(ctrl[0]),.out(out[3]));\nmux2X1  ins_02 (.in0(y[2]),.in1(y[3]),.sel(ctrl[0]),.out(out[2]));\nmux2X1  ins_01 (.in0(y[1]),.in1(y[2]),.sel(ctrl[0]),.out(out[1]));\nmux2X1  ins_00 (.in0(y[0]),.in1(y[1]),.sel(ctrl[0]),.out(out[0]));\n\nendmodule\n\nmodule mux2X1( in0,in1,sel,out);\ninput in0,in1;\ninput sel;\noutput out;\nassign out=(sel)?in1:in0;\nendmodule", "corrupted_code": "module barrel_shifter (in, ctrl, out);\n  input  [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n  wire [7:0] x,y;\n \n//4bit shift right\nmux2X1  ins_17 (.in0(in[7]),.in1(1'b0),.sel(ctrl[2]),.out(x[7]));\nmux2X1  ins_16 (.in0(in[6]),.in1(1'b0),.sel(ctrl[2]),.out(x[6]));\nmux2X1  ins_15 (.in0(in[5]),.in1(1'b0),.sel(ctrl[2]),.out(x[5]));\nmux2X1  ins_14 (.in0(in[4]),.in1(1'b0),.sel(ctrl[2]),.out(x[4]));\nmux2X1  ins_13 (.in0(in[3]),.in1(in[7]),.sel(ctrl[2]),.out(x[3]));\nmux2X1  ins_12 (.in0(in[2]),.in1(in[6]),.sel(ctrl[2]),.out(x[2]));\nmux2X1  ins_11 (.in0(in[1]),.in1(in[5]),.sel(ctrl[2]),.out(x[1]));\nmux2X1  ins_10 (.in0(in[0]),.in1(in[4]),.sel(ctrl[2]),.out(x[0]));\n \n//2 bit shift right\n \nmux2X1  ins_27 (.in0(x[7]),.in1(1'b0),.sel(ctrl[1]),.out(y[7]));\nmux2X1  ins_26 (.in0(x[6]),.in1(1'b0),.sel(ctrl[1]),.out(y[6]));\nmux2X1  ins_25 (.in0(x[5]),.in1(x[7]),.sel(ctrl[1]),.out(y[5]));\nmux2X1  ins_24 (.in0(x[4]),.in1(x[6]),.sel(ctrl[1]),.out(y[4]));\nmux2X1  ins_23 (.in0(x[3]),.in1(x[5]),.sel(ctrl[1]),.out(y[3]));\nmux2X1  ins_22 (.in0(x[2]),.in1(x[4]),.sel(ctrl[1]),.out(y[2]));\nmux2X1  ins_21 (.in0(x[1]),.in1(x[3]),.sel(ctrl[1]),.out(y[1]));\nmux2X1  ins_20 (.in0(x[0]),.in1(x[2]),.sel(ctrl[1]),.out(y[0]));\n \n//1 bit shift right\nmux2X1  ins_07 (.in0(y[7]),.in1(1'b0),.sel(ctrl[0]),.out(out[7]));\nmux2X1  ins_06 (.in0(y[6]),.in1(y[7]),.sel(ctrl[0]),.out(out[6]));\nmux2X1  ins_05 (.in0(y[5]),.in1(y[6]),.sel(ctrl[0]),.out(out[5]));\nmux2X1  ins_04 (.in0(y[4]),.in1(y[5]),.sel(ctrl[0]),.out(out[4]));\nmux2X1  ins_03 (.in0(y[3]),.in1(y[4]),.sel(ctrl[0]),.out(out[3]));\nmux2X1  ins_02 (.in0(y[2]),.in1(y[3]),.sel(ctrl[0]),.out(out[2]));\nmux2X1  ins_01 (.in0(y[1]),.in1(y[2]),.sel(ctrl[0]),.out(out[1]));\nmux2X1  ins_00 (.in0(y[0]),.in1(y[1]),.sel(ctrl[0]),.out(out[0]));\n\nendmodule\n\nmodule mux2X1( in0,in1,sel,out);\ninput in0,in1;\ninput sel;\noutput out;\nassign out <= (sel)?in1:in0;\nendmodule", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 44, "original_snippet": "ut=(sel)?in1:in0;", "modified_snippet": "ut <= (sel)?in1:in0;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 0, "applicable_modifications": ["change_constant", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.988444", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "Shifter", "design_name": "right_shifter", "module_name": "right_shifter", "description": "Please act as a professional verilog designer.\n\nImplement a right shifter. The module performs an 8-bit right shift on a 1-bit input by first initializing the q register to 0. On each rising edge of the clock, the module shifts the contents of the q register to the right by one bit and inserts the new input bit d into the most significant position of the register.\n\nModule name:  \n    right_shifter    \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    d: Input signal to be right-shifted.\n\nOutput ports:\n    q: Output signal representing the result of the right shift operation.\n\nImplementation:\nThe register is defined as reg [7:0] q and initialized to 0 using the initial statement. The value of q is right-shifted by 1 bit using the >> operator: q <= (q >> 1).\nThe most significant bit (q[7]) of the register is assigned the value of the input signal (d): q[7] <= d.\n\nGive me the complete code.\n"}, "clean_code": "module right_shifter(clk, q,d);  \n\n    input  clk;  \n    input d;  \n    output  [7:0] q;  \n    reg   [7:0]  q; \n    initial q = 0;\n\n    always @(posedge clk)\n          begin\n            q <= (q >> 1);\n            q[7] <= d;\n          end  \n\nendmodule", "corrupted_code": "module right_shifter(clk, q,d);  \n\n    input  clk;  \n    input d;  \n    output  [7:0] q;  \n    reg   [7:0]  q; \n    initial q = 0;\n\n    always @(posedge clk)\n          begin\n            q <= (q >> 1);\n            q[7] <= d;\n          end  \n\n\n    wire clk_dup;\n    assign clk_dup = clk;\nendmodule", "corruption_explanation": "Added duplicate clock signal clk_dup", "modification_type": "duplicate_clock_signal", "modification_line": 5, "original_snippet": "(none)", "modified_snippet": "wire clk_dup;\n    assign clk_dup = clk;", "issue_description": "The buggy code has a duplicate clock signal. A phantom clock domain is created, which may confuse CDC analysis tools and create subtle timing issues in synthesis. This violates clock domain design best practices.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a duplicate_clock_signal modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added duplicate clock signal clk_dup\n   \u2022 Line 5: Original: (none)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 5.\n   \u2022 Restore the original code: (none)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to duplicate clock signal.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["duplicate_clock_signal"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.991492", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "Shifter", "design_name": "right_shifter", "module_name": "right_shifter", "description": "Please act as a professional verilog designer.\n\nImplement a right shifter. The module performs an 8-bit right shift on a 1-bit input by first initializing the q register to 0. On each rising edge of the clock, the module shifts the contents of the q register to the right by one bit and inserts the new input bit d into the most significant position of the register.\n\nModule name:  \n    right_shifter    \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    d: Input signal to be right-shifted.\n\nOutput ports:\n    q: Output signal representing the result of the right shift operation.\n\nImplementation:\nThe register is defined as reg [7:0] q and initialized to 0 using the initial statement. The value of q is right-shifted by 1 bit using the >> operator: q <= (q >> 1).\nThe most significant bit (q[7]) of the register is assigned the value of the input signal (d): q[7] <= d.\n\nGive me the complete code.\n"}, "clean_code": "module right_shifter(clk, q,d);  \n\n    input  clk;  \n    input d;  \n    output  [7:0] q;  \n    reg   [7:0]  q; \n    initial q = 0;\n\n    always @(posedge clk)\n          begin\n            q <= (q >> 1);\n            q[7] <= d;\n          end  \n\nendmodule", "corrupted_code": "module right_shifter(clk, q,d);  \n\n    input  clk;  \n    input d;  \n    output  [7:0] q;  \n    reg   [7:0]  q; \n    initial q = 0;\n\n    always @(posedge clk)\n          begin\n            q <= (q << 1);\n            q[7] <= d;\n          end  \n\nendmodule", "corruption_explanation": "Changed operator from '>>' to '<<'", "modification_type": "change_operator", "modification_line": 11, "original_snippet": ">>", "modified_snippet": "<<", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '>>' to '<<'\n   \u2022 Line 11: Original: >>\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 11.\n   \u2022 Restore the original code: >>\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.992160", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "Shifter", "design_name": "right_shifter", "module_name": "right_shifter", "description": "Please act as a professional verilog designer.\n\nImplement a right shifter. The module performs an 8-bit right shift on a 1-bit input by first initializing the q register to 0. On each rising edge of the clock, the module shifts the contents of the q register to the right by one bit and inserts the new input bit d into the most significant position of the register.\n\nModule name:  \n    right_shifter    \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    d: Input signal to be right-shifted.\n\nOutput ports:\n    q: Output signal representing the result of the right shift operation.\n\nImplementation:\nThe register is defined as reg [7:0] q and initialized to 0 using the initial statement. The value of q is right-shifted by 1 bit using the >> operator: q <= (q >> 1).\nThe most significant bit (q[7]) of the register is assigned the value of the input signal (d): q[7] <= d.\n\nGive me the complete code.\n"}, "clean_code": "module right_shifter(clk, q,d);  \n\n    input  clk;  \n    input d;  \n    output  [7:0] q;  \n    reg   [7:0]  q; \n    initial q = 0;\n\n    always @(posedge clk)\n          begin\n            q <= (q >> 1);\n            q[7] <= d;\n          end  \n\nendmodule", "corrupted_code": "module right_shifter(clk, q,d);  \n\n    input  clk;  \n    input d;  \n    output  [7:0] q;  \n    reg   [7:0]  q; \n    initial q = 0;\n\n      \n\nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 9, "original_snippet": "always @(posedge clk)\n          begin\n            q <= (q >> 1);\n            q[7] <= d;\n          end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 9: Original: always @(posedge clk)\n          begin\n            q <= (q >> 1);\n            q[7] <= d;\n          end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 9.\n   \u2022 Restore the original code: always @(posedge clk)\n          begin\n            q <= (q >> 1);\n            q[7] <= d;\n          end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.992738", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "Shifter", "design_name": "right_shifter", "module_name": "right_shifter", "description": "Please act as a professional verilog designer.\n\nImplement a right shifter. The module performs an 8-bit right shift on a 1-bit input by first initializing the q register to 0. On each rising edge of the clock, the module shifts the contents of the q register to the right by one bit and inserts the new input bit d into the most significant position of the register.\n\nModule name:  \n    right_shifter    \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    d: Input signal to be right-shifted.\n\nOutput ports:\n    q: Output signal representing the result of the right shift operation.\n\nImplementation:\nThe register is defined as reg [7:0] q and initialized to 0 using the initial statement. The value of q is right-shifted by 1 bit using the >> operator: q <= (q >> 1).\nThe most significant bit (q[7]) of the register is assigned the value of the input signal (d): q[7] <= d.\n\nGive me the complete code.\n"}, "clean_code": "module right_shifter(clk, q,d);  \n\n    input  clk;  \n    input d;  \n    output  [7:0] q;  \n    reg   [7:0]  q; \n    initial q = 0;\n\n    always @(posedge clk)\n          begin\n            q <= (q >> 1);\n            q[7] <= d;\n          end  \n\nendmodule", "corrupted_code": "module right_shifter(clk, q,d);  \n\n    input  clk;  \n    input d;  \n    output  [7:0] q;  \n    reg   [7:0]  q; \n    initial q = 0;\n\n      \n\nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 9, "original_snippet": "always @(posedge clk)\n          begin\n            q <= (q >> 1);\n            q[7] <= d;\n          end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 9: Original: always @(posedge clk)\n          begin\n            q <= (q >> 1);\n            q[7] <= d;\n          end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 9.\n   \u2022 Restore the original code: always @(posedge clk)\n          begin\n            q <= (q >> 1);\n            q[7] <= d;\n          end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.993317", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "Shifter", "design_name": "right_shifter", "module_name": "right_shifter", "description": "Please act as a professional verilog designer.\n\nImplement a right shifter. The module performs an 8-bit right shift on a 1-bit input by first initializing the q register to 0. On each rising edge of the clock, the module shifts the contents of the q register to the right by one bit and inserts the new input bit d into the most significant position of the register.\n\nModule name:  \n    right_shifter    \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    d: Input signal to be right-shifted.\n\nOutput ports:\n    q: Output signal representing the result of the right shift operation.\n\nImplementation:\nThe register is defined as reg [7:0] q and initialized to 0 using the initial statement. The value of q is right-shifted by 1 bit using the >> operator: q <= (q >> 1).\nThe most significant bit (q[7]) of the register is assigned the value of the input signal (d): q[7] <= d.\n\nGive me the complete code.\n"}, "clean_code": "module right_shifter(clk, q,d);  \n\n    input  clk;  \n    input d;  \n    output  [7:0] q;  \n    reg   [7:0]  q; \n    initial q = 0;\n\n    always @(posedge clk)\n          begin\n            q <= (q >> 1);\n            q[7] <= d;\n          end  \n\nendmodule", "corrupted_code": "module right_shifter(clk, q,d);  \n\n    input  clk;  \n    input d;  \n    output  [7:0] q;  \n    reg   [7:0]  q; \n    initial q = 0;\n\n    always @(posedge clk)\n          begin\n            q <= (q << 1);\n            q[7] <= d;\n          end  \n\nendmodule", "corruption_explanation": "Changed operator from '>>' to '<<'", "modification_type": "change_operator", "modification_line": 11, "original_snippet": ">>", "modified_snippet": "<<", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '>>' to '<<'\n   \u2022 Line 11: Original: >>\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 11.\n   \u2022 Restore the original code: >>\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.993961", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "Shifter", "design_name": "right_shifter", "module_name": "right_shifter", "description": "Please act as a professional verilog designer.\n\nImplement a right shifter. The module performs an 8-bit right shift on a 1-bit input by first initializing the q register to 0. On each rising edge of the clock, the module shifts the contents of the q register to the right by one bit and inserts the new input bit d into the most significant position of the register.\n\nModule name:  \n    right_shifter    \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    d: Input signal to be right-shifted.\n\nOutput ports:\n    q: Output signal representing the result of the right shift operation.\n\nImplementation:\nThe register is defined as reg [7:0] q and initialized to 0 using the initial statement. The value of q is right-shifted by 1 bit using the >> operator: q <= (q >> 1).\nThe most significant bit (q[7]) of the register is assigned the value of the input signal (d): q[7] <= d.\n\nGive me the complete code.\n"}, "clean_code": "module right_shifter(clk, q,d);  \n\n    input  clk;  \n    input d;  \n    output  [7:0] q;  \n    reg   [7:0]  q; \n    initial q = 0;\n\n    always @(posedge clk)\n          begin\n            q <= (q >> 1);\n            q[7] <= d;\n          end  \n\nendmodule", "corrupted_code": "module right_shifter(clk, q,d);  \n\n    input  clk;  \n    input d;  \n    output  [7:0] q;  \n    reg   [7:0]  q; \n    initial q = 1;\n\n    always @(posedge clk)\n          begin\n            q <= (q >> 1);\n            q[7] <= d;\n          end  \n\nendmodule", "corruption_explanation": "Changed constant from 0 to 1", "modification_type": "change_constant", "modification_line": 7, "original_snippet": "0", "modified_snippet": "1", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 0 to 1\n   \u2022 Line 7: Original: 0\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 7.\n   \u2022 Restore the original code: 0\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_constant"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.994529", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "Shifter", "design_name": "right_shifter", "module_name": "right_shifter", "description": "Please act as a professional verilog designer.\n\nImplement a right shifter. The module performs an 8-bit right shift on a 1-bit input by first initializing the q register to 0. On each rising edge of the clock, the module shifts the contents of the q register to the right by one bit and inserts the new input bit d into the most significant position of the register.\n\nModule name:  \n    right_shifter    \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    d: Input signal to be right-shifted.\n\nOutput ports:\n    q: Output signal representing the result of the right shift operation.\n\nImplementation:\nThe register is defined as reg [7:0] q and initialized to 0 using the initial statement. The value of q is right-shifted by 1 bit using the >> operator: q <= (q >> 1).\nThe most significant bit (q[7]) of the register is assigned the value of the input signal (d): q[7] <= d.\n\nGive me the complete code.\n"}, "clean_code": "module right_shifter(clk, q,d);  \n\n    input  clk;  \n    input d;  \n    output  [7:0] q;  \n    reg   [7:0]  q; \n    initial q = 0;\n\n    always @(posedge clk)\n          begin\n            q <= (q >> 1);\n            q[7] <= d;\n          end  \n\nendmodule", "corrupted_code": "module right_shifter(clk, q,d);  \n\n    input  clk;  \n    input d;  \n    output  [7:0] q;  \n    reg   [7:0]  q; \n    initial q = 0;\n\n    always @(posedge clk)\n          begin\n            q <= (q << 1);\n            q[7] <= d;\n          end  \n\nendmodule", "corruption_explanation": "Changed operator from '>>' to '<<'", "modification_type": "change_operator", "modification_line": 11, "original_snippet": ">>", "modified_snippet": "<<", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '>>' to '<<'\n   \u2022 Line 11: Original: >>\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 11.\n   \u2022 Restore the original code: >>\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.995157", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "Shifter", "design_name": "right_shifter", "module_name": "right_shifter", "description": "Please act as a professional verilog designer.\n\nImplement a right shifter. The module performs an 8-bit right shift on a 1-bit input by first initializing the q register to 0. On each rising edge of the clock, the module shifts the contents of the q register to the right by one bit and inserts the new input bit d into the most significant position of the register.\n\nModule name:  \n    right_shifter    \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    d: Input signal to be right-shifted.\n\nOutput ports:\n    q: Output signal representing the result of the right shift operation.\n\nImplementation:\nThe register is defined as reg [7:0] q and initialized to 0 using the initial statement. The value of q is right-shifted by 1 bit using the >> operator: q <= (q >> 1).\nThe most significant bit (q[7]) of the register is assigned the value of the input signal (d): q[7] <= d.\n\nGive me the complete code.\n"}, "clean_code": "module right_shifter(clk, q,d);  \n\n    input  clk;  \n    input d;  \n    output  [7:0] q;  \n    reg   [7:0]  q; \n    initial q = 0;\n\n    always @(posedge clk)\n          begin\n            q <= (q >> 1);\n            q[7] <= d;\n          end  \n\nendmodule", "corrupted_code": "module right_shifter(clk, q,d);  \n\n    input  clk;  \n    input d;  \n    output  [7:0] q;  \n    reg   [7:0]  q; \n    initial q = 0;\n\n    always @(posedge clk)\n          begin\n            q <= (q >> 1);\n            q[7] <= d;\n          end  \n\n\n    wire clk_dup;\n    assign clk_dup = clk;\nendmodule", "corruption_explanation": "Added duplicate clock signal clk_dup", "modification_type": "duplicate_clock_signal", "modification_line": 5, "original_snippet": "(none)", "modified_snippet": "wire clk_dup;\n    assign clk_dup = clk;", "issue_description": "The buggy code has a duplicate clock signal. A phantom clock domain is created, which may confuse CDC analysis tools and create subtle timing issues in synthesis. This violates clock domain design best practices.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a duplicate_clock_signal modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added duplicate clock signal clk_dup\n   \u2022 Line 5: Original: (none)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 5.\n   \u2022 Restore the original code: (none)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to duplicate clock signal.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["duplicate_clock_signal"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.995710", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "Shifter", "design_name": "right_shifter", "module_name": "right_shifter", "description": "Please act as a professional verilog designer.\n\nImplement a right shifter. The module performs an 8-bit right shift on a 1-bit input by first initializing the q register to 0. On each rising edge of the clock, the module shifts the contents of the q register to the right by one bit and inserts the new input bit d into the most significant position of the register.\n\nModule name:  \n    right_shifter    \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    d: Input signal to be right-shifted.\n\nOutput ports:\n    q: Output signal representing the result of the right shift operation.\n\nImplementation:\nThe register is defined as reg [7:0] q and initialized to 0 using the initial statement. The value of q is right-shifted by 1 bit using the >> operator: q <= (q >> 1).\nThe most significant bit (q[7]) of the register is assigned the value of the input signal (d): q[7] <= d.\n\nGive me the complete code.\n"}, "clean_code": "module right_shifter(clk, q,d);  \n\n    input  clk;  \n    input d;  \n    output  [7:0] q;  \n    reg   [7:0]  q; \n    initial q = 0;\n\n    always @(posedge clk)\n          begin\n            q <= (q >> 1);\n            q[7] <= d;\n          end  \n\nendmodule", "corrupted_code": "module right_shifter(clk, q,d);  \n\n    input  clk;  \n    input d;  \n    output  [7:0] q;  \n    reg   [7:0]  q; \n    initial q <= 0;\n\n    always @(posedge clk)\n          begin\n            q <= (q >> 1);\n            q[7] <= d;\n          end  \n\nendmodule", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 7, "original_snippet": "q = 0;", "modified_snippet": "q <= 0;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:22.996323", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "Shifter", "design_name": "LFSR", "module_name": "LFSR", "description": "Please act as a professional Verilog designer.\n\nA Linear Feedback Shift Register (LFSR) designed for generating pseudo-random sequences. This 4-bit LFSR uses a specific feedback mechanism to produce a sequence of bits that appears random.\n\nModule name:\n    LFSR\n\nInput ports:\n    clk: Clock signal to synchronize the shifting operation.\n    rst: Active high reset signal to initialize the register.\n\nOutput ports:\n    out [3:0]: 4-bit output representing the current state of the LFSR.\n\nImplementation:\nThe LFSR operates on the principle of shifting bits and applying feedback based on the XOR of specific bits in the register.\nThe feedback is calculated by XORing the most significant bit (out[3]) and the second most significant bit (out[2]). The result is inverted to produce the feedback signal.\nOn the rising edge of the clock (clk), if the reset (rst) is high, the register is initialized to zero. Otherwise, the bits in the register are shifted left, and the new feedback value is inserted at the least significant bit (LSB).\n"}, "clean_code": "module LFSR (out, clk, rst);\n  input clk, rst;\n  output reg [3:0] out;\n  wire feedback;\n\n  assign feedback = ~(out[3] ^ out[2]);\n\nalways @(posedge clk, posedge rst)\n  begin\n    if (rst)\n      out = 4'b0;\n    else\n      out = {out[2:0],feedback};\n  end\nendmodule", "corrupted_code": "module LFSR (out, clk, rst);\n  input clk, rst;\n  output reg [3:0] out;\n  wire feedback;\n\n  assign feedback = ~(out[3] ^ out[2]);\nassign feedback = 1'b0;  // Conflicting assignment\n\nalways @(posedge clk, posedge rst)\n  begin\n    if (rst)\n      out = 4'b0;\n    else\n      out = {out[2:0],feedback};\n  end\nendmodule", "corruption_explanation": "Added conflicting driver for signal 'feedback'", "modification_type": "add_multiple_driver", "modification_line": 5, "original_snippet": "assign feedback = ~(out[3] ^ out[2]);", "modified_snippet": "assign feedback = ~(out[3] ^ out[2]);\nassign feedback = 1'b0;  // Conflicting assignment", "issue_description": "The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_multiple_driver modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added conflicting driver for signal 'feedback'\n   \u2022 Line 5: Original: assign feedback = ~(out[3] ^ out[2]);\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 5.\n   \u2022 Restore the original code: assign feedback = ~(out[3] ^ out[2]);\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add multiple driver.", "complexity": 1, "applicable_modifications": ["change_constant", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["add_multiple_driver"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.058286", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "Shifter", "design_name": "LFSR", "module_name": "LFSR", "description": "Please act as a professional Verilog designer.\n\nA Linear Feedback Shift Register (LFSR) designed for generating pseudo-random sequences. This 4-bit LFSR uses a specific feedback mechanism to produce a sequence of bits that appears random.\n\nModule name:\n    LFSR\n\nInput ports:\n    clk: Clock signal to synchronize the shifting operation.\n    rst: Active high reset signal to initialize the register.\n\nOutput ports:\n    out [3:0]: 4-bit output representing the current state of the LFSR.\n\nImplementation:\nThe LFSR operates on the principle of shifting bits and applying feedback based on the XOR of specific bits in the register.\nThe feedback is calculated by XORing the most significant bit (out[3]) and the second most significant bit (out[2]). The result is inverted to produce the feedback signal.\nOn the rising edge of the clock (clk), if the reset (rst) is high, the register is initialized to zero. Otherwise, the bits in the register are shifted left, and the new feedback value is inserted at the least significant bit (LSB).\n"}, "clean_code": "module LFSR (out, clk, rst);\n  input clk, rst;\n  output reg [3:0] out;\n  wire feedback;\n\n  assign feedback = ~(out[3] ^ out[2]);\n\nalways @(posedge clk, posedge rst)\n  begin\n    if (rst)\n      out = 4'b0;\n    else\n      out = {out[2:0],feedback};\n  end\nendmodule", "corrupted_code": "module LFSR (out, clk, rst);\n  input clk, rst;\n  output reg [3:0] out;\n  wire feedback;\n\n  assign feedback = ~(out[3] ^ out[2]);\n\nalways @(clk, rst)\n  begin\n    if (rst)\n      out = 4'b0;\n    else\n      out = {out[2:0],feedback};\n  end\nendmodule", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 8, "original_snippet": "always @(posedge clk, posedge rst)", "modified_snippet": "always @(clk, rst)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 8: Original: always @(posedge clk, posedge rst)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 8.\n   \u2022 Restore the original code: always @(posedge clk, posedge rst)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 1, "applicable_modifications": ["change_constant", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_sensitivity_list"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.059094", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "Shifter", "design_name": "LFSR", "module_name": "LFSR", "description": "Please act as a professional Verilog designer.\n\nA Linear Feedback Shift Register (LFSR) designed for generating pseudo-random sequences. This 4-bit LFSR uses a specific feedback mechanism to produce a sequence of bits that appears random.\n\nModule name:\n    LFSR\n\nInput ports:\n    clk: Clock signal to synchronize the shifting operation.\n    rst: Active high reset signal to initialize the register.\n\nOutput ports:\n    out [3:0]: 4-bit output representing the current state of the LFSR.\n\nImplementation:\nThe LFSR operates on the principle of shifting bits and applying feedback based on the XOR of specific bits in the register.\nThe feedback is calculated by XORing the most significant bit (out[3]) and the second most significant bit (out[2]). The result is inverted to produce the feedback signal.\nOn the rising edge of the clock (clk), if the reset (rst) is high, the register is initialized to zero. Otherwise, the bits in the register are shifted left, and the new feedback value is inserted at the least significant bit (LSB).\n"}, "clean_code": "module LFSR (out, clk, rst);\n  input clk, rst;\n  output reg [3:0] out;\n  wire feedback;\n\n  assign feedback = ~(out[3] ^ out[2]);\n\nalways @(posedge clk, posedge rst)\n  begin\n    if (rst)\n      out = 4'b0;\n    else\n      out = {out[2:0],feedback};\n  end\nendmodule", "corrupted_code": "module LFSR (out, clk, rst);\n  input clk, rst;\n  output reg [3:0] out;\n  wire feedback;\n\n  assign feedback = ~(out[3] ^ out[2]);\n\nalways @(posedge clk, posedge rst)\n  begin\n    if (rst)\n      out = 4'b1;\n    else\n      out = {out[2:0],feedback};\n  end\nendmodule", "corruption_explanation": "Changed constant from 4'b0 to 4'b1", "modification_type": "change_constant", "modification_line": 11, "original_snippet": "4'b0", "modified_snippet": "4'b1", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 4'b0 to 4'b1\n   \u2022 Line 11: Original: 4'b0\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 11.\n   \u2022 Restore the original code: 4'b0\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 1, "applicable_modifications": ["change_constant", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_constant"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.059540", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "Shifter", "design_name": "LFSR", "module_name": "LFSR", "description": "Please act as a professional Verilog designer.\n\nA Linear Feedback Shift Register (LFSR) designed for generating pseudo-random sequences. This 4-bit LFSR uses a specific feedback mechanism to produce a sequence of bits that appears random.\n\nModule name:\n    LFSR\n\nInput ports:\n    clk: Clock signal to synchronize the shifting operation.\n    rst: Active high reset signal to initialize the register.\n\nOutput ports:\n    out [3:0]: 4-bit output representing the current state of the LFSR.\n\nImplementation:\nThe LFSR operates on the principle of shifting bits and applying feedback based on the XOR of specific bits in the register.\nThe feedback is calculated by XORing the most significant bit (out[3]) and the second most significant bit (out[2]). The result is inverted to produce the feedback signal.\nOn the rising edge of the clock (clk), if the reset (rst) is high, the register is initialized to zero. Otherwise, the bits in the register are shifted left, and the new feedback value is inserted at the least significant bit (LSB).\n"}, "clean_code": "module LFSR (out, clk, rst);\n  input clk, rst;\n  output reg [3:0] out;\n  wire feedback;\n\n  assign feedback = ~(out[3] ^ out[2]);\n\nalways @(posedge clk, posedge rst)\n  begin\n    if (rst)\n      out = 4'b0;\n    else\n      out = {out[2:0],feedback};\n  end\nendmodule", "corrupted_code": "module LFSR (out, clk, rst);\n  input clk, rst;\n  output reg [3:0] out;\n  wire feedback;\n\n  assign feedback = ~(out[3] ^ out[2]);\n\nalways @(posedge clk, posedge rst)\n  begin\n    if (rst)\n      out = 4'b0;\n    else\n      out <= {out[2:0],feedback};\n  end\nendmodule", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 13, "original_snippet": "out = {out[2:0],feedback};", "modified_snippet": "out <= {out[2:0],feedback};", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 1, "applicable_modifications": ["change_constant", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.060051", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "Shifter", "design_name": "LFSR", "module_name": "LFSR", "description": "Please act as a professional Verilog designer.\n\nA Linear Feedback Shift Register (LFSR) designed for generating pseudo-random sequences. This 4-bit LFSR uses a specific feedback mechanism to produce a sequence of bits that appears random.\n\nModule name:\n    LFSR\n\nInput ports:\n    clk: Clock signal to synchronize the shifting operation.\n    rst: Active high reset signal to initialize the register.\n\nOutput ports:\n    out [3:0]: 4-bit output representing the current state of the LFSR.\n\nImplementation:\nThe LFSR operates on the principle of shifting bits and applying feedback based on the XOR of specific bits in the register.\nThe feedback is calculated by XORing the most significant bit (out[3]) and the second most significant bit (out[2]). The result is inverted to produce the feedback signal.\nOn the rising edge of the clock (clk), if the reset (rst) is high, the register is initialized to zero. Otherwise, the bits in the register are shifted left, and the new feedback value is inserted at the least significant bit (LSB).\n"}, "clean_code": "module LFSR (out, clk, rst);\n  input clk, rst;\n  output reg [3:0] out;\n  wire feedback;\n\n  assign feedback = ~(out[3] ^ out[2]);\n\nalways @(posedge clk, posedge rst)\n  begin\n    if (rst)\n      out = 4'b0;\n    else\n      out = {out[2:0],feedback};\n  end\nendmodule", "corrupted_code": "module LFSR (out, clk, rst);\n  input clk, rst;\n  output reg [3:0] out;\n  wire feedback;\n\n  assign feedback = ~(out[3] ^ out[2]);\n\n\nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 8, "original_snippet": "always @(posedge clk, posedge rst)\n  begin\n    if (rst)\n      out = 4'b0;\n    else\n      out = {out[2:0],feedback};\n  end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 8: Original: always @(posedge clk, posedge rst)\n  begin\n    if (rst)\n      out = 4'b0;\n    else\n      out = {out[2:0],feedback};\n  end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 8.\n   \u2022 Restore the original code: always @(posedge clk, posedge rst)\n  begin\n    if (rst)\n      out = 4'b0;\n    else\n      out = {out[2:0],feedback};\n  end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 1, "applicable_modifications": ["change_constant", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.060815", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Memory", "subcategory": "Shifter", "design_name": "LFSR", "module_name": "LFSR", "description": "Please act as a professional Verilog designer.\n\nA Linear Feedback Shift Register (LFSR) designed for generating pseudo-random sequences. This 4-bit LFSR uses a specific feedback mechanism to produce a sequence of bits that appears random.\n\nModule name:\n    LFSR\n\nInput ports:\n    clk: Clock signal to synchronize the shifting operation.\n    rst: Active high reset signal to initialize the register.\n\nOutput ports:\n    out [3:0]: 4-bit output representing the current state of the LFSR.\n\nImplementation:\nThe LFSR operates on the principle of shifting bits and applying feedback based on the XOR of specific bits in the register.\nThe feedback is calculated by XORing the most significant bit (out[3]) and the second most significant bit (out[2]). The result is inverted to produce the feedback signal.\nOn the rising edge of the clock (clk), if the reset (rst) is high, the register is initialized to zero. Otherwise, the bits in the register are shifted left, and the new feedback value is inserted at the least significant bit (LSB).\n"}, "clean_code": "module LFSR (out, clk, rst);\n  input clk, rst;\n  output reg [3:0] out;\n  wire feedback;\n\n  assign feedback = ~(out[3] ^ out[2]);\n\nalways @(posedge clk, posedge rst)\n  begin\n    if (rst)\n      out = 4'b0;\n    else\n      out = {out[2:0],feedback};\n  end\nendmodule", "corrupted_code": "module LFSR (out, clk, rst);\n  input clk, rst;\n  output reg [3:0] out;\n  wire feedback;\n\n  assign feedback = ~(out[3] ^ out[2]);\n\nalways @(posedge clk, posedge rst)\n  begin\n    if (rst)\n      out = 4'b0;\n    else\n      out = {out[2:0],feedback};\n  end\n\n    wire clk_dup;\n    assign clk_dup = clk;\nendmodule", "corruption_explanation": "Added duplicate clock signal clk_dup", "modification_type": "duplicate_clock_signal", "modification_line": 6, "original_snippet": "(none)", "modified_snippet": "wire clk_dup;\n    assign clk_dup = clk;", "issue_description": "The buggy code has a duplicate clock signal. A phantom clock domain is created, which may confuse CDC analysis tools and create subtle timing issues in synthesis. This violates clock domain design best practices.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a duplicate_clock_signal modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added duplicate clock signal clk_dup\n   \u2022 Line 6: Original: (none)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 6.\n   \u2022 Restore the original code: (none)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to duplicate clock signal.", "complexity": 1, "applicable_modifications": ["change_constant", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["duplicate_clock_signal"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.061261", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_divbyodd", "module_name": "freq_divbyodd", "description": "Please act as a professional verilog designer.\n\nA frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n    \nOutput ports:\n    clk_div: Divided clock output.  \n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5.\nTwo counters, cnt1 and cnt2, are used for tracking the rising and falling edges of the clock. Each counter counts up to NUM_DIV - 1.\nTwo separate clock dividers, clk_div1 and clk_div2, are used for positive and negative edges of the clock, respectively. These are toggled when the counters reach half of NUM_DIV.\nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges.\nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\n\nGive me the complete code."}, "clean_code": "module freq_divbyodd(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 5;\n    reg[2:0] cnt1;\n    reg[2:0] cnt2;\n    reg    clk_div1, clk_div2;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        cnt1 <= 0;\n    else if(cnt1 < NUM_DIV - 1)\n        cnt1 <= cnt1 + 1'b1;\n    else\n        cnt1 <= 0;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div1 <= 1'b1;\n    else if(cnt1 < NUM_DIV / 2)\n        clk_div1 <= 1'b1;\n    else\n        clk_div1 <= 1'b0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n       cnt2 <= 0;\n    else if(cnt2 < NUM_DIV - 1)\n       cnt2 <= cnt2 + 1'b1;\n    else\n       cnt2 <= 0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div2 <= 1'b1;\n    else if(cnt2 < NUM_DIV / 2)\n        clk_div2 <= 1'b1;\n    else\n        clk_div2 <= 1'b0;\n\n    assign clk_div = clk_div1 | clk_div2;\nendmodule", "corrupted_code": "module freq_divbyodd(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 5;\n    reg[2:0] cnt1;\n    reg[2:0] cnt2;\n    reg    clk_div1, clk_div2;\n\nalways @(posedge clk or posedge rst_n)\n    if(!rst_n)\n        cnt1 <= 0;\n    else if(cnt1 < NUM_DIV - 1)\n        cnt1 <= cnt1 + 1'b1;\n    else\n        cnt1 <= 0;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div1 <= 1'b1;\n    else if(cnt1 < NUM_DIV / 2)\n        clk_div1 <= 1'b1;\n    else\n        clk_div1 <= 1'b0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n       cnt2 <= 0;\n    else if(cnt2 < NUM_DIV - 1)\n       cnt2 <= cnt2 + 1'b1;\n    else\n       cnt2 <= 0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div2 <= 1'b1;\n    else if(cnt2 < NUM_DIV / 2)\n        clk_div2 <= 1'b1;\n    else\n        clk_div2 <= 1'b0;\n\n    assign clk_div = clk_div1 | clk_div2;\nendmodule", "corruption_explanation": "Inverted reset polarity in sensitivity", "modification_type": "invert_reset_polarity", "modification_line": 16, "original_snippet": "always @(posedge clk or negedge rst_n)", "modified_snippet": "always @(posedge clk or posedge rst_n)", "issue_description": "The buggy code has inverted reset polarity. If the design expects active-low reset (!rst), it now uses active-high, or vice versa. This causes the reset logic to activate during normal operation and deactivate during actual reset, breaking initialization.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_reset_polarity modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted reset polarity in sensitivity\n   \u2022 Line 16: Original: always @(posedge clk or negedge rst_n)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 16.\n   \u2022 Restore the original code: always @(posedge clk or negedge rst_n)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert reset polarity.", "complexity": 23, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "invert_reset_polarity", "remove_async_reset"], "stacked_count": 1, "applied_modifications": ["invert_reset_polarity"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.064659", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_divbyodd", "module_name": "freq_divbyodd", "description": "Please act as a professional verilog designer.\n\nA frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n    \nOutput ports:\n    clk_div: Divided clock output.  \n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5.\nTwo counters, cnt1 and cnt2, are used for tracking the rising and falling edges of the clock. Each counter counts up to NUM_DIV - 1.\nTwo separate clock dividers, clk_div1 and clk_div2, are used for positive and negative edges of the clock, respectively. These are toggled when the counters reach half of NUM_DIV.\nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges.\nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\n\nGive me the complete code."}, "clean_code": "module freq_divbyodd(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 5;\n    reg[2:0] cnt1;\n    reg[2:0] cnt2;\n    reg    clk_div1, clk_div2;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        cnt1 <= 0;\n    else if(cnt1 < NUM_DIV - 1)\n        cnt1 <= cnt1 + 1'b1;\n    else\n        cnt1 <= 0;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div1 <= 1'b1;\n    else if(cnt1 < NUM_DIV / 2)\n        clk_div1 <= 1'b1;\n    else\n        clk_div1 <= 1'b0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n       cnt2 <= 0;\n    else if(cnt2 < NUM_DIV - 1)\n       cnt2 <= cnt2 + 1'b1;\n    else\n       cnt2 <= 0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div2 <= 1'b1;\n    else if(cnt2 < NUM_DIV / 2)\n        clk_div2 <= 1'b1;\n    else\n        clk_div2 <= 1'b0;\n\n    assign clk_div = clk_div1 | clk_div2;\nendmodule", "corrupted_code": "module freq_divbyodd(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 5;\n    reg[2:0] cnt1;\n    reg[2:0] cnt2;\n    reg    clk_div1, clk_div2;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        cnt1 <= 0;\n    else if(cnt1 < NUM_DIV - 1)\n        cnt1 <= cnt1 + 1'b1;\n    else\n        cnt1 <= 0;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div1 <= 1'b1;\n    else if(cnt1 < NUM_DIV / 2)\n        clk_div1 <= 1'b1;\n    else\n        clk_div1 <= 1'b0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n       cnt2 <= 0;\n    else if(cnt2 < NUM_DIV - 1)\n       cnt2 <= cnt2 + 1'b1;\n    else\n       cnt2 <= 0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div2 >= 1'b1;\n    else if(cnt2 < NUM_DIV / 2)\n        clk_div2 <= 1'b1;\n    else\n        clk_div2 <= 1'b0;\n\n    assign clk_div = clk_div1 | clk_div2;\nendmodule", "corruption_explanation": "Changed operator from '<=' to '>='", "modification_type": "change_operator", "modification_line": 42, "original_snippet": "2 <= 1", "modified_snippet": "2 >= 1", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '<=' to '>='\n   \u2022 Line 42: Original: 2 <= 1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 42.\n   \u2022 Restore the original code: 2 <= 1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 23, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "invert_reset_polarity", "remove_async_reset"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.066154", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_divbyodd", "module_name": "freq_divbyodd", "description": "Please act as a professional verilog designer.\n\nA frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n    \nOutput ports:\n    clk_div: Divided clock output.  \n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5.\nTwo counters, cnt1 and cnt2, are used for tracking the rising and falling edges of the clock. Each counter counts up to NUM_DIV - 1.\nTwo separate clock dividers, clk_div1 and clk_div2, are used for positive and negative edges of the clock, respectively. These are toggled when the counters reach half of NUM_DIV.\nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges.\nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\n\nGive me the complete code."}, "clean_code": "module freq_divbyodd(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 5;\n    reg[2:0] cnt1;\n    reg[2:0] cnt2;\n    reg    clk_div1, clk_div2;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        cnt1 <= 0;\n    else if(cnt1 < NUM_DIV - 1)\n        cnt1 <= cnt1 + 1'b1;\n    else\n        cnt1 <= 0;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div1 <= 1'b1;\n    else if(cnt1 < NUM_DIV / 2)\n        clk_div1 <= 1'b1;\n    else\n        clk_div1 <= 1'b0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n       cnt2 <= 0;\n    else if(cnt2 < NUM_DIV - 1)\n       cnt2 <= cnt2 + 1'b1;\n    else\n       cnt2 <= 0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div2 <= 1'b1;\n    else if(cnt2 < NUM_DIV / 2)\n        clk_div2 <= 1'b1;\n    else\n        clk_div2 <= 1'b0;\n\n    assign clk_div = clk_div1 | clk_div2;\nendmodule", "corrupted_code": "module freq_divbyodd(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 5;\n    reg[2:0] cnt1;\n    reg[2:0] cnt2;\n    reg    clk_div1, clk_div2;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        cnt1 <= 0;\n    else if(cnt1 < NUM_DIV - 1)\n        cnt1 <= cnt1 + 1'b1;\n    else\n        cnt1 <= 0;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div1 <= 1'b1;\n    else if(cnt1 < NUM_DIV / 2)\n        clk_div1 <= 1'b1;\n    else\n        clk_div1 <= 1'b0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n       cnt2 <= 0;\n    else if(cnt2 < NUM_DIV - 1)\n       cnt2 = cnt2 + 1'b1;\n    else\n       cnt2 <= 0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div2 <= 1'b1;\n    else if(cnt2 < NUM_DIV / 2)\n        clk_div2 <= 1'b1;\n    else\n        clk_div2 <= 1'b0;\n\n    assign clk_div = clk_div1 | clk_div2;\nendmodule", "corruption_explanation": "Changed non-blocking (<=) to blocking (=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 36, "original_snippet": "cnt2 <= cnt2 + 1'b1;", "modified_snippet": "cnt2 = cnt2 + 1'b1;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 23, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "invert_reset_polarity", "remove_async_reset"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.067863", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_divbyodd", "module_name": "freq_divbyodd", "description": "Please act as a professional verilog designer.\n\nA frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n    \nOutput ports:\n    clk_div: Divided clock output.  \n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5.\nTwo counters, cnt1 and cnt2, are used for tracking the rising and falling edges of the clock. Each counter counts up to NUM_DIV - 1.\nTwo separate clock dividers, clk_div1 and clk_div2, are used for positive and negative edges of the clock, respectively. These are toggled when the counters reach half of NUM_DIV.\nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges.\nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\n\nGive me the complete code."}, "clean_code": "module freq_divbyodd(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 5;\n    reg[2:0] cnt1;\n    reg[2:0] cnt2;\n    reg    clk_div1, clk_div2;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        cnt1 <= 0;\n    else if(cnt1 < NUM_DIV - 1)\n        cnt1 <= cnt1 + 1'b1;\n    else\n        cnt1 <= 0;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div1 <= 1'b1;\n    else if(cnt1 < NUM_DIV / 2)\n        clk_div1 <= 1'b1;\n    else\n        clk_div1 <= 1'b0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n       cnt2 <= 0;\n    else if(cnt2 < NUM_DIV - 1)\n       cnt2 <= cnt2 + 1'b1;\n    else\n       cnt2 <= 0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div2 <= 1'b1;\n    else if(cnt2 < NUM_DIV / 2)\n        clk_div2 <= 1'b1;\n    else\n        clk_div2 <= 1'b0;\n\n    assign clk_div = clk_div1 | clk_div2;\nendmodule", "corrupted_code": "module freq_divbyodd(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 5;\n    reg[2:0] cnt1;\n    reg[2:0] cnt2;\n    reg    clk_div1, clk_div2;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        cnt1 <= 0;\n    else if(cnt1 < NUM_DIV - 1)\n        cnt1 <= cnt1 + 1'b1;\n    else\n        cnt1 <= 0;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div1 <= 1'b1;\n    else if(cnt1 < NUM_DIV / 2)\n        clk_div1 <= 1'b1;\n    else\n        1 <= clk_div1'b0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n       cnt2 <= 0;\n    else if(cnt2 < NUM_DIV - 1)\n       cnt2 <= cnt2 + 1'b1;\n    else\n       cnt2 <= 0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div2 <= 1'b1;\n    else if(cnt2 < NUM_DIV / 2)\n        clk_div2 <= 1'b1;\n    else\n        clk_div2 <= 1'b0;\n\n    assign clk_div = clk_div1 | clk_div2;\nendmodule", "corruption_explanation": "Swapped operands: 'clk_div1 <= 1' -> '1 <= clk_div1'", "modification_type": "swap_operands", "modification_line": 30, "original_snippet": "clk_div1 <= 1", "modified_snippet": "1 <= clk_div1", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'clk_div1 <= 1' -> '1 <= clk_div1'\n   \u2022 Line 30: Original: clk_div1 <= 1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 30.\n   \u2022 Restore the original code: clk_div1 <= 1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 23, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "invert_reset_polarity", "remove_async_reset"], "stacked_count": 1, "applied_modifications": ["swap_operands"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.069381", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_divbyodd", "module_name": "freq_divbyodd", "description": "Please act as a professional verilog designer.\n\nA frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n    \nOutput ports:\n    clk_div: Divided clock output.  \n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5.\nTwo counters, cnt1 and cnt2, are used for tracking the rising and falling edges of the clock. Each counter counts up to NUM_DIV - 1.\nTwo separate clock dividers, clk_div1 and clk_div2, are used for positive and negative edges of the clock, respectively. These are toggled when the counters reach half of NUM_DIV.\nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges.\nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\n\nGive me the complete code."}, "clean_code": "module freq_divbyodd(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 5;\n    reg[2:0] cnt1;\n    reg[2:0] cnt2;\n    reg    clk_div1, clk_div2;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        cnt1 <= 0;\n    else if(cnt1 < NUM_DIV - 1)\n        cnt1 <= cnt1 + 1'b1;\n    else\n        cnt1 <= 0;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div1 <= 1'b1;\n    else if(cnt1 < NUM_DIV / 2)\n        clk_div1 <= 1'b1;\n    else\n        clk_div1 <= 1'b0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n       cnt2 <= 0;\n    else if(cnt2 < NUM_DIV - 1)\n       cnt2 <= cnt2 + 1'b1;\n    else\n       cnt2 <= 0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div2 <= 1'b1;\n    else if(cnt2 < NUM_DIV / 2)\n        clk_div2 <= 1'b1;\n    else\n        clk_div2 <= 1'b0;\n\n    assign clk_div = clk_div1 | clk_div2;\nendmodule", "corrupted_code": "module freq_divbyodd(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 5;\n    reg[2:0] cnt1;\n    reg[2:0] cnt2;\n    reg    clk_div1, clk_div2;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        cnt1 <= 0;\n    else if(cnt1 < NUM_DIV - 1)\n        cnt1 <= cnt1 + 1'b1;\n    else\n        cnt1 <= 0;\n\nalways @(posedge clk)\n    if(!rst_n)\n        clk_div1 <= 1'b1;\n    else if(cnt1 < NUM_DIV / 2)\n        clk_div1 <= 1'b1;\n    else\n        clk_div1 <= 1'b0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n       cnt2 <= 0;\n    else if(cnt2 < NUM_DIV - 1)\n       cnt2 <= cnt2 + 1'b1;\n    else\n       cnt2 <= 0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div2 <= 1'b1;\n    else if(cnt2 < NUM_DIV / 2)\n        clk_div2 <= 1'b1;\n    else\n        clk_div2 <= 1'b0;\n\n    assign clk_div = clk_div1 | clk_div2;\nendmodule", "corruption_explanation": "Removed async reset from sensitivity list", "modification_type": "remove_async_reset", "modification_line": 24, "original_snippet": "always @(posedge clk or negedge rst_n)", "modified_snippet": "always @(posedge clk)", "issue_description": "The buggy code has removed async reset from the sensitivity list. The always block only triggers on clock edges, not reset. This causes metastability on power-up and removes the ability to asynchronously reset the design.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_async_reset modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed async reset from sensitivity list\n   \u2022 Line 24: Original: always @(posedge clk or negedge rst_n)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 24.\n   \u2022 Restore the original code: always @(posedge clk or negedge rst_n)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove async reset.", "complexity": 23, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "invert_reset_polarity", "remove_async_reset"], "stacked_count": 1, "applied_modifications": ["remove_async_reset"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.070983", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_divbyodd", "module_name": "freq_divbyodd", "description": "Please act as a professional verilog designer.\n\nA frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n    \nOutput ports:\n    clk_div: Divided clock output.  \n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5.\nTwo counters, cnt1 and cnt2, are used for tracking the rising and falling edges of the clock. Each counter counts up to NUM_DIV - 1.\nTwo separate clock dividers, clk_div1 and clk_div2, are used for positive and negative edges of the clock, respectively. These are toggled when the counters reach half of NUM_DIV.\nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges.\nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\n\nGive me the complete code."}, "clean_code": "module freq_divbyodd(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 5;\n    reg[2:0] cnt1;\n    reg[2:0] cnt2;\n    reg    clk_div1, clk_div2;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        cnt1 <= 0;\n    else if(cnt1 < NUM_DIV - 1)\n        cnt1 <= cnt1 + 1'b1;\n    else\n        cnt1 <= 0;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div1 <= 1'b1;\n    else if(cnt1 < NUM_DIV / 2)\n        clk_div1 <= 1'b1;\n    else\n        clk_div1 <= 1'b0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n       cnt2 <= 0;\n    else if(cnt2 < NUM_DIV - 1)\n       cnt2 <= cnt2 + 1'b1;\n    else\n       cnt2 <= 0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div2 <= 1'b1;\n    else if(cnt2 < NUM_DIV / 2)\n        clk_div2 <= 1'b1;\n    else\n        clk_div2 <= 1'b0;\n\n    assign clk_div = clk_div1 | clk_div2;\nendmodule", "corrupted_code": "module freq_divbyodd(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 5;\n    reg[2:0] cnt1;\n    reg[2:0] cnt2;\n    reg    clk_div1, clk_div2;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        cnt1 <= 0;\n    else if(cnt1 < NUM_DIV - 1)\n        cnt1 <= cnt1 + 1'b1;\n    else\n        cnt1 <= 0;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div1 <= 1'b1;\n    else if(cnt1 < NUM_DIV / 2)\n        clk_div1 <= 1'b1;\n    else\n        clk_div1 <= 1'b0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n       cnt2 <= 0;\n    else if(cnt2 < NUM_DIV - 1)\n       cnt2 >= cnt2 + 1'b1;\n    else\n       cnt2 <= 0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div2 <= 1'b1;\n    else if(cnt2 < NUM_DIV / 2)\n        clk_div2 <= 1'b1;\n    else\n        clk_div2 <= 1'b0;\n\n    assign clk_div = clk_div1 | clk_div2;\nendmodule", "corruption_explanation": "Changed operator from '<=' to '>='", "modification_type": "change_operator", "modification_line": 36, "original_snippet": "2 <= c", "modified_snippet": "2 >= c", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '<=' to '>='\n   \u2022 Line 36: Original: 2 <= c\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 36.\n   \u2022 Restore the original code: 2 <= c\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 23, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "invert_reset_polarity", "remove_async_reset"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.072774", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_divbyodd", "module_name": "freq_divbyodd", "description": "Please act as a professional verilog designer.\n\nA frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n    \nOutput ports:\n    clk_div: Divided clock output.  \n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5.\nTwo counters, cnt1 and cnt2, are used for tracking the rising and falling edges of the clock. Each counter counts up to NUM_DIV - 1.\nTwo separate clock dividers, clk_div1 and clk_div2, are used for positive and negative edges of the clock, respectively. These are toggled when the counters reach half of NUM_DIV.\nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges.\nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\n\nGive me the complete code."}, "clean_code": "module freq_divbyodd(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 5;\n    reg[2:0] cnt1;\n    reg[2:0] cnt2;\n    reg    clk_div1, clk_div2;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        cnt1 <= 0;\n    else if(cnt1 < NUM_DIV - 1)\n        cnt1 <= cnt1 + 1'b1;\n    else\n        cnt1 <= 0;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div1 <= 1'b1;\n    else if(cnt1 < NUM_DIV / 2)\n        clk_div1 <= 1'b1;\n    else\n        clk_div1 <= 1'b0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n       cnt2 <= 0;\n    else if(cnt2 < NUM_DIV - 1)\n       cnt2 <= cnt2 + 1'b1;\n    else\n       cnt2 <= 0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div2 <= 1'b1;\n    else if(cnt2 < NUM_DIV / 2)\n        clk_div2 <= 1'b1;\n    else\n        clk_div2 <= 1'b0;\n\n    assign clk_div = clk_div1 | clk_div2;\nendmodule", "corrupted_code": "module freq_divbyodd(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 5;\n    reg[2:0] cnt1;\n    reg[2:0] cnt2;\n    reg    clk_div1, clk_div2;\n\nalways @(posedge clk or negedge rst_n)\n    if (rst_n)\n        cnt1 <= 0;\n    else if(cnt1 < NUM_DIV - 1)\n        cnt1 <= cnt1 + 1'b1;\n    else\n        cnt1 <= 0;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div1 <= 1'b1;\n    else if(cnt1 < NUM_DIV / 2)\n        clk_div1 <= 1'b1;\n    else\n        clk_div1 <= 1'b0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n       cnt2 <= 0;\n    else if(cnt2 < NUM_DIV - 1)\n       cnt2 <= cnt2 + 1'b1;\n    else\n       cnt2 <= 0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div2 <= 1'b1;\n    else if(cnt2 < NUM_DIV / 2)\n        clk_div2 <= 1'b1;\n    else\n        clk_div2 <= 1'b0;\n\n    assign clk_div = clk_div1 | clk_div2;\nendmodule", "corruption_explanation": "Inverted reset polarity in condition", "modification_type": "invert_reset_polarity", "modification_line": 17, "original_snippet": "if(!rst_n)", "modified_snippet": "if (rst_n)", "issue_description": "The buggy code has inverted reset polarity. If the design expects active-low reset (!rst), it now uses active-high, or vice versa. This causes the reset logic to activate during normal operation and deactivate during actual reset, breaking initialization.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_reset_polarity modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted reset polarity in condition\n   \u2022 Line 17: Original: if(!rst_n)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 17.\n   \u2022 Restore the original code: if(!rst_n)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert reset polarity.", "complexity": 23, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "invert_reset_polarity", "remove_async_reset"], "stacked_count": 1, "applied_modifications": ["invert_reset_polarity"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.074398", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_divbyodd", "module_name": "freq_divbyodd", "description": "Please act as a professional verilog designer.\n\nA frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n    \nOutput ports:\n    clk_div: Divided clock output.  \n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5.\nTwo counters, cnt1 and cnt2, are used for tracking the rising and falling edges of the clock. Each counter counts up to NUM_DIV - 1.\nTwo separate clock dividers, clk_div1 and clk_div2, are used for positive and negative edges of the clock, respectively. These are toggled when the counters reach half of NUM_DIV.\nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges.\nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\n\nGive me the complete code."}, "clean_code": "module freq_divbyodd(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 5;\n    reg[2:0] cnt1;\n    reg[2:0] cnt2;\n    reg    clk_div1, clk_div2;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        cnt1 <= 0;\n    else if(cnt1 < NUM_DIV - 1)\n        cnt1 <= cnt1 + 1'b1;\n    else\n        cnt1 <= 0;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div1 <= 1'b1;\n    else if(cnt1 < NUM_DIV / 2)\n        clk_div1 <= 1'b1;\n    else\n        clk_div1 <= 1'b0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n       cnt2 <= 0;\n    else if(cnt2 < NUM_DIV - 1)\n       cnt2 <= cnt2 + 1'b1;\n    else\n       cnt2 <= 0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div2 <= 1'b1;\n    else if(cnt2 < NUM_DIV / 2)\n        clk_div2 <= 1'b1;\n    else\n        clk_div2 <= 1'b0;\n\n    assign clk_div = clk_div1 | clk_div2;\nendmodule", "corrupted_code": "module freq_divbyodd(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 5;\n    reg[2:0] cnt1;\n    reg[2:0] cnt2;\n    reg    clk_div1, clk_div2;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        cnt1 <= 0;\n    else if(cnt1 < NUM_DIV - 1)\n        cnt1 <= cnt1 + 1'b1;\n    else\n        cnt1 <= 0;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div1 <= 1'b1;\n    else if(cnt1 < NUM_DIV / 2)\n        clk_div1 <= 1'b1;\n    else\n        clk_div1 <= 1'b0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n       cnt2 <= 0;\n    else if(cnt2 < NUM_DIV - 1)\n       cnt2 <= cnt2 + 1'b1;\n    else\n       cnt2 <= 0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div2 <= 1'b1;\n    else if(cnt2 < NUM_DIV * 2)\n        clk_div2 <= 1'b1;\n    else\n        clk_div2 <= 1'b0;\n\n    assign clk_div = clk_div1 | clk_div2;\nendmodule", "corruption_explanation": "Changed operator from '/' to '*'", "modification_type": "change_operator", "modification_line": 43, "original_snippet": "/", "modified_snippet": "*", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '/' to '*'\n   \u2022 Line 43: Original: /\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 43.\n   \u2022 Restore the original code: /\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 23, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "invert_reset_polarity", "remove_async_reset"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.076205", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_divbyodd", "module_name": "freq_divbyodd", "description": "Please act as a professional verilog designer.\n\nA frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n    \nOutput ports:\n    clk_div: Divided clock output.  \n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5.\nTwo counters, cnt1 and cnt2, are used for tracking the rising and falling edges of the clock. Each counter counts up to NUM_DIV - 1.\nTwo separate clock dividers, clk_div1 and clk_div2, are used for positive and negative edges of the clock, respectively. These are toggled when the counters reach half of NUM_DIV.\nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges.\nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\n\nGive me the complete code."}, "clean_code": "module freq_divbyodd(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 5;\n    reg[2:0] cnt1;\n    reg[2:0] cnt2;\n    reg    clk_div1, clk_div2;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        cnt1 <= 0;\n    else if(cnt1 < NUM_DIV - 1)\n        cnt1 <= cnt1 + 1'b1;\n    else\n        cnt1 <= 0;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div1 <= 1'b1;\n    else if(cnt1 < NUM_DIV / 2)\n        clk_div1 <= 1'b1;\n    else\n        clk_div1 <= 1'b0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n       cnt2 <= 0;\n    else if(cnt2 < NUM_DIV - 1)\n       cnt2 <= cnt2 + 1'b1;\n    else\n       cnt2 <= 0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div2 <= 1'b1;\n    else if(cnt2 < NUM_DIV / 2)\n        clk_div2 <= 1'b1;\n    else\n        clk_div2 <= 1'b0;\n\n    assign clk_div = clk_div1 | clk_div2;\nendmodule", "corrupted_code": "module freq_divbyodd(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 5;\n    reg[2:0] cnt1;\n    reg[2:0] cnt2;\n    reg    clk_div1, clk_div2;\n\nalways @(posedge clk or posedge rst_n)\n    if(!rst_n)\n        cnt1 <= 0;\n    else if(cnt1 < NUM_DIV - 1)\n        cnt1 <= cnt1 + 1'b1;\n    else\n        cnt1 <= 0;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div1 <= 1'b1;\n    else if(cnt1 < NUM_DIV / 2)\n        clk_div1 <= 1'b1;\n    else\n        clk_div1 <= 1'b0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n       cnt2 <= 0;\n    else if(cnt2 < NUM_DIV - 1)\n       cnt2 <= cnt2 + 1'b1;\n    else\n       cnt2 <= 0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div2 <= 1'b1;\n    else if(cnt2 < NUM_DIV / 2)\n        clk_div2 <= 1'b1;\n    else\n        clk_div2 <= 1'b0;\n\n    assign clk_div = clk_div1 | clk_div2;\nendmodule", "corruption_explanation": "Inverted reset polarity in sensitivity", "modification_type": "invert_reset_polarity", "modification_line": 16, "original_snippet": "always @(posedge clk or negedge rst_n)", "modified_snippet": "always @(posedge clk or posedge rst_n)", "issue_description": "The buggy code has inverted reset polarity. If the design expects active-low reset (!rst), it now uses active-high, or vice versa. This causes the reset logic to activate during normal operation and deactivate during actual reset, breaking initialization.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_reset_polarity modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted reset polarity in sensitivity\n   \u2022 Line 16: Original: always @(posedge clk or negedge rst_n)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 16.\n   \u2022 Restore the original code: always @(posedge clk or negedge rst_n)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert reset polarity.", "complexity": 23, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "invert_reset_polarity", "remove_async_reset"], "stacked_count": 1, "applied_modifications": ["invert_reset_polarity"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.077838", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_divbyodd", "module_name": "freq_divbyodd", "description": "Please act as a professional verilog designer.\n\nA frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n    \nOutput ports:\n    clk_div: Divided clock output.  \n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5.\nTwo counters, cnt1 and cnt2, are used for tracking the rising and falling edges of the clock. Each counter counts up to NUM_DIV - 1.\nTwo separate clock dividers, clk_div1 and clk_div2, are used for positive and negative edges of the clock, respectively. These are toggled when the counters reach half of NUM_DIV.\nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges.\nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\n\nGive me the complete code."}, "clean_code": "module freq_divbyodd(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 5;\n    reg[2:0] cnt1;\n    reg[2:0] cnt2;\n    reg    clk_div1, clk_div2;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        cnt1 <= 0;\n    else if(cnt1 < NUM_DIV - 1)\n        cnt1 <= cnt1 + 1'b1;\n    else\n        cnt1 <= 0;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div1 <= 1'b1;\n    else if(cnt1 < NUM_DIV / 2)\n        clk_div1 <= 1'b1;\n    else\n        clk_div1 <= 1'b0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n       cnt2 <= 0;\n    else if(cnt2 < NUM_DIV - 1)\n       cnt2 <= cnt2 + 1'b1;\n    else\n       cnt2 <= 0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div2 <= 1'b1;\n    else if(cnt2 < NUM_DIV / 2)\n        clk_div2 <= 1'b1;\n    else\n        clk_div2 <= 1'b0;\n\n    assign clk_div = clk_div1 | clk_div2;\nendmodule", "corrupted_code": "module freq_divbyodd(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 5;\n    reg[2:1] cnt1;\n    reg[2:0] cnt2;\n    reg    clk_div1, clk_div2;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        cnt1 <= 0;\n    else if(cnt1 < NUM_DIV - 1)\n        cnt1 <= cnt1 + 1'b1;\n    else\n        cnt1 <= 0;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div1 <= 1'b1;\n    else if(cnt1 < NUM_DIV / 2)\n        clk_div1 <= 1'b1;\n    else\n        clk_div1 <= 1'b0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n       cnt2 <= 0;\n    else if(cnt2 < NUM_DIV - 1)\n       cnt2 <= cnt2 + 1'b1;\n    else\n       cnt2 <= 0;\n\nalways @(negedge clk or negedge rst_n)\n    if(!rst_n)\n        clk_div2 <= 1'b1;\n    else if(cnt2 < NUM_DIV / 2)\n        clk_div2 <= 1'b1;\n    else\n        clk_div2 <= 1'b0;\n\n    assign clk_div = clk_div1 | clk_div2;\nendmodule", "corruption_explanation": "Changed bit width from [2:0] to [2:1]", "modification_type": "change_bit_width", "modification_line": 12, "original_snippet": "[2:0]", "modified_snippet": "[2:1]", "issue_description": "The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_bit_width modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed bit width from [2:0] to [2:1]\n   \u2022 Line 12: Original: [2:0]\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 12.\n   \u2022 Restore the original code: [2:0]\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change bit width.", "complexity": 23, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "invert_reset_polarity", "remove_async_reset"], "stacked_count": 1, "applied_modifications": ["change_bit_width"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.079457", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_div", "module_name": "freq_div", "description": "Please act as a professional verilog designer.\n\nImplement a frequency divider that the input clock frequency of 100MHz signal, and the outputs are 3 clock frequencies: 50MHz, 10MHz, 1MHz.\n\nModule name:  \n    freq_div      \n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three counters to divide the input clock frequency. \nCLK_50 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_50 is set to 0.\nOtherwise, CLK_50 is toggled by inverting its current value.\nCLK_10 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_10 is set to 0, and the counter cnt_10 is reset to 0.\nIf the counter cnt_10 reaches a value of 4, CLK_10 is toggled by inverting its current value, and the counter cnt_10 is reset to 0.\nOtherwise, the counter cnt_10 is incremented by 1.\nCLK_1 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_1 is set to 0, and the counter cnt_100 is reset to 0.\nIf the counter cnt_100 reaches a value of 49, CLK_1 is toggled by inverting its current value, and the counter cnt_100 is reset to 0.\nOtherwise, the counter cnt_100 is incremented by 1.\n\nGive me the complete code.\n"}, "clean_code": "module freq_div (CLK_in,CLK_50,CLK_10,CLK_1,RST);\ninput CLK_in,RST;\noutput reg CLK_50,CLK_10,CLK_1;\n\nreg [3:0] cnt_10;\nreg [6:0] cnt_100;\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_50<= 1'b0;\n        end\n\telse begin\n\t\tCLK_50<= ~CLK_50;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_10<= 1'b0;\n                cnt_10<=0;\n        end\n\telse if (cnt_10==4) begin\n\t\tCLK_10<= ~CLK_10;\n                cnt_10<=0;\n        end\n        else begin\n                cnt_10<=cnt_10+1;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_1<= 1'b0;\n                cnt_100<=0;\n        end\n\telse if (cnt_100==49) begin\n\t\tCLK_1<= ~CLK_1;\n                cnt_100<=0;\n        end\n        else begin\n                cnt_100<=cnt_100+1;\n        end\nend\n\nendmodule", "corrupted_code": "module freq_div (CLK_in,CLK_50,CLK_10,CLK_1,RST);\ninput CLK_in,RST;\noutput reg CLK_50,CLK_10,CLK_1;\n\nreg [3:0] cnt_10;\nreg [6:0] cnt_100;\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\t1 <= CLK_50'b0;\n        end\n\telse begin\n\t\tCLK_50<= ~CLK_50;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_10<= 1'b0;\n                cnt_10<=0;\n        end\n\telse if (cnt_10==4) begin\n\t\tCLK_10<= ~CLK_10;\n                cnt_10<=0;\n        end\n        else begin\n                cnt_10<=cnt_10+1;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_1<= 1'b0;\n                cnt_100<=0;\n        end\n\telse if (cnt_100==49) begin\n\t\tCLK_1<= ~CLK_1;\n                cnt_100<=0;\n        end\n        else begin\n                cnt_100<=cnt_100+1;\n        end\nend\n\nendmodule", "corruption_explanation": "Swapped operands: 'CLK_50 <= 1' -> '1 <= CLK_50'", "modification_type": "swap_operands", "modification_line": 10, "original_snippet": "CLK_50<= 1", "modified_snippet": "1 <= CLK_50", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'CLK_50 <= 1' -> '1 <= CLK_50'\n   \u2022 Line 10: Original: CLK_50<= 1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 10.\n   \u2022 Restore the original code: CLK_50<= 1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 21, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_operands"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.082907", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_div", "module_name": "freq_div", "description": "Please act as a professional verilog designer.\n\nImplement a frequency divider that the input clock frequency of 100MHz signal, and the outputs are 3 clock frequencies: 50MHz, 10MHz, 1MHz.\n\nModule name:  \n    freq_div      \n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three counters to divide the input clock frequency. \nCLK_50 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_50 is set to 0.\nOtherwise, CLK_50 is toggled by inverting its current value.\nCLK_10 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_10 is set to 0, and the counter cnt_10 is reset to 0.\nIf the counter cnt_10 reaches a value of 4, CLK_10 is toggled by inverting its current value, and the counter cnt_10 is reset to 0.\nOtherwise, the counter cnt_10 is incremented by 1.\nCLK_1 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_1 is set to 0, and the counter cnt_100 is reset to 0.\nIf the counter cnt_100 reaches a value of 49, CLK_1 is toggled by inverting its current value, and the counter cnt_100 is reset to 0.\nOtherwise, the counter cnt_100 is incremented by 1.\n\nGive me the complete code.\n"}, "clean_code": "module freq_div (CLK_in,CLK_50,CLK_10,CLK_1,RST);\ninput CLK_in,RST;\noutput reg CLK_50,CLK_10,CLK_1;\n\nreg [3:0] cnt_10;\nreg [6:0] cnt_100;\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_50<= 1'b0;\n        end\n\telse begin\n\t\tCLK_50<= ~CLK_50;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_10<= 1'b0;\n                cnt_10<=0;\n        end\n\telse if (cnt_10==4) begin\n\t\tCLK_10<= ~CLK_10;\n                cnt_10<=0;\n        end\n        else begin\n                cnt_10<=cnt_10+1;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_1<= 1'b0;\n                cnt_100<=0;\n        end\n\telse if (cnt_100==49) begin\n\t\tCLK_1<= ~CLK_1;\n                cnt_100<=0;\n        end\n        else begin\n                cnt_100<=cnt_100+1;\n        end\nend\n\nendmodule", "corrupted_code": "module freq_div (CLK_in,CLK_50,CLK_10,CLK_1,RST);\ninput CLK_in,RST;\noutput reg CLK_50,CLK_10,CLK_1;\n\nreg [3:0] cnt_10;\nreg [6:0] cnt_100;\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_50 = 1'b0;\n        end\n\telse begin\n\t\tCLK_50<= ~CLK_50;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_10<= 1'b0;\n                cnt_10<=0;\n        end\n\telse if (cnt_10==4) begin\n\t\tCLK_10<= ~CLK_10;\n                cnt_10<=0;\n        end\n        else begin\n                cnt_10<=cnt_10+1;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_1<= 1'b0;\n                cnt_100<=0;\n        end\n\telse if (cnt_100==49) begin\n\t\tCLK_1<= ~CLK_1;\n                cnt_100<=0;\n        end\n        else begin\n                cnt_100<=cnt_100+1;\n        end\nend\n\nendmodule", "corruption_explanation": "Changed non-blocking (<=) to blocking (=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 10, "original_snippet": "CLK_50<= 1'b0;", "modified_snippet": "CLK_50 = 1'b0;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 21, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.084710", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_div", "module_name": "freq_div", "description": "Please act as a professional verilog designer.\n\nImplement a frequency divider that the input clock frequency of 100MHz signal, and the outputs are 3 clock frequencies: 50MHz, 10MHz, 1MHz.\n\nModule name:  \n    freq_div      \n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three counters to divide the input clock frequency. \nCLK_50 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_50 is set to 0.\nOtherwise, CLK_50 is toggled by inverting its current value.\nCLK_10 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_10 is set to 0, and the counter cnt_10 is reset to 0.\nIf the counter cnt_10 reaches a value of 4, CLK_10 is toggled by inverting its current value, and the counter cnt_10 is reset to 0.\nOtherwise, the counter cnt_10 is incremented by 1.\nCLK_1 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_1 is set to 0, and the counter cnt_100 is reset to 0.\nIf the counter cnt_100 reaches a value of 49, CLK_1 is toggled by inverting its current value, and the counter cnt_100 is reset to 0.\nOtherwise, the counter cnt_100 is incremented by 1.\n\nGive me the complete code.\n"}, "clean_code": "module freq_div (CLK_in,CLK_50,CLK_10,CLK_1,RST);\ninput CLK_in,RST;\noutput reg CLK_50,CLK_10,CLK_1;\n\nreg [3:0] cnt_10;\nreg [6:0] cnt_100;\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_50<= 1'b0;\n        end\n\telse begin\n\t\tCLK_50<= ~CLK_50;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_10<= 1'b0;\n                cnt_10<=0;\n        end\n\telse if (cnt_10==4) begin\n\t\tCLK_10<= ~CLK_10;\n                cnt_10<=0;\n        end\n        else begin\n                cnt_10<=cnt_10+1;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_1<= 1'b0;\n                cnt_100<=0;\n        end\n\telse if (cnt_100==49) begin\n\t\tCLK_1<= ~CLK_1;\n                cnt_100<=0;\n        end\n        else begin\n                cnt_100<=cnt_100+1;\n        end\nend\n\nendmodule", "corrupted_code": "module freq_div (CLK_in,CLK_50,CLK_10,CLK_1,RST);\ninput CLK_in,RST;\noutput reg CLK_50,CLK_10,CLK_1;\n\nreg [3:0] cnt_10;\nreg [6:0] cnt_100;\n\nalways @(CLK_in or RST) begin\n\tif (RST) begin\n\t\tCLK_50<= 1'b0;\n        end\n\telse begin\n\t\tCLK_50<= ~CLK_50;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_10<= 1'b0;\n                cnt_10<=0;\n        end\n\telse if (cnt_10==4) begin\n\t\tCLK_10<= ~CLK_10;\n                cnt_10<=0;\n        end\n        else begin\n                cnt_10<=cnt_10+1;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_1<= 1'b0;\n                cnt_100<=0;\n        end\n\telse if (cnt_100==49) begin\n\t\tCLK_1<= ~CLK_1;\n                cnt_100<=0;\n        end\n        else begin\n                cnt_100<=cnt_100+1;\n        end\nend\n\nendmodule", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 8, "original_snippet": "always @(posedge CLK_in or posedge RST)", "modified_snippet": "always @(CLK_in or RST)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 8: Original: always @(posedge CLK_in or posedge RST)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 8.\n   \u2022 Restore the original code: always @(posedge CLK_in or posedge RST)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 21, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_sensitivity_list"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.086362", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_div", "module_name": "freq_div", "description": "Please act as a professional verilog designer.\n\nImplement a frequency divider that the input clock frequency of 100MHz signal, and the outputs are 3 clock frequencies: 50MHz, 10MHz, 1MHz.\n\nModule name:  \n    freq_div      \n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three counters to divide the input clock frequency. \nCLK_50 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_50 is set to 0.\nOtherwise, CLK_50 is toggled by inverting its current value.\nCLK_10 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_10 is set to 0, and the counter cnt_10 is reset to 0.\nIf the counter cnt_10 reaches a value of 4, CLK_10 is toggled by inverting its current value, and the counter cnt_10 is reset to 0.\nOtherwise, the counter cnt_10 is incremented by 1.\nCLK_1 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_1 is set to 0, and the counter cnt_100 is reset to 0.\nIf the counter cnt_100 reaches a value of 49, CLK_1 is toggled by inverting its current value, and the counter cnt_100 is reset to 0.\nOtherwise, the counter cnt_100 is incremented by 1.\n\nGive me the complete code.\n"}, "clean_code": "module freq_div (CLK_in,CLK_50,CLK_10,CLK_1,RST);\ninput CLK_in,RST;\noutput reg CLK_50,CLK_10,CLK_1;\n\nreg [3:0] cnt_10;\nreg [6:0] cnt_100;\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_50<= 1'b0;\n        end\n\telse begin\n\t\tCLK_50<= ~CLK_50;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_10<= 1'b0;\n                cnt_10<=0;\n        end\n\telse if (cnt_10==4) begin\n\t\tCLK_10<= ~CLK_10;\n                cnt_10<=0;\n        end\n        else begin\n                cnt_10<=cnt_10+1;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_1<= 1'b0;\n                cnt_100<=0;\n        end\n\telse if (cnt_100==49) begin\n\t\tCLK_1<= ~CLK_1;\n                cnt_100<=0;\n        end\n        else begin\n                cnt_100<=cnt_100+1;\n        end\nend\n\nendmodule", "corrupted_code": "module freq_div (CLK_in,CLK_50,CLK_10,CLK_1,RST);\ninput CLK_in,RST;\noutput reg CLK_50,CLK_10,CLK_1;\n\nreg [3:0] cnt_10;\nreg [6:0] cnt_100;\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_50<= 1'b0;\n        end\n\telse begin\n\t\tCLK_50<= ~CLK_50;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_10<= 1'b0;\n                cnt_10<=0;\n        end\n\telse if (cnt_10==4) begin\n\t\tCLK_10<= ~CLK_10;\n                cnt_10<=0;\n        end\n        else begin\n                cnt_10<=cnt_10+1;\n        end\nend\n\n\n\telse if (cnt_100==49) begin\n\t\tCLK_1<= ~CLK_1;\n                cnt_100<=0;\n        end\n        else begin\n                cnt_100<=cnt_100+1;\n        end\nend\n\nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 31, "original_snippet": "always @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_1<= 1'b0;\n                cnt_100<=0;\n        end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 31: Original: always @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_1<= 1'b0;\n                cnt_100<=0;\n        end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 31.\n   \u2022 Restore the original code: always @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_1<= 1'b0;\n                cnt_100<=0;\n        end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 21, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.087905", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_div", "module_name": "freq_div", "description": "Please act as a professional verilog designer.\n\nImplement a frequency divider that the input clock frequency of 100MHz signal, and the outputs are 3 clock frequencies: 50MHz, 10MHz, 1MHz.\n\nModule name:  \n    freq_div      \n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three counters to divide the input clock frequency. \nCLK_50 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_50 is set to 0.\nOtherwise, CLK_50 is toggled by inverting its current value.\nCLK_10 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_10 is set to 0, and the counter cnt_10 is reset to 0.\nIf the counter cnt_10 reaches a value of 4, CLK_10 is toggled by inverting its current value, and the counter cnt_10 is reset to 0.\nOtherwise, the counter cnt_10 is incremented by 1.\nCLK_1 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_1 is set to 0, and the counter cnt_100 is reset to 0.\nIf the counter cnt_100 reaches a value of 49, CLK_1 is toggled by inverting its current value, and the counter cnt_100 is reset to 0.\nOtherwise, the counter cnt_100 is incremented by 1.\n\nGive me the complete code.\n"}, "clean_code": "module freq_div (CLK_in,CLK_50,CLK_10,CLK_1,RST);\ninput CLK_in,RST;\noutput reg CLK_50,CLK_10,CLK_1;\n\nreg [3:0] cnt_10;\nreg [6:0] cnt_100;\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_50<= 1'b0;\n        end\n\telse begin\n\t\tCLK_50<= ~CLK_50;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_10<= 1'b0;\n                cnt_10<=0;\n        end\n\telse if (cnt_10==4) begin\n\t\tCLK_10<= ~CLK_10;\n                cnt_10<=0;\n        end\n        else begin\n                cnt_10<=cnt_10+1;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_1<= 1'b0;\n                cnt_100<=0;\n        end\n\telse if (cnt_100==49) begin\n\t\tCLK_1<= ~CLK_1;\n                cnt_100<=0;\n        end\n        else begin\n                cnt_100<=cnt_100+1;\n        end\nend\n\nendmodule", "corrupted_code": "module freq_div (CLK_in,CLK_50,CLK_10,CLK_1,RST);\ninput CLK_in,RST;\noutput reg CLK_50,CLK_10,CLK_1;\n\nreg [3:0] cnt_10;\nreg [6:0] cnt_100;\n\nalways @(posedge CLK_in) begin\n\tif (RST) begin\n\t\tCLK_50<= 1'b0;\n        end\n\telse begin\n\t\tCLK_50<= ~CLK_50;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_10<= 1'b0;\n                cnt_10<=0;\n        end\n\telse if (cnt_10==4) begin\n\t\tCLK_10<= ~CLK_10;\n                cnt_10<=0;\n        end\n        else begin\n                cnt_10<=cnt_10+1;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_1<= 1'b0;\n                cnt_100<=0;\n        end\n\telse if (cnt_100==49) begin\n\t\tCLK_1<= ~CLK_1;\n                cnt_100<=0;\n        end\n        else begin\n                cnt_100<=cnt_100+1;\n        end\nend\n\nendmodule", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 8, "original_snippet": "always @(posedge CLK_in or posedge RST)", "modified_snippet": "always @(posedge CLK_in)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 8: Original: always @(posedge CLK_in or posedge RST)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 8.\n   \u2022 Restore the original code: always @(posedge CLK_in or posedge RST)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 21, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_sensitivity_list"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.089452", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_div", "module_name": "freq_div", "description": "Please act as a professional verilog designer.\n\nImplement a frequency divider that the input clock frequency of 100MHz signal, and the outputs are 3 clock frequencies: 50MHz, 10MHz, 1MHz.\n\nModule name:  \n    freq_div      \n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three counters to divide the input clock frequency. \nCLK_50 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_50 is set to 0.\nOtherwise, CLK_50 is toggled by inverting its current value.\nCLK_10 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_10 is set to 0, and the counter cnt_10 is reset to 0.\nIf the counter cnt_10 reaches a value of 4, CLK_10 is toggled by inverting its current value, and the counter cnt_10 is reset to 0.\nOtherwise, the counter cnt_10 is incremented by 1.\nCLK_1 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_1 is set to 0, and the counter cnt_100 is reset to 0.\nIf the counter cnt_100 reaches a value of 49, CLK_1 is toggled by inverting its current value, and the counter cnt_100 is reset to 0.\nOtherwise, the counter cnt_100 is incremented by 1.\n\nGive me the complete code.\n"}, "clean_code": "module freq_div (CLK_in,CLK_50,CLK_10,CLK_1,RST);\ninput CLK_in,RST;\noutput reg CLK_50,CLK_10,CLK_1;\n\nreg [3:0] cnt_10;\nreg [6:0] cnt_100;\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_50<= 1'b0;\n        end\n\telse begin\n\t\tCLK_50<= ~CLK_50;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_10<= 1'b0;\n                cnt_10<=0;\n        end\n\telse if (cnt_10==4) begin\n\t\tCLK_10<= ~CLK_10;\n                cnt_10<=0;\n        end\n        else begin\n                cnt_10<=cnt_10+1;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_1<= 1'b0;\n                cnt_100<=0;\n        end\n\telse if (cnt_100==49) begin\n\t\tCLK_1<= ~CLK_1;\n                cnt_100<=0;\n        end\n        else begin\n                cnt_100<=cnt_100+1;\n        end\nend\n\nendmodule", "corrupted_code": "module freq_div (CLK_in,CLK_50,CLK_10,CLK_1,RST);\ninput CLK_in,RST;\noutput reg CLK_50,CLK_10,CLK_1;\n\nreg [3:0] cnt_10;\nreg [6:0] cnt_100;\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (!RST) begin\n\t\tCLK_50<= 1'b0;\n        end\n\telse begin\n\t\tCLK_50<= ~CLK_50;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_10<= 1'b0;\n                cnt_10<=0;\n        end\n\telse if (cnt_10==4) begin\n\t\tCLK_10<= ~CLK_10;\n                cnt_10<=0;\n        end\n        else begin\n                cnt_10<=cnt_10+1;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_1<= 1'b0;\n                cnt_100<=0;\n        end\n\telse if (cnt_100==49) begin\n\t\tCLK_1<= ~CLK_1;\n                cnt_100<=0;\n        end\n        else begin\n                cnt_100<=cnt_100+1;\n        end\nend\n\nendmodule", "corruption_explanation": "Inverted reset polarity in condition", "modification_type": "invert_reset_polarity", "modification_line": 9, "original_snippet": "if (RST)", "modified_snippet": "if (!RST)", "issue_description": "The buggy code has inverted reset polarity. If the design expects active-low reset (!rst), it now uses active-high, or vice versa. This causes the reset logic to activate during normal operation and deactivate during actual reset, breaking initialization.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_reset_polarity modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted reset polarity in condition\n   \u2022 Line 9: Original: if (RST)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 9.\n   \u2022 Restore the original code: if (RST)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert reset polarity.", "complexity": 21, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_reset_polarity"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.090997", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_div", "module_name": "freq_div", "description": "Please act as a professional verilog designer.\n\nImplement a frequency divider that the input clock frequency of 100MHz signal, and the outputs are 3 clock frequencies: 50MHz, 10MHz, 1MHz.\n\nModule name:  \n    freq_div      \n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three counters to divide the input clock frequency. \nCLK_50 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_50 is set to 0.\nOtherwise, CLK_50 is toggled by inverting its current value.\nCLK_10 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_10 is set to 0, and the counter cnt_10 is reset to 0.\nIf the counter cnt_10 reaches a value of 4, CLK_10 is toggled by inverting its current value, and the counter cnt_10 is reset to 0.\nOtherwise, the counter cnt_10 is incremented by 1.\nCLK_1 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_1 is set to 0, and the counter cnt_100 is reset to 0.\nIf the counter cnt_100 reaches a value of 49, CLK_1 is toggled by inverting its current value, and the counter cnt_100 is reset to 0.\nOtherwise, the counter cnt_100 is incremented by 1.\n\nGive me the complete code.\n"}, "clean_code": "module freq_div (CLK_in,CLK_50,CLK_10,CLK_1,RST);\ninput CLK_in,RST;\noutput reg CLK_50,CLK_10,CLK_1;\n\nreg [3:0] cnt_10;\nreg [6:0] cnt_100;\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_50<= 1'b0;\n        end\n\telse begin\n\t\tCLK_50<= ~CLK_50;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_10<= 1'b0;\n                cnt_10<=0;\n        end\n\telse if (cnt_10==4) begin\n\t\tCLK_10<= ~CLK_10;\n                cnt_10<=0;\n        end\n        else begin\n                cnt_10<=cnt_10+1;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_1<= 1'b0;\n                cnt_100<=0;\n        end\n\telse if (cnt_100==49) begin\n\t\tCLK_1<= ~CLK_1;\n                cnt_100<=0;\n        end\n        else begin\n                cnt_100<=cnt_100+1;\n        end\nend\n\nendmodule", "corrupted_code": "module freq_div (CLK_in,CLK_50,CLK_10,CLK_1,RST);\ninput CLK_in,RST;\noutput reg CLK_50,CLK_10,CLK_1;\n\nreg [3:0] cnt_10;\nreg [6:0] cnt_100;\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_50<= 1'b0;\n        end\n\telse begin\n\t\tCLK_50<= ~CLK_50;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_10<= 1'b0;\n                cnt_10<=0;\n        end\n\telse if (cnt_10==4) begin\n\t\tCLK_10<= ~CLK_10;\n                cnt_10<=0;\n        end\n        else begin\n                cnt_10<=cnt_10+1;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_1>= 1'b0;\n                cnt_100<=0;\n        end\n\telse if (cnt_100==49) begin\n\t\tCLK_1<= ~CLK_1;\n                cnt_100<=0;\n        end\n        else begin\n                cnt_100<=cnt_100+1;\n        end\nend\n\nendmodule", "corruption_explanation": "Changed operator from '<=' to '>='", "modification_type": "change_operator", "modification_line": 33, "original_snippet": "1<= 1", "modified_snippet": "1>= 1", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '<=' to '>='\n   \u2022 Line 33: Original: 1<= 1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 33.\n   \u2022 Restore the original code: 1<= 1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 21, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.092705", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_div", "module_name": "freq_div", "description": "Please act as a professional verilog designer.\n\nImplement a frequency divider that the input clock frequency of 100MHz signal, and the outputs are 3 clock frequencies: 50MHz, 10MHz, 1MHz.\n\nModule name:  \n    freq_div      \n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three counters to divide the input clock frequency. \nCLK_50 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_50 is set to 0.\nOtherwise, CLK_50 is toggled by inverting its current value.\nCLK_10 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_10 is set to 0, and the counter cnt_10 is reset to 0.\nIf the counter cnt_10 reaches a value of 4, CLK_10 is toggled by inverting its current value, and the counter cnt_10 is reset to 0.\nOtherwise, the counter cnt_10 is incremented by 1.\nCLK_1 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_1 is set to 0, and the counter cnt_100 is reset to 0.\nIf the counter cnt_100 reaches a value of 49, CLK_1 is toggled by inverting its current value, and the counter cnt_100 is reset to 0.\nOtherwise, the counter cnt_100 is incremented by 1.\n\nGive me the complete code.\n"}, "clean_code": "module freq_div (CLK_in,CLK_50,CLK_10,CLK_1,RST);\ninput CLK_in,RST;\noutput reg CLK_50,CLK_10,CLK_1;\n\nreg [3:0] cnt_10;\nreg [6:0] cnt_100;\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_50<= 1'b0;\n        end\n\telse begin\n\t\tCLK_50<= ~CLK_50;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_10<= 1'b0;\n                cnt_10<=0;\n        end\n\telse if (cnt_10==4) begin\n\t\tCLK_10<= ~CLK_10;\n                cnt_10<=0;\n        end\n        else begin\n                cnt_10<=cnt_10+1;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_1<= 1'b0;\n                cnt_100<=0;\n        end\n\telse if (cnt_100==49) begin\n\t\tCLK_1<= ~CLK_1;\n                cnt_100<=0;\n        end\n        else begin\n                cnt_100<=cnt_100+1;\n        end\nend\n\nendmodule", "corrupted_code": "module freq_div (CLK_in,CLK_50,CLK_10,CLK_1,RST);\ninput CLK_in,RST;\noutput reg CLK_50,CLK_10,CLK_1;\n\nreg [3:0] cnt_10;\nreg [6:0] cnt_100;\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_50<= 1'b0;\n        end\n\telse begin\n\t\tCLK_50<= ~CLK_50;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_10<= 1'b0;\n                cnt_10<=0;\n        end\n\telse if (cnt_10==4) begin\n\t\tCLK_10<= ~CLK_10;\n                cnt_10<=0;\n        end\n        else begin\n                cnt_10<=cnt_10+1;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_1<= 1'b0;\n                cnt_100<=0;\n        end\n\telse if (cnt_100==49) begin\n\t\tCLK_1<= ~CLK_1;\n                <=cnt_100+1;\n        end\nend\n\nendmodule", "corruption_explanation": "Removed CDC synchronizer stage", "modification_type": "modify_cdc", "modification_line": 38, "original_snippet": "cnt_100<=0;\n        end\n        else begin\n                cnt_100", "modified_snippet": "(removed)", "issue_description": "The buggy code has a broken clock domain crossing synchronizer. A synchronizer flip-flop stage was removed, reducing metastability protection. This creates CDC violations that cause random data corruption in multi-clock domain designs.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a modify_cdc modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed CDC synchronizer stage\n   \u2022 Line 38: Original: cnt_100<=0;\n        end\n        else begin\n                cnt_100\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 38.\n   \u2022 Restore the original code: cnt_100<=0;\n        end\n        else begin\n                cnt_100\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to modify cdc.", "complexity": 21, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["modify_cdc"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.094490", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_div", "module_name": "freq_div", "description": "Please act as a professional verilog designer.\n\nImplement a frequency divider that the input clock frequency of 100MHz signal, and the outputs are 3 clock frequencies: 50MHz, 10MHz, 1MHz.\n\nModule name:  \n    freq_div      \n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three counters to divide the input clock frequency. \nCLK_50 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_50 is set to 0.\nOtherwise, CLK_50 is toggled by inverting its current value.\nCLK_10 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_10 is set to 0, and the counter cnt_10 is reset to 0.\nIf the counter cnt_10 reaches a value of 4, CLK_10 is toggled by inverting its current value, and the counter cnt_10 is reset to 0.\nOtherwise, the counter cnt_10 is incremented by 1.\nCLK_1 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_1 is set to 0, and the counter cnt_100 is reset to 0.\nIf the counter cnt_100 reaches a value of 49, CLK_1 is toggled by inverting its current value, and the counter cnt_100 is reset to 0.\nOtherwise, the counter cnt_100 is incremented by 1.\n\nGive me the complete code.\n"}, "clean_code": "module freq_div (CLK_in,CLK_50,CLK_10,CLK_1,RST);\ninput CLK_in,RST;\noutput reg CLK_50,CLK_10,CLK_1;\n\nreg [3:0] cnt_10;\nreg [6:0] cnt_100;\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_50<= 1'b0;\n        end\n\telse begin\n\t\tCLK_50<= ~CLK_50;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_10<= 1'b0;\n                cnt_10<=0;\n        end\n\telse if (cnt_10==4) begin\n\t\tCLK_10<= ~CLK_10;\n                cnt_10<=0;\n        end\n        else begin\n                cnt_10<=cnt_10+1;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_1<= 1'b0;\n                cnt_100<=0;\n        end\n\telse if (cnt_100==49) begin\n\t\tCLK_1<= ~CLK_1;\n                cnt_100<=0;\n        end\n        else begin\n                cnt_100<=cnt_100+1;\n        end\nend\n\nendmodule", "corrupted_code": "module freq_div (CLK_in,CLK_50,CLK_10,CLK_1,RST);\ninput CLK_in,RST;\noutput reg CLK_50,CLK_10,CLK_1;\n\nreg [3:0] cnt_10;\nreg [6:0] cnt_100;\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_50<= 1'b0;\n        end\n\telse begin\n\t\tCLK_50<= ~CLK_50;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_10<= 1'b0;\n                cnt_10<=0;\n        end\n\telse if (cnt_10==4) begin\n\t\tCLK_10<= ~CLK_10;\n                cnt_10<=0;\n        end\n        else begin\n                cnt_10>=cnt_10+1;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_1<= 1'b0;\n                cnt_100<=0;\n        end\n\telse if (cnt_100==49) begin\n\t\tCLK_1<= ~CLK_1;\n                cnt_100<=0;\n        end\n        else begin\n                cnt_100<=cnt_100+1;\n        end\nend\n\nendmodule", "corruption_explanation": "Changed operator from '<=' to '>='", "modification_type": "change_operator", "modification_line": 27, "original_snippet": "0<=c", "modified_snippet": "0>=c", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '<=' to '>='\n   \u2022 Line 27: Original: 0<=c\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 27.\n   \u2022 Restore the original code: 0<=c\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 21, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.096225", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_div", "module_name": "freq_div", "description": "Please act as a professional verilog designer.\n\nImplement a frequency divider that the input clock frequency of 100MHz signal, and the outputs are 3 clock frequencies: 50MHz, 10MHz, 1MHz.\n\nModule name:  \n    freq_div      \n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three counters to divide the input clock frequency. \nCLK_50 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_50 is set to 0.\nOtherwise, CLK_50 is toggled by inverting its current value.\nCLK_10 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_10 is set to 0, and the counter cnt_10 is reset to 0.\nIf the counter cnt_10 reaches a value of 4, CLK_10 is toggled by inverting its current value, and the counter cnt_10 is reset to 0.\nOtherwise, the counter cnt_10 is incremented by 1.\nCLK_1 generation:\nOn every positive edge of CLK_in or RST, if RST is active, CLK_1 is set to 0, and the counter cnt_100 is reset to 0.\nIf the counter cnt_100 reaches a value of 49, CLK_1 is toggled by inverting its current value, and the counter cnt_100 is reset to 0.\nOtherwise, the counter cnt_100 is incremented by 1.\n\nGive me the complete code.\n"}, "clean_code": "module freq_div (CLK_in,CLK_50,CLK_10,CLK_1,RST);\ninput CLK_in,RST;\noutput reg CLK_50,CLK_10,CLK_1;\n\nreg [3:0] cnt_10;\nreg [6:0] cnt_100;\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_50<= 1'b0;\n        end\n\telse begin\n\t\tCLK_50<= ~CLK_50;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_10<= 1'b0;\n                cnt_10<=0;\n        end\n\telse if (cnt_10==4) begin\n\t\tCLK_10<= ~CLK_10;\n                cnt_10<=0;\n        end\n        else begin\n                cnt_10<=cnt_10+1;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_1<= 1'b0;\n                cnt_100<=0;\n        end\n\telse if (cnt_100==49) begin\n\t\tCLK_1<= ~CLK_1;\n                cnt_100<=0;\n        end\n        else begin\n                cnt_100<=cnt_100+1;\n        end\nend\n\nendmodule", "corrupted_code": "module freq_div (CLK_in,CLK_50,CLK_10,CLK_1,RST);\ninput CLK_in,RST;\noutput reg CLK_50,CLK_10,CLK_1;\n\nreg [3:0] cnt_10;\nreg [6:0] cnt_100;\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_50<= 1'b0;\n        end\n\telse begin\n\t\tCLK_50<= ~CLK_50;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_10<= 1'b0;\n                cnt_10<=0;\n        end\n\telse if (cnt_10==4) begin\n\t\tCLK_10<= ~CLK_10;\n                cnt_10<=0;\n        end\n        else begin\n                cnt_10<=cnt_10+1;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_1<= 1'b0;\n                cnt_100<=0;\n        end\n\telse if (cnt_100==49) begin\n\t\tCLK_1<= ~CLK_1;\n                cnt_100<=0;\n        end\nend\n\nendmodule", "corruption_explanation": "Removed else branch (may cause latch inference)", "modification_type": "remove_else_branch", "modification_line": 32, "original_snippet": "if (RST) begin\n\t\tCLK_1<= 1'b0;\n                cnt_100<=0;\n        end\n\telse if (cnt_100==49) begin\n\t\tCLK_1<= ~CLK_1;\n                cnt_100<=0;\n        end\n        else begin\n                cnt_100", "modified_snippet": "if (RST) begin\n\t\tCLK_1<= 1'b0;\n                cnt_100<=0;\n        end\n\telse if (cnt_100==49) begin\n\t\tCLK_1<= ~CLK_1;\n                cnt_100<=0;\n        end", "issue_description": "The buggy code is missing an else branch in a conditional statement. In combinational logic (always_comb or always @*), this can cause latch inference because the output is not defined for all input conditions. In sequential logic, signals may retain old values unexpectedly. This violates RTL design best practices requiring complete conditional assignments.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module should provide a complete conditional assignment to avoid latch inference.\n   \u2022 Combinational logic must define outputs for all input conditions.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an if statement without an else branch.\n   \u2022 The assigned signal is not defined when the condition is false.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The else branch has been removed from the conditional.\n   \u2022 This creates an incomplete conditional assignment.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Missing else branch leaves the signal undefined in some cases.\n   \u2022 Impact: Latch inference in combinational blocks, or stale values in sequential blocks.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Add an else branch with appropriate default or alternative assignment.\n   \u2022 Ensure all signals are assigned in all branches of the conditional.\n\n6. RTL Design Principle Violated:\n   \u2022 Combinational logic must have complete assignments to avoid latch inference.\n   \u2022 All conditional blocks should have else clauses or default values.", "complexity": 21, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_else_branch"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.097807", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_divbyeven", "module_name": "freq_divbyeven", "description": "Please act as a professional verilog designer.\n\nFrequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name: \n    freq_diveven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\n    The frequency divider uses a counter (`cnt`) to count the number of clock cycles. The `NUM_DIV` parameter specifies the division factor, which must be an even number.\n    - When the reset signal (`rst_n`) is low, the counter and the divided clock signal (`clk_div`) are initialized to zero.\n    - On each positive edge of the input clock (`clk`), if the counter is less than half of `NUM_DIV - 1`, the counter increments without changing the divided clock output.\n    - When the counter reaches the specified limit, it resets to zero and toggles the `clk_div` output signal, effectively dividing the frequency of the input clock by the even number specified by `NUM_DIV`.\n\nCounter:\n    - The counter is a 4-bit register (`cnt`) that tracks the number of clock cycles.\n\nGive me the complete code."}, "clean_code": "module freq_divbyeven(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 6;\n    reg    [3:0] cnt;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n) begin\n        cnt     <= 4'd0;\n        clk_div    <= 1'b0;\n    end\n    else if(cnt < NUM_DIV / 2 - 1) begin\n        cnt     <= cnt + 1'b1;\n        clk_div    <= clk_div;\n    end\n    else begin\n        cnt     <= 4'd0;\n        clk_div    <= ~clk_div;\n    end\n endmodule", "corrupted_code": "module freq_divbyeven(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 6;\n    reg    [3:0] cnt;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n) begin\n        cnt     <= 4'd0;\n        clk_div    <= 1'b0;\n    end\n    else if(cnt < NUM_DIV / 2 - 1) begin\n        cnt     <= cnt + 1'b1;\n        clk_div    <= clk_div;\n    end\n endmodule", "corruption_explanation": "Removed else branch (may cause latch inference)", "modification_type": "remove_else_branch", "modification_line": 15, "original_snippet": "if(!rst_n) begin\n        cnt     <= 4'd0;\n        clk_div    <= 1'b0;\n    end\n    else if(cnt < NUM_DIV / 2 - 1) begin\n        cnt     <= cnt + 1'b1;\n        clk_div    <= clk_div;\n    end\n    else be", "modified_snippet": "if(!rst_n) begin\n        cnt     <= 4'd0;\n        clk_div    <= 1'b0;\n    end\n    else if(cnt < NUM_DIV / 2 - 1) begin\n        cnt     <= cnt + 1'b1;\n        clk_div    <= clk_div;\n    end", "issue_description": "The buggy code is missing an else branch in a conditional statement. In combinational logic (always_comb or always @*), this can cause latch inference because the output is not defined for all input conditions. In sequential logic, signals may retain old values unexpectedly. This violates RTL design best practices requiring complete conditional assignments.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module should provide a complete conditional assignment to avoid latch inference.\n   \u2022 Combinational logic must define outputs for all input conditions.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an if statement without an else branch.\n   \u2022 The assigned signal is not defined when the condition is false.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The else branch has been removed from the conditional.\n   \u2022 This creates an incomplete conditional assignment.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Missing else branch leaves the signal undefined in some cases.\n   \u2022 Impact: Latch inference in combinational blocks, or stale values in sequential blocks.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Add an else branch with appropriate default or alternative assignment.\n   \u2022 Ensure all signals are assigned in all branches of the conditional.\n\n6. RTL Design Principle Violated:\n   \u2022 Combinational logic must have complete assignments to avoid latch inference.\n   \u2022 All conditional blocks should have else clauses or default values.", "complexity": 10, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "invert_condition", "invert_reset_polarity", "remove_async_reset"], "stacked_count": 1, "applied_modifications": ["remove_else_branch"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.159260", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_divbyeven", "module_name": "freq_divbyeven", "description": "Please act as a professional verilog designer.\n\nFrequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name: \n    freq_diveven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\n    The frequency divider uses a counter (`cnt`) to count the number of clock cycles. The `NUM_DIV` parameter specifies the division factor, which must be an even number.\n    - When the reset signal (`rst_n`) is low, the counter and the divided clock signal (`clk_div`) are initialized to zero.\n    - On each positive edge of the input clock (`clk`), if the counter is less than half of `NUM_DIV - 1`, the counter increments without changing the divided clock output.\n    - When the counter reaches the specified limit, it resets to zero and toggles the `clk_div` output signal, effectively dividing the frequency of the input clock by the even number specified by `NUM_DIV`.\n\nCounter:\n    - The counter is a 4-bit register (`cnt`) that tracks the number of clock cycles.\n\nGive me the complete code."}, "clean_code": "module freq_divbyeven(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 6;\n    reg    [3:0] cnt;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n) begin\n        cnt     <= 4'd0;\n        clk_div    <= 1'b0;\n    end\n    else if(cnt < NUM_DIV / 2 - 1) begin\n        cnt     <= cnt + 1'b1;\n        clk_div    <= clk_div;\n    end\n    else begin\n        cnt     <= 4'd0;\n        clk_div    <= ~clk_div;\n    end\n endmodule", "corrupted_code": "module freq_divbyeven(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 6;\n    reg    [3:0] cnt;\n\nalways @(posedge clk)\n    if(!rst_n) begin\n        cnt     <= 4'd0;\n        clk_div    <= 1'b0;\n    end\n    else if(cnt < NUM_DIV / 2 - 1) begin\n        cnt     <= cnt + 1'b1;\n        clk_div    <= clk_div;\n    end\n    else begin\n        cnt     <= 4'd0;\n        clk_div    <= ~clk_div;\n    end\n endmodule", "corruption_explanation": "Removed async reset from sensitivity list", "modification_type": "remove_async_reset", "modification_line": 14, "original_snippet": "always @(posedge clk or negedge rst_n)", "modified_snippet": "always @(posedge clk)", "issue_description": "The buggy code has removed async reset from the sensitivity list. The always block only triggers on clock edges, not reset. This causes metastability on power-up and removes the ability to asynchronously reset the design.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_async_reset modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed async reset from sensitivity list\n   \u2022 Line 14: Original: always @(posedge clk or negedge rst_n)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 14.\n   \u2022 Restore the original code: always @(posedge clk or negedge rst_n)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove async reset.", "complexity": 10, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "invert_condition", "invert_reset_polarity", "remove_async_reset"], "stacked_count": 1, "applied_modifications": ["remove_async_reset"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.160285", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_divbyeven", "module_name": "freq_divbyeven", "description": "Please act as a professional verilog designer.\n\nFrequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name: \n    freq_diveven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\n    The frequency divider uses a counter (`cnt`) to count the number of clock cycles. The `NUM_DIV` parameter specifies the division factor, which must be an even number.\n    - When the reset signal (`rst_n`) is low, the counter and the divided clock signal (`clk_div`) are initialized to zero.\n    - On each positive edge of the input clock (`clk`), if the counter is less than half of `NUM_DIV - 1`, the counter increments without changing the divided clock output.\n    - When the counter reaches the specified limit, it resets to zero and toggles the `clk_div` output signal, effectively dividing the frequency of the input clock by the even number specified by `NUM_DIV`.\n\nCounter:\n    - The counter is a 4-bit register (`cnt`) that tracks the number of clock cycles.\n\nGive me the complete code."}, "clean_code": "module freq_divbyeven(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 6;\n    reg    [3:0] cnt;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n) begin\n        cnt     <= 4'd0;\n        clk_div    <= 1'b0;\n    end\n    else if(cnt < NUM_DIV / 2 - 1) begin\n        cnt     <= cnt + 1'b1;\n        clk_div    <= clk_div;\n    end\n    else begin\n        cnt     <= 4'd0;\n        clk_div    <= ~clk_div;\n    end\n endmodule", "corrupted_code": "module freq_divbyeven(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 6;\n    reg    [3:0] cnt;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n) begin\n        cnt     <= 4'd0;\n        clk_div    <= 1'b0;\n    end\n    else if(cnt < NUM_DIV / 2 + 1) begin\n        cnt     <= cnt + 1'b1;\n        clk_div    <= clk_div;\n    end\n    else begin\n        cnt     <= 4'd0;\n        clk_div    <= ~clk_div;\n    end\n endmodule", "corruption_explanation": "Changed operator from '-' to '+'", "modification_type": "change_operator", "modification_line": 19, "original_snippet": "-", "modified_snippet": "+", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '-' to '+'\n   \u2022 Line 19: Original: -\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 19.\n   \u2022 Restore the original code: -\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 10, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "invert_condition", "invert_reset_polarity", "remove_async_reset"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.161397", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_divbyeven", "module_name": "freq_divbyeven", "description": "Please act as a professional verilog designer.\n\nFrequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name: \n    freq_diveven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\n    The frequency divider uses a counter (`cnt`) to count the number of clock cycles. The `NUM_DIV` parameter specifies the division factor, which must be an even number.\n    - When the reset signal (`rst_n`) is low, the counter and the divided clock signal (`clk_div`) are initialized to zero.\n    - On each positive edge of the input clock (`clk`), if the counter is less than half of `NUM_DIV - 1`, the counter increments without changing the divided clock output.\n    - When the counter reaches the specified limit, it resets to zero and toggles the `clk_div` output signal, effectively dividing the frequency of the input clock by the even number specified by `NUM_DIV`.\n\nCounter:\n    - The counter is a 4-bit register (`cnt`) that tracks the number of clock cycles.\n\nGive me the complete code."}, "clean_code": "module freq_divbyeven(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 6;\n    reg    [3:0] cnt;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n) begin\n        cnt     <= 4'd0;\n        clk_div    <= 1'b0;\n    end\n    else if(cnt < NUM_DIV / 2 - 1) begin\n        cnt     <= cnt + 1'b1;\n        clk_div    <= clk_div;\n    end\n    else begin\n        cnt     <= 4'd0;\n        clk_div    <= ~clk_div;\n    end\n endmodule", "corrupted_code": "module freq_divbyeven(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 6;\n    reg    [2:0] cnt;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n) begin\n        cnt     <= 4'd0;\n        clk_div    <= 1'b0;\n    end\n    else if(cnt < NUM_DIV / 2 - 1) begin\n        cnt     <= cnt + 1'b1;\n        clk_div    <= clk_div;\n    end\n    else begin\n        cnt     <= 4'd0;\n        clk_div    <= ~clk_div;\n    end\n endmodule", "corruption_explanation": "Changed bit width from [3:0] to [2:0]", "modification_type": "change_bit_width", "modification_line": 12, "original_snippet": "[3:0]", "modified_snippet": "[2:0]", "issue_description": "The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_bit_width modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed bit width from [3:0] to [2:0]\n   \u2022 Line 12: Original: [3:0]\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 12.\n   \u2022 Restore the original code: [3:0]\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change bit width.", "complexity": 10, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "invert_condition", "invert_reset_polarity", "remove_async_reset"], "stacked_count": 1, "applied_modifications": ["change_bit_width"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.162410", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_divbyeven", "module_name": "freq_divbyeven", "description": "Please act as a professional verilog designer.\n\nFrequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name: \n    freq_diveven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\n    The frequency divider uses a counter (`cnt`) to count the number of clock cycles. The `NUM_DIV` parameter specifies the division factor, which must be an even number.\n    - When the reset signal (`rst_n`) is low, the counter and the divided clock signal (`clk_div`) are initialized to zero.\n    - On each positive edge of the input clock (`clk`), if the counter is less than half of `NUM_DIV - 1`, the counter increments without changing the divided clock output.\n    - When the counter reaches the specified limit, it resets to zero and toggles the `clk_div` output signal, effectively dividing the frequency of the input clock by the even number specified by `NUM_DIV`.\n\nCounter:\n    - The counter is a 4-bit register (`cnt`) that tracks the number of clock cycles.\n\nGive me the complete code."}, "clean_code": "module freq_divbyeven(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 6;\n    reg    [3:0] cnt;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n) begin\n        cnt     <= 4'd0;\n        clk_div    <= 1'b0;\n    end\n    else if(cnt < NUM_DIV / 2 - 1) begin\n        cnt     <= cnt + 1'b1;\n        clk_div    <= clk_div;\n    end\n    else begin\n        cnt     <= 4'd0;\n        clk_div    <= ~clk_div;\n    end\n endmodule", "corrupted_code": "module freq_divbyeven(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 6;\n    reg    [3:0] cnt;\n\nalways @(posedge clk or negedge rst_n)\n    if(rst_n) begin\n        cnt     <= 4'd0;\n        clk_div    <= 1'b0;\n    end\n    else if(cnt < NUM_DIV / 2 - 1) begin\n        cnt     <= cnt + 1'b1;\n        clk_div    <= clk_div;\n    end\n    else begin\n        cnt     <= 4'd0;\n        clk_div    <= ~clk_div;\n    end\n endmodule", "corruption_explanation": "Inverted condition: '!rst_n' -> 'rst_n'", "modification_type": "invert_condition", "modification_line": 15, "original_snippet": "if(!rst_n) begin", "modified_snippet": "if(rst_n) begin", "issue_description": "The buggy code has an inverted condition in an if statement. Instead of checking if(x), it checks if(!x), causing the logic to execute when it shouldn't and skip execution when it should. All conditional behavior is reversed from intended functionality.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_condition modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted condition: '!rst_n' -> 'rst_n'\n   \u2022 Line 15: Original: if(!rst_n) begin\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 15.\n   \u2022 Restore the original code: if(!rst_n) begin\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert condition.", "complexity": 10, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "invert_condition", "invert_reset_polarity", "remove_async_reset"], "stacked_count": 1, "applied_modifications": ["invert_condition"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.163393", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_divbyeven", "module_name": "freq_divbyeven", "description": "Please act as a professional verilog designer.\n\nFrequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name: \n    freq_diveven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\n    The frequency divider uses a counter (`cnt`) to count the number of clock cycles. The `NUM_DIV` parameter specifies the division factor, which must be an even number.\n    - When the reset signal (`rst_n`) is low, the counter and the divided clock signal (`clk_div`) are initialized to zero.\n    - On each positive edge of the input clock (`clk`), if the counter is less than half of `NUM_DIV - 1`, the counter increments without changing the divided clock output.\n    - When the counter reaches the specified limit, it resets to zero and toggles the `clk_div` output signal, effectively dividing the frequency of the input clock by the even number specified by `NUM_DIV`.\n\nCounter:\n    - The counter is a 4-bit register (`cnt`) that tracks the number of clock cycles.\n\nGive me the complete code."}, "clean_code": "module freq_divbyeven(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 6;\n    reg    [3:0] cnt;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n) begin\n        cnt     <= 4'd0;\n        clk_div    <= 1'b0;\n    end\n    else if(cnt < NUM_DIV / 2 - 1) begin\n        cnt     <= cnt + 1'b1;\n        clk_div    <= clk_div;\n    end\n    else begin\n        cnt     <= 4'd0;\n        clk_div    <= ~clk_div;\n    end\n endmodule", "corrupted_code": "module freq_divbyeven(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 6;\n    reg    [3:0] cnt;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n) begin\n        cnt     <= 4'd0;\n        clk_div    <= 1'b0;\n    end\n    else if(cnt < NUM_DIV / 2 - 1) begin\n        cnt     <= cnt + 1'b0;\n        clk_div    <= clk_div;\n    end\n    else begin\n        cnt     <= 4'd0;\n        clk_div    <= ~clk_div;\n    end\n endmodule", "corruption_explanation": "Changed constant from 1'b1 to 1'b0", "modification_type": "change_constant", "modification_line": 20, "original_snippet": "1'b1", "modified_snippet": "1'b0", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 1'b1 to 1'b0\n   \u2022 Line 20: Original: 1'b1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 20.\n   \u2022 Restore the original code: 1'b1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 10, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "invert_condition", "invert_reset_polarity", "remove_async_reset"], "stacked_count": 1, "applied_modifications": ["change_constant"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.164387", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_divbyeven", "module_name": "freq_divbyeven", "description": "Please act as a professional verilog designer.\n\nFrequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name: \n    freq_diveven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\n    The frequency divider uses a counter (`cnt`) to count the number of clock cycles. The `NUM_DIV` parameter specifies the division factor, which must be an even number.\n    - When the reset signal (`rst_n`) is low, the counter and the divided clock signal (`clk_div`) are initialized to zero.\n    - On each positive edge of the input clock (`clk`), if the counter is less than half of `NUM_DIV - 1`, the counter increments without changing the divided clock output.\n    - When the counter reaches the specified limit, it resets to zero and toggles the `clk_div` output signal, effectively dividing the frequency of the input clock by the even number specified by `NUM_DIV`.\n\nCounter:\n    - The counter is a 4-bit register (`cnt`) that tracks the number of clock cycles.\n\nGive me the complete code."}, "clean_code": "module freq_divbyeven(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 6;\n    reg    [3:0] cnt;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n) begin\n        cnt     <= 4'd0;\n        clk_div    <= 1'b0;\n    end\n    else if(cnt < NUM_DIV / 2 - 1) begin\n        cnt     <= cnt + 1'b1;\n        clk_div    <= clk_div;\n    end\n    else begin\n        cnt     <= 4'd0;\n        clk_div    <= ~clk_div;\n    end\n endmodule", "corrupted_code": "module freq_divbyeven(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 6;\n    reg    [2:0] cnt;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n) begin\n        cnt     <= 4'd0;\n        clk_div    <= 1'b0;\n    end\n    else if(cnt < NUM_DIV / 2 - 1) begin\n        cnt     <= cnt + 1'b1;\n        clk_div    <= clk_div;\n    end\n    else begin\n        cnt     <= 4'd0;\n        clk_div    <= ~clk_div;\n    end\n endmodule", "corruption_explanation": "Changed bit width from [3:0] to [2:0]", "modification_type": "change_bit_width", "modification_line": 12, "original_snippet": "[3:0]", "modified_snippet": "[2:0]", "issue_description": "The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_bit_width modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed bit width from [3:0] to [2:0]\n   \u2022 Line 12: Original: [3:0]\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 12.\n   \u2022 Restore the original code: [3:0]\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change bit width.", "complexity": 10, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "invert_condition", "invert_reset_polarity", "remove_async_reset"], "stacked_count": 1, "applied_modifications": ["change_bit_width"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.165356", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_divbyeven", "module_name": "freq_divbyeven", "description": "Please act as a professional verilog designer.\n\nFrequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name: \n    freq_diveven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\n    The frequency divider uses a counter (`cnt`) to count the number of clock cycles. The `NUM_DIV` parameter specifies the division factor, which must be an even number.\n    - When the reset signal (`rst_n`) is low, the counter and the divided clock signal (`clk_div`) are initialized to zero.\n    - On each positive edge of the input clock (`clk`), if the counter is less than half of `NUM_DIV - 1`, the counter increments without changing the divided clock output.\n    - When the counter reaches the specified limit, it resets to zero and toggles the `clk_div` output signal, effectively dividing the frequency of the input clock by the even number specified by `NUM_DIV`.\n\nCounter:\n    - The counter is a 4-bit register (`cnt`) that tracks the number of clock cycles.\n\nGive me the complete code."}, "clean_code": "module freq_divbyeven(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 6;\n    reg    [3:0] cnt;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n) begin\n        cnt     <= 4'd0;\n        clk_div    <= 1'b0;\n    end\n    else if(cnt < NUM_DIV / 2 - 1) begin\n        cnt     <= cnt + 1'b1;\n        clk_div    <= clk_div;\n    end\n    else begin\n        cnt     <= 4'd0;\n        clk_div    <= ~clk_div;\n    end\n endmodule", "corrupted_code": "module freq_divbyeven(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 6;\n    reg    [3:0] cnt;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n) begin\n        cnt     <= 4'd0;\n        1 <= clk_div'b0;\n    end\n    else if(cnt < NUM_DIV / 2 - 1) begin\n        cnt     <= cnt + 1'b1;\n        clk_div    <= clk_div;\n    end\n    else begin\n        cnt     <= 4'd0;\n        clk_div    <= ~clk_div;\n    end\n endmodule", "corruption_explanation": "Swapped operands: 'clk_div <= 1' -> '1 <= clk_div'", "modification_type": "swap_operands", "modification_line": 17, "original_snippet": "clk_div    <= 1", "modified_snippet": "1 <= clk_div", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'clk_div <= 1' -> '1 <= clk_div'\n   \u2022 Line 17: Original: clk_div    <= 1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 17.\n   \u2022 Restore the original code: clk_div    <= 1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 10, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "invert_condition", "invert_reset_polarity", "remove_async_reset"], "stacked_count": 1, "applied_modifications": ["swap_operands"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.166373", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_divbyeven", "module_name": "freq_divbyeven", "description": "Please act as a professional verilog designer.\n\nFrequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name: \n    freq_diveven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\n    The frequency divider uses a counter (`cnt`) to count the number of clock cycles. The `NUM_DIV` parameter specifies the division factor, which must be an even number.\n    - When the reset signal (`rst_n`) is low, the counter and the divided clock signal (`clk_div`) are initialized to zero.\n    - On each positive edge of the input clock (`clk`), if the counter is less than half of `NUM_DIV - 1`, the counter increments without changing the divided clock output.\n    - When the counter reaches the specified limit, it resets to zero and toggles the `clk_div` output signal, effectively dividing the frequency of the input clock by the even number specified by `NUM_DIV`.\n\nCounter:\n    - The counter is a 4-bit register (`cnt`) that tracks the number of clock cycles.\n\nGive me the complete code."}, "clean_code": "module freq_divbyeven(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 6;\n    reg    [3:0] cnt;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n) begin\n        cnt     <= 4'd0;\n        clk_div    <= 1'b0;\n    end\n    else if(cnt < NUM_DIV / 2 - 1) begin\n        cnt     <= cnt + 1'b1;\n        clk_div    <= clk_div;\n    end\n    else begin\n        cnt     <= 4'd0;\n        clk_div    <= ~clk_div;\n    end\n endmodule", "corrupted_code": "module freq_divbyeven(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 6;\n    reg    [3:0] cnt;\n\nalways @(posedge clk)\n    if(!rst_n) begin\n        cnt     <= 4'd0;\n        clk_div    <= 1'b0;\n    end\n    else if(cnt < NUM_DIV / 2 - 1) begin\n        cnt     <= cnt + 1'b1;\n        clk_div    <= clk_div;\n    end\n    else begin\n        cnt     <= 4'd0;\n        clk_div    <= ~clk_div;\n    end\n endmodule", "corruption_explanation": "Removed async reset from sensitivity list", "modification_type": "remove_async_reset", "modification_line": 14, "original_snippet": "always @(posedge clk or negedge rst_n)", "modified_snippet": "always @(posedge clk)", "issue_description": "The buggy code has removed async reset from the sensitivity list. The always block only triggers on clock edges, not reset. This causes metastability on power-up and removes the ability to asynchronously reset the design.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_async_reset modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed async reset from sensitivity list\n   \u2022 Line 14: Original: always @(posedge clk or negedge rst_n)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 14.\n   \u2022 Restore the original code: always @(posedge clk or negedge rst_n)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove async reset.", "complexity": 10, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "invert_condition", "invert_reset_polarity", "remove_async_reset"], "stacked_count": 1, "applied_modifications": ["remove_async_reset"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.167332", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_divbyeven", "module_name": "freq_divbyeven", "description": "Please act as a professional verilog designer.\n\nFrequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name: \n    freq_diveven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\n    The frequency divider uses a counter (`cnt`) to count the number of clock cycles. The `NUM_DIV` parameter specifies the division factor, which must be an even number.\n    - When the reset signal (`rst_n`) is low, the counter and the divided clock signal (`clk_div`) are initialized to zero.\n    - On each positive edge of the input clock (`clk`), if the counter is less than half of `NUM_DIV - 1`, the counter increments without changing the divided clock output.\n    - When the counter reaches the specified limit, it resets to zero and toggles the `clk_div` output signal, effectively dividing the frequency of the input clock by the even number specified by `NUM_DIV`.\n\nCounter:\n    - The counter is a 4-bit register (`cnt`) that tracks the number of clock cycles.\n\nGive me the complete code."}, "clean_code": "module freq_divbyeven(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 6;\n    reg    [3:0] cnt;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n) begin\n        cnt     <= 4'd0;\n        clk_div    <= 1'b0;\n    end\n    else if(cnt < NUM_DIV / 2 - 1) begin\n        cnt     <= cnt + 1'b1;\n        clk_div    <= clk_div;\n    end\n    else begin\n        cnt     <= 4'd0;\n        clk_div    <= ~clk_div;\n    end\n endmodule", "corrupted_code": "module freq_divbyeven(\n    clk,\n    rst_n,\n    clk_div\n);\n    input clk;\n    input rst_n;\n    output clk_div;\n    reg clk_div;\n\n    parameter NUM_DIV = 6;\n    reg    [3:0] cnt;\n\nalways @(posedge clk or negedge rst_n)\n    if(!rst_n) begin\n        cnt     <= 4'd0;\n        clk_div    <= ~clk_div;\n    end\n    else begin\n        cnt     <= 4'd0;\n        clk_div    <= 1'b0;\n    end\n    else if(cnt < NUM_DIV / 2 - 1) begin\n        cnt     <= cnt + 1'b1;\n        clk_div    <= clk_div;\n    end\n endmodule", "corruption_explanation": "Swapped if and else bodies", "modification_type": "invert_if_else", "modification_line": 15, "original_snippet": "if(!rst_n) begin\n        cnt     <= 4'd0;\n        clk_div    <= 1'b0;\n    end\n    else if(cnt < NUM_DIV / 2 - 1) begin\n        cnt     <= cnt + 1'b1;\n        clk_div    <= clk_div;\n    end\n    else be", "modified_snippet": "if(!rst_n) begin\n        cnt     <= 4'd0;\n        clk_div    <= ~clk_div;\n    end\n    else begin\n        cnt     <= 4'd0;\n        clk_div    <= 1'b0;\n    end\n    else if(cnt < NUM_DIV / 2 - 1) begin\n ", "issue_description": "The buggy code has swapped if and else bodies in a conditional block. This causes the logic to execute the opposite branch for each condition, leading to incorrect behavior when the condition is true vs false. Test cases that depend on the conditional logic will fail because the intended branch is not executed.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module contains conditional logic that should execute different code paths based on a condition.\n   \u2022 The if branch should handle the true case, and the else branch should handle the false case.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Identified a conditional block with both if and else branches.\n   \u2022 The branches contain different assignments or logic operations.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The if and else bodies have been swapped.\n   \u2022 Logic that should execute when condition is true now executes when false, and vice versa.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The conditional bodies are inverted.\n   \u2022 Impact: All conditional behavior is reversed, causing incorrect outputs for all test cases.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Swap the if and else bodies back to their correct positions.\n   \u2022 Verify that the condition evaluates correctly and executes the intended branch.\n\n6. RTL Design Principle Violated:\n   \u2022 Correct conditional logic requires matching the intended behavior with the branch bodies.", "complexity": 10, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "invert_condition", "invert_reset_polarity", "remove_async_reset"], "stacked_count": 1, "applied_modifications": ["invert_if_else"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.168451", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_divbyfrac", "module_name": "freq_divbyfrac", "description": "Please act as a professional Verilog designer.\n\nA frequency divider that divides the input clock frequency by fractional values. It generates a clock signal with a fractional frequency division (3.5x), using the double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance. By dividing uneven clock cycles and phase-shifting them, a smooth fractional clock output is produced.\n\nModule name: \n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal to initialize the module.\n    \nOutput ports:\n    clk_div: Fractionally divided clock output.\n\nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating an intermediate divided clock signal. For 3.5x division:\nThe counter cycles through 7 clock cycles (MUL2_DIV_CLK = 7).\nIt generates two uneven clock periods: one with 4 source clock cycles and another with 3 source clock cycles.\nIn the next cycle, phase-shifted versions of the divided clock are generated. One phase is delayed by half a clock period, and the other is advanced by half a clock period.\nFinally, the two intermediate clocks are logically OR-ed to produce the final fractional divided clock output, ensuring the divided clock signal has a uniform period.\n\nGive me the complete code."}, "clean_code": "module freq_divbyfrac(\n    input               rst_n ,\n    input               clk,\n    output              clk_div\n    );\n\n   parameter            MUL2_DIV_CLK = 7 ;\n   reg [3:0]            cnt ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         cnt    <= 'b0 ;\n      end\n      else if (cnt == MUL2_DIV_CLK-1) begin\n         cnt    <= 'b0 ;\n      end\n      else begin\n         cnt    <= cnt + 1'b1 ;\n      end\n   end\n\n   reg                  clk_ave_r ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_ave_r <= 1'b0 ;\n      end\n      //first cycle: 4 source clk cycle\n      else if (cnt == 0) begin\n         clk_ave_r <= 1 ;\n      end\n      //2nd cycle: 3 source clk cycle\n      else if (cnt == (MUL2_DIV_CLK/2)+1) begin\n         clk_ave_r <= 1 ;\n      end\n      else begin\n         clk_ave_r <= 0 ;\n      end\n   end\n\n   //adjust\n   reg                  clk_adjust_r ;\n   always @(negedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_adjust_r <= 1'b0 ;\n      end\n      else if (cnt == 1) begin\n         clk_adjust_r <= 1 ;\n      end\n      else if (cnt == (MUL2_DIV_CLK/2)+1 ) begin\n         clk_adjust_r <= 1 ;\n      end\n      else begin\n         clk_adjust_r <= 0 ;\n      end\n   end\n\n   assign clk_div = clk_adjust_r | clk_ave_r ;\n\nendmodule\n", "corrupted_code": "module freq_divbyfrac(\n    input               rst_n ,\n    input               clk,\n    output              clk_div\n    );\n\n   parameter            MUL2_DIV_CLK = 7 ;\n   reg [3:0]            cnt ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         cnt    <= 'b0 ;\n      end\n      else if (cnt == MUL2_DIV_CLK-1) begin\n         cnt    <= 'b0 ;\n      end\n      else begin\n         cnt    <= cnt + 1'b1 ;\n      end\n   end\n\n   reg                  clk_ave_r ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_ave_r <= 1'b0 ;\n      end\n      //first cycle: 4 source clk cycle\n      else if (cnt == 0) begin\n          <= 1 ;\n      end\n      else begin\n         clk_ave_r <= 0 ;\n      end\n   end\n\n   //adjust\n   reg                  clk_adjust_r ;\n   always @(negedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_adjust_r <= 1'b0 ;\n      end\n      else if (cnt == 1) begin\n         clk_adjust_r <= 1 ;\n      end\n      else if (cnt == (MUL2_DIV_CLK/2)+1 ) begin\n         clk_adjust_r <= 1 ;\n      end\n      else begin\n         clk_adjust_r <= 0 ;\n      end\n   end\n\n   assign clk_div = clk_adjust_r | clk_ave_r ;\n\nendmodule\n", "corruption_explanation": "Removed CDC synchronizer stage", "modification_type": "modify_cdc", "modification_line": 28, "original_snippet": "clk_ave_r <= 1 ;\n      end\n      //2nd cycle: 3 source clk cycle\n      else if (cnt == (MUL2_DIV_CLK/2)+1) begin\n         clk_ave_r", "modified_snippet": "(removed)", "issue_description": "The buggy code has a broken clock domain crossing synchronizer. A synchronizer flip-flop stage was removed, reducing metastability protection. This creates CDC violations that cause random data corruption in multi-clock domain designs.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a modify_cdc modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed CDC synchronizer stage\n   \u2022 Line 28: Original: clk_ave_r <= 1 ;\n      end\n      //2nd cycle: 3 source clk cycle\n      else if (cnt == (MUL2_DIV_CLK/2)+1) begin\n         clk_ave_r\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 28.\n   \u2022 Restore the original code: clk_ave_r <= 1 ;\n      end\n      //2nd cycle: 3 source clk cycle\n      else if (cnt == (MUL2_DIV_CLK/2)+1) begin\n         clk_ave_r\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to modify cdc.", "complexity": 26, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["modify_cdc"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.173094", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_divbyfrac", "module_name": "freq_divbyfrac", "description": "Please act as a professional Verilog designer.\n\nA frequency divider that divides the input clock frequency by fractional values. It generates a clock signal with a fractional frequency division (3.5x), using the double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance. By dividing uneven clock cycles and phase-shifting them, a smooth fractional clock output is produced.\n\nModule name: \n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal to initialize the module.\n    \nOutput ports:\n    clk_div: Fractionally divided clock output.\n\nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating an intermediate divided clock signal. For 3.5x division:\nThe counter cycles through 7 clock cycles (MUL2_DIV_CLK = 7).\nIt generates two uneven clock periods: one with 4 source clock cycles and another with 3 source clock cycles.\nIn the next cycle, phase-shifted versions of the divided clock are generated. One phase is delayed by half a clock period, and the other is advanced by half a clock period.\nFinally, the two intermediate clocks are logically OR-ed to produce the final fractional divided clock output, ensuring the divided clock signal has a uniform period.\n\nGive me the complete code."}, "clean_code": "module freq_divbyfrac(\n    input               rst_n ,\n    input               clk,\n    output              clk_div\n    );\n\n   parameter            MUL2_DIV_CLK = 7 ;\n   reg [3:0]            cnt ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         cnt    <= 'b0 ;\n      end\n      else if (cnt == MUL2_DIV_CLK-1) begin\n         cnt    <= 'b0 ;\n      end\n      else begin\n         cnt    <= cnt + 1'b1 ;\n      end\n   end\n\n   reg                  clk_ave_r ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_ave_r <= 1'b0 ;\n      end\n      //first cycle: 4 source clk cycle\n      else if (cnt == 0) begin\n         clk_ave_r <= 1 ;\n      end\n      //2nd cycle: 3 source clk cycle\n      else if (cnt == (MUL2_DIV_CLK/2)+1) begin\n         clk_ave_r <= 1 ;\n      end\n      else begin\n         clk_ave_r <= 0 ;\n      end\n   end\n\n   //adjust\n   reg                  clk_adjust_r ;\n   always @(negedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_adjust_r <= 1'b0 ;\n      end\n      else if (cnt == 1) begin\n         clk_adjust_r <= 1 ;\n      end\n      else if (cnt == (MUL2_DIV_CLK/2)+1 ) begin\n         clk_adjust_r <= 1 ;\n      end\n      else begin\n         clk_adjust_r <= 0 ;\n      end\n   end\n\n   assign clk_div = clk_adjust_r | clk_ave_r ;\n\nendmodule\n", "corrupted_code": "module freq_divbyfrac(\n    input               rst_n ,\n    input               clk,\n    output              clk_div\n    );\n\n   parameter            MUL2_DIV_CLK = 7 ;\n   reg [3:0]            cnt ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         cnt    <= 'b0 ;\n      end\n      else if (cnt == MUL2_DIV_CLK-1) begin\n         cnt    <= 'b0 ;\n      end\n      else begin\n         cnt    <= cnt + 1'b1 ;\n      end\n   end\n\n   reg                  clk_ave_r ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_ave_r <= 1'b0 ;\n      end\n      //first cycle: 4 source clk cycle\n      else if (cnt == 0) begin\n         clk_ave_r <= 1 ;\n      end\n      //2nd cycle: 3 source clk cycle\n      else if (cnt == (MUL2_DIV_CLK/2)+1) begin\n         clk_ave_r <= 1 ;\n      end\n      else begin\n         clk_ave_r <= 0 ;\n      end\n   end\n\n   //adjust\n   reg                  clk_adjust_r ;\n   always @(negedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_adjust_r <= 1'b0 ;\n      end\n      else if (cnt == 1) begin\n         clk_adjust_r <= 1 ;\n      end\n      else if (cnt == (MUL2_DIV_CLK/2)+1 ) begin\n         clk_adjust_r <= 1 ;\n      end\n      else begin\n         clk_adjust_r <= 0 ;\n      end\n   end\n\n   assign clk_div = clk_adjust_r | clk_ave_r ;\nassign clk_div = 1'b0;  // Conflicting assignment\n\nendmodule\n", "corruption_explanation": "Added conflicting driver for signal 'clk_div'", "modification_type": "add_multiple_driver", "modification_line": 55, "original_snippet": "assign clk_div = clk_adjust_r | clk_ave_r ;", "modified_snippet": "assign clk_div = clk_adjust_r | clk_ave_r ;\nassign clk_div = 1'b0;  // Conflicting assignment", "issue_description": "The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_multiple_driver modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added conflicting driver for signal 'clk_div'\n   \u2022 Line 55: Original: assign clk_div = clk_adjust_r | clk_ave_r ;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 55.\n   \u2022 Restore the original code: assign clk_div = clk_adjust_r | clk_ave_r ;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add multiple driver.", "complexity": 26, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["add_multiple_driver"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.175700", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_divbyfrac", "module_name": "freq_divbyfrac", "description": "Please act as a professional Verilog designer.\n\nA frequency divider that divides the input clock frequency by fractional values. It generates a clock signal with a fractional frequency division (3.5x), using the double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance. By dividing uneven clock cycles and phase-shifting them, a smooth fractional clock output is produced.\n\nModule name: \n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal to initialize the module.\n    \nOutput ports:\n    clk_div: Fractionally divided clock output.\n\nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating an intermediate divided clock signal. For 3.5x division:\nThe counter cycles through 7 clock cycles (MUL2_DIV_CLK = 7).\nIt generates two uneven clock periods: one with 4 source clock cycles and another with 3 source clock cycles.\nIn the next cycle, phase-shifted versions of the divided clock are generated. One phase is delayed by half a clock period, and the other is advanced by half a clock period.\nFinally, the two intermediate clocks are logically OR-ed to produce the final fractional divided clock output, ensuring the divided clock signal has a uniform period.\n\nGive me the complete code."}, "clean_code": "module freq_divbyfrac(\n    input               rst_n ,\n    input               clk,\n    output              clk_div\n    );\n\n   parameter            MUL2_DIV_CLK = 7 ;\n   reg [3:0]            cnt ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         cnt    <= 'b0 ;\n      end\n      else if (cnt == MUL2_DIV_CLK-1) begin\n         cnt    <= 'b0 ;\n      end\n      else begin\n         cnt    <= cnt + 1'b1 ;\n      end\n   end\n\n   reg                  clk_ave_r ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_ave_r <= 1'b0 ;\n      end\n      //first cycle: 4 source clk cycle\n      else if (cnt == 0) begin\n         clk_ave_r <= 1 ;\n      end\n      //2nd cycle: 3 source clk cycle\n      else if (cnt == (MUL2_DIV_CLK/2)+1) begin\n         clk_ave_r <= 1 ;\n      end\n      else begin\n         clk_ave_r <= 0 ;\n      end\n   end\n\n   //adjust\n   reg                  clk_adjust_r ;\n   always @(negedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_adjust_r <= 1'b0 ;\n      end\n      else if (cnt == 1) begin\n         clk_adjust_r <= 1 ;\n      end\n      else if (cnt == (MUL2_DIV_CLK/2)+1 ) begin\n         clk_adjust_r <= 1 ;\n      end\n      else begin\n         clk_adjust_r <= 0 ;\n      end\n   end\n\n   assign clk_div = clk_adjust_r | clk_ave_r ;\n\nendmodule\n", "corrupted_code": "module freq_divbyfrac(\n    input               rst_n ,\n    input               clk,\n    output              clk_div\n    );\n\n   parameter            MUL2_DIV_CLK = 7 ;\n   reg [3:0]            cnt ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         cnt    <= 'b0 ;\n      end\n      else if (cnt == MUL2_DIV_CLK-1) begin\n         cnt    <= 'b0 ;\n      end\n      else begin\n         cnt    <= cnt + 1'b1 ;\n      end\n   end\n\n   reg                  clk_ave_r ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_ave_r <= 1'b0 ;\n      end\n      //first cycle: 4 source clk cycle\n      else if (cnt == 0) begin\n         clk_ave_r <= 1 ;\n      end\n      //2nd cycle: 3 source clk cycle\n      else if (cnt == (MUL2_DIV_CLK/2)+1) begin\n         clk_ave_r <= 1 ;\n      end\n      else begin\n         clk_ave_r <= 0 ;\n      end\n   end\n\n   //adjust\n   reg                  clk_adjust_r ;\n   always @(negedge clk) begin\n      if (!rst_n) begin\n         clk_adjust_r <= 1'b0 ;\n      end\n      else if (cnt == 1) begin\n         clk_adjust_r <= 1 ;\n      end\n      else if (cnt == (MUL2_DIV_CLK/2)+1 ) begin\n         clk_adjust_r <= 1 ;\n      end\n      else begin\n         clk_adjust_r <= 0 ;\n      end\n   end\n\n   assign clk_div = clk_adjust_r | clk_ave_r ;\n\nendmodule\n", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 41, "original_snippet": "always @(negedge clk or negedge rst_n)", "modified_snippet": "always @(negedge clk)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 41: Original: always @(negedge clk or negedge rst_n)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 41.\n   \u2022 Restore the original code: always @(negedge clk or negedge rst_n)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 26, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_sensitivity_list"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.177959", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_divbyfrac", "module_name": "freq_divbyfrac", "description": "Please act as a professional Verilog designer.\n\nA frequency divider that divides the input clock frequency by fractional values. It generates a clock signal with a fractional frequency division (3.5x), using the double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance. By dividing uneven clock cycles and phase-shifting them, a smooth fractional clock output is produced.\n\nModule name: \n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal to initialize the module.\n    \nOutput ports:\n    clk_div: Fractionally divided clock output.\n\nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating an intermediate divided clock signal. For 3.5x division:\nThe counter cycles through 7 clock cycles (MUL2_DIV_CLK = 7).\nIt generates two uneven clock periods: one with 4 source clock cycles and another with 3 source clock cycles.\nIn the next cycle, phase-shifted versions of the divided clock are generated. One phase is delayed by half a clock period, and the other is advanced by half a clock period.\nFinally, the two intermediate clocks are logically OR-ed to produce the final fractional divided clock output, ensuring the divided clock signal has a uniform period.\n\nGive me the complete code."}, "clean_code": "module freq_divbyfrac(\n    input               rst_n ,\n    input               clk,\n    output              clk_div\n    );\n\n   parameter            MUL2_DIV_CLK = 7 ;\n   reg [3:0]            cnt ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         cnt    <= 'b0 ;\n      end\n      else if (cnt == MUL2_DIV_CLK-1) begin\n         cnt    <= 'b0 ;\n      end\n      else begin\n         cnt    <= cnt + 1'b1 ;\n      end\n   end\n\n   reg                  clk_ave_r ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_ave_r <= 1'b0 ;\n      end\n      //first cycle: 4 source clk cycle\n      else if (cnt == 0) begin\n         clk_ave_r <= 1 ;\n      end\n      //2nd cycle: 3 source clk cycle\n      else if (cnt == (MUL2_DIV_CLK/2)+1) begin\n         clk_ave_r <= 1 ;\n      end\n      else begin\n         clk_ave_r <= 0 ;\n      end\n   end\n\n   //adjust\n   reg                  clk_adjust_r ;\n   always @(negedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_adjust_r <= 1'b0 ;\n      end\n      else if (cnt == 1) begin\n         clk_adjust_r <= 1 ;\n      end\n      else if (cnt == (MUL2_DIV_CLK/2)+1 ) begin\n         clk_adjust_r <= 1 ;\n      end\n      else begin\n         clk_adjust_r <= 0 ;\n      end\n   end\n\n   assign clk_div = clk_adjust_r | clk_ave_r ;\n\nendmodule\n", "corrupted_code": "module freq_divbyfrac(\n    input               rst_n ,\n    input               clk,\n    output              clk_div\n    );\n\n   parameter            MUL2_DIV_CLK = 7 ;\n   reg [3:0]            cnt ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         cnt    <= 'b0 ;\n      end\n      else if (cnt == MUL2_DIV_CLK-1) begin\n         cnt    <= 'b0 ;\n      end\n      else begin\n         cnt    <= cnt + 1'b1 ;\n      end\n   end\n\n   reg                  clk_ave_r ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_ave_r <= 1'b0 ;\n      end\n      //first cycle: 4 source clk cycle\n      else if (cnt == 0) begin\n         clk_ave_r <= 1 ;\n      end\n      //2nd cycle: 3 source clk cycle\n      else if (cnt == (MUL2_DIV_CLK/2)+1) begin\n         clk_ave_r <= 1 ;\n      end\n      else begin\n         clk_ave_r <= 0 ;\n      end\n   end\n\n   //adjust\n   reg                  clk_adjust_r ;\n   always @(negedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_adjust_r <= 1'b0 ;\n      end\n      else if (cnt == 1) begin\n         clk_adjust_r <= 1 ;\n      end\n      else if (cnt == (MUL2_DIV_CLK/2)+1 ) begin\n         clk_adjust_r <= 1 ;\n      end\n   end\n\n   assign clk_div = clk_adjust_r | clk_ave_r ;\n\nendmodule\n", "corruption_explanation": "Removed else branch (may cause latch inference)", "modification_type": "remove_else_branch", "modification_line": 42, "original_snippet": "if (!rst_n) begin\n         clk_adjust_r <= 1'b0 ;\n      end\n      else if (cnt == 1) begin\n         clk_adjust_r <= 1 ;\n      end\n      else if (cnt == (MUL2_DIV_CLK/2)+1 ) begin\n         clk_adjust_r", "modified_snippet": "if (!rst_n) begin\n         clk_adjust_r <= 1'b0 ;\n      end\n      else if (cnt == 1) begin\n         clk_adjust_r <= 1 ;\n      end\n      else if (cnt == (MUL2_DIV_CLK/2)+1 ) begin\n         clk_adjust_r", "issue_description": "The buggy code is missing an else branch in a conditional statement. In combinational logic (always_comb or always @*), this can cause latch inference because the output is not defined for all input conditions. In sequential logic, signals may retain old values unexpectedly. This violates RTL design best practices requiring complete conditional assignments.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module should provide a complete conditional assignment to avoid latch inference.\n   \u2022 Combinational logic must define outputs for all input conditions.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an if statement without an else branch.\n   \u2022 The assigned signal is not defined when the condition is false.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The else branch has been removed from the conditional.\n   \u2022 This creates an incomplete conditional assignment.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Missing else branch leaves the signal undefined in some cases.\n   \u2022 Impact: Latch inference in combinational blocks, or stale values in sequential blocks.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Add an else branch with appropriate default or alternative assignment.\n   \u2022 Ensure all signals are assigned in all branches of the conditional.\n\n6. RTL Design Principle Violated:\n   \u2022 Combinational logic must have complete assignments to avoid latch inference.\n   \u2022 All conditional blocks should have else clauses or default values.", "complexity": 26, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_else_branch"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.181979", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_divbyfrac", "module_name": "freq_divbyfrac", "description": "Please act as a professional Verilog designer.\n\nA frequency divider that divides the input clock frequency by fractional values. It generates a clock signal with a fractional frequency division (3.5x), using the double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance. By dividing uneven clock cycles and phase-shifting them, a smooth fractional clock output is produced.\n\nModule name: \n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal to initialize the module.\n    \nOutput ports:\n    clk_div: Fractionally divided clock output.\n\nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating an intermediate divided clock signal. For 3.5x division:\nThe counter cycles through 7 clock cycles (MUL2_DIV_CLK = 7).\nIt generates two uneven clock periods: one with 4 source clock cycles and another with 3 source clock cycles.\nIn the next cycle, phase-shifted versions of the divided clock are generated. One phase is delayed by half a clock period, and the other is advanced by half a clock period.\nFinally, the two intermediate clocks are logically OR-ed to produce the final fractional divided clock output, ensuring the divided clock signal has a uniform period.\n\nGive me the complete code."}, "clean_code": "module freq_divbyfrac(\n    input               rst_n ,\n    input               clk,\n    output              clk_div\n    );\n\n   parameter            MUL2_DIV_CLK = 7 ;\n   reg [3:0]            cnt ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         cnt    <= 'b0 ;\n      end\n      else if (cnt == MUL2_DIV_CLK-1) begin\n         cnt    <= 'b0 ;\n      end\n      else begin\n         cnt    <= cnt + 1'b1 ;\n      end\n   end\n\n   reg                  clk_ave_r ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_ave_r <= 1'b0 ;\n      end\n      //first cycle: 4 source clk cycle\n      else if (cnt == 0) begin\n         clk_ave_r <= 1 ;\n      end\n      //2nd cycle: 3 source clk cycle\n      else if (cnt == (MUL2_DIV_CLK/2)+1) begin\n         clk_ave_r <= 1 ;\n      end\n      else begin\n         clk_ave_r <= 0 ;\n      end\n   end\n\n   //adjust\n   reg                  clk_adjust_r ;\n   always @(negedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_adjust_r <= 1'b0 ;\n      end\n      else if (cnt == 1) begin\n         clk_adjust_r <= 1 ;\n      end\n      else if (cnt == (MUL2_DIV_CLK/2)+1 ) begin\n         clk_adjust_r <= 1 ;\n      end\n      else begin\n         clk_adjust_r <= 0 ;\n      end\n   end\n\n   assign clk_div = clk_adjust_r | clk_ave_r ;\n\nendmodule\n", "corrupted_code": "module freq_divbyfrac(\n    input               rst_n ,\n    input               clk,\n    output              clk_div\n    );\n\n   parameter            MUL2_DIV_CLK = 7 ;\n   reg [3:0]            cnt ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         cnt    <= 'b0 ;\n      end\n      else if (cnt == MUL2_DIV_CLK-1) begin\n         cnt    <= 'b0 ;\n      end\n      else begin\n         cnt    <= cnt + 1'b1 ;\n      end\n   end\n\n   reg                  clk_ave_r ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_ave_r <= 1'b0 ;\n      end\n      //first cycle: 4 source clk cycle\n      else if (cnt == 0) begin\n         clk_ave_r <= 1 ;\n      end\n      //2nd cycle: 3 source clk cycle\n      else if (cnt == (MUL2_DIV_CLK/2)+1) begin\n         clk_ave_r <= 1 ;\n      end\n      else begin\n         clk_ave_r <= 0 ;\n      end\n   end\n\n   //adjust\n   reg                  clk_adjust_r ;\n   always @(negedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_adjust_r <= 1'b0 ;\n      end\n      else if (cnt == 1) begin\n         clk_adjust_r <= 1 ;\n      end\n      else if (cnt == (MUL2_DIV_CLK/2)+1 ) begin\n         clk_adjust_r <= 1 ;\n      end\n      else begin\n         clk_adjust_r <= 0 ;\n      end\n   end\n\n   assign clk_div = clk_adjust_r | clk_ave_r ;\nassign clk_div = 1'b0;  // Conflicting assignment\n\nendmodule\n", "corruption_explanation": "Added conflicting driver for signal 'clk_div'", "modification_type": "add_multiple_driver", "modification_line": 55, "original_snippet": "assign clk_div = clk_adjust_r | clk_ave_r ;", "modified_snippet": "assign clk_div = clk_adjust_r | clk_ave_r ;\nassign clk_div = 1'b0;  // Conflicting assignment", "issue_description": "The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_multiple_driver modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added conflicting driver for signal 'clk_div'\n   \u2022 Line 55: Original: assign clk_div = clk_adjust_r | clk_ave_r ;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 55.\n   \u2022 Restore the original code: assign clk_div = clk_adjust_r | clk_ave_r ;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add multiple driver.", "complexity": 26, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["add_multiple_driver"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.184124", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_divbyfrac", "module_name": "freq_divbyfrac", "description": "Please act as a professional Verilog designer.\n\nA frequency divider that divides the input clock frequency by fractional values. It generates a clock signal with a fractional frequency division (3.5x), using the double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance. By dividing uneven clock cycles and phase-shifting them, a smooth fractional clock output is produced.\n\nModule name: \n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal to initialize the module.\n    \nOutput ports:\n    clk_div: Fractionally divided clock output.\n\nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating an intermediate divided clock signal. For 3.5x division:\nThe counter cycles through 7 clock cycles (MUL2_DIV_CLK = 7).\nIt generates two uneven clock periods: one with 4 source clock cycles and another with 3 source clock cycles.\nIn the next cycle, phase-shifted versions of the divided clock are generated. One phase is delayed by half a clock period, and the other is advanced by half a clock period.\nFinally, the two intermediate clocks are logically OR-ed to produce the final fractional divided clock output, ensuring the divided clock signal has a uniform period.\n\nGive me the complete code."}, "clean_code": "module freq_divbyfrac(\n    input               rst_n ,\n    input               clk,\n    output              clk_div\n    );\n\n   parameter            MUL2_DIV_CLK = 7 ;\n   reg [3:0]            cnt ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         cnt    <= 'b0 ;\n      end\n      else if (cnt == MUL2_DIV_CLK-1) begin\n         cnt    <= 'b0 ;\n      end\n      else begin\n         cnt    <= cnt + 1'b1 ;\n      end\n   end\n\n   reg                  clk_ave_r ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_ave_r <= 1'b0 ;\n      end\n      //first cycle: 4 source clk cycle\n      else if (cnt == 0) begin\n         clk_ave_r <= 1 ;\n      end\n      //2nd cycle: 3 source clk cycle\n      else if (cnt == (MUL2_DIV_CLK/2)+1) begin\n         clk_ave_r <= 1 ;\n      end\n      else begin\n         clk_ave_r <= 0 ;\n      end\n   end\n\n   //adjust\n   reg                  clk_adjust_r ;\n   always @(negedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_adjust_r <= 1'b0 ;\n      end\n      else if (cnt == 1) begin\n         clk_adjust_r <= 1 ;\n      end\n      else if (cnt == (MUL2_DIV_CLK/2)+1 ) begin\n         clk_adjust_r <= 1 ;\n      end\n      else begin\n         clk_adjust_r <= 0 ;\n      end\n   end\n\n   assign clk_div = clk_adjust_r | clk_ave_r ;\n\nendmodule\n", "corrupted_code": "module freq_divbyfrac(\n    input               rst_n ,\n    input               clk,\n    output              clk_div\n    );\n\n   parameter            MUL2_DIV_CLK = 7 ;\n   reg [3:0]            cnt ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         cnt    <= 'b0 ;\n      end\n      else if (cnt == MUL2_DIV_CLK-1) begin\n         cnt    <= 'b0 ;\n      end\n      else begin\n         cnt    <= cnt + 1'b1 ;\n      end\n   end\n\n   reg                  clk_ave_r ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_ave_r <= 1'b0 ;\n      end\n      //first cycle: 4 source clk cycle\n      else if (cnt == 0) begin\n         clk_ave_r <= 1 ;\n      end\n      //2nd cycle: 3 source clk cycle\n      else if (cnt == (MUL2_DIV_CLK/2)+1) begin\n         clk_ave_r <= 1 ;\n      end\n      else begin\n         clk_ave_r <= 0 ;\n      end\n   end\n\n   //adjust\n   reg                  clk_adjust_r ;\n   always @(negedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_adjust_r <= 1'b0 ;\n      end\n      else if (cnt == 1) begin\n         clk_adjust_r <= 1 ;\n      end\n      else if (cnt == (MUL2_DIV_CLK/2)+1 ) begin\n         clk_adjust_r <= 1 ;\n      end\n      else begin\n         clk_adjust_r <= 0 ;\n      end\n   end\n\n   assign clk_div = clk_adjust_r | clk_ave_r ;\nassign clk_div = 1'b0;  // Conflicting assignment\n\nendmodule\n", "corruption_explanation": "Added conflicting driver for signal 'clk_div'", "modification_type": "add_multiple_driver", "modification_line": 55, "original_snippet": "assign clk_div = clk_adjust_r | clk_ave_r ;", "modified_snippet": "assign clk_div = clk_adjust_r | clk_ave_r ;\nassign clk_div = 1'b0;  // Conflicting assignment", "issue_description": "The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_multiple_driver modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added conflicting driver for signal 'clk_div'\n   \u2022 Line 55: Original: assign clk_div = clk_adjust_r | clk_ave_r ;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 55.\n   \u2022 Restore the original code: assign clk_div = clk_adjust_r | clk_ave_r ;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add multiple driver.", "complexity": 26, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["add_multiple_driver"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.186273", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_divbyfrac", "module_name": "freq_divbyfrac", "description": "Please act as a professional Verilog designer.\n\nA frequency divider that divides the input clock frequency by fractional values. It generates a clock signal with a fractional frequency division (3.5x), using the double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance. By dividing uneven clock cycles and phase-shifting them, a smooth fractional clock output is produced.\n\nModule name: \n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal to initialize the module.\n    \nOutput ports:\n    clk_div: Fractionally divided clock output.\n\nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating an intermediate divided clock signal. For 3.5x division:\nThe counter cycles through 7 clock cycles (MUL2_DIV_CLK = 7).\nIt generates two uneven clock periods: one with 4 source clock cycles and another with 3 source clock cycles.\nIn the next cycle, phase-shifted versions of the divided clock are generated. One phase is delayed by half a clock period, and the other is advanced by half a clock period.\nFinally, the two intermediate clocks are logically OR-ed to produce the final fractional divided clock output, ensuring the divided clock signal has a uniform period.\n\nGive me the complete code."}, "clean_code": "module freq_divbyfrac(\n    input               rst_n ,\n    input               clk,\n    output              clk_div\n    );\n\n   parameter            MUL2_DIV_CLK = 7 ;\n   reg [3:0]            cnt ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         cnt    <= 'b0 ;\n      end\n      else if (cnt == MUL2_DIV_CLK-1) begin\n         cnt    <= 'b0 ;\n      end\n      else begin\n         cnt    <= cnt + 1'b1 ;\n      end\n   end\n\n   reg                  clk_ave_r ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_ave_r <= 1'b0 ;\n      end\n      //first cycle: 4 source clk cycle\n      else if (cnt == 0) begin\n         clk_ave_r <= 1 ;\n      end\n      //2nd cycle: 3 source clk cycle\n      else if (cnt == (MUL2_DIV_CLK/2)+1) begin\n         clk_ave_r <= 1 ;\n      end\n      else begin\n         clk_ave_r <= 0 ;\n      end\n   end\n\n   //adjust\n   reg                  clk_adjust_r ;\n   always @(negedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_adjust_r <= 1'b0 ;\n      end\n      else if (cnt == 1) begin\n         clk_adjust_r <= 1 ;\n      end\n      else if (cnt == (MUL2_DIV_CLK/2)+1 ) begin\n         clk_adjust_r <= 1 ;\n      end\n      else begin\n         clk_adjust_r <= 0 ;\n      end\n   end\n\n   assign clk_div = clk_adjust_r | clk_ave_r ;\n\nendmodule\n", "corrupted_code": "module freq_divbyfrac(\n    input               rst_n ,\n    input               clk,\n    output              clk_div\n    );\n\n   parameter            MUL2_DIV_CLK = 7 ;\n   reg [3:0]            cnt ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         cnt    <= 'b0 ;\n      end\n      else if (cnt == MUL2_DIV_CLK-1) begin\n         cnt    <= 'b0 ;\n      end\n      else begin\n         cnt    <= cnt + 1'b1 ;\n      end\n   end\n\n   reg                  clk_ave_r ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_ave_r <= 1'b0 ;\n      end\n      //first cycle: 4 source clk cycle\n      else if (cnt == 0) begin\n         clk_ave_r <= 0 ;\n      end\n      //2nd cycle: 3 source clk cycle\n      else if (cnt == (MUL2_DIV_CLK/2)+1) begin\n         clk_ave_r <= 1 ;\n      end\n      else begin\n         clk_ave_r <= 0 ;\n      end\n   end\n\n   //adjust\n   reg                  clk_adjust_r ;\n   always @(negedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_adjust_r <= 1'b0 ;\n      end\n      else if (cnt == 1) begin\n         clk_adjust_r <= 1 ;\n      end\n      else if (cnt == (MUL2_DIV_CLK/2)+1 ) begin\n         clk_adjust_r <= 1 ;\n      end\n      else begin\n         clk_adjust_r <= 0 ;\n      end\n   end\n\n   assign clk_div = clk_adjust_r | clk_ave_r ;\n\nendmodule\n", "corruption_explanation": "Changed constant from 1 to 0", "modification_type": "change_constant", "modification_line": 28, "original_snippet": "1", "modified_snippet": "0", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 1 to 0\n   \u2022 Line 28: Original: 1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 28.\n   \u2022 Restore the original code: 1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 26, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_constant"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.188499", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_divbyfrac", "module_name": "freq_divbyfrac", "description": "Please act as a professional Verilog designer.\n\nA frequency divider that divides the input clock frequency by fractional values. It generates a clock signal with a fractional frequency division (3.5x), using the double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance. By dividing uneven clock cycles and phase-shifting them, a smooth fractional clock output is produced.\n\nModule name: \n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal to initialize the module.\n    \nOutput ports:\n    clk_div: Fractionally divided clock output.\n\nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating an intermediate divided clock signal. For 3.5x division:\nThe counter cycles through 7 clock cycles (MUL2_DIV_CLK = 7).\nIt generates two uneven clock periods: one with 4 source clock cycles and another with 3 source clock cycles.\nIn the next cycle, phase-shifted versions of the divided clock are generated. One phase is delayed by half a clock period, and the other is advanced by half a clock period.\nFinally, the two intermediate clocks are logically OR-ed to produce the final fractional divided clock output, ensuring the divided clock signal has a uniform period.\n\nGive me the complete code."}, "clean_code": "module freq_divbyfrac(\n    input               rst_n ,\n    input               clk,\n    output              clk_div\n    );\n\n   parameter            MUL2_DIV_CLK = 7 ;\n   reg [3:0]            cnt ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         cnt    <= 'b0 ;\n      end\n      else if (cnt == MUL2_DIV_CLK-1) begin\n         cnt    <= 'b0 ;\n      end\n      else begin\n         cnt    <= cnt + 1'b1 ;\n      end\n   end\n\n   reg                  clk_ave_r ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_ave_r <= 1'b0 ;\n      end\n      //first cycle: 4 source clk cycle\n      else if (cnt == 0) begin\n         clk_ave_r <= 1 ;\n      end\n      //2nd cycle: 3 source clk cycle\n      else if (cnt == (MUL2_DIV_CLK/2)+1) begin\n         clk_ave_r <= 1 ;\n      end\n      else begin\n         clk_ave_r <= 0 ;\n      end\n   end\n\n   //adjust\n   reg                  clk_adjust_r ;\n   always @(negedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_adjust_r <= 1'b0 ;\n      end\n      else if (cnt == 1) begin\n         clk_adjust_r <= 1 ;\n      end\n      else if (cnt == (MUL2_DIV_CLK/2)+1 ) begin\n         clk_adjust_r <= 1 ;\n      end\n      else begin\n         clk_adjust_r <= 0 ;\n      end\n   end\n\n   assign clk_div = clk_adjust_r | clk_ave_r ;\n\nendmodule\n", "corrupted_code": "module freq_divbyfrac(\n    input               rst_n ,\n    input               clk,\n    output              clk_div\n    );\n\n   parameter            MUL2_DIV_CLK = 7 ;\n   reg [3:0]            cnt ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         cnt    <= 'b0 ;\n      end\n      else if (cnt == MUL2_DIV_CLK-1) begin\n         cnt    <= 'b0 ;\n      end\n      else begin\n         cnt    <= cnt + 1'b1 ;\n      end\n   end\n\n   reg                  clk_ave_r ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_ave_r <= 1'b0 ;\n      end\n      //first cycle: 4 source clk cycle\n      else if (cnt == 0) begin\n         clk_ave_r <= 1 ;\n      end\n      //2nd cycle: 3 source clk cycle\n      else if (cnt == (MUL2_DIV_CLK/2)+1) begin\n         clk_ave_r <= 1 ;\n      end\n      else begin\n         clk_ave_r <= 0 ;\n      end\n   end\n\n   //adjust\n   reg                  clk_adjust_r ;\n   always @(negedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_adjust_r <= 1'b0 ;\n      end\n      else if (cnt == 1) begin\n         clk_adjust_r <= 2 ;\n      end\n      else if (cnt == (MUL2_DIV_CLK/2)+1 ) begin\n         clk_adjust_r <= 1 ;\n      end\n      else begin\n         clk_adjust_r <= 0 ;\n      end\n   end\n\n   assign clk_div = clk_adjust_r | clk_ave_r ;\n\nendmodule\n", "corruption_explanation": "Changed constant from 1 to 2", "modification_type": "change_constant", "modification_line": 46, "original_snippet": "1", "modified_snippet": "2", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 1 to 2\n   \u2022 Line 46: Original: 1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 46.\n   \u2022 Restore the original code: 1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 26, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_constant"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.191104", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Frequency divider", "design_name": "freq_divbyfrac", "module_name": "freq_divbyfrac", "description": "Please act as a professional Verilog designer.\n\nA frequency divider that divides the input clock frequency by fractional values. It generates a clock signal with a fractional frequency division (3.5x), using the double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance. By dividing uneven clock cycles and phase-shifting them, a smooth fractional clock output is produced.\n\nModule name: \n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal to initialize the module.\n    \nOutput ports:\n    clk_div: Fractionally divided clock output.\n\nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating an intermediate divided clock signal. For 3.5x division:\nThe counter cycles through 7 clock cycles (MUL2_DIV_CLK = 7).\nIt generates two uneven clock periods: one with 4 source clock cycles and another with 3 source clock cycles.\nIn the next cycle, phase-shifted versions of the divided clock are generated. One phase is delayed by half a clock period, and the other is advanced by half a clock period.\nFinally, the two intermediate clocks are logically OR-ed to produce the final fractional divided clock output, ensuring the divided clock signal has a uniform period.\n\nGive me the complete code."}, "clean_code": "module freq_divbyfrac(\n    input               rst_n ,\n    input               clk,\n    output              clk_div\n    );\n\n   parameter            MUL2_DIV_CLK = 7 ;\n   reg [3:0]            cnt ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         cnt    <= 'b0 ;\n      end\n      else if (cnt == MUL2_DIV_CLK-1) begin\n         cnt    <= 'b0 ;\n      end\n      else begin\n         cnt    <= cnt + 1'b1 ;\n      end\n   end\n\n   reg                  clk_ave_r ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_ave_r <= 1'b0 ;\n      end\n      //first cycle: 4 source clk cycle\n      else if (cnt == 0) begin\n         clk_ave_r <= 1 ;\n      end\n      //2nd cycle: 3 source clk cycle\n      else if (cnt == (MUL2_DIV_CLK/2)+1) begin\n         clk_ave_r <= 1 ;\n      end\n      else begin\n         clk_ave_r <= 0 ;\n      end\n   end\n\n   //adjust\n   reg                  clk_adjust_r ;\n   always @(negedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_adjust_r <= 1'b0 ;\n      end\n      else if (cnt == 1) begin\n         clk_adjust_r <= 1 ;\n      end\n      else if (cnt == (MUL2_DIV_CLK/2)+1 ) begin\n         clk_adjust_r <= 1 ;\n      end\n      else begin\n         clk_adjust_r <= 0 ;\n      end\n   end\n\n   assign clk_div = clk_adjust_r | clk_ave_r ;\n\nendmodule\n", "corrupted_code": "module freq_divbyfrac(\n    input               rst_n ,\n    input               clk,\n    output              clk_div\n    );\n\n   parameter            MUL2_DIV_CLK = 7 ;\n   reg [3:0]            cnt ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         cnt    <= 'b0 ;\n      end\n      else if (cnt == MUL2_DIV_CLK-2) begin\n         cnt    <= 'b0 ;\n      end\n      else begin\n         cnt    <= cnt + 1'b1 ;\n      end\n   end\n\n   reg                  clk_ave_r ;\n   always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_ave_r <= 1'b0 ;\n      end\n      //first cycle: 4 source clk cycle\n      else if (cnt == 0) begin\n         clk_ave_r <= 1 ;\n      end\n      //2nd cycle: 3 source clk cycle\n      else if (cnt == (MUL2_DIV_CLK/2)+1) begin\n         clk_ave_r <= 1 ;\n      end\n      else begin\n         clk_ave_r <= 0 ;\n      end\n   end\n\n   //adjust\n   reg                  clk_adjust_r ;\n   always @(negedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         clk_adjust_r <= 1'b0 ;\n      end\n      else if (cnt == 1) begin\n         clk_adjust_r <= 1 ;\n      end\n      else if (cnt == (MUL2_DIV_CLK/2)+1 ) begin\n         clk_adjust_r <= 1 ;\n      end\n      else begin\n         clk_adjust_r <= 0 ;\n      end\n   end\n\n   assign clk_div = clk_adjust_r | clk_ave_r ;\n\nendmodule\n", "corruption_explanation": "Changed constant from 1 to 2", "modification_type": "change_constant", "modification_line": 13, "original_snippet": "1", "modified_snippet": "2", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 1 to 2\n   \u2022 Line 13: Original: 1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 13.\n   \u2022 Restore the original code: 1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 26, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_constant"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.193712", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Signal generation", "design_name": "signal_generator", "module_name": "signal_generator", "description": "Please act as a professional verilog designer.\n\nImplement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named \"wave\". The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\n\nModule name:  \n    signal_generator \n                 \nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n\nImplementation:\nState and Waveform Generation:\nThe module includes a register, state, used to control the state of the waveform generation.\nThe module also includes a register, wave, with a width of 5 bits, which represents the generated waveform.\nThe state and waveform registers are updated in the always block, triggered on the positive edge of the clock signal (posedge clk) or the negative edge of the reset signal (negedge rst_n).\nOn reset, indicated by ~rst_n, the state register is cleared to 0, and the wave register is cleared to 0.\nThe waveform generation is controlled using a case statement based on the current state:\nIf the state is 0, the waveform (wave) is incremented by 1.\nIf the waveform reaches 31 (wave == 31), the state is transitioned to 1.\nIf the state is 1, the waveform is decremented by 1.\nIf the waveform reaches 0 (wave == 0), the state is transitioned back to 0.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions.\n\nGive me the complete code.\n"}, "clean_code": "module signal_generator(\n  input clk,\n  input rst_n,\n  output reg [4:0] wave\n);\n\n  reg [1:0] state;\n  \n  always @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n      state <= 2'b0;\n      wave <= 5'b0;\n    end\n    else begin\n      case (state)\n        2'b00:\n          begin\n            if (wave == 5'b11111)\n              state <= 2'b01;\n            else\n              wave <= wave + 1;\n          end\n          \n        2'b01:\n          begin\n            if (wave == 5'b00000)\n              state <= 2'b00;\n            else\n              wave <= wave - 1;\n          end\n      endcase\n    end\n  end\n\nendmodule", "corrupted_code": "module signal_generator(\n  input clk,\n  input rst_n,\n  output reg [4:0] wave\n);\n\n  reg [1:0] state;\n  \n  always @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n      state <= 2'b0;\n      wave <= 5'b0;\n    end\n    else begin\n      case (state)\n        2'b00:\n          begin\n            if (wave == 5'b11111)\n              state <= 2'b01;\n            else\n              wave <= wave + 1;\n          end\n          \n        2'b01:\n          begin\n            if (wave == 5'b00000)\n              state <= 2'b00;\n            else\n\n          end\n      endcase\n    end\n  end\n\nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 29, "original_snippet": "wave <= wave - 1;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 29: Original: wave <= wave - 1;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 29.\n   \u2022 Restore the original code: wave <= wave - 1;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 13, "applicable_modifications": ["invert_if_else", "remove_else_branch", "remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.199008", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Signal generation", "design_name": "signal_generator", "module_name": "signal_generator", "description": "Please act as a professional verilog designer.\n\nImplement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named \"wave\". The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\n\nModule name:  \n    signal_generator \n                 \nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n\nImplementation:\nState and Waveform Generation:\nThe module includes a register, state, used to control the state of the waveform generation.\nThe module also includes a register, wave, with a width of 5 bits, which represents the generated waveform.\nThe state and waveform registers are updated in the always block, triggered on the positive edge of the clock signal (posedge clk) or the negative edge of the reset signal (negedge rst_n).\nOn reset, indicated by ~rst_n, the state register is cleared to 0, and the wave register is cleared to 0.\nThe waveform generation is controlled using a case statement based on the current state:\nIf the state is 0, the waveform (wave) is incremented by 1.\nIf the waveform reaches 31 (wave == 31), the state is transitioned to 1.\nIf the state is 1, the waveform is decremented by 1.\nIf the waveform reaches 0 (wave == 0), the state is transitioned back to 0.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions.\n\nGive me the complete code.\n"}, "clean_code": "module signal_generator(\n  input clk,\n  input rst_n,\n  output reg [4:0] wave\n);\n\n  reg [1:0] state;\n  \n  always @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n      state <= 2'b0;\n      wave <= 5'b0;\n    end\n    else begin\n      case (state)\n        2'b00:\n          begin\n            if (wave == 5'b11111)\n              state <= 2'b01;\n            else\n              wave <= wave + 1;\n          end\n          \n        2'b01:\n          begin\n            if (wave == 5'b00000)\n              state <= 2'b00;\n            else\n              wave <= wave - 1;\n          end\n      endcase\n    end\n  end\n\nendmodule", "corrupted_code": "module signal_generator(\n  input clk,\n  input rst_n,\n  output reg [4:1] wave\n);\n\n  reg [1:0] state;\n  \n  always @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n      state <= 2'b0;\n      wave <= 5'b0;\n    end\n    else begin\n      case (state)\n        2'b00:\n          begin\n            if (wave == 5'b11111)\n              state <= 2'b01;\n            else\n              wave <= wave + 1;\n          end\n          \n        2'b01:\n          begin\n            if (wave == 5'b00000)\n              state <= 2'b00;\n            else\n              wave <= wave - 1;\n          end\n      endcase\n    end\n  end\n\nendmodule", "corruption_explanation": "Changed bit width from [4:0] to [4:1]", "modification_type": "change_bit_width", "modification_line": 4, "original_snippet": "[4:0]", "modified_snippet": "[4:1]", "issue_description": "The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_bit_width modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed bit width from [4:0] to [4:1]\n   \u2022 Line 4: Original: [4:0]\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 4.\n   \u2022 Restore the original code: [4:0]\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change bit width.", "complexity": 13, "applicable_modifications": ["invert_if_else", "remove_else_branch", "remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_bit_width"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.199801", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Signal generation", "design_name": "signal_generator", "module_name": "signal_generator", "description": "Please act as a professional verilog designer.\n\nImplement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named \"wave\". The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\n\nModule name:  \n    signal_generator \n                 \nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n\nImplementation:\nState and Waveform Generation:\nThe module includes a register, state, used to control the state of the waveform generation.\nThe module also includes a register, wave, with a width of 5 bits, which represents the generated waveform.\nThe state and waveform registers are updated in the always block, triggered on the positive edge of the clock signal (posedge clk) or the negative edge of the reset signal (negedge rst_n).\nOn reset, indicated by ~rst_n, the state register is cleared to 0, and the wave register is cleared to 0.\nThe waveform generation is controlled using a case statement based on the current state:\nIf the state is 0, the waveform (wave) is incremented by 1.\nIf the waveform reaches 31 (wave == 31), the state is transitioned to 1.\nIf the state is 1, the waveform is decremented by 1.\nIf the waveform reaches 0 (wave == 0), the state is transitioned back to 0.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions.\n\nGive me the complete code.\n"}, "clean_code": "module signal_generator(\n  input clk,\n  input rst_n,\n  output reg [4:0] wave\n);\n\n  reg [1:0] state;\n  \n  always @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n      state <= 2'b0;\n      wave <= 5'b0;\n    end\n    else begin\n      case (state)\n        2'b00:\n          begin\n            if (wave == 5'b11111)\n              state <= 2'b01;\n            else\n              wave <= wave + 1;\n          end\n          \n        2'b01:\n          begin\n            if (wave == 5'b00000)\n              state <= 2'b00;\n            else\n              wave <= wave - 1;\n          end\n      endcase\n    end\n  end\n\nendmodule", "corrupted_code": "module signal_generator(\n  input clk,\n  input rst_n,\n  output reg [4:0] wave\n);\n\n  reg [1:0] state;\n  \n  always @(posedge clk or posedge rst_n) begin\n    if (~rst_n) begin\n      state <= 2'b0;\n      wave <= 5'b0;\n    end\n    else begin\n      case (state)\n        2'b00:\n          begin\n            if (wave == 5'b11111)\n              state <= 2'b01;\n            else\n              wave <= wave + 1;\n          end\n          \n        2'b01:\n          begin\n            if (wave == 5'b00000)\n              state <= 2'b00;\n            else\n              wave <= wave - 1;\n          end\n      endcase\n    end\n  end\n\nendmodule", "corruption_explanation": "Inverted reset polarity in sensitivity", "modification_type": "invert_reset_polarity", "modification_line": 9, "original_snippet": "always @(posedge clk or negedge rst_n)", "modified_snippet": "always @(posedge clk or posedge rst_n)", "issue_description": "The buggy code has inverted reset polarity. If the design expects active-low reset (!rst), it now uses active-high, or vice versa. This causes the reset logic to activate during normal operation and deactivate during actual reset, breaking initialization.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_reset_polarity modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted reset polarity in sensitivity\n   \u2022 Line 9: Original: always @(posedge clk or negedge rst_n)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 9.\n   \u2022 Restore the original code: always @(posedge clk or negedge rst_n)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert reset polarity.", "complexity": 13, "applicable_modifications": ["invert_if_else", "remove_else_branch", "remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_reset_polarity"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.258138", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Signal generation", "design_name": "square_wave", "module_name": "square_wave", "description": "Please act as a professional verilog designer.\n\nThe module is a simple yet effective generator designed to produce square wave signals with variable frequency. It takes an input clock signal and a frequency value, and outputs a square wave signal toggling at the specified frequency.\n\nModule name:  \n    square_wave \n                 \nInput ports:\n    clk: Clock signal that drives the module.\n    [7:0]freq: Frequency control, specifying how often the square wave toggles.\n\nOutput ports:\n    wave_out: Square wave output signal.\n\nInternal Registers:\n    count (reg [7:0]): Counter register used to track cycles between wave toggles.\n    \nImplementation:\nCounter Operation:\n    The count register increments on each rising edge of the clk.\n    When count reaches (freq - 1), the count is reset to 0 and wave_out is toggled (i.e., flipped from 0 to 1 or from 1 to 0).\n    If count has not reached freq, it simply increments by one on the next clock cycle.\nSquare Wave Generation:\n    The module produces a square wave by flipping the wave_out signal at the rate determined by freq.\n    The higher the freq value, the slower the square wave toggles (i.e., the lower the output frequency), and vice versa.\n    \nGive me the complete code.\n"}, "clean_code": "module square_wave(\n    input clk,                     \n    input [7:0] freq,           \n    output reg wave_out          \n);\n\nreg [7:0] count;                \n\ninitial begin\n    wave_out = 0;  \n    count = 0;     \nend\n\nalways @(posedge clk) begin\n    if(count == freq - 1 ) begin      \n        count <= 0;\n        wave_out <=  ~wave_out ;            \n\n    end else begin\n        count <= count + 1;        \n    end\nend\n\nendmodule", "corrupted_code": "module square_wave(\n    input clk,                     \n    input [7:0] freq,           \n    output reg wave_out          \n);\n\nreg [7:0] count;                \n\ninitial begin\n    wave_out = 0;  \n    count = 0;     \nend\n\nalways @(posedge clk) begin\n    if(count == freq - 1 ) begin      \n         <= count + 1;        \n    end\nend\n\nendmodule", "corruption_explanation": "Removed CDC synchronizer stage", "modification_type": "modify_cdc", "modification_line": 16, "original_snippet": "count <= 0;\n        wave_out <=  ~wave_out ;            \n\n    end else begin\n        count", "modified_snippet": "(removed)", "issue_description": "The buggy code has a broken clock domain crossing synchronizer. A synchronizer flip-flop stage was removed, reducing metastability protection. This creates CDC violations that cause random data corruption in multi-clock domain designs.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a modify_cdc modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed CDC synchronizer stage\n   \u2022 Line 16: Original: count <= 0;\n        wave_out <=  ~wave_out ;            \n\n    end else begin\n        count\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 16.\n   \u2022 Restore the original code: count <= 0;\n        wave_out <=  ~wave_out ;            \n\n    end else begin\n        count\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to modify cdc.", "complexity": 7, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["modify_cdc"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.262466", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Signal generation", "design_name": "square_wave", "module_name": "square_wave", "description": "Please act as a professional verilog designer.\n\nThe module is a simple yet effective generator designed to produce square wave signals with variable frequency. It takes an input clock signal and a frequency value, and outputs a square wave signal toggling at the specified frequency.\n\nModule name:  \n    square_wave \n                 \nInput ports:\n    clk: Clock signal that drives the module.\n    [7:0]freq: Frequency control, specifying how often the square wave toggles.\n\nOutput ports:\n    wave_out: Square wave output signal.\n\nInternal Registers:\n    count (reg [7:0]): Counter register used to track cycles between wave toggles.\n    \nImplementation:\nCounter Operation:\n    The count register increments on each rising edge of the clk.\n    When count reaches (freq - 1), the count is reset to 0 and wave_out is toggled (i.e., flipped from 0 to 1 or from 1 to 0).\n    If count has not reached freq, it simply increments by one on the next clock cycle.\nSquare Wave Generation:\n    The module produces a square wave by flipping the wave_out signal at the rate determined by freq.\n    The higher the freq value, the slower the square wave toggles (i.e., the lower the output frequency), and vice versa.\n    \nGive me the complete code.\n"}, "clean_code": "module square_wave(\n    input clk,                     \n    input [7:0] freq,           \n    output reg wave_out          \n);\n\nreg [7:0] count;                \n\ninitial begin\n    wave_out = 0;  \n    count = 0;     \nend\n\nalways @(posedge clk) begin\n    if(count == freq - 1 ) begin      \n        count <= 0;\n        wave_out <=  ~wave_out ;            \n\n    end else begin\n        count <= count + 1;        \n    end\nend\n\nendmodule", "corrupted_code": "module square_wave(\n    input clk,                     \n    input [7:0] freq,           \n    output reg wave_out          \n);\n\nreg [7:0] count;                \n\ninitial begin\n    wave_out = 0;  \n    count = 0;     \nend\n\n else begin\n        count <= count + 1;        \n    end\nend\n\nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 14, "original_snippet": "always @(posedge clk) begin\n    if(count == freq - 1 ) begin      \n        count <= 0;\n        wave_out <=  ~wave_out ;            \n\n    end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 14: Original: always @(posedge clk) begin\n    if(count == freq - 1 ) begin      \n        count <= 0;\n        wave_out <=  ~wave_out ;            \n\n    end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 14.\n   \u2022 Restore the original code: always @(posedge clk) begin\n    if(count == freq - 1 ) begin      \n        count <= 0;\n        wave_out <=  ~wave_out ;            \n\n    end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 7, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.263197", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Signal generation", "design_name": "square_wave", "module_name": "square_wave", "description": "Please act as a professional verilog designer.\n\nThe module is a simple yet effective generator designed to produce square wave signals with variable frequency. It takes an input clock signal and a frequency value, and outputs a square wave signal toggling at the specified frequency.\n\nModule name:  \n    square_wave \n                 \nInput ports:\n    clk: Clock signal that drives the module.\n    [7:0]freq: Frequency control, specifying how often the square wave toggles.\n\nOutput ports:\n    wave_out: Square wave output signal.\n\nInternal Registers:\n    count (reg [7:0]): Counter register used to track cycles between wave toggles.\n    \nImplementation:\nCounter Operation:\n    The count register increments on each rising edge of the clk.\n    When count reaches (freq - 1), the count is reset to 0 and wave_out is toggled (i.e., flipped from 0 to 1 or from 1 to 0).\n    If count has not reached freq, it simply increments by one on the next clock cycle.\nSquare Wave Generation:\n    The module produces a square wave by flipping the wave_out signal at the rate determined by freq.\n    The higher the freq value, the slower the square wave toggles (i.e., the lower the output frequency), and vice versa.\n    \nGive me the complete code.\n"}, "clean_code": "module square_wave(\n    input clk,                     \n    input [7:0] freq,           \n    output reg wave_out          \n);\n\nreg [7:0] count;                \n\ninitial begin\n    wave_out = 0;  \n    count = 0;     \nend\n\nalways @(posedge clk) begin\n    if(count == freq - 1 ) begin      \n        count <= 0;\n        wave_out <=  ~wave_out ;            \n\n    end else begin\n        count <= count + 1;        \n    end\nend\n\nendmodule", "corrupted_code": "module square_wave(\n    input clk,                     \n    input [7:0] freq,           \n    output reg wave_out          \n);\n\nreg [7:0] count;                \n\ninitial begin\n    wave_out = 0;  \n    count = 0;     \nend\n\nalways @(clk) begin\n    if(count == freq - 1 ) begin      \n        count <= 0;\n        wave_out <=  ~wave_out ;            \n\n    end else begin\n        count <= count + 1;        \n    end\nend\n\nendmodule", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 14, "original_snippet": "always @(posedge clk)", "modified_snippet": "always @(clk)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 14: Original: always @(posedge clk)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 14.\n   \u2022 Restore the original code: always @(posedge clk)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 7, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_sensitivity_list"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.264676", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Signal generation", "design_name": "square_wave", "module_name": "square_wave", "description": "Please act as a professional verilog designer.\n\nThe module is a simple yet effective generator designed to produce square wave signals with variable frequency. It takes an input clock signal and a frequency value, and outputs a square wave signal toggling at the specified frequency.\n\nModule name:  \n    square_wave \n                 \nInput ports:\n    clk: Clock signal that drives the module.\n    [7:0]freq: Frequency control, specifying how often the square wave toggles.\n\nOutput ports:\n    wave_out: Square wave output signal.\n\nInternal Registers:\n    count (reg [7:0]): Counter register used to track cycles between wave toggles.\n    \nImplementation:\nCounter Operation:\n    The count register increments on each rising edge of the clk.\n    When count reaches (freq - 1), the count is reset to 0 and wave_out is toggled (i.e., flipped from 0 to 1 or from 1 to 0).\n    If count has not reached freq, it simply increments by one on the next clock cycle.\nSquare Wave Generation:\n    The module produces a square wave by flipping the wave_out signal at the rate determined by freq.\n    The higher the freq value, the slower the square wave toggles (i.e., the lower the output frequency), and vice versa.\n    \nGive me the complete code.\n"}, "clean_code": "module square_wave(\n    input clk,                     \n    input [7:0] freq,           \n    output reg wave_out          \n);\n\nreg [7:0] count;                \n\ninitial begin\n    wave_out = 0;  \n    count = 0;     \nend\n\nalways @(posedge clk) begin\n    if(count == freq - 1 ) begin      \n        count <= 0;\n        wave_out <=  ~wave_out ;            \n\n    end else begin\n        count <= count + 1;        \n    end\nend\n\nendmodule", "corrupted_code": "module square_wave(\n    input clk,                     \n    input [7:0] freq,           \n    output reg wave_out          \n);\n\nreg [7:0] count;                \n\ninitial begin\n    wave_out = 0;  \n    count = 0;     \nend\n\nalways @(posedge clk) begin\n    if(count == freq - 1 ) begin      \n        count <= 1;\n        wave_out <=  ~wave_out ;            \n\n    end else begin\n        count <= count + 1;        \n    end\nend\n\nendmodule", "corruption_explanation": "Changed constant from 0 to 1", "modification_type": "change_constant", "modification_line": 16, "original_snippet": "0", "modified_snippet": "1", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 0 to 1\n   \u2022 Line 16: Original: 0\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 16.\n   \u2022 Restore the original code: 0\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 7, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_constant"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.265534", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Signal generation", "design_name": "square_wave", "module_name": "square_wave", "description": "Please act as a professional verilog designer.\n\nThe module is a simple yet effective generator designed to produce square wave signals with variable frequency. It takes an input clock signal and a frequency value, and outputs a square wave signal toggling at the specified frequency.\n\nModule name:  \n    square_wave \n                 \nInput ports:\n    clk: Clock signal that drives the module.\n    [7:0]freq: Frequency control, specifying how often the square wave toggles.\n\nOutput ports:\n    wave_out: Square wave output signal.\n\nInternal Registers:\n    count (reg [7:0]): Counter register used to track cycles between wave toggles.\n    \nImplementation:\nCounter Operation:\n    The count register increments on each rising edge of the clk.\n    When count reaches (freq - 1), the count is reset to 0 and wave_out is toggled (i.e., flipped from 0 to 1 or from 1 to 0).\n    If count has not reached freq, it simply increments by one on the next clock cycle.\nSquare Wave Generation:\n    The module produces a square wave by flipping the wave_out signal at the rate determined by freq.\n    The higher the freq value, the slower the square wave toggles (i.e., the lower the output frequency), and vice versa.\n    \nGive me the complete code.\n"}, "clean_code": "module square_wave(\n    input clk,                     \n    input [7:0] freq,           \n    output reg wave_out          \n);\n\nreg [7:0] count;                \n\ninitial begin\n    wave_out = 0;  \n    count = 0;     \nend\n\nalways @(posedge clk) begin\n    if(count == freq - 1 ) begin      \n        count <= 0;\n        wave_out <=  ~wave_out ;            \n\n    end else begin\n        count <= count + 1;        \n    end\nend\n\nendmodule", "corrupted_code": "module square_wave(\n    input clk,                     \n    input [7:0] freq,           \n    output reg wave_out          \n);\n\nreg [7:0] count;                \n\ninitial begin\n    wave_out = 0;  \n    count = 0;     \nend\n\nalways @(clk) begin\n    if(count == freq - 1 ) begin      \n        count <= 0;\n        wave_out <=  ~wave_out ;            \n\n    end else begin\n        count <= count + 1;        \n    end\nend\n\nendmodule", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 14, "original_snippet": "always @(posedge clk)", "modified_snippet": "always @(clk)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 14: Original: always @(posedge clk)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 14.\n   \u2022 Restore the original code: always @(posedge clk)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 7, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_sensitivity_list"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.266380", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Signal generation", "design_name": "square_wave", "module_name": "square_wave", "description": "Please act as a professional verilog designer.\n\nThe module is a simple yet effective generator designed to produce square wave signals with variable frequency. It takes an input clock signal and a frequency value, and outputs a square wave signal toggling at the specified frequency.\n\nModule name:  \n    square_wave \n                 \nInput ports:\n    clk: Clock signal that drives the module.\n    [7:0]freq: Frequency control, specifying how often the square wave toggles.\n\nOutput ports:\n    wave_out: Square wave output signal.\n\nInternal Registers:\n    count (reg [7:0]): Counter register used to track cycles between wave toggles.\n    \nImplementation:\nCounter Operation:\n    The count register increments on each rising edge of the clk.\n    When count reaches (freq - 1), the count is reset to 0 and wave_out is toggled (i.e., flipped from 0 to 1 or from 1 to 0).\n    If count has not reached freq, it simply increments by one on the next clock cycle.\nSquare Wave Generation:\n    The module produces a square wave by flipping the wave_out signal at the rate determined by freq.\n    The higher the freq value, the slower the square wave toggles (i.e., the lower the output frequency), and vice versa.\n    \nGive me the complete code.\n"}, "clean_code": "module square_wave(\n    input clk,                     \n    input [7:0] freq,           \n    output reg wave_out          \n);\n\nreg [7:0] count;                \n\ninitial begin\n    wave_out = 0;  \n    count = 0;     \nend\n\nalways @(posedge clk) begin\n    if(count == freq - 1 ) begin      \n        count <= 0;\n        wave_out <=  ~wave_out ;            \n\n    end else begin\n        count <= count + 1;        \n    end\nend\n\nendmodule", "corrupted_code": "module square_wave(\n    input clk,                     \n    input [7:0] freq,           \n    output reg wave_out          \n);\n\nreg [7:0] count;                \n\ninitial begin\n    wave_out = 1;  \n    count = 0;     \nend\n\nalways @(posedge clk) begin\n    if(count == freq - 1 ) begin      \n        count <= 0;\n        wave_out <=  ~wave_out ;            \n\n    end else begin\n        count <= count + 1;        \n    end\nend\n\nendmodule", "corruption_explanation": "Changed constant from 0 to 1", "modification_type": "change_constant", "modification_line": 10, "original_snippet": "0", "modified_snippet": "1", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 0 to 1\n   \u2022 Line 10: Original: 0\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 10.\n   \u2022 Restore the original code: 0\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 7, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_constant"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.267204", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Signal generation", "design_name": "square_wave", "module_name": "square_wave", "description": "Please act as a professional verilog designer.\n\nThe module is a simple yet effective generator designed to produce square wave signals with variable frequency. It takes an input clock signal and a frequency value, and outputs a square wave signal toggling at the specified frequency.\n\nModule name:  \n    square_wave \n                 \nInput ports:\n    clk: Clock signal that drives the module.\n    [7:0]freq: Frequency control, specifying how often the square wave toggles.\n\nOutput ports:\n    wave_out: Square wave output signal.\n\nInternal Registers:\n    count (reg [7:0]): Counter register used to track cycles between wave toggles.\n    \nImplementation:\nCounter Operation:\n    The count register increments on each rising edge of the clk.\n    When count reaches (freq - 1), the count is reset to 0 and wave_out is toggled (i.e., flipped from 0 to 1 or from 1 to 0).\n    If count has not reached freq, it simply increments by one on the next clock cycle.\nSquare Wave Generation:\n    The module produces a square wave by flipping the wave_out signal at the rate determined by freq.\n    The higher the freq value, the slower the square wave toggles (i.e., the lower the output frequency), and vice versa.\n    \nGive me the complete code.\n"}, "clean_code": "module square_wave(\n    input clk,                     \n    input [7:0] freq,           \n    output reg wave_out          \n);\n\nreg [7:0] count;                \n\ninitial begin\n    wave_out = 0;  \n    count = 0;     \nend\n\nalways @(posedge clk) begin\n    if(count == freq - 1 ) begin      \n        count <= 0;\n        wave_out <=  ~wave_out ;            \n\n    end else begin\n        count <= count + 1;        \n    end\nend\n\nendmodule", "corrupted_code": "module square_wave(\n    input clk,                     \n    input [7:0] freq,           \n    output reg wave_out          \n);\n\nreg [7:0] count;                \n\ninitial begin\n    wave_out = 0;  \n    count = 0;     \nend\n\nalways @(posedge clk) begin\n    if(count == freq - 1 ) begin      \n         <= count + 1;        \n    end\nend\n\nendmodule", "corruption_explanation": "Removed CDC synchronizer stage", "modification_type": "modify_cdc", "modification_line": 16, "original_snippet": "count <= 0;\n        wave_out <=  ~wave_out ;            \n\n    end else begin\n        count", "modified_snippet": "(removed)", "issue_description": "The buggy code has a broken clock domain crossing synchronizer. A synchronizer flip-flop stage was removed, reducing metastability protection. This creates CDC violations that cause random data corruption in multi-clock domain designs.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a modify_cdc modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed CDC synchronizer stage\n   \u2022 Line 16: Original: count <= 0;\n        wave_out <=  ~wave_out ;            \n\n    end else begin\n        count\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 16.\n   \u2022 Restore the original code: count <= 0;\n        wave_out <=  ~wave_out ;            \n\n    end else begin\n        count\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to modify cdc.", "complexity": 7, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["modify_cdc"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.268128", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Signal generation", "design_name": "square_wave", "module_name": "square_wave", "description": "Please act as a professional verilog designer.\n\nThe module is a simple yet effective generator designed to produce square wave signals with variable frequency. It takes an input clock signal and a frequency value, and outputs a square wave signal toggling at the specified frequency.\n\nModule name:  \n    square_wave \n                 \nInput ports:\n    clk: Clock signal that drives the module.\n    [7:0]freq: Frequency control, specifying how often the square wave toggles.\n\nOutput ports:\n    wave_out: Square wave output signal.\n\nInternal Registers:\n    count (reg [7:0]): Counter register used to track cycles between wave toggles.\n    \nImplementation:\nCounter Operation:\n    The count register increments on each rising edge of the clk.\n    When count reaches (freq - 1), the count is reset to 0 and wave_out is toggled (i.e., flipped from 0 to 1 or from 1 to 0).\n    If count has not reached freq, it simply increments by one on the next clock cycle.\nSquare Wave Generation:\n    The module produces a square wave by flipping the wave_out signal at the rate determined by freq.\n    The higher the freq value, the slower the square wave toggles (i.e., the lower the output frequency), and vice versa.\n    \nGive me the complete code.\n"}, "clean_code": "module square_wave(\n    input clk,                     \n    input [7:0] freq,           \n    output reg wave_out          \n);\n\nreg [7:0] count;                \n\ninitial begin\n    wave_out = 0;  \n    count = 0;     \nend\n\nalways @(posedge clk) begin\n    if(count == freq - 1 ) begin      \n        count <= 0;\n        wave_out <=  ~wave_out ;            \n\n    end else begin\n        count <= count + 1;        \n    end\nend\n\nendmodule", "corrupted_code": "module square_wave(\n    input clk,                     \n    input [7:0] freq,           \n    output reg wave_out          \n);\n\nreg [7:0] count;                \n\ninitial begin\n    wave_out = 0;  \n    count = 0;     \nend\n\nalways @(posedge clk) begin\n    if(!(count == freq - 1)) begin      \n        count <= 0;\n        wave_out <=  ~wave_out ;            \n\n    end else begin\n        count <= count + 1;        \n    end\nend\n\nendmodule", "corruption_explanation": "Inverted condition: 'count == freq - 1' -> '!(count == freq - 1)'", "modification_type": "invert_condition", "modification_line": 15, "original_snippet": "if(count == freq - 1 ) begin", "modified_snippet": "if(!(count == freq - 1)) begin", "issue_description": "The buggy code has an inverted condition in an if statement. Instead of checking if(x), it checks if(!x), causing the logic to execute when it shouldn't and skip execution when it should. All conditional behavior is reversed from intended functionality.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_condition modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted condition: 'count == freq - 1' -> '!(count == freq - 1)'\n   \u2022 Line 15: Original: if(count == freq - 1 ) begin\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 15.\n   \u2022 Restore the original code: if(count == freq - 1 ) begin\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert condition.", "complexity": 7, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_condition"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.268971", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "pulse_detect", "module_name": "pulse_detect", "description": "Please act as a professional verilog designer.\n\nImplement a module for pulse detection. The 1-bit input signal data_in is a continuous input, which is triggered by clk. When \"data_in\" changes from 0 to 1 to 0(3 cycles), this is considered as a \"pulse\". The indicating signal dataout is 1 at the end cycle of the \"pulse\", and then returns to 0 until the corresponding pulse appears again. For example, if data_in is 01010(5 cycles), the data_out is 00101.\n\n\nModule name:  \n    pulse_detect\n\nInput ports\uff1a\n    clk: Clock signal.\n    rst_n: Reset signal (active low).\n    data_in: One-bit input signal.\n\nOutput ports\uff1a\n    data_out: Output signal indicating the presence of pulses.\n\nImplementation:\nDeclare the module pulse_detect with input and output ports as specified in the ports statement.\nDeclare a register state to keep track of the current state of the pulse detection process.\nInside an always block, sensitive to the positive edge of the clk signal and the negative edge of the rst_n signal, implement the logic for pulse detection and output generation.\nIn the reset condition (~rst_n), set the state register to the initial state and set the data_out output to 0, indicating no pulse. Continue the detection process for the remaining states. For each state, check the value of data_in and transition to the next state accordingly. If the current state satisfies the last state of a \"pulse\", set data_out to 1, indicating the end of a pulse. Otherwise, set data_out to 0.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\nmodule pulse_detect(    \n    input clk,\n    input rst_n,\n    input data_in,\n    output reg data_out\n);\n\nparameter s0 = 2'b00; // initial\nparameter s1 = 2'b01; // 0, 00\nparameter s2 = 2'b10; // 01\nparameter s3 = 2'b11; // 010\n\nreg [1:0] pulse_level1, pulse_level2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        pulse_level1 <= s0;\n    else\n        pulse_level1 <= pulse_level2;\nend\n\nalways @(*) begin\n    case (pulse_level1)\n        s0: begin\n            if (data_in == 0)\n                pulse_level2 = s1;\n            else\n                pulse_level2 = s0;\n        end\n\n        s1: begin\n            if (data_in == 1)\n                pulse_level2 = s2;\n            else\n                pulse_level2 = s1;\n        end\n\n        s2: begin\n            if (data_in == 0)\n                pulse_level2 = s3;\n            else\n                pulse_level2 = s0;\n        end\n\n        s3: begin\n            if (data_in == 1)\n                pulse_level2 = s2;\n            else\n                pulse_level2 = s1;\n        end\n    endcase\nend\n\n// always @(posedge clk or negedge rst_n) begin\n//     if (~rst_n)\n//         data_out <= 0;\n//     else if (pulse_level1 == s2 && data_in == 0)\n//         begin\n//         data_out <= 1;\n//         end\n//     else\n//         data_out <= 0;\n// end\n\nalways @(*) begin\n    if (~rst_n)\n        data_out = 0;\n    else if (pulse_level1 == s2 && data_in == 0)\n        data_out = 1;\n    else\n        data_out = 0;\nend\n\nendmodule\n", "corrupted_code": "`timescale 1ns/1ns\n\nmodule pulse_detect(    \n    input clk,\n    input rst_n,\n    input data_in,\n    output reg data_out\n);\n\nparameter s0 = 2'b00; // initial\nparameter s1 = 2'b01; // 0, 00\nparameter s2 = 2'b10; // 01\nparameter s3 = 2'b11; // 010\n\nreg [1:1] pulse_level1, pulse_level2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        pulse_level1 <= s0;\n    else\n        pulse_level1 <= pulse_level2;\nend\n\nalways @(*) begin\n    case (pulse_level1)\n        s0: begin\n            if (data_in == 0)\n                pulse_level2 = s1;\n            else\n                pulse_level2 = s0;\n        end\n\n        s1: begin\n            if (data_in == 1)\n                pulse_level2 = s2;\n            else\n                pulse_level2 = s1;\n        end\n\n        s2: begin\n            if (data_in == 0)\n                pulse_level2 = s3;\n            else\n                pulse_level2 = s0;\n        end\n\n        s3: begin\n            if (data_in == 1)\n                pulse_level2 = s2;\n            else\n                pulse_level2 = s1;\n        end\n    endcase\nend\n\n// always @(posedge clk or negedge rst_n) begin\n//     if (~rst_n)\n//         data_out <= 0;\n//     else if (pulse_level1 == s2 && data_in == 0)\n//         begin\n//         data_out <= 1;\n//         end\n//     else\n//         data_out <= 0;\n// end\n\nalways @(*) begin\n    if (~rst_n)\n        data_out = 0;\n    else if (pulse_level1 == s2 && data_in == 0)\n        data_out = 1;\n    else\n        data_out = 0;\nend\n\nendmodule\n", "corruption_explanation": "Changed bit width from [1:0] to [1:1]", "modification_type": "change_bit_width", "modification_line": 15, "original_snippet": "[1:0]", "modified_snippet": "[1:1]", "issue_description": "The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_bit_width modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed bit width from [1:0] to [1:1]\n   \u2022 Line 15: Original: [1:0]\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 15.\n   \u2022 Restore the original code: [1:0]\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change bit width.", "complexity": 21, "applicable_modifications": ["remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_bit_width"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.277598", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "pulse_detect", "module_name": "pulse_detect", "description": "Please act as a professional verilog designer.\n\nImplement a module for pulse detection. The 1-bit input signal data_in is a continuous input, which is triggered by clk. When \"data_in\" changes from 0 to 1 to 0(3 cycles), this is considered as a \"pulse\". The indicating signal dataout is 1 at the end cycle of the \"pulse\", and then returns to 0 until the corresponding pulse appears again. For example, if data_in is 01010(5 cycles), the data_out is 00101.\n\n\nModule name:  \n    pulse_detect\n\nInput ports\uff1a\n    clk: Clock signal.\n    rst_n: Reset signal (active low).\n    data_in: One-bit input signal.\n\nOutput ports\uff1a\n    data_out: Output signal indicating the presence of pulses.\n\nImplementation:\nDeclare the module pulse_detect with input and output ports as specified in the ports statement.\nDeclare a register state to keep track of the current state of the pulse detection process.\nInside an always block, sensitive to the positive edge of the clk signal and the negative edge of the rst_n signal, implement the logic for pulse detection and output generation.\nIn the reset condition (~rst_n), set the state register to the initial state and set the data_out output to 0, indicating no pulse. Continue the detection process for the remaining states. For each state, check the value of data_in and transition to the next state accordingly. If the current state satisfies the last state of a \"pulse\", set data_out to 1, indicating the end of a pulse. Otherwise, set data_out to 0.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\nmodule pulse_detect(    \n    input clk,\n    input rst_n,\n    input data_in,\n    output reg data_out\n);\n\nparameter s0 = 2'b00; // initial\nparameter s1 = 2'b01; // 0, 00\nparameter s2 = 2'b10; // 01\nparameter s3 = 2'b11; // 010\n\nreg [1:0] pulse_level1, pulse_level2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        pulse_level1 <= s0;\n    else\n        pulse_level1 <= pulse_level2;\nend\n\nalways @(*) begin\n    case (pulse_level1)\n        s0: begin\n            if (data_in == 0)\n                pulse_level2 = s1;\n            else\n                pulse_level2 = s0;\n        end\n\n        s1: begin\n            if (data_in == 1)\n                pulse_level2 = s2;\n            else\n                pulse_level2 = s1;\n        end\n\n        s2: begin\n            if (data_in == 0)\n                pulse_level2 = s3;\n            else\n                pulse_level2 = s0;\n        end\n\n        s3: begin\n            if (data_in == 1)\n                pulse_level2 = s2;\n            else\n                pulse_level2 = s1;\n        end\n    endcase\nend\n\n// always @(posedge clk or negedge rst_n) begin\n//     if (~rst_n)\n//         data_out <= 0;\n//     else if (pulse_level1 == s2 && data_in == 0)\n//         begin\n//         data_out <= 1;\n//         end\n//     else\n//         data_out <= 0;\n// end\n\nalways @(*) begin\n    if (~rst_n)\n        data_out = 0;\n    else if (pulse_level1 == s2 && data_in == 0)\n        data_out = 1;\n    else\n        data_out = 0;\nend\n\nendmodule\n", "corrupted_code": "`timescale 1ns/1ns\n\nmodule pulse_detect(    \n    input clk,\n    input rst_n,\n    input data_in,\n    output reg data_out\n);\n\nparameter s0 = 2'b00; // initial\nparameter s1 = 2'b01; // 0, 00\nparameter s2 = 2'b10; // 01\nparameter s3 = 2'b11; // 010\n\nreg [1:0] pulse_level1, pulse_level2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n         <= pulse_level2;\nend\n\nalways @(*) begin\n    case (pulse_level1)\n        s0: begin\n            if (data_in == 0)\n                pulse_level2 = s1;\n            else\n                pulse_level2 = s0;\n        end\n\n        s1: begin\n            if (data_in == 1)\n                pulse_level2 = s2;\n            else\n                pulse_level2 = s1;\n        end\n\n        s2: begin\n            if (data_in == 0)\n                pulse_level2 = s3;\n            else\n                pulse_level2 = s0;\n        end\n\n        s3: begin\n            if (data_in == 1)\n                pulse_level2 = s2;\n            else\n                pulse_level2 = s1;\n        end\n    endcase\nend\n\n// always @(posedge clk or negedge rst_n) begin\n//     if (~rst_n)\n//         data_out <= 0;\n//     else if (pulse_level1 == s2 && data_in == 0)\n//         begin\n//         data_out <= 1;\n//         end\n//     else\n//         data_out <= 0;\n// end\n\nalways @(*) begin\n    if (~rst_n)\n        data_out = 0;\n    else if (pulse_level1 == s2 && data_in == 0)\n        data_out = 1;\n    else\n        data_out = 0;\nend\n\nendmodule\n", "corruption_explanation": "Removed CDC synchronizer stage", "modification_type": "modify_cdc", "modification_line": 19, "original_snippet": "pulse_level1 <= s0;\n    else\n        pulse_level1", "modified_snippet": "(removed)", "issue_description": "The buggy code has a broken clock domain crossing synchronizer. A synchronizer flip-flop stage was removed, reducing metastability protection. This creates CDC violations that cause random data corruption in multi-clock domain designs.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a modify_cdc modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed CDC synchronizer stage\n   \u2022 Line 19: Original: pulse_level1 <= s0;\n    else\n        pulse_level1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 19.\n   \u2022 Restore the original code: pulse_level1 <= s0;\n    else\n        pulse_level1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to modify cdc.", "complexity": 21, "applicable_modifications": ["remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["modify_cdc"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.280156", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "pulse_detect", "module_name": "pulse_detect", "description": "Please act as a professional verilog designer.\n\nImplement a module for pulse detection. The 1-bit input signal data_in is a continuous input, which is triggered by clk. When \"data_in\" changes from 0 to 1 to 0(3 cycles), this is considered as a \"pulse\". The indicating signal dataout is 1 at the end cycle of the \"pulse\", and then returns to 0 until the corresponding pulse appears again. For example, if data_in is 01010(5 cycles), the data_out is 00101.\n\n\nModule name:  \n    pulse_detect\n\nInput ports\uff1a\n    clk: Clock signal.\n    rst_n: Reset signal (active low).\n    data_in: One-bit input signal.\n\nOutput ports\uff1a\n    data_out: Output signal indicating the presence of pulses.\n\nImplementation:\nDeclare the module pulse_detect with input and output ports as specified in the ports statement.\nDeclare a register state to keep track of the current state of the pulse detection process.\nInside an always block, sensitive to the positive edge of the clk signal and the negative edge of the rst_n signal, implement the logic for pulse detection and output generation.\nIn the reset condition (~rst_n), set the state register to the initial state and set the data_out output to 0, indicating no pulse. Continue the detection process for the remaining states. For each state, check the value of data_in and transition to the next state accordingly. If the current state satisfies the last state of a \"pulse\", set data_out to 1, indicating the end of a pulse. Otherwise, set data_out to 0.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\nmodule pulse_detect(    \n    input clk,\n    input rst_n,\n    input data_in,\n    output reg data_out\n);\n\nparameter s0 = 2'b00; // initial\nparameter s1 = 2'b01; // 0, 00\nparameter s2 = 2'b10; // 01\nparameter s3 = 2'b11; // 010\n\nreg [1:0] pulse_level1, pulse_level2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        pulse_level1 <= s0;\n    else\n        pulse_level1 <= pulse_level2;\nend\n\nalways @(*) begin\n    case (pulse_level1)\n        s0: begin\n            if (data_in == 0)\n                pulse_level2 = s1;\n            else\n                pulse_level2 = s0;\n        end\n\n        s1: begin\n            if (data_in == 1)\n                pulse_level2 = s2;\n            else\n                pulse_level2 = s1;\n        end\n\n        s2: begin\n            if (data_in == 0)\n                pulse_level2 = s3;\n            else\n                pulse_level2 = s0;\n        end\n\n        s3: begin\n            if (data_in == 1)\n                pulse_level2 = s2;\n            else\n                pulse_level2 = s1;\n        end\n    endcase\nend\n\n// always @(posedge clk or negedge rst_n) begin\n//     if (~rst_n)\n//         data_out <= 0;\n//     else if (pulse_level1 == s2 && data_in == 0)\n//         begin\n//         data_out <= 1;\n//         end\n//     else\n//         data_out <= 0;\n// end\n\nalways @(*) begin\n    if (~rst_n)\n        data_out = 0;\n    else if (pulse_level1 == s2 && data_in == 0)\n        data_out = 1;\n    else\n        data_out = 0;\nend\n\nendmodule\n", "corrupted_code": "`timescale 1ns/1ns\n\nmodule pulse_detect(    \n    input clk,\n    input rst_n,\n    input data_in,\n    output reg data_out\n);\n\nparameter s0 = 2'b00; // initial\nparameter s1 = 2'b01; // 0, 00\nparameter s2 = 2'b10; // 01\nparameter s3 = 2'b11; // 010\n\nreg [1:0] pulse_level1, pulse_level2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n         <= pulse_level2;\nend\n\nalways @(*) begin\n    case (pulse_level1)\n        s0: begin\n            if (data_in == 0)\n                pulse_level2 = s1;\n            else\n                pulse_level2 = s0;\n        end\n\n        s1: begin\n            if (data_in == 1)\n                pulse_level2 = s2;\n            else\n                pulse_level2 = s1;\n        end\n\n        s2: begin\n            if (data_in == 0)\n                pulse_level2 = s3;\n            else\n                pulse_level2 = s0;\n        end\n\n        s3: begin\n            if (data_in == 1)\n                pulse_level2 = s2;\n            else\n                pulse_level2 = s1;\n        end\n    endcase\nend\n\n// always @(posedge clk or negedge rst_n) begin\n//     if (~rst_n)\n//         data_out <= 0;\n//     else if (pulse_level1 == s2 && data_in == 0)\n//         begin\n//         data_out <= 1;\n//         end\n//     else\n//         data_out <= 0;\n// end\n\nalways @(*) begin\n    if (~rst_n)\n        data_out = 0;\n    else if (pulse_level1 == s2 && data_in == 0)\n        data_out = 1;\n    else\n        data_out = 0;\nend\n\nendmodule\n", "corruption_explanation": "Removed CDC synchronizer stage", "modification_type": "modify_cdc", "modification_line": 19, "original_snippet": "pulse_level1 <= s0;\n    else\n        pulse_level1", "modified_snippet": "(removed)", "issue_description": "The buggy code has a broken clock domain crossing synchronizer. A synchronizer flip-flop stage was removed, reducing metastability protection. This creates CDC violations that cause random data corruption in multi-clock domain designs.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a modify_cdc modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed CDC synchronizer stage\n   \u2022 Line 19: Original: pulse_level1 <= s0;\n    else\n        pulse_level1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 19.\n   \u2022 Restore the original code: pulse_level1 <= s0;\n    else\n        pulse_level1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to modify cdc.", "complexity": 21, "applicable_modifications": ["remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["modify_cdc"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.283239", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "pulse_detect", "module_name": "pulse_detect", "description": "Please act as a professional verilog designer.\n\nImplement a module for pulse detection. The 1-bit input signal data_in is a continuous input, which is triggered by clk. When \"data_in\" changes from 0 to 1 to 0(3 cycles), this is considered as a \"pulse\". The indicating signal dataout is 1 at the end cycle of the \"pulse\", and then returns to 0 until the corresponding pulse appears again. For example, if data_in is 01010(5 cycles), the data_out is 00101.\n\n\nModule name:  \n    pulse_detect\n\nInput ports\uff1a\n    clk: Clock signal.\n    rst_n: Reset signal (active low).\n    data_in: One-bit input signal.\n\nOutput ports\uff1a\n    data_out: Output signal indicating the presence of pulses.\n\nImplementation:\nDeclare the module pulse_detect with input and output ports as specified in the ports statement.\nDeclare a register state to keep track of the current state of the pulse detection process.\nInside an always block, sensitive to the positive edge of the clk signal and the negative edge of the rst_n signal, implement the logic for pulse detection and output generation.\nIn the reset condition (~rst_n), set the state register to the initial state and set the data_out output to 0, indicating no pulse. Continue the detection process for the remaining states. For each state, check the value of data_in and transition to the next state accordingly. If the current state satisfies the last state of a \"pulse\", set data_out to 1, indicating the end of a pulse. Otherwise, set data_out to 0.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\nmodule pulse_detect(    \n    input clk,\n    input rst_n,\n    input data_in,\n    output reg data_out\n);\n\nparameter s0 = 2'b00; // initial\nparameter s1 = 2'b01; // 0, 00\nparameter s2 = 2'b10; // 01\nparameter s3 = 2'b11; // 010\n\nreg [1:0] pulse_level1, pulse_level2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        pulse_level1 <= s0;\n    else\n        pulse_level1 <= pulse_level2;\nend\n\nalways @(*) begin\n    case (pulse_level1)\n        s0: begin\n            if (data_in == 0)\n                pulse_level2 = s1;\n            else\n                pulse_level2 = s0;\n        end\n\n        s1: begin\n            if (data_in == 1)\n                pulse_level2 = s2;\n            else\n                pulse_level2 = s1;\n        end\n\n        s2: begin\n            if (data_in == 0)\n                pulse_level2 = s3;\n            else\n                pulse_level2 = s0;\n        end\n\n        s3: begin\n            if (data_in == 1)\n                pulse_level2 = s2;\n            else\n                pulse_level2 = s1;\n        end\n    endcase\nend\n\n// always @(posedge clk or negedge rst_n) begin\n//     if (~rst_n)\n//         data_out <= 0;\n//     else if (pulse_level1 == s2 && data_in == 0)\n//         begin\n//         data_out <= 1;\n//         end\n//     else\n//         data_out <= 0;\n// end\n\nalways @(*) begin\n    if (~rst_n)\n        data_out = 0;\n    else if (pulse_level1 == s2 && data_in == 0)\n        data_out = 1;\n    else\n        data_out = 0;\nend\n\nendmodule\n", "corrupted_code": "`timescale 1ns/1ns\n\nmodule pulse_detect(    \n    input clk,\n    input rst_n,\n    input data_in,\n    output reg data_out\n);\n\nparameter s0 = 2'b00; // initial\nparameter s1 = 2'b01; // 0, 00\nparameter s2 = 2'b10; // 01\nparameter s3 = 2'b11; // 010\n\nreg [1:0] pulse_level1, pulse_level2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        pulse_level1 <= s0;\n    else\n        pulse_level1 <= pulse_level2;\nend\n\nalways @(a) begin\n    case (pulse_level1)\n        s0: begin\n            if (data_in == 0)\n                pulse_level2 = s1;\n            else\n                pulse_level2 = s0;\n        end\n\n        s1: begin\n            if (data_in == 1)\n                pulse_level2 = s2;\n            else\n                pulse_level2 = s1;\n        end\n\n        s2: begin\n            if (data_in == 0)\n                pulse_level2 = s3;\n            else\n                pulse_level2 = s0;\n        end\n\n        s3: begin\n            if (data_in == 1)\n                pulse_level2 = s2;\n            else\n                pulse_level2 = s1;\n        end\n    endcase\nend\n\n// always @(posedge clk or negedge rst_n) begin\n//     if (~rst_n)\n//         data_out <= 0;\n//     else if (pulse_level1 == s2 && data_in == 0)\n//         begin\n//         data_out <= 1;\n//         end\n//     else\n//         data_out <= 0;\n// end\n\nalways @(*) begin\n    if (~rst_n)\n        data_out = 0;\n    else if (pulse_level1 == s2 && data_in == 0)\n        data_out = 1;\n    else\n        data_out = 0;\nend\n\nendmodule\n", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 24, "original_snippet": "always @(*)", "modified_snippet": "always @(a)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 24: Original: always @(*)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 24.\n   \u2022 Restore the original code: always @(*)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 21, "applicable_modifications": ["remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_sensitivity_list"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.285847", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "parallel2serial", "module_name": "parallel2serial", "description": "Please act as a professional verilog designer.\n\nImplement a module for parallel-to-serial conversion, where every four input bits are converted to a serial one bit output (from MSB to LSB). The output signal valid_out is set to 1 to indicate the availability of valid serial output. When valid_out = 1, the most significant bit of d is output, and the remaining three bits are output sequentially in the following 3 cycles.\n\nModule name:  \n    parallel2serial     \n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst_n: Reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n    d: 4-bit parallel data input.\n\nOutput ports:\n    valid_out: Valid signal indicating the availability of serial output.\n    dout: Serial output representing the converted data.\n\nImplementation:\nThe most significant bit of the parallel input is assigned to the serial output (dout). On each clock cycle, if the counter (cnt) is 3, indicating the last bit of the parallel input, the module updates the data register (data) with the parallel input (d), resets the counter (cnt) to 0, and sets the valid signal (valid) to 1.\nOtherwise, the module increments the counter (cnt) by 1, sets the valid signal (valid) to 0, and shifts the data register (data) one bit to the left, with the most significant bit shifted to the least significant bit.\nCounter Register: If the reset signal (rst_n) is high, the register (cnt) is incremented by 1.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule parallel2serial(\n\tinput wire clk  ,\n\tinput wire rst_n  ,\n\tinput wire [3:0]d ,\n\toutput wire valid_out ,\n\toutput wire dout\n\t);\n\n\nreg [3:0] data = 'd0;\nreg [1:0]cnt;\nreg valid;\nassign dout = data[3];\nassign valid_out =valid;\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)begin\n        data<= 'd0;\n        cnt <= 'd0;\n        valid <= 'd0;\n    end\n    else  begin\n                \n\t\tif (cnt == 'd3) begin\n\t\t\tdata <= d;\n\t\t\tcnt <= 'd0;\n\t\t\tvalid <= 1;\n\t\tend\n\t\telse begin\n\t\t\tcnt <= cnt + 'd1;\n\t\t\tvalid <= 0;\n\t\t\tdata  <= {data[2:0],data[3]};\n\t\tend\n    end\n\t\t\nend\n\n\nendmodule", "corrupted_code": "`timescale 1ns/1ns\nmodule parallel2serial(\n\tinput wire clk  ,\n\tinput wire rst_n  ,\n\tinput wire [3:0]d ,\n\toutput wire valid_out ,\n\toutput wire dout\n\t);\n\n\nreg [3:0] data = 'd0;\nreg [1:0]cnt;\nreg valid;\nassign dout = data[3];\nassign valid_out =valid;\nassign valid_out = 1'b0;  // Conflicting assignment\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)begin\n        data<= 'd0;\n        cnt <= 'd0;\n        valid <= 'd0;\n    end\n    else  begin\n                \n\t\tif (cnt == 'd3) begin\n\t\t\tdata <= d;\n\t\t\tcnt <= 'd0;\n\t\t\tvalid <= 1;\n\t\tend\n\t\telse begin\n\t\t\tcnt <= cnt + 'd1;\n\t\t\tvalid <= 0;\n\t\t\tdata  <= {data[2:0],data[3]};\n\t\tend\n    end\n\t\t\nend\n\n\nendmodule", "corruption_explanation": "Added conflicting driver for signal 'valid_out'", "modification_type": "add_multiple_driver", "modification_line": 15, "original_snippet": "assign valid_out =valid;", "modified_snippet": "assign valid_out =valid;\nassign valid_out = 1'b0;  // Conflicting assignment", "issue_description": "The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_multiple_driver modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added conflicting driver for signal 'valid_out'\n   \u2022 Line 15: Original: assign valid_out =valid;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 15.\n   \u2022 Restore the original code: assign valid_out =valid;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add multiple driver.", "complexity": 8, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["add_multiple_driver"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.357308", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "parallel2serial", "module_name": "parallel2serial", "description": "Please act as a professional verilog designer.\n\nImplement a module for parallel-to-serial conversion, where every four input bits are converted to a serial one bit output (from MSB to LSB). The output signal valid_out is set to 1 to indicate the availability of valid serial output. When valid_out = 1, the most significant bit of d is output, and the remaining three bits are output sequentially in the following 3 cycles.\n\nModule name:  \n    parallel2serial     \n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst_n: Reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n    d: 4-bit parallel data input.\n\nOutput ports:\n    valid_out: Valid signal indicating the availability of serial output.\n    dout: Serial output representing the converted data.\n\nImplementation:\nThe most significant bit of the parallel input is assigned to the serial output (dout). On each clock cycle, if the counter (cnt) is 3, indicating the last bit of the parallel input, the module updates the data register (data) with the parallel input (d), resets the counter (cnt) to 0, and sets the valid signal (valid) to 1.\nOtherwise, the module increments the counter (cnt) by 1, sets the valid signal (valid) to 0, and shifts the data register (data) one bit to the left, with the most significant bit shifted to the least significant bit.\nCounter Register: If the reset signal (rst_n) is high, the register (cnt) is incremented by 1.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule parallel2serial(\n\tinput wire clk  ,\n\tinput wire rst_n  ,\n\tinput wire [3:0]d ,\n\toutput wire valid_out ,\n\toutput wire dout\n\t);\n\n\nreg [3:0] data = 'd0;\nreg [1:0]cnt;\nreg valid;\nassign dout = data[3];\nassign valid_out =valid;\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)begin\n        data<= 'd0;\n        cnt <= 'd0;\n        valid <= 'd0;\n    end\n    else  begin\n                \n\t\tif (cnt == 'd3) begin\n\t\t\tdata <= d;\n\t\t\tcnt <= 'd0;\n\t\t\tvalid <= 1;\n\t\tend\n\t\telse begin\n\t\t\tcnt <= cnt + 'd1;\n\t\t\tvalid <= 0;\n\t\t\tdata  <= {data[2:0],data[3]};\n\t\tend\n    end\n\t\t\nend\n\n\nendmodule", "corrupted_code": "`timescale 1ns/1ns\nmodule parallel2serial(\n\tinput wire clk  ,\n\tinput wire rst_n  ,\n\tinput wire [3:0]d ,\n\toutput wire valid_out ,\n\toutput wire dout\n\t);\n\n\nreg [4:0] data = 'd0;\nreg [1:0]cnt;\nreg valid;\nassign dout = data[3];\nassign valid_out =valid;\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)begin\n        data<= 'd0;\n        cnt <= 'd0;\n        valid <= 'd0;\n    end\n    else  begin\n                \n\t\tif (cnt == 'd3) begin\n\t\t\tdata <= d;\n\t\t\tcnt <= 'd0;\n\t\t\tvalid <= 1;\n\t\tend\n\t\telse begin\n\t\t\tcnt <= cnt + 'd1;\n\t\t\tvalid <= 0;\n\t\t\tdata  <= {data[2:0],data[3]};\n\t\tend\n    end\n\t\t\nend\n\n\nendmodule", "corruption_explanation": "Changed bit width from [3:0] to [4:0]", "modification_type": "change_bit_width", "modification_line": 11, "original_snippet": "[3:0]", "modified_snippet": "[4:0]", "issue_description": "The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_bit_width modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed bit width from [3:0] to [4:0]\n   \u2022 Line 11: Original: [3:0]\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 11.\n   \u2022 Restore the original code: [3:0]\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change bit width.", "complexity": 8, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_bit_width"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.358232", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "parallel2serial", "module_name": "parallel2serial", "description": "Please act as a professional verilog designer.\n\nImplement a module for parallel-to-serial conversion, where every four input bits are converted to a serial one bit output (from MSB to LSB). The output signal valid_out is set to 1 to indicate the availability of valid serial output. When valid_out = 1, the most significant bit of d is output, and the remaining three bits are output sequentially in the following 3 cycles.\n\nModule name:  \n    parallel2serial     \n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst_n: Reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n    d: 4-bit parallel data input.\n\nOutput ports:\n    valid_out: Valid signal indicating the availability of serial output.\n    dout: Serial output representing the converted data.\n\nImplementation:\nThe most significant bit of the parallel input is assigned to the serial output (dout). On each clock cycle, if the counter (cnt) is 3, indicating the last bit of the parallel input, the module updates the data register (data) with the parallel input (d), resets the counter (cnt) to 0, and sets the valid signal (valid) to 1.\nOtherwise, the module increments the counter (cnt) by 1, sets the valid signal (valid) to 0, and shifts the data register (data) one bit to the left, with the most significant bit shifted to the least significant bit.\nCounter Register: If the reset signal (rst_n) is high, the register (cnt) is incremented by 1.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule parallel2serial(\n\tinput wire clk  ,\n\tinput wire rst_n  ,\n\tinput wire [3:0]d ,\n\toutput wire valid_out ,\n\toutput wire dout\n\t);\n\n\nreg [3:0] data = 'd0;\nreg [1:0]cnt;\nreg valid;\nassign dout = data[3];\nassign valid_out =valid;\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)begin\n        data<= 'd0;\n        cnt <= 'd0;\n        valid <= 'd0;\n    end\n    else  begin\n                \n\t\tif (cnt == 'd3) begin\n\t\t\tdata <= d;\n\t\t\tcnt <= 'd0;\n\t\t\tvalid <= 1;\n\t\tend\n\t\telse begin\n\t\t\tcnt <= cnt + 'd1;\n\t\t\tvalid <= 0;\n\t\t\tdata  <= {data[2:0],data[3]};\n\t\tend\n    end\n\t\t\nend\n\n\nendmodule", "corrupted_code": "`timescale 1ns/1ns\nmodule parallel2serial(\n\tinput wire clk  ,\n\tinput wire rst_n  ,\n\tinput wire [3:0]d ,\n\toutput wire valid_out ,\n\toutput wire dout\n\t);\n\n\nreg [3:0] data = 'd0;\nreg [1:0]cnt;\nreg valid;\nassign dout = data[3];\nassign valid_out =valid;\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)begin\n                \n\t\tif (cnt == 'd3) begin\n\t\t\tdata <= d;\n\t\t\tcnt <= 'd0;\n\t\t\tvalid <= 1;\n\t\tend\n    else  begin\n        data<= 'd0;\n        cnt <= 'd0;\n        valid <= 'd0;\n    end\n\t\telse begin\n\t\t\tcnt <= cnt + 'd1;\n\t\t\tvalid <= 0;\n\t\t\tdata  <= {data[2:0],data[3]};\n\t\tend\n    end\n\t\t\nend\n\n\nendmodule", "corruption_explanation": "Swapped if and else bodies", "modification_type": "invert_if_else", "modification_line": 17, "original_snippet": "if(!rst_n)begin\n        data<= 'd0;\n        cnt <= 'd0;\n        valid <= 'd0;\n    end\n    else  begin\n                \n\t\tif (cnt == 'd3) begin\n\t\t\tdata <= d;\n\t\t\tcnt <= 'd0;\n\t\t\tvalid <= 1;\n\t\tend", "modified_snippet": "if(!rst_n)begin\n                \n\t\tif (cnt == 'd3) begin\n\t\t\tdata <= d;\n\t\t\tcnt <= 'd0;\n\t\t\tvalid <= 1;\n\t\tend\n    else  begin\n        data<= 'd0;\n        cnt <= 'd0;\n        valid <= 'd0;\n    end", "issue_description": "The buggy code has swapped if and else bodies in a conditional block. This causes the logic to execute the opposite branch for each condition, leading to incorrect behavior when the condition is true vs false. Test cases that depend on the conditional logic will fail because the intended branch is not executed.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module contains conditional logic that should execute different code paths based on a condition.\n   \u2022 The if branch should handle the true case, and the else branch should handle the false case.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Identified a conditional block with both if and else branches.\n   \u2022 The branches contain different assignments or logic operations.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The if and else bodies have been swapped.\n   \u2022 Logic that should execute when condition is true now executes when false, and vice versa.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The conditional bodies are inverted.\n   \u2022 Impact: All conditional behavior is reversed, causing incorrect outputs for all test cases.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Swap the if and else bodies back to their correct positions.\n   \u2022 Verify that the condition evaluates correctly and executes the intended branch.\n\n6. RTL Design Principle Violated:\n   \u2022 Correct conditional logic requires matching the intended behavior with the branch bodies.", "complexity": 8, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_if_else"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.359130", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "parallel2serial", "module_name": "parallel2serial", "description": "Please act as a professional verilog designer.\n\nImplement a module for parallel-to-serial conversion, where every four input bits are converted to a serial one bit output (from MSB to LSB). The output signal valid_out is set to 1 to indicate the availability of valid serial output. When valid_out = 1, the most significant bit of d is output, and the remaining three bits are output sequentially in the following 3 cycles.\n\nModule name:  \n    parallel2serial     \n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst_n: Reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n    d: 4-bit parallel data input.\n\nOutput ports:\n    valid_out: Valid signal indicating the availability of serial output.\n    dout: Serial output representing the converted data.\n\nImplementation:\nThe most significant bit of the parallel input is assigned to the serial output (dout). On each clock cycle, if the counter (cnt) is 3, indicating the last bit of the parallel input, the module updates the data register (data) with the parallel input (d), resets the counter (cnt) to 0, and sets the valid signal (valid) to 1.\nOtherwise, the module increments the counter (cnt) by 1, sets the valid signal (valid) to 0, and shifts the data register (data) one bit to the left, with the most significant bit shifted to the least significant bit.\nCounter Register: If the reset signal (rst_n) is high, the register (cnt) is incremented by 1.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule parallel2serial(\n\tinput wire clk  ,\n\tinput wire rst_n  ,\n\tinput wire [3:0]d ,\n\toutput wire valid_out ,\n\toutput wire dout\n\t);\n\n\nreg [3:0] data = 'd0;\nreg [1:0]cnt;\nreg valid;\nassign dout = data[3];\nassign valid_out =valid;\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)begin\n        data<= 'd0;\n        cnt <= 'd0;\n        valid <= 'd0;\n    end\n    else  begin\n                \n\t\tif (cnt == 'd3) begin\n\t\t\tdata <= d;\n\t\t\tcnt <= 'd0;\n\t\t\tvalid <= 1;\n\t\tend\n\t\telse begin\n\t\t\tcnt <= cnt + 'd1;\n\t\t\tvalid <= 0;\n\t\t\tdata  <= {data[2:0],data[3]};\n\t\tend\n    end\n\t\t\nend\n\n\nendmodule", "corrupted_code": "`timescale 1ns/1ns\nmodule parallel2serial(\n\tinput wire clk  ,\n\tinput wire rst_n  ,\n\tinput wire [3:0]d ,\n\toutput wire valid_out ,\n\toutput wire dout\n\t);\n\n\nreg [3:0] data = 'd0;\nreg [1:0]cnt;\nreg valid;\nassign dout = data[3];\nassign valid_out =valid;\n\n    else  begin\n                \n\t\tif (cnt == 'd3) begin\n\t\t\tdata <= d;\n\t\t\tcnt <= 'd0;\n\t\t\tvalid <= 1;\n\t\tend\n\t\telse begin\n\t\t\tcnt <= cnt + 'd1;\n\t\t\tvalid <= 0;\n\t\t\tdata  <= {data[2:0],data[3]};\n\t\tend\n    end\n\t\t\nend\n\n\nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 16, "original_snippet": "always @(posedge clk or negedge rst_n) begin\n    if(!rst_n)begin\n        data<= 'd0;\n        cnt <= 'd0;\n        valid <= 'd0;\n    end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 16: Original: always @(posedge clk or negedge rst_n) begin\n    if(!rst_n)begin\n        data<= 'd0;\n        cnt <= 'd0;\n        valid <= 'd0;\n    end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 16.\n   \u2022 Restore the original code: always @(posedge clk or negedge rst_n) begin\n    if(!rst_n)begin\n        data<= 'd0;\n        cnt <= 'd0;\n        valid <= 'd0;\n    end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 8, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.360076", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "parallel2serial", "module_name": "parallel2serial", "description": "Please act as a professional verilog designer.\n\nImplement a module for parallel-to-serial conversion, where every four input bits are converted to a serial one bit output (from MSB to LSB). The output signal valid_out is set to 1 to indicate the availability of valid serial output. When valid_out = 1, the most significant bit of d is output, and the remaining three bits are output sequentially in the following 3 cycles.\n\nModule name:  \n    parallel2serial     \n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst_n: Reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n    d: 4-bit parallel data input.\n\nOutput ports:\n    valid_out: Valid signal indicating the availability of serial output.\n    dout: Serial output representing the converted data.\n\nImplementation:\nThe most significant bit of the parallel input is assigned to the serial output (dout). On each clock cycle, if the counter (cnt) is 3, indicating the last bit of the parallel input, the module updates the data register (data) with the parallel input (d), resets the counter (cnt) to 0, and sets the valid signal (valid) to 1.\nOtherwise, the module increments the counter (cnt) by 1, sets the valid signal (valid) to 0, and shifts the data register (data) one bit to the left, with the most significant bit shifted to the least significant bit.\nCounter Register: If the reset signal (rst_n) is high, the register (cnt) is incremented by 1.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule parallel2serial(\n\tinput wire clk  ,\n\tinput wire rst_n  ,\n\tinput wire [3:0]d ,\n\toutput wire valid_out ,\n\toutput wire dout\n\t);\n\n\nreg [3:0] data = 'd0;\nreg [1:0]cnt;\nreg valid;\nassign dout = data[3];\nassign valid_out =valid;\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)begin\n        data<= 'd0;\n        cnt <= 'd0;\n        valid <= 'd0;\n    end\n    else  begin\n                \n\t\tif (cnt == 'd3) begin\n\t\t\tdata <= d;\n\t\t\tcnt <= 'd0;\n\t\t\tvalid <= 1;\n\t\tend\n\t\telse begin\n\t\t\tcnt <= cnt + 'd1;\n\t\t\tvalid <= 0;\n\t\t\tdata  <= {data[2:0],data[3]};\n\t\tend\n    end\n\t\t\nend\n\n\nendmodule", "corrupted_code": "`timescale 1ns/1ns\nmodule parallel2serial(\n\tinput wire clk  ,\n\tinput wire rst_n  ,\n\tinput wire [3:0]d ,\n\toutput wire valid_out ,\n\toutput wire dout\n\t);\n\n\nreg [3:0] data = 'd0;\nreg [1:0]cnt;\nreg valid;\nassign dout = data[3];\nassign valid_out =valid;\nassign valid_out = 1'b0;  // Conflicting assignment\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)begin\n        data<= 'd0;\n        cnt <= 'd0;\n        valid <= 'd0;\n    end\n    else  begin\n                \n\t\tif (cnt == 'd3) begin\n\t\t\tdata <= d;\n\t\t\tcnt <= 'd0;\n\t\t\tvalid <= 1;\n\t\tend\n\t\telse begin\n\t\t\tcnt <= cnt + 'd1;\n\t\t\tvalid <= 0;\n\t\t\tdata  <= {data[2:0],data[3]};\n\t\tend\n    end\n\t\t\nend\n\n\nendmodule", "corruption_explanation": "Added conflicting driver for signal 'valid_out'", "modification_type": "add_multiple_driver", "modification_line": 15, "original_snippet": "assign valid_out =valid;", "modified_snippet": "assign valid_out =valid;\nassign valid_out = 1'b0;  // Conflicting assignment", "issue_description": "The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_multiple_driver modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added conflicting driver for signal 'valid_out'\n   \u2022 Line 15: Original: assign valid_out =valid;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 15.\n   \u2022 Restore the original code: assign valid_out =valid;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add multiple driver.", "complexity": 8, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["add_multiple_driver"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.361050", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "parallel2serial", "module_name": "parallel2serial", "description": "Please act as a professional verilog designer.\n\nImplement a module for parallel-to-serial conversion, where every four input bits are converted to a serial one bit output (from MSB to LSB). The output signal valid_out is set to 1 to indicate the availability of valid serial output. When valid_out = 1, the most significant bit of d is output, and the remaining three bits are output sequentially in the following 3 cycles.\n\nModule name:  \n    parallel2serial     \n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst_n: Reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n    d: 4-bit parallel data input.\n\nOutput ports:\n    valid_out: Valid signal indicating the availability of serial output.\n    dout: Serial output representing the converted data.\n\nImplementation:\nThe most significant bit of the parallel input is assigned to the serial output (dout). On each clock cycle, if the counter (cnt) is 3, indicating the last bit of the parallel input, the module updates the data register (data) with the parallel input (d), resets the counter (cnt) to 0, and sets the valid signal (valid) to 1.\nOtherwise, the module increments the counter (cnt) by 1, sets the valid signal (valid) to 0, and shifts the data register (data) one bit to the left, with the most significant bit shifted to the least significant bit.\nCounter Register: If the reset signal (rst_n) is high, the register (cnt) is incremented by 1.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule parallel2serial(\n\tinput wire clk  ,\n\tinput wire rst_n  ,\n\tinput wire [3:0]d ,\n\toutput wire valid_out ,\n\toutput wire dout\n\t);\n\n\nreg [3:0] data = 'd0;\nreg [1:0]cnt;\nreg valid;\nassign dout = data[3];\nassign valid_out =valid;\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)begin\n        data<= 'd0;\n        cnt <= 'd0;\n        valid <= 'd0;\n    end\n    else  begin\n                \n\t\tif (cnt == 'd3) begin\n\t\t\tdata <= d;\n\t\t\tcnt <= 'd0;\n\t\t\tvalid <= 1;\n\t\tend\n\t\telse begin\n\t\t\tcnt <= cnt + 'd1;\n\t\t\tvalid <= 0;\n\t\t\tdata  <= {data[2:0],data[3]};\n\t\tend\n    end\n\t\t\nend\n\n\nendmodule", "corrupted_code": "`timescale 1ns/1ns\nmodule parallel2serial(\n\tinput wire clk  ,\n\tinput wire rst_n  ,\n\tinput wire [3:0]d ,\n\toutput wire valid_out ,\n\toutput wire dout\n\t);\n\n\nreg [3:0] data = 'd0;\nreg [1:0]cnt;\nreg valid;\nassign dout = data[3];\nassign valid_out =valid;\nalways @(posedge clk) begin\n    if(!rst_n)begin\n        data<= 'd0;\n        cnt <= 'd0;\n        valid <= 'd0;\n    end\n    else  begin\n                \n\t\tif (cnt == 'd3) begin\n\t\t\tdata <= d;\n\t\t\tcnt <= 'd0;\n\t\t\tvalid <= 1;\n\t\tend\n\t\telse begin\n\t\t\tcnt <= cnt + 'd1;\n\t\t\tvalid <= 0;\n\t\t\tdata  <= {data[2:0],data[3]};\n\t\tend\n    end\n\t\t\nend\n\n\nendmodule", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 16, "original_snippet": "always @(posedge clk or negedge rst_n)", "modified_snippet": "always @(posedge clk)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 16: Original: always @(posedge clk or negedge rst_n)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 16.\n   \u2022 Restore the original code: always @(posedge clk or negedge rst_n)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 8, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_sensitivity_list"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.362082", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "parallel2serial", "module_name": "parallel2serial", "description": "Please act as a professional verilog designer.\n\nImplement a module for parallel-to-serial conversion, where every four input bits are converted to a serial one bit output (from MSB to LSB). The output signal valid_out is set to 1 to indicate the availability of valid serial output. When valid_out = 1, the most significant bit of d is output, and the remaining three bits are output sequentially in the following 3 cycles.\n\nModule name:  \n    parallel2serial     \n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst_n: Reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n    d: 4-bit parallel data input.\n\nOutput ports:\n    valid_out: Valid signal indicating the availability of serial output.\n    dout: Serial output representing the converted data.\n\nImplementation:\nThe most significant bit of the parallel input is assigned to the serial output (dout). On each clock cycle, if the counter (cnt) is 3, indicating the last bit of the parallel input, the module updates the data register (data) with the parallel input (d), resets the counter (cnt) to 0, and sets the valid signal (valid) to 1.\nOtherwise, the module increments the counter (cnt) by 1, sets the valid signal (valid) to 0, and shifts the data register (data) one bit to the left, with the most significant bit shifted to the least significant bit.\nCounter Register: If the reset signal (rst_n) is high, the register (cnt) is incremented by 1.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule parallel2serial(\n\tinput wire clk  ,\n\tinput wire rst_n  ,\n\tinput wire [3:0]d ,\n\toutput wire valid_out ,\n\toutput wire dout\n\t);\n\n\nreg [3:0] data = 'd0;\nreg [1:0]cnt;\nreg valid;\nassign dout = data[3];\nassign valid_out =valid;\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)begin\n        data<= 'd0;\n        cnt <= 'd0;\n        valid <= 'd0;\n    end\n    else  begin\n                \n\t\tif (cnt == 'd3) begin\n\t\t\tdata <= d;\n\t\t\tcnt <= 'd0;\n\t\t\tvalid <= 1;\n\t\tend\n\t\telse begin\n\t\t\tcnt <= cnt + 'd1;\n\t\t\tvalid <= 0;\n\t\t\tdata  <= {data[2:0],data[3]};\n\t\tend\n    end\n\t\t\nend\n\n\nendmodule", "corrupted_code": "`timescale 1ns/1ns\nmodule parallel2serial(\n\tinput wire clk  ,\n\tinput wire rst_n  ,\n\tinput wire [3:0]d ,\n\toutput wire valid_out ,\n\toutput wire dout\n\t);\n\n\nreg [3:0] data = 'd0;\nreg [1:0]cnt;\nreg valid;\nassign dout = data[3];\nassign valid_out =valid;\nalways @(posedge clk or negedge rst_n) begin\n    if(rst_n)begin\n        data<= 'd0;\n        cnt <= 'd0;\n        valid <= 'd0;\n    end\n    else  begin\n                \n\t\tif (cnt == 'd3) begin\n\t\t\tdata <= d;\n\t\t\tcnt <= 'd0;\n\t\t\tvalid <= 1;\n\t\tend\n\t\telse begin\n\t\t\tcnt <= cnt + 'd1;\n\t\t\tvalid <= 0;\n\t\t\tdata  <= {data[2:0],data[3]};\n\t\tend\n    end\n\t\t\nend\n\n\nendmodule", "corruption_explanation": "Inverted condition: '!rst_n' -> 'rst_n'", "modification_type": "invert_condition", "modification_line": 17, "original_snippet": "if(!rst_n)begin", "modified_snippet": "if(rst_n)begin", "issue_description": "The buggy code has an inverted condition in an if statement. Instead of checking if(x), it checks if(!x), causing the logic to execute when it shouldn't and skip execution when it should. All conditional behavior is reversed from intended functionality.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_condition modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted condition: '!rst_n' -> 'rst_n'\n   \u2022 Line 17: Original: if(!rst_n)begin\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 17.\n   \u2022 Restore the original code: if(!rst_n)begin\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert condition.", "complexity": 8, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_condition"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.363108", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "parallel2serial", "module_name": "parallel2serial", "description": "Please act as a professional verilog designer.\n\nImplement a module for parallel-to-serial conversion, where every four input bits are converted to a serial one bit output (from MSB to LSB). The output signal valid_out is set to 1 to indicate the availability of valid serial output. When valid_out = 1, the most significant bit of d is output, and the remaining three bits are output sequentially in the following 3 cycles.\n\nModule name:  \n    parallel2serial     \n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst_n: Reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n    d: 4-bit parallel data input.\n\nOutput ports:\n    valid_out: Valid signal indicating the availability of serial output.\n    dout: Serial output representing the converted data.\n\nImplementation:\nThe most significant bit of the parallel input is assigned to the serial output (dout). On each clock cycle, if the counter (cnt) is 3, indicating the last bit of the parallel input, the module updates the data register (data) with the parallel input (d), resets the counter (cnt) to 0, and sets the valid signal (valid) to 1.\nOtherwise, the module increments the counter (cnt) by 1, sets the valid signal (valid) to 0, and shifts the data register (data) one bit to the left, with the most significant bit shifted to the least significant bit.\nCounter Register: If the reset signal (rst_n) is high, the register (cnt) is incremented by 1.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule parallel2serial(\n\tinput wire clk  ,\n\tinput wire rst_n  ,\n\tinput wire [3:0]d ,\n\toutput wire valid_out ,\n\toutput wire dout\n\t);\n\n\nreg [3:0] data = 'd0;\nreg [1:0]cnt;\nreg valid;\nassign dout = data[3];\nassign valid_out =valid;\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)begin\n        data<= 'd0;\n        cnt <= 'd0;\n        valid <= 'd0;\n    end\n    else  begin\n                \n\t\tif (cnt == 'd3) begin\n\t\t\tdata <= d;\n\t\t\tcnt <= 'd0;\n\t\t\tvalid <= 1;\n\t\tend\n\t\telse begin\n\t\t\tcnt <= cnt + 'd1;\n\t\t\tvalid <= 0;\n\t\t\tdata  <= {data[2:0],data[3]};\n\t\tend\n    end\n\t\t\nend\n\n\nendmodule", "corrupted_code": "`timescale 1ns/1ns\nmodule parallel2serial(\n\tinput wire clk  ,\n\tinput wire rst_n  ,\n\tinput wire [3:0]d ,\n\toutput wire valid_out ,\n\toutput wire dout\n\t);\n\n\nreg [3:0] data = 'd0;\nreg [1:0]cnt;\nreg valid;\nassign dout = data[3];\nassign valid_out =valid;\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)begin\n        data<= 'd0;\n        \n        valid <= 'd0;\n    end\n    else  begin\n                \n\t\tif (cnt == 'd3) begin\n\t\t\tdata <= d;\n\t\t\tcnt <= 'd0;\n\t\t\tvalid <= 1;\n\t\tend\n\t\telse begin\n\t\t\tcnt <= cnt + 'd1;\n\t\t\tvalid <= 0;\n\t\t\tdata  <= {data[2:0],data[3]};\n\t\tend\n    end\n\t\t\nend\n\n\nendmodule", "corruption_explanation": "Removed assignment from reset block", "modification_type": "remove_reset_assignment", "modification_line": 17, "original_snippet": "cnt <= 'd0;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing a signal initialization in the reset block. This leaves registers with undefined initial values after reset, causing unpredictable behavior on startup. Simulation may pass but hardware behavior will be incorrect.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_reset_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed assignment from reset block\n   \u2022 Line 17: Original: cnt <= 'd0;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 17.\n   \u2022 Restore the original code: cnt <= 'd0;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove reset assignment.", "complexity": 8, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_reset_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.364144", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "parallel2serial", "module_name": "parallel2serial", "description": "Please act as a professional verilog designer.\n\nImplement a module for parallel-to-serial conversion, where every four input bits are converted to a serial one bit output (from MSB to LSB). The output signal valid_out is set to 1 to indicate the availability of valid serial output. When valid_out = 1, the most significant bit of d is output, and the remaining three bits are output sequentially in the following 3 cycles.\n\nModule name:  \n    parallel2serial     \n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst_n: Reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n    d: 4-bit parallel data input.\n\nOutput ports:\n    valid_out: Valid signal indicating the availability of serial output.\n    dout: Serial output representing the converted data.\n\nImplementation:\nThe most significant bit of the parallel input is assigned to the serial output (dout). On each clock cycle, if the counter (cnt) is 3, indicating the last bit of the parallel input, the module updates the data register (data) with the parallel input (d), resets the counter (cnt) to 0, and sets the valid signal (valid) to 1.\nOtherwise, the module increments the counter (cnt) by 1, sets the valid signal (valid) to 0, and shifts the data register (data) one bit to the left, with the most significant bit shifted to the least significant bit.\nCounter Register: If the reset signal (rst_n) is high, the register (cnt) is incremented by 1.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule parallel2serial(\n\tinput wire clk  ,\n\tinput wire rst_n  ,\n\tinput wire [3:0]d ,\n\toutput wire valid_out ,\n\toutput wire dout\n\t);\n\n\nreg [3:0] data = 'd0;\nreg [1:0]cnt;\nreg valid;\nassign dout = data[3];\nassign valid_out =valid;\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)begin\n        data<= 'd0;\n        cnt <= 'd0;\n        valid <= 'd0;\n    end\n    else  begin\n                \n\t\tif (cnt == 'd3) begin\n\t\t\tdata <= d;\n\t\t\tcnt <= 'd0;\n\t\t\tvalid <= 1;\n\t\tend\n\t\telse begin\n\t\t\tcnt <= cnt + 'd1;\n\t\t\tvalid <= 0;\n\t\t\tdata  <= {data[2:0],data[3]};\n\t\tend\n    end\n\t\t\nend\n\n\nendmodule", "corrupted_code": "`timescale 1ns/1ns\nmodule parallel2serial(\n\tinput wire clk  ,\n\tinput wire rst_n  ,\n\tinput wire [3:0]d ,\n\toutput wire valid_out ,\n\toutput wire dout\n\t);\n\n\nreg [3:0] data = 'd0;\nreg [1:0]cnt;\nreg valid;\nassign dout = data[3];\nassign valid_out =valid;\nalways @(posedge clk) begin\n    if(!rst_n)begin\n        data<= 'd0;\n        cnt <= 'd0;\n        valid <= 'd0;\n    end\n    else  begin\n                \n\t\tif (cnt == 'd3) begin\n\t\t\tdata <= d;\n\t\t\tcnt <= 'd0;\n\t\t\tvalid <= 1;\n\t\tend\n\t\telse begin\n\t\t\tcnt <= cnt + 'd1;\n\t\t\tvalid <= 0;\n\t\t\tdata  <= {data[2:0],data[3]};\n\t\tend\n    end\n\t\t\nend\n\n\nendmodule", "corruption_explanation": "Removed async reset from sensitivity list", "modification_type": "remove_async_reset", "modification_line": 16, "original_snippet": "always @(posedge clk or negedge rst_n)", "modified_snippet": "always @(posedge clk)", "issue_description": "The buggy code has removed async reset from the sensitivity list. The always block only triggers on clock edges, not reset. This causes metastability on power-up and removes the ability to asynchronously reset the design.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_async_reset modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed async reset from sensitivity list\n   \u2022 Line 16: Original: always @(posedge clk or negedge rst_n)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 16.\n   \u2022 Restore the original code: always @(posedge clk or negedge rst_n)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove async reset.", "complexity": 8, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_async_reset"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.365180", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "parallel2serial", "module_name": "parallel2serial", "description": "Please act as a professional verilog designer.\n\nImplement a module for parallel-to-serial conversion, where every four input bits are converted to a serial one bit output (from MSB to LSB). The output signal valid_out is set to 1 to indicate the availability of valid serial output. When valid_out = 1, the most significant bit of d is output, and the remaining three bits are output sequentially in the following 3 cycles.\n\nModule name:  \n    parallel2serial     \n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst_n: Reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n    d: 4-bit parallel data input.\n\nOutput ports:\n    valid_out: Valid signal indicating the availability of serial output.\n    dout: Serial output representing the converted data.\n\nImplementation:\nThe most significant bit of the parallel input is assigned to the serial output (dout). On each clock cycle, if the counter (cnt) is 3, indicating the last bit of the parallel input, the module updates the data register (data) with the parallel input (d), resets the counter (cnt) to 0, and sets the valid signal (valid) to 1.\nOtherwise, the module increments the counter (cnt) by 1, sets the valid signal (valid) to 0, and shifts the data register (data) one bit to the left, with the most significant bit shifted to the least significant bit.\nCounter Register: If the reset signal (rst_n) is high, the register (cnt) is incremented by 1.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule parallel2serial(\n\tinput wire clk  ,\n\tinput wire rst_n  ,\n\tinput wire [3:0]d ,\n\toutput wire valid_out ,\n\toutput wire dout\n\t);\n\n\nreg [3:0] data = 'd0;\nreg [1:0]cnt;\nreg valid;\nassign dout = data[3];\nassign valid_out =valid;\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)begin\n        data<= 'd0;\n        cnt <= 'd0;\n        valid <= 'd0;\n    end\n    else  begin\n                \n\t\tif (cnt == 'd3) begin\n\t\t\tdata <= d;\n\t\t\tcnt <= 'd0;\n\t\t\tvalid <= 1;\n\t\tend\n\t\telse begin\n\t\t\tcnt <= cnt + 'd1;\n\t\t\tvalid <= 0;\n\t\t\tdata  <= {data[2:0],data[3]};\n\t\tend\n    end\n\t\t\nend\n\n\nendmodule", "corrupted_code": "`timescale 1ns/1ns\nmodule parallel2serial(\n\tinput wire clk  ,\n\tinput wire rst_n  ,\n\tinput wire [3:0]d ,\n\toutput wire valid_out ,\n\toutput wire dout\n\t);\n\n\nreg [3:0] data = 'd0;\nreg [1:0]cnt;\nreg valid;\nassign dout = data[3];\nassign valid_out =valid;\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)begin\n        data<= 'd0;\n        cnt <= 'd0;\n        valid <= 'd0;\n    end\n    else  begin\n                \n\t\tif (cnt == 'd3) begin\n\t\t\tdata <= d;\n\t\t\tcnt <= 'd0;\n\t\t\tvalid <= 1;\n\t\tend\n\t\telse begin\n\n\t\t\tvalid <= 0;\n\t\t\tdata  <= {data[2:0],data[3]};\n\t\tend\n    end\n\t\t\nend\n\n\nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 30, "original_snippet": "cnt <= cnt + 'd1;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 30: Original: cnt <= cnt + 'd1;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 30.\n   \u2022 Restore the original code: cnt <= cnt + 'd1;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 8, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.366197", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "calendar", "module_name": "calendar", "description": "Please act as a professional verilog designer.\n\nImplement a module of perpetual calendar. The starting value of Secs, Mins, and Hours are all 0. Both Secs and Mins loop continuously from 0 to 59. When Secs=59, Min increases by 1 at the next cycle, and when Min=59 && Secs=59, Hours increases by 1 at the next cycle. Hours is counted from the 0-23 cycle.\n\nModule name:  \n    calendar  \n                 \nInput ports:\n    CLK: Clock input\n    RST: Active high reset signal\n\nOutput ports:\n    Hours: 6-bit output representing the current hours\n    Mins: 6-bit output representing the current minutes\n    Secs: 6-bit output representing the current seconds\n\nImplementation:\nThe calendar module uses three always blocks to update the values of seconds, minutes, and hours based on the clock signal and reset signal.\nThe first always block triggers on the positive edge of the clock signal (posedge CLK) or the positive edge of the reset signal (posedge RST). It checks if the reset signal is active (RST) and sets the seconds value (Secs) to 0. If the seconds value is 59, it wraps around and sets the seconds value to 0. Otherwise, it increments the seconds value by 1.\nThe second always block also triggers on the positive edge of the clock signal or the positive edge of the reset signal. It handles the minutes value (Mins). If the reset signal is active, it sets the minutes value to 0. If both the minutes and seconds values are 59, it wraps around and sets the minutes value to 0. If the seconds value is 59, it increments the minutes value by 1. Otherwise, it keeps the minutes value unchanged.\nThe third always block triggers on the positive edge of the clock signal or the positive edge of the reset signal. It handles the hours value (Hours). If the reset signal is active, it sets the hours value to 0. If the hours, minutes, and seconds values are all at their maximum (23, 59, and 59 respectively), it wraps around and sets the hours value to 0. If the minutes and seconds values are both 59, it increments the hours value by 1. Otherwise, it keeps the hours value unchanged.\n\nGive me the complete code.\n"}, "clean_code": "module calendar(CLK,RST,Hours,Mins,Secs);\ninput CLK,RST;\noutput [5:0] Hours,Mins,Secs;\nreg [5:0] Hours,Mins,Secs;\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tSecs <= 0;\n\telse if (Secs == 59)\n\t\tSecs <= 0;\n\telse\n\t\tSecs <= Secs + 1;\nend\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tMins <= 0;\n\telse if((Mins==59)&&(Secs==59))\n\t\tMins <= 0;\n\telse if(Secs== 59)\n\t\tMins <= Mins + 1;\n\telse\n\t\tMins <= Mins;\nend\n\nalways@(posedge CLK or posedge RST) begin\n        if (RST)\n                Hours <= 0;\n        else if((Hours == 23)&&(Mins==59)&&(Secs==59))\n                Hours <= 0;\n        else if((Mins == 59)&&(Secs==59))\n                Hours <= Hours + 1;\n        else\n                Hours <= Hours;\nend\n\nendmodule", "corrupted_code": "module calendar(CLK,RST,Hours,Mins,Secs);\ninput CLK,RST;\noutput [5:0] Hours,Mins,Secs;\nreg [5:0] Hours,Mins,Secs;\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tSecs <= 0;\n\telse if (Secs == 59)\n\t\tSecs <= 0;\n\telse\n\t\tSecs <= Secs + 1;\nend\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tMins = 0;\n\telse if((Mins==59)&&(Secs==59))\n\t\tMins <= 0;\n\telse if(Secs== 59)\n\t\tMins <= Mins + 1;\n\telse\n\t\tMins <= Mins;\nend\n\nalways@(posedge CLK or posedge RST) begin\n        if (RST)\n                Hours <= 0;\n        else if((Hours == 23)&&(Mins==59)&&(Secs==59))\n                Hours <= 0;\n        else if((Mins == 59)&&(Secs==59))\n                Hours <= Hours + 1;\n        else\n                Hours <= Hours;\nend\n\nendmodule", "corruption_explanation": "Changed non-blocking (<=) to blocking (=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 17, "original_snippet": "Mins <= 0;", "modified_snippet": "Mins = 0;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 26, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.369317", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "calendar", "module_name": "calendar", "description": "Please act as a professional verilog designer.\n\nImplement a module of perpetual calendar. The starting value of Secs, Mins, and Hours are all 0. Both Secs and Mins loop continuously from 0 to 59. When Secs=59, Min increases by 1 at the next cycle, and when Min=59 && Secs=59, Hours increases by 1 at the next cycle. Hours is counted from the 0-23 cycle.\n\nModule name:  \n    calendar  \n                 \nInput ports:\n    CLK: Clock input\n    RST: Active high reset signal\n\nOutput ports:\n    Hours: 6-bit output representing the current hours\n    Mins: 6-bit output representing the current minutes\n    Secs: 6-bit output representing the current seconds\n\nImplementation:\nThe calendar module uses three always blocks to update the values of seconds, minutes, and hours based on the clock signal and reset signal.\nThe first always block triggers on the positive edge of the clock signal (posedge CLK) or the positive edge of the reset signal (posedge RST). It checks if the reset signal is active (RST) and sets the seconds value (Secs) to 0. If the seconds value is 59, it wraps around and sets the seconds value to 0. Otherwise, it increments the seconds value by 1.\nThe second always block also triggers on the positive edge of the clock signal or the positive edge of the reset signal. It handles the minutes value (Mins). If the reset signal is active, it sets the minutes value to 0. If both the minutes and seconds values are 59, it wraps around and sets the minutes value to 0. If the seconds value is 59, it increments the minutes value by 1. Otherwise, it keeps the minutes value unchanged.\nThe third always block triggers on the positive edge of the clock signal or the positive edge of the reset signal. It handles the hours value (Hours). If the reset signal is active, it sets the hours value to 0. If the hours, minutes, and seconds values are all at their maximum (23, 59, and 59 respectively), it wraps around and sets the hours value to 0. If the minutes and seconds values are both 59, it increments the hours value by 1. Otherwise, it keeps the hours value unchanged.\n\nGive me the complete code.\n"}, "clean_code": "module calendar(CLK,RST,Hours,Mins,Secs);\ninput CLK,RST;\noutput [5:0] Hours,Mins,Secs;\nreg [5:0] Hours,Mins,Secs;\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tSecs <= 0;\n\telse if (Secs == 59)\n\t\tSecs <= 0;\n\telse\n\t\tSecs <= Secs + 1;\nend\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tMins <= 0;\n\telse if((Mins==59)&&(Secs==59))\n\t\tMins <= 0;\n\telse if(Secs== 59)\n\t\tMins <= Mins + 1;\n\telse\n\t\tMins <= Mins;\nend\n\nalways@(posedge CLK or posedge RST) begin\n        if (RST)\n                Hours <= 0;\n        else if((Hours == 23)&&(Mins==59)&&(Secs==59))\n                Hours <= 0;\n        else if((Mins == 59)&&(Secs==59))\n                Hours <= Hours + 1;\n        else\n                Hours <= Hours;\nend\n\nendmodule", "corrupted_code": "module calendar(CLK,RST,Hours,Mins,Secs);\ninput CLK,RST;\noutput [5:0] Hours,Mins,Secs;\nreg [5:0] Hours,Mins,Secs;\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tSecs <= 0;\n\telse if (Secs == 59)\n\t\tSecs <= 0;\n\telse\n\t\tSecs <= Secs + 1;\nend\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tMins <= 0;\n\telse if((Mins==59)&&(Secs==59))\n\t\tMins <= 0;\n\telse if(Secs== 59)\n\t\tMins <= Mins + 1;\n\telse\n\t\t==59)&&(Secs==59))\n                Hours <= 0;\n        else if((Mins == 59)&&(Secs==59))\n                Hours <= Hours + 1;\n        else\n                Hours <= Hours;\nend\n\nendmodule", "corruption_explanation": "Removed CDC synchronizer stage", "modification_type": "modify_cdc", "modification_line": 23, "original_snippet": "Mins <= Mins;\nend\n\nalways@(posedge CLK or posedge RST) begin\n        if (RST)\n                Hours <= 0;\n        else if((Hours == 23)&&(Mins", "modified_snippet": "(removed)", "issue_description": "The buggy code has a broken clock domain crossing synchronizer. A synchronizer flip-flop stage was removed, reducing metastability protection. This creates CDC violations that cause random data corruption in multi-clock domain designs.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a modify_cdc modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed CDC synchronizer stage\n   \u2022 Line 23: Original: Mins <= Mins;\nend\n\nalways@(posedge CLK or posedge RST) begin\n        if (RST)\n                Hours <= 0;\n        else if((Hours == 23)&&(Mins\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 23.\n   \u2022 Restore the original code: Mins <= Mins;\nend\n\nalways@(posedge CLK or posedge RST) begin\n        if (RST)\n                Hours <= 0;\n        else if((Hours == 23)&&(Mins\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to modify cdc.", "complexity": 26, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["modify_cdc"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.370723", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "calendar", "module_name": "calendar", "description": "Please act as a professional verilog designer.\n\nImplement a module of perpetual calendar. The starting value of Secs, Mins, and Hours are all 0. Both Secs and Mins loop continuously from 0 to 59. When Secs=59, Min increases by 1 at the next cycle, and when Min=59 && Secs=59, Hours increases by 1 at the next cycle. Hours is counted from the 0-23 cycle.\n\nModule name:  \n    calendar  \n                 \nInput ports:\n    CLK: Clock input\n    RST: Active high reset signal\n\nOutput ports:\n    Hours: 6-bit output representing the current hours\n    Mins: 6-bit output representing the current minutes\n    Secs: 6-bit output representing the current seconds\n\nImplementation:\nThe calendar module uses three always blocks to update the values of seconds, minutes, and hours based on the clock signal and reset signal.\nThe first always block triggers on the positive edge of the clock signal (posedge CLK) or the positive edge of the reset signal (posedge RST). It checks if the reset signal is active (RST) and sets the seconds value (Secs) to 0. If the seconds value is 59, it wraps around and sets the seconds value to 0. Otherwise, it increments the seconds value by 1.\nThe second always block also triggers on the positive edge of the clock signal or the positive edge of the reset signal. It handles the minutes value (Mins). If the reset signal is active, it sets the minutes value to 0. If both the minutes and seconds values are 59, it wraps around and sets the minutes value to 0. If the seconds value is 59, it increments the minutes value by 1. Otherwise, it keeps the minutes value unchanged.\nThe third always block triggers on the positive edge of the clock signal or the positive edge of the reset signal. It handles the hours value (Hours). If the reset signal is active, it sets the hours value to 0. If the hours, minutes, and seconds values are all at their maximum (23, 59, and 59 respectively), it wraps around and sets the hours value to 0. If the minutes and seconds values are both 59, it increments the hours value by 1. Otherwise, it keeps the hours value unchanged.\n\nGive me the complete code.\n"}, "clean_code": "module calendar(CLK,RST,Hours,Mins,Secs);\ninput CLK,RST;\noutput [5:0] Hours,Mins,Secs;\nreg [5:0] Hours,Mins,Secs;\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tSecs <= 0;\n\telse if (Secs == 59)\n\t\tSecs <= 0;\n\telse\n\t\tSecs <= Secs + 1;\nend\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tMins <= 0;\n\telse if((Mins==59)&&(Secs==59))\n\t\tMins <= 0;\n\telse if(Secs== 59)\n\t\tMins <= Mins + 1;\n\telse\n\t\tMins <= Mins;\nend\n\nalways@(posedge CLK or posedge RST) begin\n        if (RST)\n                Hours <= 0;\n        else if((Hours == 23)&&(Mins==59)&&(Secs==59))\n                Hours <= 0;\n        else if((Mins == 59)&&(Secs==59))\n                Hours <= Hours + 1;\n        else\n                Hours <= Hours;\nend\n\nendmodule", "corrupted_code": "module calendar(CLK,RST,Hours,Mins,Secs);\ninput CLK,RST;\noutput [5:0] Hours,Mins,Secs;\nreg [5:0] Hours,Mins,Secs;\n\nalways@(posedge CLK or posedge RST) begin\n\tif (!RST)\n\t\tSecs <= 0;\n\telse if (Secs == 59)\n\t\tSecs <= 0;\n\telse\n\t\tSecs <= Secs + 1;\nend\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tMins <= 0;\n\telse if((Mins==59)&&(Secs==59))\n\t\tMins <= 0;\n\telse if(Secs== 59)\n\t\tMins <= Mins + 1;\n\telse\n\t\tMins <= Mins;\nend\n\nalways@(posedge CLK or posedge RST) begin\n        if (RST)\n                Hours <= 0;\n        else if((Hours == 23)&&(Mins==59)&&(Secs==59))\n                Hours <= 0;\n        else if((Mins == 59)&&(Secs==59))\n                Hours <= Hours + 1;\n        else\n                Hours <= Hours;\nend\n\nendmodule", "corruption_explanation": "Inverted reset polarity in condition", "modification_type": "invert_reset_polarity", "modification_line": 7, "original_snippet": "if (RST)", "modified_snippet": "if (!RST)", "issue_description": "The buggy code has inverted reset polarity. If the design expects active-low reset (!rst), it now uses active-high, or vice versa. This causes the reset logic to activate during normal operation and deactivate during actual reset, breaking initialization.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_reset_polarity modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted reset polarity in condition\n   \u2022 Line 7: Original: if (RST)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 7.\n   \u2022 Restore the original code: if (RST)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert reset polarity.", "complexity": 26, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_reset_polarity"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.372013", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "calendar", "module_name": "calendar", "description": "Please act as a professional verilog designer.\n\nImplement a module of perpetual calendar. The starting value of Secs, Mins, and Hours are all 0. Both Secs and Mins loop continuously from 0 to 59. When Secs=59, Min increases by 1 at the next cycle, and when Min=59 && Secs=59, Hours increases by 1 at the next cycle. Hours is counted from the 0-23 cycle.\n\nModule name:  \n    calendar  \n                 \nInput ports:\n    CLK: Clock input\n    RST: Active high reset signal\n\nOutput ports:\n    Hours: 6-bit output representing the current hours\n    Mins: 6-bit output representing the current minutes\n    Secs: 6-bit output representing the current seconds\n\nImplementation:\nThe calendar module uses three always blocks to update the values of seconds, minutes, and hours based on the clock signal and reset signal.\nThe first always block triggers on the positive edge of the clock signal (posedge CLK) or the positive edge of the reset signal (posedge RST). It checks if the reset signal is active (RST) and sets the seconds value (Secs) to 0. If the seconds value is 59, it wraps around and sets the seconds value to 0. Otherwise, it increments the seconds value by 1.\nThe second always block also triggers on the positive edge of the clock signal or the positive edge of the reset signal. It handles the minutes value (Mins). If the reset signal is active, it sets the minutes value to 0. If both the minutes and seconds values are 59, it wraps around and sets the minutes value to 0. If the seconds value is 59, it increments the minutes value by 1. Otherwise, it keeps the minutes value unchanged.\nThe third always block triggers on the positive edge of the clock signal or the positive edge of the reset signal. It handles the hours value (Hours). If the reset signal is active, it sets the hours value to 0. If the hours, minutes, and seconds values are all at their maximum (23, 59, and 59 respectively), it wraps around and sets the hours value to 0. If the minutes and seconds values are both 59, it increments the hours value by 1. Otherwise, it keeps the hours value unchanged.\n\nGive me the complete code.\n"}, "clean_code": "module calendar(CLK,RST,Hours,Mins,Secs);\ninput CLK,RST;\noutput [5:0] Hours,Mins,Secs;\nreg [5:0] Hours,Mins,Secs;\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tSecs <= 0;\n\telse if (Secs == 59)\n\t\tSecs <= 0;\n\telse\n\t\tSecs <= Secs + 1;\nend\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tMins <= 0;\n\telse if((Mins==59)&&(Secs==59))\n\t\tMins <= 0;\n\telse if(Secs== 59)\n\t\tMins <= Mins + 1;\n\telse\n\t\tMins <= Mins;\nend\n\nalways@(posedge CLK or posedge RST) begin\n        if (RST)\n                Hours <= 0;\n        else if((Hours == 23)&&(Mins==59)&&(Secs==59))\n                Hours <= 0;\n        else if((Mins == 59)&&(Secs==59))\n                Hours <= Hours + 1;\n        else\n                Hours <= Hours;\nend\n\nendmodule", "corrupted_code": "module calendar(CLK,RST,Hours,Mins,Secs);\ninput CLK,RST;\noutput [5:0] Hours,Mins,Secs;\nreg [5:0] Hours,Mins,Secs;\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tSecs <= 0;\n\telse if (Secs == 59)\n\t\tSecs <= 0;\n\telse\n\t\tSecs <= Secs + 1;\nend\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tMins <= 0;\n\telse if((Mins==59)&&(Secs==59))\n\t\tMins <= 0;\n\telse if(Secs== 59)\n\t\tMins <= Mins + 1;\n\telse\n\t\tMins <= Mins;\nend\n\nalways@(posedge CLK or posedge RST) begin\n        if (RST)\n                Hours >= 0;\n        else if((Hours == 23)&&(Mins==59)&&(Secs==59))\n                Hours <= 0;\n        else if((Mins == 59)&&(Secs==59))\n                Hours <= Hours + 1;\n        else\n                Hours <= Hours;\nend\n\nendmodule", "corruption_explanation": "Changed operator from '<=' to '>='", "modification_type": "change_operator", "modification_line": 28, "original_snippet": "s <= 0", "modified_snippet": "s >= 0", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '<=' to '>='\n   \u2022 Line 28: Original: s <= 0\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 28.\n   \u2022 Restore the original code: s <= 0\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 26, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.374522", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "calendar", "module_name": "calendar", "description": "Please act as a professional verilog designer.\n\nImplement a module of perpetual calendar. The starting value of Secs, Mins, and Hours are all 0. Both Secs and Mins loop continuously from 0 to 59. When Secs=59, Min increases by 1 at the next cycle, and when Min=59 && Secs=59, Hours increases by 1 at the next cycle. Hours is counted from the 0-23 cycle.\n\nModule name:  \n    calendar  \n                 \nInput ports:\n    CLK: Clock input\n    RST: Active high reset signal\n\nOutput ports:\n    Hours: 6-bit output representing the current hours\n    Mins: 6-bit output representing the current minutes\n    Secs: 6-bit output representing the current seconds\n\nImplementation:\nThe calendar module uses three always blocks to update the values of seconds, minutes, and hours based on the clock signal and reset signal.\nThe first always block triggers on the positive edge of the clock signal (posedge CLK) or the positive edge of the reset signal (posedge RST). It checks if the reset signal is active (RST) and sets the seconds value (Secs) to 0. If the seconds value is 59, it wraps around and sets the seconds value to 0. Otherwise, it increments the seconds value by 1.\nThe second always block also triggers on the positive edge of the clock signal or the positive edge of the reset signal. It handles the minutes value (Mins). If the reset signal is active, it sets the minutes value to 0. If both the minutes and seconds values are 59, it wraps around and sets the minutes value to 0. If the seconds value is 59, it increments the minutes value by 1. Otherwise, it keeps the minutes value unchanged.\nThe third always block triggers on the positive edge of the clock signal or the positive edge of the reset signal. It handles the hours value (Hours). If the reset signal is active, it sets the hours value to 0. If the hours, minutes, and seconds values are all at their maximum (23, 59, and 59 respectively), it wraps around and sets the hours value to 0. If the minutes and seconds values are both 59, it increments the hours value by 1. Otherwise, it keeps the hours value unchanged.\n\nGive me the complete code.\n"}, "clean_code": "module calendar(CLK,RST,Hours,Mins,Secs);\ninput CLK,RST;\noutput [5:0] Hours,Mins,Secs;\nreg [5:0] Hours,Mins,Secs;\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tSecs <= 0;\n\telse if (Secs == 59)\n\t\tSecs <= 0;\n\telse\n\t\tSecs <= Secs + 1;\nend\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tMins <= 0;\n\telse if((Mins==59)&&(Secs==59))\n\t\tMins <= 0;\n\telse if(Secs== 59)\n\t\tMins <= Mins + 1;\n\telse\n\t\tMins <= Mins;\nend\n\nalways@(posedge CLK or posedge RST) begin\n        if (RST)\n                Hours <= 0;\n        else if((Hours == 23)&&(Mins==59)&&(Secs==59))\n                Hours <= 0;\n        else if((Mins == 59)&&(Secs==59))\n                Hours <= Hours + 1;\n        else\n                Hours <= Hours;\nend\n\nendmodule", "corrupted_code": "module calendar(CLK,RST,Hours,Mins,Secs);\ninput CLK,RST;\noutput [5:0] Hours,Mins,Secs;\nreg [5:0] Hours,Mins,Secs;\n\nalways @(posedge CLK) begin\n\tif (RST)\n\t\tSecs <= 0;\n\telse if (Secs == 59)\n\t\tSecs <= 0;\n\telse\n\t\tSecs <= Secs + 1;\nend\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tMins <= 0;\n\telse if((Mins==59)&&(Secs==59))\n\t\tMins <= 0;\n\telse if(Secs== 59)\n\t\tMins <= Mins + 1;\n\telse\n\t\tMins <= Mins;\nend\n\nalways@(posedge CLK or posedge RST) begin\n        if (RST)\n                Hours <= 0;\n        else if((Hours == 23)&&(Mins==59)&&(Secs==59))\n                Hours <= 0;\n        else if((Mins == 59)&&(Secs==59))\n                Hours <= Hours + 1;\n        else\n                Hours <= Hours;\nend\n\nendmodule", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 6, "original_snippet": "always@(posedge CLK or posedge RST)", "modified_snippet": "always @(posedge CLK)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 6: Original: always@(posedge CLK or posedge RST)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 6.\n   \u2022 Restore the original code: always@(posedge CLK or posedge RST)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 26, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_sensitivity_list"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.375838", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "calendar", "module_name": "calendar", "description": "Please act as a professional verilog designer.\n\nImplement a module of perpetual calendar. The starting value of Secs, Mins, and Hours are all 0. Both Secs and Mins loop continuously from 0 to 59. When Secs=59, Min increases by 1 at the next cycle, and when Min=59 && Secs=59, Hours increases by 1 at the next cycle. Hours is counted from the 0-23 cycle.\n\nModule name:  \n    calendar  \n                 \nInput ports:\n    CLK: Clock input\n    RST: Active high reset signal\n\nOutput ports:\n    Hours: 6-bit output representing the current hours\n    Mins: 6-bit output representing the current minutes\n    Secs: 6-bit output representing the current seconds\n\nImplementation:\nThe calendar module uses three always blocks to update the values of seconds, minutes, and hours based on the clock signal and reset signal.\nThe first always block triggers on the positive edge of the clock signal (posedge CLK) or the positive edge of the reset signal (posedge RST). It checks if the reset signal is active (RST) and sets the seconds value (Secs) to 0. If the seconds value is 59, it wraps around and sets the seconds value to 0. Otherwise, it increments the seconds value by 1.\nThe second always block also triggers on the positive edge of the clock signal or the positive edge of the reset signal. It handles the minutes value (Mins). If the reset signal is active, it sets the minutes value to 0. If both the minutes and seconds values are 59, it wraps around and sets the minutes value to 0. If the seconds value is 59, it increments the minutes value by 1. Otherwise, it keeps the minutes value unchanged.\nThe third always block triggers on the positive edge of the clock signal or the positive edge of the reset signal. It handles the hours value (Hours). If the reset signal is active, it sets the hours value to 0. If the hours, minutes, and seconds values are all at their maximum (23, 59, and 59 respectively), it wraps around and sets the hours value to 0. If the minutes and seconds values are both 59, it increments the hours value by 1. Otherwise, it keeps the hours value unchanged.\n\nGive me the complete code.\n"}, "clean_code": "module calendar(CLK,RST,Hours,Mins,Secs);\ninput CLK,RST;\noutput [5:0] Hours,Mins,Secs;\nreg [5:0] Hours,Mins,Secs;\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tSecs <= 0;\n\telse if (Secs == 59)\n\t\tSecs <= 0;\n\telse\n\t\tSecs <= Secs + 1;\nend\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tMins <= 0;\n\telse if((Mins==59)&&(Secs==59))\n\t\tMins <= 0;\n\telse if(Secs== 59)\n\t\tMins <= Mins + 1;\n\telse\n\t\tMins <= Mins;\nend\n\nalways@(posedge CLK or posedge RST) begin\n        if (RST)\n                Hours <= 0;\n        else if((Hours == 23)&&(Mins==59)&&(Secs==59))\n                Hours <= 0;\n        else if((Mins == 59)&&(Secs==59))\n                Hours <= Hours + 1;\n        else\n                Hours <= Hours;\nend\n\nendmodule", "corrupted_code": "module calendar(CLK,RST,Hours,Mins,Secs);\ninput CLK,RST;\noutput [5:0] Hours,Mins,Secs;\nreg [5:0] Hours,Mins,Secs;\n\nalways @(posedge CLK) begin\n\tif (RST)\n\t\tSecs <= 0;\n\telse if (Secs == 59)\n\t\tSecs <= 0;\n\telse\n\t\tSecs <= Secs + 1;\nend\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tMins <= 0;\n\telse if((Mins==59)&&(Secs==59))\n\t\tMins <= 0;\n\telse if(Secs== 59)\n\t\tMins <= Mins + 1;\n\telse\n\t\tMins <= Mins;\nend\n\nalways@(posedge CLK or posedge RST) begin\n        if (RST)\n                Hours <= 0;\n        else if((Hours == 23)&&(Mins==59)&&(Secs==59))\n                Hours <= 0;\n        else if((Mins == 59)&&(Secs==59))\n                Hours <= Hours + 1;\n        else\n                Hours <= Hours;\nend\n\nendmodule", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 6, "original_snippet": "always@(posedge CLK or posedge RST)", "modified_snippet": "always @(posedge CLK)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 6: Original: always@(posedge CLK or posedge RST)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 6.\n   \u2022 Restore the original code: always@(posedge CLK or posedge RST)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 26, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_sensitivity_list"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.377118", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "calendar", "module_name": "calendar", "description": "Please act as a professional verilog designer.\n\nImplement a module of perpetual calendar. The starting value of Secs, Mins, and Hours are all 0. Both Secs and Mins loop continuously from 0 to 59. When Secs=59, Min increases by 1 at the next cycle, and when Min=59 && Secs=59, Hours increases by 1 at the next cycle. Hours is counted from the 0-23 cycle.\n\nModule name:  \n    calendar  \n                 \nInput ports:\n    CLK: Clock input\n    RST: Active high reset signal\n\nOutput ports:\n    Hours: 6-bit output representing the current hours\n    Mins: 6-bit output representing the current minutes\n    Secs: 6-bit output representing the current seconds\n\nImplementation:\nThe calendar module uses three always blocks to update the values of seconds, minutes, and hours based on the clock signal and reset signal.\nThe first always block triggers on the positive edge of the clock signal (posedge CLK) or the positive edge of the reset signal (posedge RST). It checks if the reset signal is active (RST) and sets the seconds value (Secs) to 0. If the seconds value is 59, it wraps around and sets the seconds value to 0. Otherwise, it increments the seconds value by 1.\nThe second always block also triggers on the positive edge of the clock signal or the positive edge of the reset signal. It handles the minutes value (Mins). If the reset signal is active, it sets the minutes value to 0. If both the minutes and seconds values are 59, it wraps around and sets the minutes value to 0. If the seconds value is 59, it increments the minutes value by 1. Otherwise, it keeps the minutes value unchanged.\nThe third always block triggers on the positive edge of the clock signal or the positive edge of the reset signal. It handles the hours value (Hours). If the reset signal is active, it sets the hours value to 0. If the hours, minutes, and seconds values are all at their maximum (23, 59, and 59 respectively), it wraps around and sets the hours value to 0. If the minutes and seconds values are both 59, it increments the hours value by 1. Otherwise, it keeps the hours value unchanged.\n\nGive me the complete code.\n"}, "clean_code": "module calendar(CLK,RST,Hours,Mins,Secs);\ninput CLK,RST;\noutput [5:0] Hours,Mins,Secs;\nreg [5:0] Hours,Mins,Secs;\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tSecs <= 0;\n\telse if (Secs == 59)\n\t\tSecs <= 0;\n\telse\n\t\tSecs <= Secs + 1;\nend\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tMins <= 0;\n\telse if((Mins==59)&&(Secs==59))\n\t\tMins <= 0;\n\telse if(Secs== 59)\n\t\tMins <= Mins + 1;\n\telse\n\t\tMins <= Mins;\nend\n\nalways@(posedge CLK or posedge RST) begin\n        if (RST)\n                Hours <= 0;\n        else if((Hours == 23)&&(Mins==59)&&(Secs==59))\n                Hours <= 0;\n        else if((Mins == 59)&&(Secs==59))\n                Hours <= Hours + 1;\n        else\n                Hours <= Hours;\nend\n\nendmodule", "corrupted_code": "module calendar(CLK,RST,Hours,Mins,Secs);\ninput CLK,RST;\noutput [5:0] Hours,Mins,Secs;\nreg [5:0] Hours,Mins,Secs;\n\nalways@(posedge CLK or posedge RST) begin\n\tif (!RST)\n\t\tSecs <= 0;\n\telse if (Secs == 59)\n\t\tSecs <= 0;\n\telse\n\t\tSecs <= Secs + 1;\nend\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tMins <= 0;\n\telse if((Mins==59)&&(Secs==59))\n\t\tMins <= 0;\n\telse if(Secs== 59)\n\t\tMins <= Mins + 1;\n\telse\n\t\tMins <= Mins;\nend\n\nalways@(posedge CLK or posedge RST) begin\n        if (RST)\n                Hours <= 0;\n        else if((Hours == 23)&&(Mins==59)&&(Secs==59))\n                Hours <= 0;\n        else if((Mins == 59)&&(Secs==59))\n                Hours <= Hours + 1;\n        else\n                Hours <= Hours;\nend\n\nendmodule", "corruption_explanation": "Inverted reset polarity in condition", "modification_type": "invert_reset_polarity", "modification_line": 7, "original_snippet": "if (RST)", "modified_snippet": "if (!RST)", "issue_description": "The buggy code has inverted reset polarity. If the design expects active-low reset (!rst), it now uses active-high, or vice versa. This causes the reset logic to activate during normal operation and deactivate during actual reset, breaking initialization.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_reset_polarity modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted reset polarity in condition\n   \u2022 Line 7: Original: if (RST)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 7.\n   \u2022 Restore the original code: if (RST)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert reset polarity.", "complexity": 26, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_reset_polarity"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.378411", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "calendar", "module_name": "calendar", "description": "Please act as a professional verilog designer.\n\nImplement a module of perpetual calendar. The starting value of Secs, Mins, and Hours are all 0. Both Secs and Mins loop continuously from 0 to 59. When Secs=59, Min increases by 1 at the next cycle, and when Min=59 && Secs=59, Hours increases by 1 at the next cycle. Hours is counted from the 0-23 cycle.\n\nModule name:  \n    calendar  \n                 \nInput ports:\n    CLK: Clock input\n    RST: Active high reset signal\n\nOutput ports:\n    Hours: 6-bit output representing the current hours\n    Mins: 6-bit output representing the current minutes\n    Secs: 6-bit output representing the current seconds\n\nImplementation:\nThe calendar module uses three always blocks to update the values of seconds, minutes, and hours based on the clock signal and reset signal.\nThe first always block triggers on the positive edge of the clock signal (posedge CLK) or the positive edge of the reset signal (posedge RST). It checks if the reset signal is active (RST) and sets the seconds value (Secs) to 0. If the seconds value is 59, it wraps around and sets the seconds value to 0. Otherwise, it increments the seconds value by 1.\nThe second always block also triggers on the positive edge of the clock signal or the positive edge of the reset signal. It handles the minutes value (Mins). If the reset signal is active, it sets the minutes value to 0. If both the minutes and seconds values are 59, it wraps around and sets the minutes value to 0. If the seconds value is 59, it increments the minutes value by 1. Otherwise, it keeps the minutes value unchanged.\nThe third always block triggers on the positive edge of the clock signal or the positive edge of the reset signal. It handles the hours value (Hours). If the reset signal is active, it sets the hours value to 0. If the hours, minutes, and seconds values are all at their maximum (23, 59, and 59 respectively), it wraps around and sets the hours value to 0. If the minutes and seconds values are both 59, it increments the hours value by 1. Otherwise, it keeps the hours value unchanged.\n\nGive me the complete code.\n"}, "clean_code": "module calendar(CLK,RST,Hours,Mins,Secs);\ninput CLK,RST;\noutput [5:0] Hours,Mins,Secs;\nreg [5:0] Hours,Mins,Secs;\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tSecs <= 0;\n\telse if (Secs == 59)\n\t\tSecs <= 0;\n\telse\n\t\tSecs <= Secs + 1;\nend\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tMins <= 0;\n\telse if((Mins==59)&&(Secs==59))\n\t\tMins <= 0;\n\telse if(Secs== 59)\n\t\tMins <= Mins + 1;\n\telse\n\t\tMins <= Mins;\nend\n\nalways@(posedge CLK or posedge RST) begin\n        if (RST)\n                Hours <= 0;\n        else if((Hours == 23)&&(Mins==59)&&(Secs==59))\n                Hours <= 0;\n        else if((Mins == 59)&&(Secs==59))\n                Hours <= Hours + 1;\n        else\n                Hours <= Hours;\nend\n\nendmodule", "corrupted_code": "module calendar(CLK,RST,Hours,Mins,Secs);\ninput CLK,RST;\noutput [5:0] Hours,Mins,Secs;\nreg [5:0] Hours,Mins,Secs;\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tSecs <= 0;\n\telse if (Secs == 59)\n\t\tSecs <= 0;\n\telse\n\t\tSecs <= Secs + 1;\nend\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tMins <= 0;\n\telse if((Mins==59)&&(Secs==59))\n\t\tMins <= 0;\n\telse if(Secs== 59)\n\t\tMins <= Mins + 1;\n\telse\n\t\t==59)&&(Secs==59))\n                Hours <= 0;\n        else if((Mins == 59)&&(Secs==59))\n                Hours <= Hours + 1;\n        else\n                Hours <= Hours;\nend\n\nendmodule", "corruption_explanation": "Removed CDC synchronizer stage", "modification_type": "modify_cdc", "modification_line": 23, "original_snippet": "Mins <= Mins;\nend\n\nalways@(posedge CLK or posedge RST) begin\n        if (RST)\n                Hours <= 0;\n        else if((Hours == 23)&&(Mins", "modified_snippet": "(removed)", "issue_description": "The buggy code has a broken clock domain crossing synchronizer. A synchronizer flip-flop stage was removed, reducing metastability protection. This creates CDC violations that cause random data corruption in multi-clock domain designs.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a modify_cdc modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed CDC synchronizer stage\n   \u2022 Line 23: Original: Mins <= Mins;\nend\n\nalways@(posedge CLK or posedge RST) begin\n        if (RST)\n                Hours <= 0;\n        else if((Hours == 23)&&(Mins\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 23.\n   \u2022 Restore the original code: Mins <= Mins;\nend\n\nalways@(posedge CLK or posedge RST) begin\n        if (RST)\n                Hours <= 0;\n        else if((Hours == 23)&&(Mins\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to modify cdc.", "complexity": 26, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["modify_cdc"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.379842", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "calendar", "module_name": "calendar", "description": "Please act as a professional verilog designer.\n\nImplement a module of perpetual calendar. The starting value of Secs, Mins, and Hours are all 0. Both Secs and Mins loop continuously from 0 to 59. When Secs=59, Min increases by 1 at the next cycle, and when Min=59 && Secs=59, Hours increases by 1 at the next cycle. Hours is counted from the 0-23 cycle.\n\nModule name:  \n    calendar  \n                 \nInput ports:\n    CLK: Clock input\n    RST: Active high reset signal\n\nOutput ports:\n    Hours: 6-bit output representing the current hours\n    Mins: 6-bit output representing the current minutes\n    Secs: 6-bit output representing the current seconds\n\nImplementation:\nThe calendar module uses three always blocks to update the values of seconds, minutes, and hours based on the clock signal and reset signal.\nThe first always block triggers on the positive edge of the clock signal (posedge CLK) or the positive edge of the reset signal (posedge RST). It checks if the reset signal is active (RST) and sets the seconds value (Secs) to 0. If the seconds value is 59, it wraps around and sets the seconds value to 0. Otherwise, it increments the seconds value by 1.\nThe second always block also triggers on the positive edge of the clock signal or the positive edge of the reset signal. It handles the minutes value (Mins). If the reset signal is active, it sets the minutes value to 0. If both the minutes and seconds values are 59, it wraps around and sets the minutes value to 0. If the seconds value is 59, it increments the minutes value by 1. Otherwise, it keeps the minutes value unchanged.\nThe third always block triggers on the positive edge of the clock signal or the positive edge of the reset signal. It handles the hours value (Hours). If the reset signal is active, it sets the hours value to 0. If the hours, minutes, and seconds values are all at their maximum (23, 59, and 59 respectively), it wraps around and sets the hours value to 0. If the minutes and seconds values are both 59, it increments the hours value by 1. Otherwise, it keeps the hours value unchanged.\n\nGive me the complete code.\n"}, "clean_code": "module calendar(CLK,RST,Hours,Mins,Secs);\ninput CLK,RST;\noutput [5:0] Hours,Mins,Secs;\nreg [5:0] Hours,Mins,Secs;\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tSecs <= 0;\n\telse if (Secs == 59)\n\t\tSecs <= 0;\n\telse\n\t\tSecs <= Secs + 1;\nend\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tMins <= 0;\n\telse if((Mins==59)&&(Secs==59))\n\t\tMins <= 0;\n\telse if(Secs== 59)\n\t\tMins <= Mins + 1;\n\telse\n\t\tMins <= Mins;\nend\n\nalways@(posedge CLK or posedge RST) begin\n        if (RST)\n                Hours <= 0;\n        else if((Hours == 23)&&(Mins==59)&&(Secs==59))\n                Hours <= 0;\n        else if((Mins == 59)&&(Secs==59))\n                Hours <= Hours + 1;\n        else\n                Hours <= Hours;\nend\n\nendmodule", "corrupted_code": "module calendar(CLK,RST,Hours,Mins,Secs);\ninput CLK,RST;\noutput [5:0] Hours,Mins,Secs;\nreg [5:0] Hours,Mins,Secs;\n\nalways@(posedge CLK or posedge RST) begin\n\tif (!RST)\n\t\tSecs <= 0;\n\telse if (Secs == 59)\n\t\tSecs <= 0;\n\telse\n\t\tSecs <= Secs + 1;\nend\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tMins <= 0;\n\telse if((Mins==59)&&(Secs==59))\n\t\tMins <= 0;\n\telse if(Secs== 59)\n\t\tMins <= Mins + 1;\n\telse\n\t\tMins <= Mins;\nend\n\nalways@(posedge CLK or posedge RST) begin\n        if (RST)\n                Hours <= 0;\n        else if((Hours == 23)&&(Mins==59)&&(Secs==59))\n                Hours <= 0;\n        else if((Mins == 59)&&(Secs==59))\n                Hours <= Hours + 1;\n        else\n                Hours <= Hours;\nend\n\nendmodule", "corruption_explanation": "Inverted reset polarity in condition", "modification_type": "invert_reset_polarity", "modification_line": 7, "original_snippet": "if (RST)", "modified_snippet": "if (!RST)", "issue_description": "The buggy code has inverted reset polarity. If the design expects active-low reset (!rst), it now uses active-high, or vice versa. This causes the reset logic to activate during normal operation and deactivate during actual reset, breaking initialization.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_reset_polarity modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted reset polarity in condition\n   \u2022 Line 7: Original: if (RST)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 7.\n   \u2022 Restore the original code: if (RST)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert reset polarity.", "complexity": 26, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_reset_polarity"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.381138", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "edge_detect", "module_name": "edge_detect", "description": "Please act as a professional verilog designer.\n\nImplement a module for edge detection. There is a slowly changing 1-bit signal a. When \"a\" changes from 0 to 1, the indicating signal rise is 1. When \"a\" changes from 1 to 0, the falling edge of signal a is shown, the indicating signal down is 1. rise or down will be set to 1 on the next clock when the corresponding edge appears, and then return to 0 until the corresponding edge appears again.\n\nModule name:  \n    edge_detect      \n\nInput ports:\n    clk: Clock signal.\n    rst_n: Reset signal (active low).\n    a: Input signal.\n\nOutput ports:\n    rise: Output signal indicating a rising edge.\n    down: Output signal indicating a falling edge.\n\nImplementation:\nThe edge_detect module detects rising and falling edges in the input signal a and generates corresponding output signals rise and down. The rising and falling edges are detected on the positive edge of the clock signal clk. If a rising edge is detected, the rise output signal is set to 1. If a falling edge is detected, the down output signal is set to 1. Otherwise, both output signals are set to 0. These output signals are synchronized with the clock and remain set to 1 until the corresponding edge appears again.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule edge_detect(\n\tinput clk,\n\tinput rst_n,\n\tinput a,\n\t\n\toutput reg rise,\n\toutput reg down\n);\n\treg a0;\n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) begin\n            rise <= 1'b0;\n            down <= 1'b0;\n        end \n        else begin\n            if(a & ~a0) begin\n                rise <= 1;\n                down <= 0;\n            end \n            else if (~a & a0) begin\n                rise <= 0;\n                down <= 1;\n            end else begin\n                rise <= 0;\n                down <= 0;\n            end\n        end\n    end\n    \n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) \n            a0 <= 0;\n        else \n            a0 <= a;\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns/1ns\nmodule edge_detect(\n\tinput clk,\n\tinput rst_n,\n\tinput a,\n\t\n\toutput reg rise,\n\toutput reg down\n);\n\treg a0;\n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) begin\n            rise <= 1'b0;\n            down <= 1'b0;\n        end \n        else begin\n            if(a & ~a0) begin\n                rise <= 1;\n                down <= 0;\n            end \n            else if (~a & a0) begin\n                rise <= 0;\n                down <= 1;\n            end else begin\n                rise <= 0;\n                down <= 0;\n            end\n        end\n    end\n    \n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) \n             <= a;\n    end\nendmodule\n", "corruption_explanation": "Removed CDC synchronizer stage", "modification_type": "modify_cdc", "modification_line": 33, "original_snippet": "a0 <= 0;\n        else \n            a0", "modified_snippet": "(removed)", "issue_description": "The buggy code has a broken clock domain crossing synchronizer. A synchronizer flip-flop stage was removed, reducing metastability protection. This creates CDC violations that cause random data corruption in multi-clock domain designs.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a modify_cdc modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed CDC synchronizer stage\n   \u2022 Line 33: Original: a0 <= 0;\n        else \n            a0\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 33.\n   \u2022 Restore the original code: a0 <= 0;\n        else \n            a0\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to modify cdc.", "complexity": 17, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["modify_cdc"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.383711", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "edge_detect", "module_name": "edge_detect", "description": "Please act as a professional verilog designer.\n\nImplement a module for edge detection. There is a slowly changing 1-bit signal a. When \"a\" changes from 0 to 1, the indicating signal rise is 1. When \"a\" changes from 1 to 0, the falling edge of signal a is shown, the indicating signal down is 1. rise or down will be set to 1 on the next clock when the corresponding edge appears, and then return to 0 until the corresponding edge appears again.\n\nModule name:  \n    edge_detect      \n\nInput ports:\n    clk: Clock signal.\n    rst_n: Reset signal (active low).\n    a: Input signal.\n\nOutput ports:\n    rise: Output signal indicating a rising edge.\n    down: Output signal indicating a falling edge.\n\nImplementation:\nThe edge_detect module detects rising and falling edges in the input signal a and generates corresponding output signals rise and down. The rising and falling edges are detected on the positive edge of the clock signal clk. If a rising edge is detected, the rise output signal is set to 1. If a falling edge is detected, the down output signal is set to 1. Otherwise, both output signals are set to 0. These output signals are synchronized with the clock and remain set to 1 until the corresponding edge appears again.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule edge_detect(\n\tinput clk,\n\tinput rst_n,\n\tinput a,\n\t\n\toutput reg rise,\n\toutput reg down\n);\n\treg a0;\n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) begin\n            rise <= 1'b0;\n            down <= 1'b0;\n        end \n        else begin\n            if(a & ~a0) begin\n                rise <= 1;\n                down <= 0;\n            end \n            else if (~a & a0) begin\n                rise <= 0;\n                down <= 1;\n            end else begin\n                rise <= 0;\n                down <= 0;\n            end\n        end\n    end\n    \n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) \n            a0 <= 0;\n        else \n            a0 <= a;\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns/1ns\nmodule edge_detect(\n\tinput clk,\n\tinput rst_n,\n\tinput a,\n\t\n\toutput reg rise,\n\toutput reg down\n);\n\treg a0;\n    always@(posedge clk or posedge rst_n) begin\n        if(~rst_n) begin\n            rise <= 1'b0;\n            down <= 1'b0;\n        end \n        else begin\n            if(a & ~a0) begin\n                rise <= 1;\n                down <= 0;\n            end \n            else if (~a & a0) begin\n                rise <= 0;\n                down <= 1;\n            end else begin\n                rise <= 0;\n                down <= 0;\n            end\n        end\n    end\n    \n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) \n            a0 <= 0;\n        else \n            a0 <= a;\n    end\nendmodule\n", "corruption_explanation": "Inverted reset polarity in sensitivity", "modification_type": "invert_reset_polarity", "modification_line": 11, "original_snippet": "always@(posedge clk or negedge rst_n)", "modified_snippet": "always@(posedge clk or posedge rst_n)", "issue_description": "The buggy code has inverted reset polarity. If the design expects active-low reset (!rst), it now uses active-high, or vice versa. This causes the reset logic to activate during normal operation and deactivate during actual reset, breaking initialization.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_reset_polarity modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted reset polarity in sensitivity\n   \u2022 Line 11: Original: always@(posedge clk or negedge rst_n)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 11.\n   \u2022 Restore the original code: always@(posedge clk or negedge rst_n)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert reset polarity.", "complexity": 17, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_reset_polarity"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.384767", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "edge_detect", "module_name": "edge_detect", "description": "Please act as a professional verilog designer.\n\nImplement a module for edge detection. There is a slowly changing 1-bit signal a. When \"a\" changes from 0 to 1, the indicating signal rise is 1. When \"a\" changes from 1 to 0, the falling edge of signal a is shown, the indicating signal down is 1. rise or down will be set to 1 on the next clock when the corresponding edge appears, and then return to 0 until the corresponding edge appears again.\n\nModule name:  \n    edge_detect      \n\nInput ports:\n    clk: Clock signal.\n    rst_n: Reset signal (active low).\n    a: Input signal.\n\nOutput ports:\n    rise: Output signal indicating a rising edge.\n    down: Output signal indicating a falling edge.\n\nImplementation:\nThe edge_detect module detects rising and falling edges in the input signal a and generates corresponding output signals rise and down. The rising and falling edges are detected on the positive edge of the clock signal clk. If a rising edge is detected, the rise output signal is set to 1. If a falling edge is detected, the down output signal is set to 1. Otherwise, both output signals are set to 0. These output signals are synchronized with the clock and remain set to 1 until the corresponding edge appears again.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule edge_detect(\n\tinput clk,\n\tinput rst_n,\n\tinput a,\n\t\n\toutput reg rise,\n\toutput reg down\n);\n\treg a0;\n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) begin\n            rise <= 1'b0;\n            down <= 1'b0;\n        end \n        else begin\n            if(a & ~a0) begin\n                rise <= 1;\n                down <= 0;\n            end \n            else if (~a & a0) begin\n                rise <= 0;\n                down <= 1;\n            end else begin\n                rise <= 0;\n                down <= 0;\n            end\n        end\n    end\n    \n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) \n            a0 <= 0;\n        else \n            a0 <= a;\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns/1ns\nmodule edge_detect(\n\tinput clk,\n\tinput rst_n,\n\tinput a,\n\t\n\toutput reg rise,\n\toutput reg down\n);\n\treg a0;\n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) begin\n            rise <= 1'b0;\n            down <= 1'b0;\n        end \n        else begin\n            if(a & ~a0) begin\n                rise <= 1;\n                down <= 0;\n            end \n            else if (!(~a & a0)) begin\n                rise <= 0;\n                down <= 1;\n            end else begin\n                rise <= 0;\n                down <= 0;\n            end\n        end\n    end\n    \n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) \n            a0 <= 0;\n        else \n            a0 <= a;\n    end\nendmodule\n", "corruption_explanation": "Inverted condition: '~a & a0' -> '!(~a & a0)'", "modification_type": "invert_condition", "modification_line": 21, "original_snippet": "if (~a & a0) begin", "modified_snippet": "if (!(~a & a0)) begin", "issue_description": "The buggy code has an inverted condition in an if statement. Instead of checking if(x), it checks if(!x), causing the logic to execute when it shouldn't and skip execution when it should. All conditional behavior is reversed from intended functionality.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_condition modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted condition: '~a & a0' -> '!(~a & a0)'\n   \u2022 Line 21: Original: if (~a & a0) begin\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 21.\n   \u2022 Restore the original code: if (~a & a0) begin\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert condition.", "complexity": 17, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_condition"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.385782", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "edge_detect", "module_name": "edge_detect", "description": "Please act as a professional verilog designer.\n\nImplement a module for edge detection. There is a slowly changing 1-bit signal a. When \"a\" changes from 0 to 1, the indicating signal rise is 1. When \"a\" changes from 1 to 0, the falling edge of signal a is shown, the indicating signal down is 1. rise or down will be set to 1 on the next clock when the corresponding edge appears, and then return to 0 until the corresponding edge appears again.\n\nModule name:  \n    edge_detect      \n\nInput ports:\n    clk: Clock signal.\n    rst_n: Reset signal (active low).\n    a: Input signal.\n\nOutput ports:\n    rise: Output signal indicating a rising edge.\n    down: Output signal indicating a falling edge.\n\nImplementation:\nThe edge_detect module detects rising and falling edges in the input signal a and generates corresponding output signals rise and down. The rising and falling edges are detected on the positive edge of the clock signal clk. If a rising edge is detected, the rise output signal is set to 1. If a falling edge is detected, the down output signal is set to 1. Otherwise, both output signals are set to 0. These output signals are synchronized with the clock and remain set to 1 until the corresponding edge appears again.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule edge_detect(\n\tinput clk,\n\tinput rst_n,\n\tinput a,\n\t\n\toutput reg rise,\n\toutput reg down\n);\n\treg a0;\n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) begin\n            rise <= 1'b0;\n            down <= 1'b0;\n        end \n        else begin\n            if(a & ~a0) begin\n                rise <= 1;\n                down <= 0;\n            end \n            else if (~a & a0) begin\n                rise <= 0;\n                down <= 1;\n            end else begin\n                rise <= 0;\n                down <= 0;\n            end\n        end\n    end\n    \n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) \n            a0 <= 0;\n        else \n            a0 <= a;\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns/1ns\nmodule edge_detect(\n\tinput clk,\n\tinput rst_n,\n\tinput a,\n\t\n\toutput reg rise,\n\toutput reg down\n);\n\treg a0;\n     \n        else begin\n            if(a & ~a0) begin\n                rise <= 1;\n                down <= 0;\n            end \n            else if (~a & a0) begin\n                rise <= 0;\n                down <= 1;\n            end else begin\n                rise <= 0;\n                down <= 0;\n            end\n        end\n    end\n    \n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) \n            a0 <= 0;\n        else \n            a0 <= a;\n    end\nendmodule\n", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 11, "original_snippet": "always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) begin\n            rise <= 1'b0;\n            down <= 1'b0;\n        end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 11: Original: always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) begin\n            rise <= 1'b0;\n            down <= 1'b0;\n        end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 11.\n   \u2022 Restore the original code: always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) begin\n            rise <= 1'b0;\n            down <= 1'b0;\n        end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 17, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.386784", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "edge_detect", "module_name": "edge_detect", "description": "Please act as a professional verilog designer.\n\nImplement a module for edge detection. There is a slowly changing 1-bit signal a. When \"a\" changes from 0 to 1, the indicating signal rise is 1. When \"a\" changes from 1 to 0, the falling edge of signal a is shown, the indicating signal down is 1. rise or down will be set to 1 on the next clock when the corresponding edge appears, and then return to 0 until the corresponding edge appears again.\n\nModule name:  \n    edge_detect      \n\nInput ports:\n    clk: Clock signal.\n    rst_n: Reset signal (active low).\n    a: Input signal.\n\nOutput ports:\n    rise: Output signal indicating a rising edge.\n    down: Output signal indicating a falling edge.\n\nImplementation:\nThe edge_detect module detects rising and falling edges in the input signal a and generates corresponding output signals rise and down. The rising and falling edges are detected on the positive edge of the clock signal clk. If a rising edge is detected, the rise output signal is set to 1. If a falling edge is detected, the down output signal is set to 1. Otherwise, both output signals are set to 0. These output signals are synchronized with the clock and remain set to 1 until the corresponding edge appears again.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule edge_detect(\n\tinput clk,\n\tinput rst_n,\n\tinput a,\n\t\n\toutput reg rise,\n\toutput reg down\n);\n\treg a0;\n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) begin\n            rise <= 1'b0;\n            down <= 1'b0;\n        end \n        else begin\n            if(a & ~a0) begin\n                rise <= 1;\n                down <= 0;\n            end \n            else if (~a & a0) begin\n                rise <= 0;\n                down <= 1;\n            end else begin\n                rise <= 0;\n                down <= 0;\n            end\n        end\n    end\n    \n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) \n            a0 <= 0;\n        else \n            a0 <= a;\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns/1ns\nmodule edge_detect(\n\tinput clk,\n\tinput rst_n,\n\tinput a,\n\t\n\toutput reg rise,\n\toutput reg down\n);\n\treg a0;\n    always @(posedge clk) begin\n        if(~rst_n) begin\n            rise <= 1'b0;\n            down <= 1'b0;\n        end \n        else begin\n            if(a & ~a0) begin\n                rise <= 1;\n                down <= 0;\n            end \n            else if (~a & a0) begin\n                rise <= 0;\n                down <= 1;\n            end else begin\n                rise <= 0;\n                down <= 0;\n            end\n        end\n    end\n    \n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) \n            a0 <= 0;\n        else \n            a0 <= a;\n    end\nendmodule\n", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 11, "original_snippet": "always@(posedge clk or negedge rst_n)", "modified_snippet": "always @(posedge clk)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 11: Original: always@(posedge clk or negedge rst_n)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 11.\n   \u2022 Restore the original code: always@(posedge clk or negedge rst_n)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 17, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_sensitivity_list"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.388587", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "edge_detect", "module_name": "edge_detect", "description": "Please act as a professional verilog designer.\n\nImplement a module for edge detection. There is a slowly changing 1-bit signal a. When \"a\" changes from 0 to 1, the indicating signal rise is 1. When \"a\" changes from 1 to 0, the falling edge of signal a is shown, the indicating signal down is 1. rise or down will be set to 1 on the next clock when the corresponding edge appears, and then return to 0 until the corresponding edge appears again.\n\nModule name:  \n    edge_detect      \n\nInput ports:\n    clk: Clock signal.\n    rst_n: Reset signal (active low).\n    a: Input signal.\n\nOutput ports:\n    rise: Output signal indicating a rising edge.\n    down: Output signal indicating a falling edge.\n\nImplementation:\nThe edge_detect module detects rising and falling edges in the input signal a and generates corresponding output signals rise and down. The rising and falling edges are detected on the positive edge of the clock signal clk. If a rising edge is detected, the rise output signal is set to 1. If a falling edge is detected, the down output signal is set to 1. Otherwise, both output signals are set to 0. These output signals are synchronized with the clock and remain set to 1 until the corresponding edge appears again.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule edge_detect(\n\tinput clk,\n\tinput rst_n,\n\tinput a,\n\t\n\toutput reg rise,\n\toutput reg down\n);\n\treg a0;\n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) begin\n            rise <= 1'b0;\n            down <= 1'b0;\n        end \n        else begin\n            if(a & ~a0) begin\n                rise <= 1;\n                down <= 0;\n            end \n            else if (~a & a0) begin\n                rise <= 0;\n                down <= 1;\n            end else begin\n                rise <= 0;\n                down <= 0;\n            end\n        end\n    end\n    \n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) \n            a0 <= 0;\n        else \n            a0 <= a;\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns/1ns\nmodule edge_detect(\n\tinput clk,\n\tinput rst_n,\n\tinput a,\n\t\n\toutput reg rise,\n\toutput reg down\n);\n\treg a0;\n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) begin\n            rise <= 1'b0;\n            down <= 1'b0;\n        end \n        else begin\n            if(a & ~a0) begin\n                rise <= 1;\n                down <= 0;\n            end \n            else if (~a & a0) begin\n                rise <= 0;\n                down <= 1;\n            end else begin\n                rise <= 0;\n                down <= 0;\n            end\n        end\n    end\n    \n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) \n            a0 <= 0;\n        else \n            a0 <= a;\n    end\n\n    wire clk_dup;\n    assign clk_dup = clk;\nendmodule\n", "corruption_explanation": "Added duplicate clock signal clk_dup", "modification_type": "duplicate_clock_signal", "modification_line": 15, "original_snippet": "(none)", "modified_snippet": "wire clk_dup;\n    assign clk_dup = clk;", "issue_description": "The buggy code has a duplicate clock signal. A phantom clock domain is created, which may confuse CDC analysis tools and create subtle timing issues in synthesis. This violates clock domain design best practices.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a duplicate_clock_signal modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added duplicate clock signal clk_dup\n   \u2022 Line 15: Original: (none)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 15.\n   \u2022 Restore the original code: (none)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to duplicate clock signal.", "complexity": 17, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["duplicate_clock_signal"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.390250", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "edge_detect", "module_name": "edge_detect", "description": "Please act as a professional verilog designer.\n\nImplement a module for edge detection. There is a slowly changing 1-bit signal a. When \"a\" changes from 0 to 1, the indicating signal rise is 1. When \"a\" changes from 1 to 0, the falling edge of signal a is shown, the indicating signal down is 1. rise or down will be set to 1 on the next clock when the corresponding edge appears, and then return to 0 until the corresponding edge appears again.\n\nModule name:  \n    edge_detect      \n\nInput ports:\n    clk: Clock signal.\n    rst_n: Reset signal (active low).\n    a: Input signal.\n\nOutput ports:\n    rise: Output signal indicating a rising edge.\n    down: Output signal indicating a falling edge.\n\nImplementation:\nThe edge_detect module detects rising and falling edges in the input signal a and generates corresponding output signals rise and down. The rising and falling edges are detected on the positive edge of the clock signal clk. If a rising edge is detected, the rise output signal is set to 1. If a falling edge is detected, the down output signal is set to 1. Otherwise, both output signals are set to 0. These output signals are synchronized with the clock and remain set to 1 until the corresponding edge appears again.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule edge_detect(\n\tinput clk,\n\tinput rst_n,\n\tinput a,\n\t\n\toutput reg rise,\n\toutput reg down\n);\n\treg a0;\n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) begin\n            rise <= 1'b0;\n            down <= 1'b0;\n        end \n        else begin\n            if(a & ~a0) begin\n                rise <= 1;\n                down <= 0;\n            end \n            else if (~a & a0) begin\n                rise <= 0;\n                down <= 1;\n            end else begin\n                rise <= 0;\n                down <= 0;\n            end\n        end\n    end\n    \n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) \n            a0 <= 0;\n        else \n            a0 <= a;\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns/1ns\nmodule edge_detect(\n\tinput clk,\n\tinput rst_n,\n\tinput a,\n\t\n\toutput reg rise,\n\toutput reg down\n);\n\treg a0;\n    always@(posedge clk or negedge rst_n) begin\n        if(!(~rst_n)) begin\n            rise <= 1'b0;\n            down <= 1'b0;\n        end \n        else begin\n            if(a & ~a0) begin\n                rise <= 1;\n                down <= 0;\n            end \n            else if (~a & a0) begin\n                rise <= 0;\n                down <= 1;\n            end else begin\n                rise <= 0;\n                down <= 0;\n            end\n        end\n    end\n    \n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) \n            a0 <= 0;\n        else \n            a0 <= a;\n    end\nendmodule\n", "corruption_explanation": "Inverted condition: '~rst_n' -> '!(~rst_n)'", "modification_type": "invert_condition", "modification_line": 12, "original_snippet": "if(~rst_n) begin", "modified_snippet": "if(!(~rst_n)) begin", "issue_description": "The buggy code has an inverted condition in an if statement. Instead of checking if(x), it checks if(!x), causing the logic to execute when it shouldn't and skip execution when it should. All conditional behavior is reversed from intended functionality.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_condition modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted condition: '~rst_n' -> '!(~rst_n)'\n   \u2022 Line 12: Original: if(~rst_n) begin\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 12.\n   \u2022 Restore the original code: if(~rst_n) begin\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert condition.", "complexity": 17, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_condition"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.391219", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "edge_detect", "module_name": "edge_detect", "description": "Please act as a professional verilog designer.\n\nImplement a module for edge detection. There is a slowly changing 1-bit signal a. When \"a\" changes from 0 to 1, the indicating signal rise is 1. When \"a\" changes from 1 to 0, the falling edge of signal a is shown, the indicating signal down is 1. rise or down will be set to 1 on the next clock when the corresponding edge appears, and then return to 0 until the corresponding edge appears again.\n\nModule name:  \n    edge_detect      \n\nInput ports:\n    clk: Clock signal.\n    rst_n: Reset signal (active low).\n    a: Input signal.\n\nOutput ports:\n    rise: Output signal indicating a rising edge.\n    down: Output signal indicating a falling edge.\n\nImplementation:\nThe edge_detect module detects rising and falling edges in the input signal a and generates corresponding output signals rise and down. The rising and falling edges are detected on the positive edge of the clock signal clk. If a rising edge is detected, the rise output signal is set to 1. If a falling edge is detected, the down output signal is set to 1. Otherwise, both output signals are set to 0. These output signals are synchronized with the clock and remain set to 1 until the corresponding edge appears again.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule edge_detect(\n\tinput clk,\n\tinput rst_n,\n\tinput a,\n\t\n\toutput reg rise,\n\toutput reg down\n);\n\treg a0;\n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) begin\n            rise <= 1'b0;\n            down <= 1'b0;\n        end \n        else begin\n            if(a & ~a0) begin\n                rise <= 1;\n                down <= 0;\n            end \n            else if (~a & a0) begin\n                rise <= 0;\n                down <= 1;\n            end else begin\n                rise <= 0;\n                down <= 0;\n            end\n        end\n    end\n    \n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) \n            a0 <= 0;\n        else \n            a0 <= a;\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns/1ns\nmodule edge_detect(\n\tinput clk,\n\tinput rst_n,\n\tinput a,\n\t\n\toutput reg rise,\n\toutput reg down\n);\n\treg a0;\n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) begin\n            rise <= 1'b0;\n            down <= 1'b0;\n        end \n        else begin\n            if(a & ~a0) begin\n                rise <= 1;\n                down <= 0;\n            end \n            else if (~a & a0) begin\n                rise <= 0;\n                down <= 1;\n            end else begin\n                rise <= 0;\n                down <= 0;\n            end\n        end\n    end\n    \n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) \n            a0 <= 0;\n        else \n            a0 <= a;\n    end\n\n    wire clk_dup;\n    assign clk_dup = clk;\nendmodule\n", "corruption_explanation": "Added duplicate clock signal clk_dup", "modification_type": "duplicate_clock_signal", "modification_line": 15, "original_snippet": "(none)", "modified_snippet": "wire clk_dup;\n    assign clk_dup = clk;", "issue_description": "The buggy code has a duplicate clock signal. A phantom clock domain is created, which may confuse CDC analysis tools and create subtle timing issues in synthesis. This violates clock domain design best practices.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a duplicate_clock_signal modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added duplicate clock signal clk_dup\n   \u2022 Line 15: Original: (none)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 15.\n   \u2022 Restore the original code: (none)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to duplicate clock signal.", "complexity": 17, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["duplicate_clock_signal"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.392295", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "traffic_light", "module_name": "traffic_light", "description": "Please act as a professional verilog designer.\n\nImplement a traffic light, with red, yellow and green three small indicators and a pedestrian button, under normal circumstances, the motor vehicle lane indicator light according to 60 clock cycles of green, 5 clock cycles of yellow, 10 clock cycles of red. When the pedestrian button is pressed, if the remaining green time is greater than 10 clocks, it is shortened to 10 clocks, and if it is less than 10 clocks, it remains unchanged. The lane light and the sidewalk light should be paired, when the lane light is green or yellow, the sidewalk light is red; When the lane light is red, the sidewalk light is green, and for the sake of simplicity, only the lane light is considered.\n\nModule name:  \n    traffic_light\n\nInputs:\n    rst_n: Reset signal (active low).\n    clk: Clock signal.\n    pass_request: Request signal for allowing vehicles to pass.\n\nOutputs:\n    clock[7:0]: An 8-bit output representing the count value of the internal counter.\n    red, yellow, green: Output signals representing the state of the traffic lights.\n\nParameters:\n    idle, s1_red, s2_yellow, s3_green: Enumeration values representing different states of the traffic light controller.\n\nRegisters and Wires:\n    cnt: A 8-bit register used as an internal counter for timing purposes.\n    state: A 2-bit register representing the current state of the traffic light controller.\n    p_red, p_yellow, p_green: 1-bit registers representing the next values for the red, yellow, and green signals.\n\nImplementation:\nThe following is the design track we recommend:\nThe first always block is responsible for the state transition logic. It uses a case statement to handle different states. Here's a summary of each state:\nidle: Initial state where all signals are set to 0. Transition to s1_red state occurs immediately.\ns1_red: Sets the red signal to 1 and waits for a count of 3 before transitioning to s3_green state. Otherwise, it remains in s1_red state.\ns2_yellow: Sets the yellow signal to 1 and waits for a count of 3 before transitioning to s1_red state. Otherwise, it remains in s2_yellow state.\ns3_green: Sets the green signal to 1 and waits for a count of 3 before transitioning to s2_yellow state. Otherwise, it remains in s3_green state.\nThe second always block handles the counting logic of the internal counter (cnt). The counter is decremented by 1 on every positive edge of the clock or negative edge of the reset signal. The counter values are adjusted based on various conditions:\nIf (!rst_n), the counter is set to 10.\nIf the pass_request signal is active and the green signal is active, the counter is set to 10.\nIf the green signal is inactive and the previous green signal (p_green) was active, the counter is set to 60.\nIf the yellow signal is inactive and the previous yellow signal (p_yellow) was active, the counter is set to 5.\nIf the red signal is inactive and the previous red signal (p_red) was active, the counter is set to 10.\nOtherwise, the counter is decremented normally.\nThe assign statement assigns the value of the internal counter (cnt) to the output clock.\nThe final always block handles the output signals. It assigns the previous values (p_red, p_yellow, p_green) to the output signals (red, yellow, green) on the positive edge of the clock or negative edge of the reset signal.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\nmodule traffic_light\n    (\n\t\tinput rst_n, \n      input clk, \n      input pass_request,\n\t\t  output wire[7:0]clock,\n      output reg red,\n\t\t  output reg yellow,\n\t\t  output reg green\n    );\n\t\n\tparameter \tidle = 2'd0,\n\t\t\t\ts1_red = 2'd1,\n\t\t\t\ts2_yellow = 2'd2,\n\t\t\t\ts3_green = 2'd3;\n\treg [7:0] cnt;\n\treg [1:0] state;\n\treg p_red,p_yellow,p_green;\t\n\n\nalways @(posedge clk or negedge rst_n) \n    begin\n        if(!rst_n)\n        begin\n\t\t\tstate <= idle;\n\t\t\tp_red <= 1'b0;\n\t\t\tp_green <= 1'b0;\n\t\t\tp_yellow <= 1'b0;\t\t\t\n        end\n        else case(state)\n\t\tidle:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts1_red:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b1;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s3_green;\n\t\t\t\telse\n\t\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts2_yellow:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b1;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s1_red;\n\t\t\t\telse\n\t\t\t\t\tstate <= s2_yellow;\n\t\t\tend\n\t\ts3_green:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b1;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s2_yellow;\n\t\t\t\telse\n\t\t\t\t\tstate <= s3_green;\n\t\t\tend\n\t\tendcase\n\tend\n \nalways @(posedge clk or negedge rst_n) \n      if(!rst_n)\n\t\t\tcnt <= 7'd10;\n\t\telse if (pass_request&&green&&(cnt>10))\n\t\t\tcnt <= 7'd10;\n\t\telse if (!green&&p_green)\n\t\t\tcnt <= 7'd60;\n\t\telse if (!yellow&&p_yellow)\n\t\t\tcnt <= 7'd5;\n\t\telse if (!red&&p_red)\n\t\t\tcnt <= 7'd10;\t\n\t\telse cnt <= cnt -1;\n assign clock = cnt;\n\nalways @(posedge clk or negedge rst_n) \n        if(!rst_n)\n\t\t\tbegin\n\t\t\t\tyellow <= 1'd0;\n\t\t\t\tred <= 1'd0;\n\t\t\t\tgreen <= 1'd0;\n\t\t\tend\n\t\telse \n\t\t\tbegin\n\t\t\t\tyellow <= p_yellow;\n\t\t\t\tred <= p_red;\n\t\t\t\tgreen <= p_green;\n\t\t\tend\t\t\n\nendmodule\n", "corrupted_code": "`timescale 1ns/1ns\n\nmodule traffic_light\n    (\n\t\tinput rst_n, \n      input clk, \n      input pass_request,\n\t\t  output wire[7:0]clock,\n      output reg red,\n\t\t  output reg yellow,\n\t\t  output reg green\n    );\n\t\n\tparameter \tidle = 2'd0,\n\t\t\t\ts1_red = 2'd1,\n\t\t\t\ts2_yellow = 2'd2,\n\t\t\t\ts3_green = 2'd3;\n\treg [7:0] cnt;\n\treg [1:0] state;\n\treg p_red,p_yellow,p_green;\t\n\n\nalways @(posedge clk or negedge rst_n) \n    begin\n        if(!rst_n)\n        begin\n\t\t\tstate <= idle;\n\t\t\tp_red <= 1'b0;\n\t\t\tp_green <= 1'b0;\n\t\t\tp_yellow <= 1'b0;\t\t\t\n        end\n        else case(state)\n\t\tidle:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts1_red:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b1;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s3_green;\n\t\t\t\telse\n\t\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts2_yellow:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b1;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s1_red;\n\t\t\t\telse\n\t\t\t\t\tstate <= s2_yellow;\n\t\t\tend\n\t\ts3_green:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b1;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s2_yellow;\n\t\t\t\telse\n\t\t\t\t\tstate <= s3_green;\n\t\t\tend\n\t\tendcase\n\tend\n \nalways @(posedge clk or negedge rst_n) \n      if(!rst_n)\n\t\t\tcnt <= 7'd10;\n\t\telse if (pass_request&&green&&(cnt>10))\n\t\t\tcnt <= 7'd10;\n\t\telse if (!green&&p_green)\n\t\t\tcnt <= 7'd60;\n\t\telse if (!yellow&&p_yellow)\n\t\t\tcnt <= 7'd5;\n\t\telse if (!red&&p_red)\n\t\t\tcnt <= 7'd10;\t\n\t\telse cnt <= cnt -1;\n assign clock = cnt;\n\nalways @(posedge clk or negedge rst_n) \n        if(!rst_n)\n\t\t\tbegin\n\t\t\t\tyellow <= 1'd0;\n\t\t\t\tred <= 1'd0;\n\t\t\t\tgreen <= 1'd0;\n\t\t\tend\n\t\telse \n\t\t\tbegin\n\t\t\t\tyellow <= p_yellow;\n\t\t\t\tred = p_red;\n\t\t\t\tgreen <= p_green;\n\t\t\tend\t\t\n\nendmodule\n", "corruption_explanation": "Changed non-blocking (<=) to blocking (=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 97, "original_snippet": "red <= p_red;", "modified_snippet": "red = p_red;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 49, "applicable_modifications": ["invert_if_else", "remove_else_branch", "remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.399959", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "traffic_light", "module_name": "traffic_light", "description": "Please act as a professional verilog designer.\n\nImplement a traffic light, with red, yellow and green three small indicators and a pedestrian button, under normal circumstances, the motor vehicle lane indicator light according to 60 clock cycles of green, 5 clock cycles of yellow, 10 clock cycles of red. When the pedestrian button is pressed, if the remaining green time is greater than 10 clocks, it is shortened to 10 clocks, and if it is less than 10 clocks, it remains unchanged. The lane light and the sidewalk light should be paired, when the lane light is green or yellow, the sidewalk light is red; When the lane light is red, the sidewalk light is green, and for the sake of simplicity, only the lane light is considered.\n\nModule name:  \n    traffic_light\n\nInputs:\n    rst_n: Reset signal (active low).\n    clk: Clock signal.\n    pass_request: Request signal for allowing vehicles to pass.\n\nOutputs:\n    clock[7:0]: An 8-bit output representing the count value of the internal counter.\n    red, yellow, green: Output signals representing the state of the traffic lights.\n\nParameters:\n    idle, s1_red, s2_yellow, s3_green: Enumeration values representing different states of the traffic light controller.\n\nRegisters and Wires:\n    cnt: A 8-bit register used as an internal counter for timing purposes.\n    state: A 2-bit register representing the current state of the traffic light controller.\n    p_red, p_yellow, p_green: 1-bit registers representing the next values for the red, yellow, and green signals.\n\nImplementation:\nThe following is the design track we recommend:\nThe first always block is responsible for the state transition logic. It uses a case statement to handle different states. Here's a summary of each state:\nidle: Initial state where all signals are set to 0. Transition to s1_red state occurs immediately.\ns1_red: Sets the red signal to 1 and waits for a count of 3 before transitioning to s3_green state. Otherwise, it remains in s1_red state.\ns2_yellow: Sets the yellow signal to 1 and waits for a count of 3 before transitioning to s1_red state. Otherwise, it remains in s2_yellow state.\ns3_green: Sets the green signal to 1 and waits for a count of 3 before transitioning to s2_yellow state. Otherwise, it remains in s3_green state.\nThe second always block handles the counting logic of the internal counter (cnt). The counter is decremented by 1 on every positive edge of the clock or negative edge of the reset signal. The counter values are adjusted based on various conditions:\nIf (!rst_n), the counter is set to 10.\nIf the pass_request signal is active and the green signal is active, the counter is set to 10.\nIf the green signal is inactive and the previous green signal (p_green) was active, the counter is set to 60.\nIf the yellow signal is inactive and the previous yellow signal (p_yellow) was active, the counter is set to 5.\nIf the red signal is inactive and the previous red signal (p_red) was active, the counter is set to 10.\nOtherwise, the counter is decremented normally.\nThe assign statement assigns the value of the internal counter (cnt) to the output clock.\nThe final always block handles the output signals. It assigns the previous values (p_red, p_yellow, p_green) to the output signals (red, yellow, green) on the positive edge of the clock or negative edge of the reset signal.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\nmodule traffic_light\n    (\n\t\tinput rst_n, \n      input clk, \n      input pass_request,\n\t\t  output wire[7:0]clock,\n      output reg red,\n\t\t  output reg yellow,\n\t\t  output reg green\n    );\n\t\n\tparameter \tidle = 2'd0,\n\t\t\t\ts1_red = 2'd1,\n\t\t\t\ts2_yellow = 2'd2,\n\t\t\t\ts3_green = 2'd3;\n\treg [7:0] cnt;\n\treg [1:0] state;\n\treg p_red,p_yellow,p_green;\t\n\n\nalways @(posedge clk or negedge rst_n) \n    begin\n        if(!rst_n)\n        begin\n\t\t\tstate <= idle;\n\t\t\tp_red <= 1'b0;\n\t\t\tp_green <= 1'b0;\n\t\t\tp_yellow <= 1'b0;\t\t\t\n        end\n        else case(state)\n\t\tidle:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts1_red:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b1;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s3_green;\n\t\t\t\telse\n\t\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts2_yellow:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b1;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s1_red;\n\t\t\t\telse\n\t\t\t\t\tstate <= s2_yellow;\n\t\t\tend\n\t\ts3_green:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b1;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s2_yellow;\n\t\t\t\telse\n\t\t\t\t\tstate <= s3_green;\n\t\t\tend\n\t\tendcase\n\tend\n \nalways @(posedge clk or negedge rst_n) \n      if(!rst_n)\n\t\t\tcnt <= 7'd10;\n\t\telse if (pass_request&&green&&(cnt>10))\n\t\t\tcnt <= 7'd10;\n\t\telse if (!green&&p_green)\n\t\t\tcnt <= 7'd60;\n\t\telse if (!yellow&&p_yellow)\n\t\t\tcnt <= 7'd5;\n\t\telse if (!red&&p_red)\n\t\t\tcnt <= 7'd10;\t\n\t\telse cnt <= cnt -1;\n assign clock = cnt;\n\nalways @(posedge clk or negedge rst_n) \n        if(!rst_n)\n\t\t\tbegin\n\t\t\t\tyellow <= 1'd0;\n\t\t\t\tred <= 1'd0;\n\t\t\t\tgreen <= 1'd0;\n\t\t\tend\n\t\telse \n\t\t\tbegin\n\t\t\t\tyellow <= p_yellow;\n\t\t\t\tred <= p_red;\n\t\t\t\tgreen <= p_green;\n\t\t\tend\t\t\n\nendmodule\n", "corrupted_code": "`timescale 1ns/1ns\n\nmodule traffic_light\n    (\n\t\tinput rst_n, \n      input clk, \n      input pass_request,\n\t\t  output wire[7:0]clock,\n      output reg red,\n\t\t  output reg yellow,\n\t\t  output reg green\n    );\n\t\n\tparameter \tidle = 2'd0,\n\t\t\t\ts1_red = 2'd1,\n\t\t\t\ts2_yellow = 2'd2,\n\t\t\t\ts3_green = 2'd3;\n\treg [7:0] cnt;\n\treg [1:0] state;\n\treg p_red,p_yellow,p_green;\t\n\n\nalways @(posedge clk or negedge rst_n) \n    begin\n        if(rst_n)\n        begin\n\t\t\tstate <= idle;\n\t\t\tp_red <= 1'b0;\n\t\t\tp_green <= 1'b0;\n\t\t\tp_yellow <= 1'b0;\t\t\t\n        end\n        else case(state)\n\t\tidle:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts1_red:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b1;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s3_green;\n\t\t\t\telse\n\t\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts2_yellow:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b1;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s1_red;\n\t\t\t\telse\n\t\t\t\t\tstate <= s2_yellow;\n\t\t\tend\n\t\ts3_green:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b1;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s2_yellow;\n\t\t\t\telse\n\t\t\t\t\tstate <= s3_green;\n\t\t\tend\n\t\tendcase\n\tend\n \nalways @(posedge clk or negedge rst_n) \n      if(!rst_n)\n\t\t\tcnt <= 7'd10;\n\t\telse if (pass_request&&green&&(cnt>10))\n\t\t\tcnt <= 7'd10;\n\t\telse if (!green&&p_green)\n\t\t\tcnt <= 7'd60;\n\t\telse if (!yellow&&p_yellow)\n\t\t\tcnt <= 7'd5;\n\t\telse if (!red&&p_red)\n\t\t\tcnt <= 7'd10;\t\n\t\telse cnt <= cnt -1;\n assign clock = cnt;\n\nalways @(posedge clk or negedge rst_n) \n        if(!rst_n)\n\t\t\tbegin\n\t\t\t\tyellow <= 1'd0;\n\t\t\t\tred <= 1'd0;\n\t\t\t\tgreen <= 1'd0;\n\t\t\tend\n\t\telse \n\t\t\tbegin\n\t\t\t\tyellow <= p_yellow;\n\t\t\t\tred <= p_red;\n\t\t\t\tgreen <= p_green;\n\t\t\tend\t\t\n\nendmodule\n", "corruption_explanation": "Inverted condition: '!rst_n' -> 'rst_n'", "modification_type": "invert_condition", "modification_line": 25, "original_snippet": "if(!rst_n)\n        begin", "modified_snippet": "if(rst_n)\n        begin", "issue_description": "The buggy code has an inverted condition in an if statement. Instead of checking if(x), it checks if(!x), causing the logic to execute when it shouldn't and skip execution when it should. All conditional behavior is reversed from intended functionality.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_condition modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted condition: '!rst_n' -> 'rst_n'\n   \u2022 Line 25: Original: if(!rst_n)\n        begin\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 25.\n   \u2022 Restore the original code: if(!rst_n)\n        begin\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert condition.", "complexity": 49, "applicable_modifications": ["invert_if_else", "remove_else_branch", "remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_condition"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.401894", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "traffic_light", "module_name": "traffic_light", "description": "Please act as a professional verilog designer.\n\nImplement a traffic light, with red, yellow and green three small indicators and a pedestrian button, under normal circumstances, the motor vehicle lane indicator light according to 60 clock cycles of green, 5 clock cycles of yellow, 10 clock cycles of red. When the pedestrian button is pressed, if the remaining green time is greater than 10 clocks, it is shortened to 10 clocks, and if it is less than 10 clocks, it remains unchanged. The lane light and the sidewalk light should be paired, when the lane light is green or yellow, the sidewalk light is red; When the lane light is red, the sidewalk light is green, and for the sake of simplicity, only the lane light is considered.\n\nModule name:  \n    traffic_light\n\nInputs:\n    rst_n: Reset signal (active low).\n    clk: Clock signal.\n    pass_request: Request signal for allowing vehicles to pass.\n\nOutputs:\n    clock[7:0]: An 8-bit output representing the count value of the internal counter.\n    red, yellow, green: Output signals representing the state of the traffic lights.\n\nParameters:\n    idle, s1_red, s2_yellow, s3_green: Enumeration values representing different states of the traffic light controller.\n\nRegisters and Wires:\n    cnt: A 8-bit register used as an internal counter for timing purposes.\n    state: A 2-bit register representing the current state of the traffic light controller.\n    p_red, p_yellow, p_green: 1-bit registers representing the next values for the red, yellow, and green signals.\n\nImplementation:\nThe following is the design track we recommend:\nThe first always block is responsible for the state transition logic. It uses a case statement to handle different states. Here's a summary of each state:\nidle: Initial state where all signals are set to 0. Transition to s1_red state occurs immediately.\ns1_red: Sets the red signal to 1 and waits for a count of 3 before transitioning to s3_green state. Otherwise, it remains in s1_red state.\ns2_yellow: Sets the yellow signal to 1 and waits for a count of 3 before transitioning to s1_red state. Otherwise, it remains in s2_yellow state.\ns3_green: Sets the green signal to 1 and waits for a count of 3 before transitioning to s2_yellow state. Otherwise, it remains in s3_green state.\nThe second always block handles the counting logic of the internal counter (cnt). The counter is decremented by 1 on every positive edge of the clock or negative edge of the reset signal. The counter values are adjusted based on various conditions:\nIf (!rst_n), the counter is set to 10.\nIf the pass_request signal is active and the green signal is active, the counter is set to 10.\nIf the green signal is inactive and the previous green signal (p_green) was active, the counter is set to 60.\nIf the yellow signal is inactive and the previous yellow signal (p_yellow) was active, the counter is set to 5.\nIf the red signal is inactive and the previous red signal (p_red) was active, the counter is set to 10.\nOtherwise, the counter is decremented normally.\nThe assign statement assigns the value of the internal counter (cnt) to the output clock.\nThe final always block handles the output signals. It assigns the previous values (p_red, p_yellow, p_green) to the output signals (red, yellow, green) on the positive edge of the clock or negative edge of the reset signal.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\nmodule traffic_light\n    (\n\t\tinput rst_n, \n      input clk, \n      input pass_request,\n\t\t  output wire[7:0]clock,\n      output reg red,\n\t\t  output reg yellow,\n\t\t  output reg green\n    );\n\t\n\tparameter \tidle = 2'd0,\n\t\t\t\ts1_red = 2'd1,\n\t\t\t\ts2_yellow = 2'd2,\n\t\t\t\ts3_green = 2'd3;\n\treg [7:0] cnt;\n\treg [1:0] state;\n\treg p_red,p_yellow,p_green;\t\n\n\nalways @(posedge clk or negedge rst_n) \n    begin\n        if(!rst_n)\n        begin\n\t\t\tstate <= idle;\n\t\t\tp_red <= 1'b0;\n\t\t\tp_green <= 1'b0;\n\t\t\tp_yellow <= 1'b0;\t\t\t\n        end\n        else case(state)\n\t\tidle:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts1_red:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b1;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s3_green;\n\t\t\t\telse\n\t\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts2_yellow:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b1;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s1_red;\n\t\t\t\telse\n\t\t\t\t\tstate <= s2_yellow;\n\t\t\tend\n\t\ts3_green:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b1;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s2_yellow;\n\t\t\t\telse\n\t\t\t\t\tstate <= s3_green;\n\t\t\tend\n\t\tendcase\n\tend\n \nalways @(posedge clk or negedge rst_n) \n      if(!rst_n)\n\t\t\tcnt <= 7'd10;\n\t\telse if (pass_request&&green&&(cnt>10))\n\t\t\tcnt <= 7'd10;\n\t\telse if (!green&&p_green)\n\t\t\tcnt <= 7'd60;\n\t\telse if (!yellow&&p_yellow)\n\t\t\tcnt <= 7'd5;\n\t\telse if (!red&&p_red)\n\t\t\tcnt <= 7'd10;\t\n\t\telse cnt <= cnt -1;\n assign clock = cnt;\n\nalways @(posedge clk or negedge rst_n) \n        if(!rst_n)\n\t\t\tbegin\n\t\t\t\tyellow <= 1'd0;\n\t\t\t\tred <= 1'd0;\n\t\t\t\tgreen <= 1'd0;\n\t\t\tend\n\t\telse \n\t\t\tbegin\n\t\t\t\tyellow <= p_yellow;\n\t\t\t\tred <= p_red;\n\t\t\t\tgreen <= p_green;\n\t\t\tend\t\t\n\nendmodule\n", "corrupted_code": "`timescale 1ns/1ns\n\nmodule traffic_light\n    (\n\t\tinput rst_n, \n      input clk, \n      input pass_request,\n\t\t  output wire[7:0]clock,\n      output reg red,\n\t\t  output reg yellow,\n\t\t  output reg green\n    );\n\t\n\tparameter \tidle = 2'd0,\n\t\t\t\ts1_red = 2'd1,\n\t\t\t\ts2_yellow = 2'd2,\n\t\t\t\ts3_green = 2'd3;\n\treg [7:0] cnt;\n\treg [1:0] state;\n\treg p_red,p_yellow,p_green;\t\n\n\nalways @(posedge clk or negedge rst_n) \n    begin\n        if(!rst_n)\n        begin\n\t\t\tstate <= idle;\n\t\t\tp_red <= 1'b0;\n\t\t\tp_green <= 1'b0;\n\t\t\tp_yellow <= 1'b0;\t\t\t\n        end\n        else case(state)\n\t\tidle:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts1_red:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b1;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s3_green;\n\t\t\t\telse\n\t\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts2_yellow:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b1;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s1_red;\n\t\t\t\telse\n\t\t\t\t\tstate <= s2_yellow;\n\t\t\tend\n\t\ts3_green:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b1;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate >= s2_yellow;\n\t\t\t\telse\n\t\t\t\t\tstate <= s3_green;\n\t\t\tend\n\t\tendcase\n\tend\n \nalways @(posedge clk or negedge rst_n) \n      if(!rst_n)\n\t\t\tcnt <= 7'd10;\n\t\telse if (pass_request&&green&&(cnt>10))\n\t\t\tcnt <= 7'd10;\n\t\telse if (!green&&p_green)\n\t\t\tcnt <= 7'd60;\n\t\telse if (!yellow&&p_yellow)\n\t\t\tcnt <= 7'd5;\n\t\telse if (!red&&p_red)\n\t\t\tcnt <= 7'd10;\t\n\t\telse cnt <= cnt -1;\n assign clock = cnt;\n\nalways @(posedge clk or negedge rst_n) \n        if(!rst_n)\n\t\t\tbegin\n\t\t\t\tyellow <= 1'd0;\n\t\t\t\tred <= 1'd0;\n\t\t\t\tgreen <= 1'd0;\n\t\t\tend\n\t\telse \n\t\t\tbegin\n\t\t\t\tyellow <= p_yellow;\n\t\t\t\tred <= p_red;\n\t\t\t\tgreen <= p_green;\n\t\t\tend\t\t\n\nendmodule\n", "corruption_explanation": "Changed operator from '<=' to '>='", "modification_type": "change_operator", "modification_line": 66, "original_snippet": "e <= s", "modified_snippet": "e >= s", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '<=' to '>='\n   \u2022 Line 66: Original: e <= s\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 66.\n   \u2022 Restore the original code: e <= s\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 49, "applicable_modifications": ["invert_if_else", "remove_else_branch", "remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.404024", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "traffic_light", "module_name": "traffic_light", "description": "Please act as a professional verilog designer.\n\nImplement a traffic light, with red, yellow and green three small indicators and a pedestrian button, under normal circumstances, the motor vehicle lane indicator light according to 60 clock cycles of green, 5 clock cycles of yellow, 10 clock cycles of red. When the pedestrian button is pressed, if the remaining green time is greater than 10 clocks, it is shortened to 10 clocks, and if it is less than 10 clocks, it remains unchanged. The lane light and the sidewalk light should be paired, when the lane light is green or yellow, the sidewalk light is red; When the lane light is red, the sidewalk light is green, and for the sake of simplicity, only the lane light is considered.\n\nModule name:  \n    traffic_light\n\nInputs:\n    rst_n: Reset signal (active low).\n    clk: Clock signal.\n    pass_request: Request signal for allowing vehicles to pass.\n\nOutputs:\n    clock[7:0]: An 8-bit output representing the count value of the internal counter.\n    red, yellow, green: Output signals representing the state of the traffic lights.\n\nParameters:\n    idle, s1_red, s2_yellow, s3_green: Enumeration values representing different states of the traffic light controller.\n\nRegisters and Wires:\n    cnt: A 8-bit register used as an internal counter for timing purposes.\n    state: A 2-bit register representing the current state of the traffic light controller.\n    p_red, p_yellow, p_green: 1-bit registers representing the next values for the red, yellow, and green signals.\n\nImplementation:\nThe following is the design track we recommend:\nThe first always block is responsible for the state transition logic. It uses a case statement to handle different states. Here's a summary of each state:\nidle: Initial state where all signals are set to 0. Transition to s1_red state occurs immediately.\ns1_red: Sets the red signal to 1 and waits for a count of 3 before transitioning to s3_green state. Otherwise, it remains in s1_red state.\ns2_yellow: Sets the yellow signal to 1 and waits for a count of 3 before transitioning to s1_red state. Otherwise, it remains in s2_yellow state.\ns3_green: Sets the green signal to 1 and waits for a count of 3 before transitioning to s2_yellow state. Otherwise, it remains in s3_green state.\nThe second always block handles the counting logic of the internal counter (cnt). The counter is decremented by 1 on every positive edge of the clock or negative edge of the reset signal. The counter values are adjusted based on various conditions:\nIf (!rst_n), the counter is set to 10.\nIf the pass_request signal is active and the green signal is active, the counter is set to 10.\nIf the green signal is inactive and the previous green signal (p_green) was active, the counter is set to 60.\nIf the yellow signal is inactive and the previous yellow signal (p_yellow) was active, the counter is set to 5.\nIf the red signal is inactive and the previous red signal (p_red) was active, the counter is set to 10.\nOtherwise, the counter is decremented normally.\nThe assign statement assigns the value of the internal counter (cnt) to the output clock.\nThe final always block handles the output signals. It assigns the previous values (p_red, p_yellow, p_green) to the output signals (red, yellow, green) on the positive edge of the clock or negative edge of the reset signal.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\nmodule traffic_light\n    (\n\t\tinput rst_n, \n      input clk, \n      input pass_request,\n\t\t  output wire[7:0]clock,\n      output reg red,\n\t\t  output reg yellow,\n\t\t  output reg green\n    );\n\t\n\tparameter \tidle = 2'd0,\n\t\t\t\ts1_red = 2'd1,\n\t\t\t\ts2_yellow = 2'd2,\n\t\t\t\ts3_green = 2'd3;\n\treg [7:0] cnt;\n\treg [1:0] state;\n\treg p_red,p_yellow,p_green;\t\n\n\nalways @(posedge clk or negedge rst_n) \n    begin\n        if(!rst_n)\n        begin\n\t\t\tstate <= idle;\n\t\t\tp_red <= 1'b0;\n\t\t\tp_green <= 1'b0;\n\t\t\tp_yellow <= 1'b0;\t\t\t\n        end\n        else case(state)\n\t\tidle:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts1_red:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b1;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s3_green;\n\t\t\t\telse\n\t\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts2_yellow:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b1;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s1_red;\n\t\t\t\telse\n\t\t\t\t\tstate <= s2_yellow;\n\t\t\tend\n\t\ts3_green:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b1;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s2_yellow;\n\t\t\t\telse\n\t\t\t\t\tstate <= s3_green;\n\t\t\tend\n\t\tendcase\n\tend\n \nalways @(posedge clk or negedge rst_n) \n      if(!rst_n)\n\t\t\tcnt <= 7'd10;\n\t\telse if (pass_request&&green&&(cnt>10))\n\t\t\tcnt <= 7'd10;\n\t\telse if (!green&&p_green)\n\t\t\tcnt <= 7'd60;\n\t\telse if (!yellow&&p_yellow)\n\t\t\tcnt <= 7'd5;\n\t\telse if (!red&&p_red)\n\t\t\tcnt <= 7'd10;\t\n\t\telse cnt <= cnt -1;\n assign clock = cnt;\n\nalways @(posedge clk or negedge rst_n) \n        if(!rst_n)\n\t\t\tbegin\n\t\t\t\tyellow <= 1'd0;\n\t\t\t\tred <= 1'd0;\n\t\t\t\tgreen <= 1'd0;\n\t\t\tend\n\t\telse \n\t\t\tbegin\n\t\t\t\tyellow <= p_yellow;\n\t\t\t\tred <= p_red;\n\t\t\t\tgreen <= p_green;\n\t\t\tend\t\t\n\nendmodule\n", "corrupted_code": "`timescale 1ns/1ns\n\nmodule traffic_light\n    (\n\t\tinput rst_n, \n      input clk, \n      input pass_request,\n\t\t  output wire[7:0]clock,\n      output reg red,\n\t\t  output reg yellow,\n\t\t  output reg green\n    );\n\t\n\tparameter \tidle = 2'd0,\n\t\t\t\ts1_red = 2'd1,\n\t\t\t\ts2_yellow = 2'd2,\n\t\t\t\ts3_green = 2'd3;\n\treg [7:0] cnt;\n\treg [1:0] state;\n\treg p_red,p_yellow,p_green;\t\n\n\nalways @(posedge clk or negedge rst_n) \n    begin\n        if(!rst_n)\n        begin\n\t\t\tstate <= idle;\n\t\t\tp_red <= 1'b0;\n\t\t\tp_green <= 1'b0;\n\t\t\tp_yellow <= 1'b0;\t\t\t\n        end\n        else case(state)\n\t\tidle:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts1_red:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b1;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s3_green;\n\t\t\t\telse\n\t\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts2_yellow:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b1;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s1_red;\n\t\t\t\telse\n\t\t\t\t\tstate <= s2_yellow;\n\t\t\tend\n\t\ts3_green:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b1;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s2_yellow;\n\t\t\t\telse\n\t\t\t\t\tstate <= s3_green;\n\t\t\tend\n\t\tendcase\n\tend\n \nalways @(posedge clk) \n      if(!rst_n)\n\t\t\tcnt <= 7'd10;\n\t\telse if (pass_request&&green&&(cnt>10))\n\t\t\tcnt <= 7'd10;\n\t\telse if (!green&&p_green)\n\t\t\tcnt <= 7'd60;\n\t\telse if (!yellow&&p_yellow)\n\t\t\tcnt <= 7'd5;\n\t\telse if (!red&&p_red)\n\t\t\tcnt <= 7'd10;\t\n\t\telse cnt <= cnt -1;\n assign clock = cnt;\n\nalways @(posedge clk or negedge rst_n) \n        if(!rst_n)\n\t\t\tbegin\n\t\t\t\tyellow <= 1'd0;\n\t\t\t\tred <= 1'd0;\n\t\t\t\tgreen <= 1'd0;\n\t\t\tend\n\t\telse \n\t\t\tbegin\n\t\t\t\tyellow <= p_yellow;\n\t\t\t\tred <= p_red;\n\t\t\t\tgreen <= p_green;\n\t\t\tend\t\t\n\nendmodule\n", "corruption_explanation": "Removed async reset from sensitivity list", "modification_type": "remove_async_reset", "modification_line": 73, "original_snippet": "always @(posedge clk or negedge rst_n)", "modified_snippet": "always @(posedge clk)", "issue_description": "The buggy code has removed async reset from the sensitivity list. The always block only triggers on clock edges, not reset. This causes metastability on power-up and removes the ability to asynchronously reset the design.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_async_reset modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed async reset from sensitivity list\n   \u2022 Line 73: Original: always @(posedge clk or negedge rst_n)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 73.\n   \u2022 Restore the original code: always @(posedge clk or negedge rst_n)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove async reset.", "complexity": 49, "applicable_modifications": ["invert_if_else", "remove_else_branch", "remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_async_reset"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.405556", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "traffic_light", "module_name": "traffic_light", "description": "Please act as a professional verilog designer.\n\nImplement a traffic light, with red, yellow and green three small indicators and a pedestrian button, under normal circumstances, the motor vehicle lane indicator light according to 60 clock cycles of green, 5 clock cycles of yellow, 10 clock cycles of red. When the pedestrian button is pressed, if the remaining green time is greater than 10 clocks, it is shortened to 10 clocks, and if it is less than 10 clocks, it remains unchanged. The lane light and the sidewalk light should be paired, when the lane light is green or yellow, the sidewalk light is red; When the lane light is red, the sidewalk light is green, and for the sake of simplicity, only the lane light is considered.\n\nModule name:  \n    traffic_light\n\nInputs:\n    rst_n: Reset signal (active low).\n    clk: Clock signal.\n    pass_request: Request signal for allowing vehicles to pass.\n\nOutputs:\n    clock[7:0]: An 8-bit output representing the count value of the internal counter.\n    red, yellow, green: Output signals representing the state of the traffic lights.\n\nParameters:\n    idle, s1_red, s2_yellow, s3_green: Enumeration values representing different states of the traffic light controller.\n\nRegisters and Wires:\n    cnt: A 8-bit register used as an internal counter for timing purposes.\n    state: A 2-bit register representing the current state of the traffic light controller.\n    p_red, p_yellow, p_green: 1-bit registers representing the next values for the red, yellow, and green signals.\n\nImplementation:\nThe following is the design track we recommend:\nThe first always block is responsible for the state transition logic. It uses a case statement to handle different states. Here's a summary of each state:\nidle: Initial state where all signals are set to 0. Transition to s1_red state occurs immediately.\ns1_red: Sets the red signal to 1 and waits for a count of 3 before transitioning to s3_green state. Otherwise, it remains in s1_red state.\ns2_yellow: Sets the yellow signal to 1 and waits for a count of 3 before transitioning to s1_red state. Otherwise, it remains in s2_yellow state.\ns3_green: Sets the green signal to 1 and waits for a count of 3 before transitioning to s2_yellow state. Otherwise, it remains in s3_green state.\nThe second always block handles the counting logic of the internal counter (cnt). The counter is decremented by 1 on every positive edge of the clock or negative edge of the reset signal. The counter values are adjusted based on various conditions:\nIf (!rst_n), the counter is set to 10.\nIf the pass_request signal is active and the green signal is active, the counter is set to 10.\nIf the green signal is inactive and the previous green signal (p_green) was active, the counter is set to 60.\nIf the yellow signal is inactive and the previous yellow signal (p_yellow) was active, the counter is set to 5.\nIf the red signal is inactive and the previous red signal (p_red) was active, the counter is set to 10.\nOtherwise, the counter is decremented normally.\nThe assign statement assigns the value of the internal counter (cnt) to the output clock.\nThe final always block handles the output signals. It assigns the previous values (p_red, p_yellow, p_green) to the output signals (red, yellow, green) on the positive edge of the clock or negative edge of the reset signal.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\nmodule traffic_light\n    (\n\t\tinput rst_n, \n      input clk, \n      input pass_request,\n\t\t  output wire[7:0]clock,\n      output reg red,\n\t\t  output reg yellow,\n\t\t  output reg green\n    );\n\t\n\tparameter \tidle = 2'd0,\n\t\t\t\ts1_red = 2'd1,\n\t\t\t\ts2_yellow = 2'd2,\n\t\t\t\ts3_green = 2'd3;\n\treg [7:0] cnt;\n\treg [1:0] state;\n\treg p_red,p_yellow,p_green;\t\n\n\nalways @(posedge clk or negedge rst_n) \n    begin\n        if(!rst_n)\n        begin\n\t\t\tstate <= idle;\n\t\t\tp_red <= 1'b0;\n\t\t\tp_green <= 1'b0;\n\t\t\tp_yellow <= 1'b0;\t\t\t\n        end\n        else case(state)\n\t\tidle:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts1_red:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b1;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s3_green;\n\t\t\t\telse\n\t\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts2_yellow:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b1;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s1_red;\n\t\t\t\telse\n\t\t\t\t\tstate <= s2_yellow;\n\t\t\tend\n\t\ts3_green:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b1;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s2_yellow;\n\t\t\t\telse\n\t\t\t\t\tstate <= s3_green;\n\t\t\tend\n\t\tendcase\n\tend\n \nalways @(posedge clk or negedge rst_n) \n      if(!rst_n)\n\t\t\tcnt <= 7'd10;\n\t\telse if (pass_request&&green&&(cnt>10))\n\t\t\tcnt <= 7'd10;\n\t\telse if (!green&&p_green)\n\t\t\tcnt <= 7'd60;\n\t\telse if (!yellow&&p_yellow)\n\t\t\tcnt <= 7'd5;\n\t\telse if (!red&&p_red)\n\t\t\tcnt <= 7'd10;\t\n\t\telse cnt <= cnt -1;\n assign clock = cnt;\n\nalways @(posedge clk or negedge rst_n) \n        if(!rst_n)\n\t\t\tbegin\n\t\t\t\tyellow <= 1'd0;\n\t\t\t\tred <= 1'd0;\n\t\t\t\tgreen <= 1'd0;\n\t\t\tend\n\t\telse \n\t\t\tbegin\n\t\t\t\tyellow <= p_yellow;\n\t\t\t\tred <= p_red;\n\t\t\t\tgreen <= p_green;\n\t\t\tend\t\t\n\nendmodule\n", "corrupted_code": "`timescale 1ns/1ns\n\nmodule traffic_light\n    (\n\t\tinput rst_n, \n      input clk, \n      input pass_request,\n\t\t  output wire[7:0]clock,\n      output reg red,\n\t\t  output reg yellow,\n\t\t  output reg green\n    );\n\t\n\tparameter \tidle = 2'd0,\n\t\t\t\ts1_red = 2'd1,\n\t\t\t\ts2_yellow = 2'd2,\n\t\t\t\ts3_green <= 2'd3;\n\treg [7:0] cnt;\n\treg [1:0] state;\n\treg p_red,p_yellow,p_green;\t\n\n\nalways @(posedge clk or negedge rst_n) \n    begin\n        if(!rst_n)\n        begin\n\t\t\tstate <= idle;\n\t\t\tp_red <= 1'b0;\n\t\t\tp_green <= 1'b0;\n\t\t\tp_yellow <= 1'b0;\t\t\t\n        end\n        else case(state)\n\t\tidle:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts1_red:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b1;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s3_green;\n\t\t\t\telse\n\t\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts2_yellow:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b1;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s1_red;\n\t\t\t\telse\n\t\t\t\t\tstate <= s2_yellow;\n\t\t\tend\n\t\ts3_green:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b1;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s2_yellow;\n\t\t\t\telse\n\t\t\t\t\tstate <= s3_green;\n\t\t\tend\n\t\tendcase\n\tend\n \nalways @(posedge clk or negedge rst_n) \n      if(!rst_n)\n\t\t\tcnt <= 7'd10;\n\t\telse if (pass_request&&green&&(cnt>10))\n\t\t\tcnt <= 7'd10;\n\t\telse if (!green&&p_green)\n\t\t\tcnt <= 7'd60;\n\t\telse if (!yellow&&p_yellow)\n\t\t\tcnt <= 7'd5;\n\t\telse if (!red&&p_red)\n\t\t\tcnt <= 7'd10;\t\n\t\telse cnt <= cnt -1;\n assign clock = cnt;\n\nalways @(posedge clk or negedge rst_n) \n        if(!rst_n)\n\t\t\tbegin\n\t\t\t\tyellow <= 1'd0;\n\t\t\t\tred <= 1'd0;\n\t\t\t\tgreen <= 1'd0;\n\t\t\tend\n\t\telse \n\t\t\tbegin\n\t\t\t\tyellow <= p_yellow;\n\t\t\t\tred <= p_red;\n\t\t\t\tgreen <= p_green;\n\t\t\tend\t\t\n\nendmodule\n", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 17, "original_snippet": "s3_green = 2'd3;", "modified_snippet": "s3_green <= 2'd3;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 49, "applicable_modifications": ["invert_if_else", "remove_else_branch", "remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.407299", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "traffic_light", "module_name": "traffic_light", "description": "Please act as a professional verilog designer.\n\nImplement a traffic light, with red, yellow and green three small indicators and a pedestrian button, under normal circumstances, the motor vehicle lane indicator light according to 60 clock cycles of green, 5 clock cycles of yellow, 10 clock cycles of red. When the pedestrian button is pressed, if the remaining green time is greater than 10 clocks, it is shortened to 10 clocks, and if it is less than 10 clocks, it remains unchanged. The lane light and the sidewalk light should be paired, when the lane light is green or yellow, the sidewalk light is red; When the lane light is red, the sidewalk light is green, and for the sake of simplicity, only the lane light is considered.\n\nModule name:  \n    traffic_light\n\nInputs:\n    rst_n: Reset signal (active low).\n    clk: Clock signal.\n    pass_request: Request signal for allowing vehicles to pass.\n\nOutputs:\n    clock[7:0]: An 8-bit output representing the count value of the internal counter.\n    red, yellow, green: Output signals representing the state of the traffic lights.\n\nParameters:\n    idle, s1_red, s2_yellow, s3_green: Enumeration values representing different states of the traffic light controller.\n\nRegisters and Wires:\n    cnt: A 8-bit register used as an internal counter for timing purposes.\n    state: A 2-bit register representing the current state of the traffic light controller.\n    p_red, p_yellow, p_green: 1-bit registers representing the next values for the red, yellow, and green signals.\n\nImplementation:\nThe following is the design track we recommend:\nThe first always block is responsible for the state transition logic. It uses a case statement to handle different states. Here's a summary of each state:\nidle: Initial state where all signals are set to 0. Transition to s1_red state occurs immediately.\ns1_red: Sets the red signal to 1 and waits for a count of 3 before transitioning to s3_green state. Otherwise, it remains in s1_red state.\ns2_yellow: Sets the yellow signal to 1 and waits for a count of 3 before transitioning to s1_red state. Otherwise, it remains in s2_yellow state.\ns3_green: Sets the green signal to 1 and waits for a count of 3 before transitioning to s2_yellow state. Otherwise, it remains in s3_green state.\nThe second always block handles the counting logic of the internal counter (cnt). The counter is decremented by 1 on every positive edge of the clock or negative edge of the reset signal. The counter values are adjusted based on various conditions:\nIf (!rst_n), the counter is set to 10.\nIf the pass_request signal is active and the green signal is active, the counter is set to 10.\nIf the green signal is inactive and the previous green signal (p_green) was active, the counter is set to 60.\nIf the yellow signal is inactive and the previous yellow signal (p_yellow) was active, the counter is set to 5.\nIf the red signal is inactive and the previous red signal (p_red) was active, the counter is set to 10.\nOtherwise, the counter is decremented normally.\nThe assign statement assigns the value of the internal counter (cnt) to the output clock.\nThe final always block handles the output signals. It assigns the previous values (p_red, p_yellow, p_green) to the output signals (red, yellow, green) on the positive edge of the clock or negative edge of the reset signal.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\n\nmodule traffic_light\n    (\n\t\tinput rst_n, \n      input clk, \n      input pass_request,\n\t\t  output wire[7:0]clock,\n      output reg red,\n\t\t  output reg yellow,\n\t\t  output reg green\n    );\n\t\n\tparameter \tidle = 2'd0,\n\t\t\t\ts1_red = 2'd1,\n\t\t\t\ts2_yellow = 2'd2,\n\t\t\t\ts3_green = 2'd3;\n\treg [7:0] cnt;\n\treg [1:0] state;\n\treg p_red,p_yellow,p_green;\t\n\n\nalways @(posedge clk or negedge rst_n) \n    begin\n        if(!rst_n)\n        begin\n\t\t\tstate <= idle;\n\t\t\tp_red <= 1'b0;\n\t\t\tp_green <= 1'b0;\n\t\t\tp_yellow <= 1'b0;\t\t\t\n        end\n        else case(state)\n\t\tidle:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts1_red:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b1;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s3_green;\n\t\t\t\telse\n\t\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts2_yellow:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b1;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s1_red;\n\t\t\t\telse\n\t\t\t\t\tstate <= s2_yellow;\n\t\t\tend\n\t\ts3_green:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b1;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s2_yellow;\n\t\t\t\telse\n\t\t\t\t\tstate <= s3_green;\n\t\t\tend\n\t\tendcase\n\tend\n \nalways @(posedge clk or negedge rst_n) \n      if(!rst_n)\n\t\t\tcnt <= 7'd10;\n\t\telse if (pass_request&&green&&(cnt>10))\n\t\t\tcnt <= 7'd10;\n\t\telse if (!green&&p_green)\n\t\t\tcnt <= 7'd60;\n\t\telse if (!yellow&&p_yellow)\n\t\t\tcnt <= 7'd5;\n\t\telse if (!red&&p_red)\n\t\t\tcnt <= 7'd10;\t\n\t\telse cnt <= cnt -1;\n assign clock = cnt;\n\nalways @(posedge clk or negedge rst_n) \n        if(!rst_n)\n\t\t\tbegin\n\t\t\t\tyellow <= 1'd0;\n\t\t\t\tred <= 1'd0;\n\t\t\t\tgreen <= 1'd0;\n\t\t\tend\n\t\telse \n\t\t\tbegin\n\t\t\t\tyellow <= p_yellow;\n\t\t\t\tred <= p_red;\n\t\t\t\tgreen <= p_green;\n\t\t\tend\t\t\n\nendmodule\n", "corrupted_code": "`timescale 1ns/1ns\n\nmodule traffic_light\n    (\n\t\tinput rst_n, \n      input clk, \n      input pass_request,\n\t\t  output wire[7:0]clock,\n      output reg red,\n\t\t  output reg yellow,\n\t\t  output reg green\n    );\n\t\n\tparameter \tidle = 2'd0,\n\t\t\t\ts1_red = 2'd1,\n\t\t\t\ts2_yellow = 2'd2,\n\t\t\t\ts3_green = 2'd3;\n\treg [7:0] cnt;\n\treg [1:0] state;\n\treg p_red,p_yellow,p_green;\t\n\n\nalways @(posedge clk or negedge rst_n) \n    begin\n        if(!rst_n)\n        begin\n\t\t\tstate <= idle;\n\t\t\tp_red <= 1'b0;\n\t\t\tp_green <= 1'b0;\n\t\t\tp_yellow <= 1'b0;\t\t\t\n        end\n        else case(state)\n\t\tidle:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts1_red:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b1;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s3_green;\n\t\t\t\telse\n\t\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts2_yellow:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b1;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s1_red;\n\t\t\t\telse\n\t\t\t\t\tstate <= s2_yellow;\n\t\t\tend\n\t\ts3_green:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b1;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s2_yellow;\n\t\t\t\telse\n\t\t\t\t\tstate <= s3_green;\n\t\t\tend\n\t\t\n        UNREACHABLE_STATE: begin\n            // This state should never be reached\n        end\nendcase\n\tend\n \nalways @(posedge clk or negedge rst_n) \n      if(!rst_n)\n\t\t\tcnt <= 7'd10;\n\t\telse if (pass_request&&green&&(cnt>10))\n\t\t\tcnt <= 7'd10;\n\t\telse if (!green&&p_green)\n\t\t\tcnt <= 7'd60;\n\t\telse if (!yellow&&p_yellow)\n\t\t\tcnt <= 7'd5;\n\t\telse if (!red&&p_red)\n\t\t\tcnt <= 7'd10;\t\n\t\telse cnt <= cnt -1;\n assign clock = cnt;\n\nalways @(posedge clk or negedge rst_n) \n        if(!rst_n)\n\t\t\tbegin\n\t\t\t\tyellow <= 1'd0;\n\t\t\t\tred <= 1'd0;\n\t\t\t\tgreen <= 1'd0;\n\t\t\tend\n\t\telse \n\t\t\tbegin\n\t\t\t\tyellow <= p_yellow;\n\t\t\t\tred <= p_red;\n\t\t\t\tgreen <= p_green;\n\t\t\tend\t\t\n\nendmodule\n", "corruption_explanation": "Added unreachable state to FSM", "modification_type": "add_unreachable_state", "modification_line": 32, "original_snippet": "case(state)\n\t\tidle:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts1_red:\n\t\t\tbegin\n\t\t\t\tp_red <=", "modified_snippet": "case(state)\n\t\tidle:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts1_red:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b1;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n", "issue_description": "The buggy code has an unreachable state in the FSM. A state was added that no transition leads to, creating dead code. While this may not immediately break functionality, it indicates design issues and may confuse synthesis optimization.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_unreachable_state modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added unreachable state to FSM\n   \u2022 Line 32: Original: case(state)\n\t\tidle:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts1_red:\n\t\t\tbegin\n\t\t\t\tp_red <=\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 32.\n   \u2022 Restore the original code: case(state)\n\t\tidle:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts1_red:\n\t\t\tbegin\n\t\t\t\tp_red <=\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add unreachable state.", "complexity": 49, "applicable_modifications": ["invert_if_else", "remove_else_branch", "remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["add_unreachable_state"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.408844", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "width_8to16", "module_name": "width_8to16", "description": "Please act as a professional verilog designer.\n\nImplement a data width conversion circuit that converts 8-bit data input to 16-bit data output. The module provides two output ports: valid_out, which indicates the validity of the output data, and data_out, which represents the converted 16-bit output data. The first arriving 8-bit data should be placed in the higher 8 bits of the 16-bit data output. The valid_out and data_out signals are generated in the next clock cycle after the two data inputs. When there is only one data input, valid_out and data_out are not generated immediately. Instead, they wait for the arrival of the next data input to complete the concatenation of the two data inputs before generating valid_out and data_out. \n\nModule name:  \n    width_8to16   \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n    valid_in: Input signal indicating the validity of the input data.\n    data_in: 8-bit input data to be converted.\n\nOutput ports:\n    valid_out: Output signal indicating the validity of the output data.\n    data_out: 16-bit output data resulting from the width conversion.\n\nImplementation:\nThe data_out register is triggered on the positive edge of the clock signal (posedge clk) or the negative edge of the reset signal (negedge rst_n).\nOn reset, indicated by !rst_n, the data_out register is cleared to 0.\nIf the input data is valid (valid_in) and the flag signal is active, the data_out register is updated by concatenating the contents of the data_lock register (8 bits) and the data_in register (8 bits) to form a 16-bit output. The first valid data is temporarily stored, and when the second valid data is inputted, they are concatenated to produce the output valid_out and data_out.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule width_8to16(\n\tinput \t\t\t\t   clk \t\t,   \n\tinput \t\t\t\t   rst_n\t\t,\n\tinput\t\t\t\t      valid_in\t,\n\tinput\t   [7:0]\t\t   data_in\t,\n \n \toutput\treg\t\t\tvalid_out,\n\toutput   reg [15:0]\tdata_out\n);\nreg \t[7:0]\t\tdata_lock;  //data buffer\nreg \t\t\t\tflag\t   ;\n//input data buff in data_lock\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_lock <= 'd0;\n\telse if(valid_in && !flag)\n\t\tdata_lock <= data_in;\nend\n//generate flag\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tflag <= 'd0;\n\telse if(valid_in)\n\t\tflag <= ~flag;\nend\n//generate valid_out\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tvalid_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tvalid_out <= 1'd1;\n\telse\n\t\tvalid_out <= 'd0;\nend\n//data stitching \nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tdata_out <= {data_lock, data_in};\nend\n\nendmodule", "corrupted_code": "`timescale 1ns/1ns\nmodule width_8to16(\n\tinput \t\t\t\t   clk \t\t,   \n\tinput \t\t\t\t   rst_n\t\t,\n\tinput\t\t\t\t      valid_in\t,\n\tinput\t   [7:0]\t\t   data_in\t,\n \n \toutput\treg\t\t\tvalid_out,\n\toutput   reg [15:0]\tdata_out\n);\nreg \t[6:0]\t\tdata_lock;  //data buffer\nreg \t\t\t\tflag\t   ;\n//input data buff in data_lock\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_lock <= 'd0;\n\telse if(valid_in && !flag)\n\t\tdata_lock <= data_in;\nend\n//generate flag\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tflag <= 'd0;\n\telse if(valid_in)\n\t\tflag <= ~flag;\nend\n//generate valid_out\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tvalid_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tvalid_out <= 1'd1;\n\telse\n\t\tvalid_out <= 'd0;\nend\n//data stitching \nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tdata_out <= {data_lock, data_in};\nend\n\nendmodule", "corruption_explanation": "Changed bit width from [7:0] to [6:0]", "modification_type": "change_bit_width", "modification_line": 11, "original_snippet": "[7:0]", "modified_snippet": "[6:0]", "issue_description": "The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_bit_width modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed bit width from [7:0] to [6:0]\n   \u2022 Line 11: Original: [7:0]\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 11.\n   \u2022 Restore the original code: [7:0]\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change bit width.", "complexity": 9, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_bit_width"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.462841", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "width_8to16", "module_name": "width_8to16", "description": "Please act as a professional verilog designer.\n\nImplement a data width conversion circuit that converts 8-bit data input to 16-bit data output. The module provides two output ports: valid_out, which indicates the validity of the output data, and data_out, which represents the converted 16-bit output data. The first arriving 8-bit data should be placed in the higher 8 bits of the 16-bit data output. The valid_out and data_out signals are generated in the next clock cycle after the two data inputs. When there is only one data input, valid_out and data_out are not generated immediately. Instead, they wait for the arrival of the next data input to complete the concatenation of the two data inputs before generating valid_out and data_out. \n\nModule name:  \n    width_8to16   \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n    valid_in: Input signal indicating the validity of the input data.\n    data_in: 8-bit input data to be converted.\n\nOutput ports:\n    valid_out: Output signal indicating the validity of the output data.\n    data_out: 16-bit output data resulting from the width conversion.\n\nImplementation:\nThe data_out register is triggered on the positive edge of the clock signal (posedge clk) or the negative edge of the reset signal (negedge rst_n).\nOn reset, indicated by !rst_n, the data_out register is cleared to 0.\nIf the input data is valid (valid_in) and the flag signal is active, the data_out register is updated by concatenating the contents of the data_lock register (8 bits) and the data_in register (8 bits) to form a 16-bit output. The first valid data is temporarily stored, and when the second valid data is inputted, they are concatenated to produce the output valid_out and data_out.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule width_8to16(\n\tinput \t\t\t\t   clk \t\t,   \n\tinput \t\t\t\t   rst_n\t\t,\n\tinput\t\t\t\t      valid_in\t,\n\tinput\t   [7:0]\t\t   data_in\t,\n \n \toutput\treg\t\t\tvalid_out,\n\toutput   reg [15:0]\tdata_out\n);\nreg \t[7:0]\t\tdata_lock;  //data buffer\nreg \t\t\t\tflag\t   ;\n//input data buff in data_lock\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_lock <= 'd0;\n\telse if(valid_in && !flag)\n\t\tdata_lock <= data_in;\nend\n//generate flag\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tflag <= 'd0;\n\telse if(valid_in)\n\t\tflag <= ~flag;\nend\n//generate valid_out\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tvalid_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tvalid_out <= 1'd1;\n\telse\n\t\tvalid_out <= 'd0;\nend\n//data stitching \nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tdata_out <= {data_lock, data_in};\nend\n\nendmodule", "corrupted_code": "`timescale 1ns/1ns\nmodule width_8to16(\n\tinput \t\t\t\t   clk \t\t,   \n\tinput \t\t\t\t   rst_n\t\t,\n\tinput\t\t\t\t      valid_in\t,\n\tinput\t   [7:0]\t\t   data_in\t,\n \n \toutput\treg\t\t\tvalid_out,\n\toutput   reg [15:0]\tdata_out\n);\nreg \t[7:0]\t\tdata_lock;  //data buffer\nreg \t\t\t\tflag\t   ;\n//input data buff in data_lock\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_lock <= 'd0;\n\telse if(valid_in && !flag)\n\t\tdata_in <= data_lock;\nend\n//generate flag\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tflag <= 'd0;\n\telse if(valid_in)\n\t\tflag <= ~flag;\nend\n//generate valid_out\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tvalid_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tvalid_out <= 1'd1;\n\telse\n\t\tvalid_out <= 'd0;\nend\n//data stitching \nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tdata_out <= {data_lock, data_in};\nend\n\nendmodule", "corruption_explanation": "Swapped operands: 'data_lock <= data_in' -> 'data_in <= data_lock'", "modification_type": "swap_operands", "modification_line": 18, "original_snippet": "data_lock <= data_in", "modified_snippet": "data_in <= data_lock", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'data_lock <= data_in' -> 'data_in <= data_lock'\n   \u2022 Line 18: Original: data_lock <= data_in\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 18.\n   \u2022 Restore the original code: data_lock <= data_in\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 9, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_operands"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.464432", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "width_8to16", "module_name": "width_8to16", "description": "Please act as a professional verilog designer.\n\nImplement a data width conversion circuit that converts 8-bit data input to 16-bit data output. The module provides two output ports: valid_out, which indicates the validity of the output data, and data_out, which represents the converted 16-bit output data. The first arriving 8-bit data should be placed in the higher 8 bits of the 16-bit data output. The valid_out and data_out signals are generated in the next clock cycle after the two data inputs. When there is only one data input, valid_out and data_out are not generated immediately. Instead, they wait for the arrival of the next data input to complete the concatenation of the two data inputs before generating valid_out and data_out. \n\nModule name:  \n    width_8to16   \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n    valid_in: Input signal indicating the validity of the input data.\n    data_in: 8-bit input data to be converted.\n\nOutput ports:\n    valid_out: Output signal indicating the validity of the output data.\n    data_out: 16-bit output data resulting from the width conversion.\n\nImplementation:\nThe data_out register is triggered on the positive edge of the clock signal (posedge clk) or the negative edge of the reset signal (negedge rst_n).\nOn reset, indicated by !rst_n, the data_out register is cleared to 0.\nIf the input data is valid (valid_in) and the flag signal is active, the data_out register is updated by concatenating the contents of the data_lock register (8 bits) and the data_in register (8 bits) to form a 16-bit output. The first valid data is temporarily stored, and when the second valid data is inputted, they are concatenated to produce the output valid_out and data_out.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule width_8to16(\n\tinput \t\t\t\t   clk \t\t,   \n\tinput \t\t\t\t   rst_n\t\t,\n\tinput\t\t\t\t      valid_in\t,\n\tinput\t   [7:0]\t\t   data_in\t,\n \n \toutput\treg\t\t\tvalid_out,\n\toutput   reg [15:0]\tdata_out\n);\nreg \t[7:0]\t\tdata_lock;  //data buffer\nreg \t\t\t\tflag\t   ;\n//input data buff in data_lock\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_lock <= 'd0;\n\telse if(valid_in && !flag)\n\t\tdata_lock <= data_in;\nend\n//generate flag\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tflag <= 'd0;\n\telse if(valid_in)\n\t\tflag <= ~flag;\nend\n//generate valid_out\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tvalid_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tvalid_out <= 1'd1;\n\telse\n\t\tvalid_out <= 'd0;\nend\n//data stitching \nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tdata_out <= {data_lock, data_in};\nend\n\nendmodule", "corrupted_code": "`timescale 1ns / 1ns\nmodule width_8to16(\n\tinput \t\t\t\t   clk \t\t,   \n\tinput \t\t\t\t   rst_n\t\t,\n\tinput\t\t\t\t      valid_in\t,\n\tinput\t   [7:0]\t\t   data_in\t,\n \n \toutput\treg\t\t\tvalid_out,\n\toutput   reg [15:0]\tdata_out\n);\nreg \t[7:0]\t\tdata_lock;  //data buffer\nreg \t\t\t\tflag\t   ;\n//input data buff in data_lock\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_lock <= 'd0;\n\telse if(valid_in && !flag)\n\t\tdata_lock <= data_in;\nend\n//generate flag\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tflag <= 'd0;\n\telse if(valid_in)\n\t\tflag <= ~flag;\nend\n//generate valid_out\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tvalid_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tvalid_out <= 1'd1;\n\telse\n\t\tvalid_out <= 'd0;\nend\n//data stitching \nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tdata_out <= {data_lock, data_in};\nend\n\nendmodule", "corruption_explanation": "Swapped operands: '1ns / 1ns' -> '1ns / 1ns'", "modification_type": "swap_operands", "modification_line": 1, "original_snippet": "1ns/1ns", "modified_snippet": "1ns / 1ns", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: '1ns / 1ns' -> '1ns / 1ns'\n   \u2022 Line 1: Original: 1ns/1ns\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 1.\n   \u2022 Restore the original code: 1ns/1ns\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 9, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_operands"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.466026", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "width_8to16", "module_name": "width_8to16", "description": "Please act as a professional verilog designer.\n\nImplement a data width conversion circuit that converts 8-bit data input to 16-bit data output. The module provides two output ports: valid_out, which indicates the validity of the output data, and data_out, which represents the converted 16-bit output data. The first arriving 8-bit data should be placed in the higher 8 bits of the 16-bit data output. The valid_out and data_out signals are generated in the next clock cycle after the two data inputs. When there is only one data input, valid_out and data_out are not generated immediately. Instead, they wait for the arrival of the next data input to complete the concatenation of the two data inputs before generating valid_out and data_out. \n\nModule name:  \n    width_8to16   \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n    valid_in: Input signal indicating the validity of the input data.\n    data_in: 8-bit input data to be converted.\n\nOutput ports:\n    valid_out: Output signal indicating the validity of the output data.\n    data_out: 16-bit output data resulting from the width conversion.\n\nImplementation:\nThe data_out register is triggered on the positive edge of the clock signal (posedge clk) or the negative edge of the reset signal (negedge rst_n).\nOn reset, indicated by !rst_n, the data_out register is cleared to 0.\nIf the input data is valid (valid_in) and the flag signal is active, the data_out register is updated by concatenating the contents of the data_lock register (8 bits) and the data_in register (8 bits) to form a 16-bit output. The first valid data is temporarily stored, and when the second valid data is inputted, they are concatenated to produce the output valid_out and data_out.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule width_8to16(\n\tinput \t\t\t\t   clk \t\t,   \n\tinput \t\t\t\t   rst_n\t\t,\n\tinput\t\t\t\t      valid_in\t,\n\tinput\t   [7:0]\t\t   data_in\t,\n \n \toutput\treg\t\t\tvalid_out,\n\toutput   reg [15:0]\tdata_out\n);\nreg \t[7:0]\t\tdata_lock;  //data buffer\nreg \t\t\t\tflag\t   ;\n//input data buff in data_lock\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_lock <= 'd0;\n\telse if(valid_in && !flag)\n\t\tdata_lock <= data_in;\nend\n//generate flag\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tflag <= 'd0;\n\telse if(valid_in)\n\t\tflag <= ~flag;\nend\n//generate valid_out\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tvalid_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tvalid_out <= 1'd1;\n\telse\n\t\tvalid_out <= 'd0;\nend\n//data stitching \nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tdata_out <= {data_lock, data_in};\nend\n\nendmodule", "corrupted_code": "`timescale 1ns/1ns\nmodule width_8to16(\n\tinput \t\t\t\t   clk \t\t,   \n\tinput \t\t\t\t   rst_n\t\t,\n\tinput\t\t\t\t      valid_in\t,\n\tinput\t   [7:0]\t\t   data_in\t,\n \n \toutput\treg\t\t\tvalid_out,\n\toutput   reg [15:0]\tdata_out\n);\nreg \t[7:0]\t\tdata_lock;  //data buffer\nreg \t\t\t\tflag\t   ;\n//input data buff in data_lock\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_lock <= 'd0;\n\telse if(valid_in && !flag)\n\t\tdata_lock = data_in;\nend\n//generate flag\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tflag <= 'd0;\n\telse if(valid_in)\n\t\tflag <= ~flag;\nend\n//generate valid_out\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tvalid_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tvalid_out <= 1'd1;\n\telse\n\t\tvalid_out <= 'd0;\nend\n//data stitching \nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tdata_out <= {data_lock, data_in};\nend\n\nendmodule", "corruption_explanation": "Changed non-blocking (<=) to blocking (=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 18, "original_snippet": "data_lock <= data_in;", "modified_snippet": "data_lock = data_in;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 9, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.468063", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "width_8to16", "module_name": "width_8to16", "description": "Please act as a professional verilog designer.\n\nImplement a data width conversion circuit that converts 8-bit data input to 16-bit data output. The module provides two output ports: valid_out, which indicates the validity of the output data, and data_out, which represents the converted 16-bit output data. The first arriving 8-bit data should be placed in the higher 8 bits of the 16-bit data output. The valid_out and data_out signals are generated in the next clock cycle after the two data inputs. When there is only one data input, valid_out and data_out are not generated immediately. Instead, they wait for the arrival of the next data input to complete the concatenation of the two data inputs before generating valid_out and data_out. \n\nModule name:  \n    width_8to16   \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n    valid_in: Input signal indicating the validity of the input data.\n    data_in: 8-bit input data to be converted.\n\nOutput ports:\n    valid_out: Output signal indicating the validity of the output data.\n    data_out: 16-bit output data resulting from the width conversion.\n\nImplementation:\nThe data_out register is triggered on the positive edge of the clock signal (posedge clk) or the negative edge of the reset signal (negedge rst_n).\nOn reset, indicated by !rst_n, the data_out register is cleared to 0.\nIf the input data is valid (valid_in) and the flag signal is active, the data_out register is updated by concatenating the contents of the data_lock register (8 bits) and the data_in register (8 bits) to form a 16-bit output. The first valid data is temporarily stored, and when the second valid data is inputted, they are concatenated to produce the output valid_out and data_out.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule width_8to16(\n\tinput \t\t\t\t   clk \t\t,   \n\tinput \t\t\t\t   rst_n\t\t,\n\tinput\t\t\t\t      valid_in\t,\n\tinput\t   [7:0]\t\t   data_in\t,\n \n \toutput\treg\t\t\tvalid_out,\n\toutput   reg [15:0]\tdata_out\n);\nreg \t[7:0]\t\tdata_lock;  //data buffer\nreg \t\t\t\tflag\t   ;\n//input data buff in data_lock\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_lock <= 'd0;\n\telse if(valid_in && !flag)\n\t\tdata_lock <= data_in;\nend\n//generate flag\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tflag <= 'd0;\n\telse if(valid_in)\n\t\tflag <= ~flag;\nend\n//generate valid_out\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tvalid_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tvalid_out <= 1'd1;\n\telse\n\t\tvalid_out <= 'd0;\nend\n//data stitching \nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tdata_out <= {data_lock, data_in};\nend\n\nendmodule", "corrupted_code": "`timescale 1ns/1ns\nmodule width_8to16(\n\tinput \t\t\t\t   clk \t\t,   \n\tinput \t\t\t\t   rst_n\t\t,\n\tinput\t\t\t\t      valid_in\t,\n\tinput\t   [7:0]\t\t   data_in\t,\n \n \toutput\treg\t\t\tvalid_out,\n\toutput   reg [15:0]\tdata_out\n);\nreg \t[7:0]\t\tdata_lock;  //data buffer\nreg \t\t\t\tflag\t   ;\n//input data buff in data_lock\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_lock <= 'd0;\n\telse if(valid_in && !flag)\n\t\tdata_lock <= data_in;\nend\n//generate flag\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tflag <= 'd0;\n\telse if(valid_in)\n\t\tflag <= ~flag;\nend\n//generate valid_out\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tvalid_out <= 'd0;\n\telse if(valid_in && flag)\n\t\t1 <= valid_out'd1;\n\telse\n\t\tvalid_out <= 'd0;\nend\n//data stitching \nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tdata_out <= {data_lock, data_in};\nend\n\nendmodule", "corruption_explanation": "Swapped operands: 'valid_out <= 1' -> '1 <= valid_out'", "modification_type": "swap_operands", "modification_line": 32, "original_snippet": "valid_out <= 1", "modified_snippet": "1 <= valid_out", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'valid_out <= 1' -> '1 <= valid_out'\n   \u2022 Line 32: Original: valid_out <= 1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 32.\n   \u2022 Restore the original code: valid_out <= 1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 9, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_operands"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.470044", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "width_8to16", "module_name": "width_8to16", "description": "Please act as a professional verilog designer.\n\nImplement a data width conversion circuit that converts 8-bit data input to 16-bit data output. The module provides two output ports: valid_out, which indicates the validity of the output data, and data_out, which represents the converted 16-bit output data. The first arriving 8-bit data should be placed in the higher 8 bits of the 16-bit data output. The valid_out and data_out signals are generated in the next clock cycle after the two data inputs. When there is only one data input, valid_out and data_out are not generated immediately. Instead, they wait for the arrival of the next data input to complete the concatenation of the two data inputs before generating valid_out and data_out. \n\nModule name:  \n    width_8to16   \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n    valid_in: Input signal indicating the validity of the input data.\n    data_in: 8-bit input data to be converted.\n\nOutput ports:\n    valid_out: Output signal indicating the validity of the output data.\n    data_out: 16-bit output data resulting from the width conversion.\n\nImplementation:\nThe data_out register is triggered on the positive edge of the clock signal (posedge clk) or the negative edge of the reset signal (negedge rst_n).\nOn reset, indicated by !rst_n, the data_out register is cleared to 0.\nIf the input data is valid (valid_in) and the flag signal is active, the data_out register is updated by concatenating the contents of the data_lock register (8 bits) and the data_in register (8 bits) to form a 16-bit output. The first valid data is temporarily stored, and when the second valid data is inputted, they are concatenated to produce the output valid_out and data_out.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule width_8to16(\n\tinput \t\t\t\t   clk \t\t,   \n\tinput \t\t\t\t   rst_n\t\t,\n\tinput\t\t\t\t      valid_in\t,\n\tinput\t   [7:0]\t\t   data_in\t,\n \n \toutput\treg\t\t\tvalid_out,\n\toutput   reg [15:0]\tdata_out\n);\nreg \t[7:0]\t\tdata_lock;  //data buffer\nreg \t\t\t\tflag\t   ;\n//input data buff in data_lock\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_lock <= 'd0;\n\telse if(valid_in && !flag)\n\t\tdata_lock <= data_in;\nend\n//generate flag\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tflag <= 'd0;\n\telse if(valid_in)\n\t\tflag <= ~flag;\nend\n//generate valid_out\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tvalid_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tvalid_out <= 1'd1;\n\telse\n\t\tvalid_out <= 'd0;\nend\n//data stitching \nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tdata_out <= {data_lock, data_in};\nend\n\nendmodule", "corrupted_code": "`timescale 1ns/1ns\nmodule width_8to16(\n\tinput \t\t\t\t   clk \t\t,   \n\tinput \t\t\t\t   rst_n\t\t,\n\tinput\t\t\t\t      valid_in\t,\n\tinput\t   [7:0]\t\t   data_in\t,\n \n \toutput\treg\t\t\tvalid_out,\n\toutput   reg [15:0]\tdata_out\n);\nreg \t[7:0]\t\tdata_lock;  //data buffer\nreg \t\t\t\tflag\t   ;\n//input data buff in data_lock\nalways @(posedge clk or rst_n ) begin\n\tif(!rst_n) \n\t\tdata_lock <= 'd0;\n\telse if(valid_in && !flag)\n\t\tdata_lock <= data_in;\nend\n//generate flag\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tflag <= 'd0;\n\telse if(valid_in)\n\t\tflag <= ~flag;\nend\n//generate valid_out\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tvalid_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tvalid_out <= 1'd1;\n\telse\n\t\tvalid_out <= 'd0;\nend\n//data stitching \nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tdata_out <= {data_lock, data_in};\nend\n\nendmodule", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 14, "original_snippet": "always @(posedge clk or negedge rst_n )", "modified_snippet": "always @(posedge clk or rst_n )", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 14: Original: always @(posedge clk or negedge rst_n )\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 14.\n   \u2022 Restore the original code: always @(posedge clk or negedge rst_n )\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 9, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_sensitivity_list"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.471869", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "width_8to16", "module_name": "width_8to16", "description": "Please act as a professional verilog designer.\n\nImplement a data width conversion circuit that converts 8-bit data input to 16-bit data output. The module provides two output ports: valid_out, which indicates the validity of the output data, and data_out, which represents the converted 16-bit output data. The first arriving 8-bit data should be placed in the higher 8 bits of the 16-bit data output. The valid_out and data_out signals are generated in the next clock cycle after the two data inputs. When there is only one data input, valid_out and data_out are not generated immediately. Instead, they wait for the arrival of the next data input to complete the concatenation of the two data inputs before generating valid_out and data_out. \n\nModule name:  \n    width_8to16   \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n    valid_in: Input signal indicating the validity of the input data.\n    data_in: 8-bit input data to be converted.\n\nOutput ports:\n    valid_out: Output signal indicating the validity of the output data.\n    data_out: 16-bit output data resulting from the width conversion.\n\nImplementation:\nThe data_out register is triggered on the positive edge of the clock signal (posedge clk) or the negative edge of the reset signal (negedge rst_n).\nOn reset, indicated by !rst_n, the data_out register is cleared to 0.\nIf the input data is valid (valid_in) and the flag signal is active, the data_out register is updated by concatenating the contents of the data_lock register (8 bits) and the data_in register (8 bits) to form a 16-bit output. The first valid data is temporarily stored, and when the second valid data is inputted, they are concatenated to produce the output valid_out and data_out.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule width_8to16(\n\tinput \t\t\t\t   clk \t\t,   \n\tinput \t\t\t\t   rst_n\t\t,\n\tinput\t\t\t\t      valid_in\t,\n\tinput\t   [7:0]\t\t   data_in\t,\n \n \toutput\treg\t\t\tvalid_out,\n\toutput   reg [15:0]\tdata_out\n);\nreg \t[7:0]\t\tdata_lock;  //data buffer\nreg \t\t\t\tflag\t   ;\n//input data buff in data_lock\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_lock <= 'd0;\n\telse if(valid_in && !flag)\n\t\tdata_lock <= data_in;\nend\n//generate flag\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tflag <= 'd0;\n\telse if(valid_in)\n\t\tflag <= ~flag;\nend\n//generate valid_out\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tvalid_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tvalid_out <= 1'd1;\n\telse\n\t\tvalid_out <= 'd0;\nend\n//data stitching \nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tdata_out <= {data_lock, data_in};\nend\n\nendmodule", "corrupted_code": "`timescale 1ns/1ns\nmodule width_8to16(\n\tinput \t\t\t\t   clk \t\t,   \n\tinput \t\t\t\t   rst_n\t\t,\n\tinput\t\t\t\t      valid_in\t,\n\tinput\t   [7:1]\t\t   data_in\t,\n \n \toutput\treg\t\t\tvalid_out,\n\toutput   reg [15:0]\tdata_out\n);\nreg \t[7:0]\t\tdata_lock;  //data buffer\nreg \t\t\t\tflag\t   ;\n//input data buff in data_lock\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_lock <= 'd0;\n\telse if(valid_in && !flag)\n\t\tdata_lock <= data_in;\nend\n//generate flag\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tflag <= 'd0;\n\telse if(valid_in)\n\t\tflag <= ~flag;\nend\n//generate valid_out\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tvalid_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tvalid_out <= 1'd1;\n\telse\n\t\tvalid_out <= 'd0;\nend\n//data stitching \nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tdata_out <= {data_lock, data_in};\nend\n\nendmodule", "corruption_explanation": "Changed bit width from [7:0] to [7:1]", "modification_type": "change_bit_width", "modification_line": 6, "original_snippet": "[7:0]", "modified_snippet": "[7:1]", "issue_description": "The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_bit_width modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed bit width from [7:0] to [7:1]\n   \u2022 Line 6: Original: [7:0]\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 6.\n   \u2022 Restore the original code: [7:0]\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change bit width.", "complexity": 9, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_bit_width"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.473703", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "width_8to16", "module_name": "width_8to16", "description": "Please act as a professional verilog designer.\n\nImplement a data width conversion circuit that converts 8-bit data input to 16-bit data output. The module provides two output ports: valid_out, which indicates the validity of the output data, and data_out, which represents the converted 16-bit output data. The first arriving 8-bit data should be placed in the higher 8 bits of the 16-bit data output. The valid_out and data_out signals are generated in the next clock cycle after the two data inputs. When there is only one data input, valid_out and data_out are not generated immediately. Instead, they wait for the arrival of the next data input to complete the concatenation of the two data inputs before generating valid_out and data_out. \n\nModule name:  \n    width_8to16   \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n    valid_in: Input signal indicating the validity of the input data.\n    data_in: 8-bit input data to be converted.\n\nOutput ports:\n    valid_out: Output signal indicating the validity of the output data.\n    data_out: 16-bit output data resulting from the width conversion.\n\nImplementation:\nThe data_out register is triggered on the positive edge of the clock signal (posedge clk) or the negative edge of the reset signal (negedge rst_n).\nOn reset, indicated by !rst_n, the data_out register is cleared to 0.\nIf the input data is valid (valid_in) and the flag signal is active, the data_out register is updated by concatenating the contents of the data_lock register (8 bits) and the data_in register (8 bits) to form a 16-bit output. The first valid data is temporarily stored, and when the second valid data is inputted, they are concatenated to produce the output valid_out and data_out.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule width_8to16(\n\tinput \t\t\t\t   clk \t\t,   \n\tinput \t\t\t\t   rst_n\t\t,\n\tinput\t\t\t\t      valid_in\t,\n\tinput\t   [7:0]\t\t   data_in\t,\n \n \toutput\treg\t\t\tvalid_out,\n\toutput   reg [15:0]\tdata_out\n);\nreg \t[7:0]\t\tdata_lock;  //data buffer\nreg \t\t\t\tflag\t   ;\n//input data buff in data_lock\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_lock <= 'd0;\n\telse if(valid_in && !flag)\n\t\tdata_lock <= data_in;\nend\n//generate flag\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tflag <= 'd0;\n\telse if(valid_in)\n\t\tflag <= ~flag;\nend\n//generate valid_out\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tvalid_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tvalid_out <= 1'd1;\n\telse\n\t\tvalid_out <= 'd0;\nend\n//data stitching \nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tdata_out <= {data_lock, data_in};\nend\n\nendmodule", "corrupted_code": "`timescale 1ns/1ns\nmodule width_8to16(\n\tinput \t\t\t\t   clk \t\t,   \n\tinput \t\t\t\t   rst_n\t\t,\n\tinput\t\t\t\t      valid_in\t,\n\tinput\t   [7:0]\t\t   data_in\t,\n \n \toutput\treg\t\t\tvalid_out,\n\toutput   reg [15:0]\tdata_out\n);\nreg \t[7:0]\t\tdata_lock;  //data buffer\nreg \t\t\t\tflag\t   ;\n//input data buff in data_lock\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_lock <= 'd0;\n\telse if(valid_in && !flag)\n\t\tdata_lock <= data_in;\nend\n//generate flag\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tflag <= 'd0;\n\telse if(valid_in)\n\nend\n//generate valid_out\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tvalid_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tvalid_out <= 1'd1;\n\telse\n\t\tvalid_out <= 'd0;\nend\n//data stitching \nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tdata_out <= {data_lock, data_in};\nend\n\nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 25, "original_snippet": "flag <= ~flag;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 25: Original: flag <= ~flag;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 25.\n   \u2022 Restore the original code: flag <= ~flag;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 9, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.475572", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "width_8to16", "module_name": "width_8to16", "description": "Please act as a professional verilog designer.\n\nImplement a data width conversion circuit that converts 8-bit data input to 16-bit data output. The module provides two output ports: valid_out, which indicates the validity of the output data, and data_out, which represents the converted 16-bit output data. The first arriving 8-bit data should be placed in the higher 8 bits of the 16-bit data output. The valid_out and data_out signals are generated in the next clock cycle after the two data inputs. When there is only one data input, valid_out and data_out are not generated immediately. Instead, they wait for the arrival of the next data input to complete the concatenation of the two data inputs before generating valid_out and data_out. \n\nModule name:  \n    width_8to16   \n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n    valid_in: Input signal indicating the validity of the input data.\n    data_in: 8-bit input data to be converted.\n\nOutput ports:\n    valid_out: Output signal indicating the validity of the output data.\n    data_out: 16-bit output data resulting from the width conversion.\n\nImplementation:\nThe data_out register is triggered on the positive edge of the clock signal (posedge clk) or the negative edge of the reset signal (negedge rst_n).\nOn reset, indicated by !rst_n, the data_out register is cleared to 0.\nIf the input data is valid (valid_in) and the flag signal is active, the data_out register is updated by concatenating the contents of the data_lock register (8 bits) and the data_in register (8 bits) to form a 16-bit output. The first valid data is temporarily stored, and when the second valid data is inputted, they are concatenated to produce the output valid_out and data_out.\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns/1ns\nmodule width_8to16(\n\tinput \t\t\t\t   clk \t\t,   \n\tinput \t\t\t\t   rst_n\t\t,\n\tinput\t\t\t\t      valid_in\t,\n\tinput\t   [7:0]\t\t   data_in\t,\n \n \toutput\treg\t\t\tvalid_out,\n\toutput   reg [15:0]\tdata_out\n);\nreg \t[7:0]\t\tdata_lock;  //data buffer\nreg \t\t\t\tflag\t   ;\n//input data buff in data_lock\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_lock <= 'd0;\n\telse if(valid_in && !flag)\n\t\tdata_lock <= data_in;\nend\n//generate flag\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tflag <= 'd0;\n\telse if(valid_in)\n\t\tflag <= ~flag;\nend\n//generate valid_out\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tvalid_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tvalid_out <= 1'd1;\n\telse\n\t\tvalid_out <= 'd0;\nend\n//data stitching \nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tdata_out <= {data_lock, data_in};\nend\n\nendmodule", "corrupted_code": "`timescale 1ns/1ns\nmodule width_8to16(\n\tinput \t\t\t\t   clk \t\t,   \n\tinput \t\t\t\t   rst_n\t\t,\n\tinput\t\t\t\t      valid_in\t,\n\tinput\t   [7:0]\t\t   data_in\t,\n \n \toutput\treg\t\t\tvalid_out,\n\toutput   reg [15:0]\tdata_out\n);\nreg \t[7:0]\t\tdata_lock;  //data buffer\nreg \t\t\t\tflag\t   ;\n//input data buff in data_lock\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_lock <= 'd0;\n\telse if(valid_in && !flag)\n\t\tdata_lock <= data_in;\nend\n//generate flag\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tflag <= 'd0;\n\telse if(valid_in)\n\t\tflag <= ~flag;\nend\n//generate valid_out\nalways @(posedge clk) begin\n\tif(!rst_n) \n\t\tvalid_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tvalid_out <= 1'd1;\n\telse\n\t\tvalid_out <= 'd0;\nend\n//data stitching \nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tdata_out <= {data_lock, data_in};\nend\n\nendmodule", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 28, "original_snippet": "always @(posedge clk or negedge rst_n )", "modified_snippet": "always @(posedge clk)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 28: Original: always @(posedge clk or negedge rst_n )\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 28.\n   \u2022 Restore the original code: always @(posedge clk or negedge rst_n )\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 9, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_sensitivity_list"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.477398", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "synchronizer", "module_name": "synchronizer", "description": "Please act as a professional verilog designer.\n\nImplement a multi-bit MUX-based synchronizer, data_in will remain constant during the period when data_en is high, and data_en is high for at least 3 clk_b clock cycles. When the value of data_en is high, data can be synchronized. The data change frequency of data_in is very low. The change interval between two adjacent data is at least 10 clk_b clock cycles.\nThe clock clk_a is responsible for: input data_in is refer to clock a. enable signal data_en is refer to clock a.\nThe clock clk_b is responsible for the enable signal data_en delays two cycles, that is, two D flip-flops. This is done with reference to clock b. And the data is finally output dataout, and the output refers to clock b.\n\nModule name:  \n    synchronizer  \n\nInput ports:\n\tclk_a: Clock signal A used for synchronous operations.\n\tclk_b: Clock signal B used for synchronous operations.\n\tarstn: Active-low reset signal A. Defined as 0 for reset and 1 for reset signal inactive.\n\tbrstn: Active-low reset signal B. Defined as 0 for reset and 1 for reset signal inactive.\n\tdata_in: Input data signal of size 4 bits.\n\tdata_en: Input enable signal that controls the selection operation.\n\nOutput ports:\n    dataout: Output data signal of size 4 bits.\n\nImplementation:\nData Register:\nThe module includes a register, data_reg, to store the input data signal, data_in.\nOn the positive edge of clock signal A (clk_a) or the falling edge of reset signal A (arstn), the module updates the register. If the reset signal A (arstn) is low, indicating a reset condition, the register (data_reg) is set to 0. If the reset signal A (arstn) is high, the register (data_reg) is updated with the input data signal (data_in).\nEnable Data Register:\nThe module includes a register, en_data_reg, to store the input enable signal, data_en.\nOn the positive edge of clock signal A (clk_a) or the falling edge of reset signal A (arstn), the module updates the register. If the reset signal A (arstn) is low, the register (en_data_reg) is set to 0. If the reset signal A (arstn) is high, the register (en_data_reg) is updated with the input enable signal (data_en).\nEnable Control Registers:\nThe module includes two registers, en_clap_one and en_clap_two, to control the selection of the input data. On the positive edge of clock signal B (clk_b) or the falling edge of reset signal B (brstn), the module updates the registers. If the reset signal B (brstn) is low, indicating a reset condition, both registers (en_clap_one and en_clap_two) are set to 0.\nIf the reset signal B (brstn) is high, the registers (en_clap_one and en_clap_two) are updated based on the value of en_data_reg. The register en_clap_one is assigned the value of en_data_reg, and en_clap_two is assigned the previous value of en_clap_one.\nOutput Assignment:\nOn the positive edge of clock signal B (clk_b) or the falling edge of reset signal B (brstn), the module assigns the output data value. If the reset signal B (brstn) is low, indicating a reset condition, the output data (dataout) is set to 0. If the reset signal B (brstn) is high and the control signal (en_clap_two) is active, the output data (dataout) is assigned the value of the data register (data_reg). If the control signal (en_clap_two) is inactive, the output data (dataout) retains its previous value.\n\nGive me the complete code.\n"}, "clean_code": "module synchronizer(\n\tinput \t\t\t\tclk_a\t, \n\tinput \t\t\t\tclk_b\t,   \n\tinput \t\t\t\tarstn\t,\n\tinput\t\t\t\tbrstn   ,\n\tinput\t\t[3:0]\tdata_in\t,\n\tinput               data_en ,\n\n\toutput reg  [3:0] \tdataout\n);\n\nreg\t[3:0]\tdata_reg;\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!arstn)\tdata_reg <= 0;\n\t\telse\tdata_reg <= data_in;\nend\nreg en_data_reg;\t\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!brstn)\ten_data_reg <= 0;\n\t\telse\ten_data_reg <= data_en;   \nend\n\nreg\ten_clap_one;\t//1\nreg en_clap_two;\t//2\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_one <= 0;\n\t\telse\ten_clap_one <= en_data_reg;\t\nend\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_two <= 0;\n\t\telse\ten_clap_two <= en_clap_one;\nend\n\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\tdataout <= 0;\n\t\telse\tdataout <= (en_clap_two) ? data_reg : dataout;\nend\n\nendmodule\n", "corrupted_code": "module synchronizer(\n\tinput \t\t\t\tclk_a\t, \n\tinput \t\t\t\tclk_b\t,   \n\tinput \t\t\t\tarstn\t,\n\tinput\t\t\t\tbrstn   ,\n\tinput\t\t[3:0]\tdata_in\t,\n\tinput               data_en ,\n\n\toutput reg  [3:0] \tdataout\n);\n\nreg\t[3:0]\tdata_reg;\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!arstn)\tdata_reg <= 0;\n\t\telse\tdata_reg <= data_in;\nend\nreg en_data_reg;\t\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!brstn)\ten_data_reg <= 0;\n\t\telse\ten_data_reg <= data_en;   \nend\n\nreg\ten_clap_one;\t//1\nreg en_clap_two;\t//2\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_one <= 0;\n\t\telse\ten_data_reg <= en_clap_one;\t\nend\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_two <= 0;\n\t\telse\ten_clap_two <= en_clap_one;\nend\n\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\tdataout <= 0;\n\t\telse\tdataout <= (en_clap_two) ? data_reg : dataout;\nend\n\nendmodule\n", "corruption_explanation": "Swapped operands: 'en_clap_one <= en_data_reg' -> 'en_data_reg <= en_clap_one'", "modification_type": "swap_operands", "modification_line": 30, "original_snippet": "en_clap_one <= en_data_reg", "modified_snippet": "en_data_reg <= en_clap_one", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'en_clap_one <= en_data_reg' -> 'en_data_reg <= en_clap_one'\n   \u2022 Line 30: Original: en_clap_one <= en_data_reg\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 30.\n   \u2022 Restore the original code: en_clap_one <= en_data_reg\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 14, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_operands"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.480772", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "synchronizer", "module_name": "synchronizer", "description": "Please act as a professional verilog designer.\n\nImplement a multi-bit MUX-based synchronizer, data_in will remain constant during the period when data_en is high, and data_en is high for at least 3 clk_b clock cycles. When the value of data_en is high, data can be synchronized. The data change frequency of data_in is very low. The change interval between two adjacent data is at least 10 clk_b clock cycles.\nThe clock clk_a is responsible for: input data_in is refer to clock a. enable signal data_en is refer to clock a.\nThe clock clk_b is responsible for the enable signal data_en delays two cycles, that is, two D flip-flops. This is done with reference to clock b. And the data is finally output dataout, and the output refers to clock b.\n\nModule name:  \n    synchronizer  \n\nInput ports:\n\tclk_a: Clock signal A used for synchronous operations.\n\tclk_b: Clock signal B used for synchronous operations.\n\tarstn: Active-low reset signal A. Defined as 0 for reset and 1 for reset signal inactive.\n\tbrstn: Active-low reset signal B. Defined as 0 for reset and 1 for reset signal inactive.\n\tdata_in: Input data signal of size 4 bits.\n\tdata_en: Input enable signal that controls the selection operation.\n\nOutput ports:\n    dataout: Output data signal of size 4 bits.\n\nImplementation:\nData Register:\nThe module includes a register, data_reg, to store the input data signal, data_in.\nOn the positive edge of clock signal A (clk_a) or the falling edge of reset signal A (arstn), the module updates the register. If the reset signal A (arstn) is low, indicating a reset condition, the register (data_reg) is set to 0. If the reset signal A (arstn) is high, the register (data_reg) is updated with the input data signal (data_in).\nEnable Data Register:\nThe module includes a register, en_data_reg, to store the input enable signal, data_en.\nOn the positive edge of clock signal A (clk_a) or the falling edge of reset signal A (arstn), the module updates the register. If the reset signal A (arstn) is low, the register (en_data_reg) is set to 0. If the reset signal A (arstn) is high, the register (en_data_reg) is updated with the input enable signal (data_en).\nEnable Control Registers:\nThe module includes two registers, en_clap_one and en_clap_two, to control the selection of the input data. On the positive edge of clock signal B (clk_b) or the falling edge of reset signal B (brstn), the module updates the registers. If the reset signal B (brstn) is low, indicating a reset condition, both registers (en_clap_one and en_clap_two) are set to 0.\nIf the reset signal B (brstn) is high, the registers (en_clap_one and en_clap_two) are updated based on the value of en_data_reg. The register en_clap_one is assigned the value of en_data_reg, and en_clap_two is assigned the previous value of en_clap_one.\nOutput Assignment:\nOn the positive edge of clock signal B (clk_b) or the falling edge of reset signal B (brstn), the module assigns the output data value. If the reset signal B (brstn) is low, indicating a reset condition, the output data (dataout) is set to 0. If the reset signal B (brstn) is high and the control signal (en_clap_two) is active, the output data (dataout) is assigned the value of the data register (data_reg). If the control signal (en_clap_two) is inactive, the output data (dataout) retains its previous value.\n\nGive me the complete code.\n"}, "clean_code": "module synchronizer(\n\tinput \t\t\t\tclk_a\t, \n\tinput \t\t\t\tclk_b\t,   \n\tinput \t\t\t\tarstn\t,\n\tinput\t\t\t\tbrstn   ,\n\tinput\t\t[3:0]\tdata_in\t,\n\tinput               data_en ,\n\n\toutput reg  [3:0] \tdataout\n);\n\nreg\t[3:0]\tdata_reg;\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!arstn)\tdata_reg <= 0;\n\t\telse\tdata_reg <= data_in;\nend\nreg en_data_reg;\t\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!brstn)\ten_data_reg <= 0;\n\t\telse\ten_data_reg <= data_en;   \nend\n\nreg\ten_clap_one;\t//1\nreg en_clap_two;\t//2\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_one <= 0;\n\t\telse\ten_clap_one <= en_data_reg;\t\nend\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_two <= 0;\n\t\telse\ten_clap_two <= en_clap_one;\nend\n\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\tdataout <= 0;\n\t\telse\tdataout <= (en_clap_two) ? data_reg : dataout;\nend\n\nendmodule\n", "corrupted_code": "module synchronizer(\n\tinput \t\t\t\tclk_a\t, \n\tinput \t\t\t\tclk_b\t,   \n\tinput \t\t\t\tarstn\t,\n\tinput\t\t\t\tbrstn   ,\n\tinput\t\t[3:0]\tdata_in\t,\n\tinput               data_en ,\n\n\toutput reg  [3:0] \tdataout\n);\n\nreg\t[3:0]\tdata_reg;\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!arstn)\tdata_reg <= 0;\n\t\telse\tdata_reg <= data_in;\nend\nreg en_data_reg;\t\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!brstn)\ten_data_reg <= 0;\n\t\telse\ten_data_reg <= data_en;   \nend\n\nreg\ten_clap_one;\t//1\nreg en_clap_two;\t//2\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_one <= 0;\n\t\telse\ten_clap_one <= en_data_reg;\t\nend\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_two <= 0;\n\t\telse\ten_clap_two <= en_clap_one;\nend\n\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\tdataout <= 0;\n\t\telse\tdataout <= (en_clap_two) ? data_reg : dataout;\nend\n\n\n    wire clk_dup;\n    assign clk_dup = clk_a;\nendmodule\n", "corruption_explanation": "Added duplicate clock signal clk_dup", "modification_type": "duplicate_clock_signal", "modification_line": 18, "original_snippet": "(none)", "modified_snippet": "wire clk_dup;\n    assign clk_dup = clk_a;", "issue_description": "The buggy code has a duplicate clock signal. A phantom clock domain is created, which may confuse CDC analysis tools and create subtle timing issues in synthesis. This violates clock domain design best practices.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a duplicate_clock_signal modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added duplicate clock signal clk_dup\n   \u2022 Line 18: Original: (none)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 18.\n   \u2022 Restore the original code: (none)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to duplicate clock signal.", "complexity": 14, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["duplicate_clock_signal"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.482192", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "synchronizer", "module_name": "synchronizer", "description": "Please act as a professional verilog designer.\n\nImplement a multi-bit MUX-based synchronizer, data_in will remain constant during the period when data_en is high, and data_en is high for at least 3 clk_b clock cycles. When the value of data_en is high, data can be synchronized. The data change frequency of data_in is very low. The change interval between two adjacent data is at least 10 clk_b clock cycles.\nThe clock clk_a is responsible for: input data_in is refer to clock a. enable signal data_en is refer to clock a.\nThe clock clk_b is responsible for the enable signal data_en delays two cycles, that is, two D flip-flops. This is done with reference to clock b. And the data is finally output dataout, and the output refers to clock b.\n\nModule name:  \n    synchronizer  \n\nInput ports:\n\tclk_a: Clock signal A used for synchronous operations.\n\tclk_b: Clock signal B used for synchronous operations.\n\tarstn: Active-low reset signal A. Defined as 0 for reset and 1 for reset signal inactive.\n\tbrstn: Active-low reset signal B. Defined as 0 for reset and 1 for reset signal inactive.\n\tdata_in: Input data signal of size 4 bits.\n\tdata_en: Input enable signal that controls the selection operation.\n\nOutput ports:\n    dataout: Output data signal of size 4 bits.\n\nImplementation:\nData Register:\nThe module includes a register, data_reg, to store the input data signal, data_in.\nOn the positive edge of clock signal A (clk_a) or the falling edge of reset signal A (arstn), the module updates the register. If the reset signal A (arstn) is low, indicating a reset condition, the register (data_reg) is set to 0. If the reset signal A (arstn) is high, the register (data_reg) is updated with the input data signal (data_in).\nEnable Data Register:\nThe module includes a register, en_data_reg, to store the input enable signal, data_en.\nOn the positive edge of clock signal A (clk_a) or the falling edge of reset signal A (arstn), the module updates the register. If the reset signal A (arstn) is low, the register (en_data_reg) is set to 0. If the reset signal A (arstn) is high, the register (en_data_reg) is updated with the input enable signal (data_en).\nEnable Control Registers:\nThe module includes two registers, en_clap_one and en_clap_two, to control the selection of the input data. On the positive edge of clock signal B (clk_b) or the falling edge of reset signal B (brstn), the module updates the registers. If the reset signal B (brstn) is low, indicating a reset condition, both registers (en_clap_one and en_clap_two) are set to 0.\nIf the reset signal B (brstn) is high, the registers (en_clap_one and en_clap_two) are updated based on the value of en_data_reg. The register en_clap_one is assigned the value of en_data_reg, and en_clap_two is assigned the previous value of en_clap_one.\nOutput Assignment:\nOn the positive edge of clock signal B (clk_b) or the falling edge of reset signal B (brstn), the module assigns the output data value. If the reset signal B (brstn) is low, indicating a reset condition, the output data (dataout) is set to 0. If the reset signal B (brstn) is high and the control signal (en_clap_two) is active, the output data (dataout) is assigned the value of the data register (data_reg). If the control signal (en_clap_two) is inactive, the output data (dataout) retains its previous value.\n\nGive me the complete code.\n"}, "clean_code": "module synchronizer(\n\tinput \t\t\t\tclk_a\t, \n\tinput \t\t\t\tclk_b\t,   \n\tinput \t\t\t\tarstn\t,\n\tinput\t\t\t\tbrstn   ,\n\tinput\t\t[3:0]\tdata_in\t,\n\tinput               data_en ,\n\n\toutput reg  [3:0] \tdataout\n);\n\nreg\t[3:0]\tdata_reg;\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!arstn)\tdata_reg <= 0;\n\t\telse\tdata_reg <= data_in;\nend\nreg en_data_reg;\t\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!brstn)\ten_data_reg <= 0;\n\t\telse\ten_data_reg <= data_en;   \nend\n\nreg\ten_clap_one;\t//1\nreg en_clap_two;\t//2\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_one <= 0;\n\t\telse\ten_clap_one <= en_data_reg;\t\nend\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_two <= 0;\n\t\telse\ten_clap_two <= en_clap_one;\nend\n\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\tdataout <= 0;\n\t\telse\tdataout <= (en_clap_two) ? data_reg : dataout;\nend\n\nendmodule\n", "corrupted_code": "module synchronizer(\n\tinput \t\t\t\tclk_a\t, \n\tinput \t\t\t\tclk_b\t,   \n\tinput \t\t\t\tarstn\t,\n\tinput\t\t\t\tbrstn   ,\n\tinput\t\t[3:0]\tdata_in\t,\n\tinput               data_en ,\n\n\toutput reg  [3:0] \tdataout\n);\n\nreg\t[3:0]\tdata_reg;\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!arstn)\tdata_reg <= 0;\n\t\telse\tdata_reg <= data_in;\nend\nreg en_data_reg;\t\nalways@(posedge clk_a)\nbegin\n\tif(!brstn)\ten_data_reg <= 0;\n\t\telse\ten_data_reg <= data_en;   \nend\n\nreg\ten_clap_one;\t//1\nreg en_clap_two;\t//2\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_one <= 0;\n\t\telse\ten_clap_one <= en_data_reg;\t\nend\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_two <= 0;\n\t\telse\ten_clap_two <= en_clap_one;\nend\n\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\tdataout <= 0;\n\t\telse\tdataout <= (en_clap_two) ? data_reg : dataout;\nend\n\nendmodule\n", "corruption_explanation": "Removed async reset from sensitivity list", "modification_type": "remove_async_reset", "modification_line": 19, "original_snippet": "always@(posedge clk_a or negedge arstn)", "modified_snippet": "always@(posedge clk_a)", "issue_description": "The buggy code has removed async reset from the sensitivity list. The always block only triggers on clock edges, not reset. This causes metastability on power-up and removes the ability to asynchronously reset the design.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_async_reset modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed async reset from sensitivity list\n   \u2022 Line 19: Original: always@(posedge clk_a or negedge arstn)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 19.\n   \u2022 Restore the original code: always@(posedge clk_a or negedge arstn)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove async reset.", "complexity": 14, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_async_reset"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.483590", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "synchronizer", "module_name": "synchronizer", "description": "Please act as a professional verilog designer.\n\nImplement a multi-bit MUX-based synchronizer, data_in will remain constant during the period when data_en is high, and data_en is high for at least 3 clk_b clock cycles. When the value of data_en is high, data can be synchronized. The data change frequency of data_in is very low. The change interval between two adjacent data is at least 10 clk_b clock cycles.\nThe clock clk_a is responsible for: input data_in is refer to clock a. enable signal data_en is refer to clock a.\nThe clock clk_b is responsible for the enable signal data_en delays two cycles, that is, two D flip-flops. This is done with reference to clock b. And the data is finally output dataout, and the output refers to clock b.\n\nModule name:  \n    synchronizer  \n\nInput ports:\n\tclk_a: Clock signal A used for synchronous operations.\n\tclk_b: Clock signal B used for synchronous operations.\n\tarstn: Active-low reset signal A. Defined as 0 for reset and 1 for reset signal inactive.\n\tbrstn: Active-low reset signal B. Defined as 0 for reset and 1 for reset signal inactive.\n\tdata_in: Input data signal of size 4 bits.\n\tdata_en: Input enable signal that controls the selection operation.\n\nOutput ports:\n    dataout: Output data signal of size 4 bits.\n\nImplementation:\nData Register:\nThe module includes a register, data_reg, to store the input data signal, data_in.\nOn the positive edge of clock signal A (clk_a) or the falling edge of reset signal A (arstn), the module updates the register. If the reset signal A (arstn) is low, indicating a reset condition, the register (data_reg) is set to 0. If the reset signal A (arstn) is high, the register (data_reg) is updated with the input data signal (data_in).\nEnable Data Register:\nThe module includes a register, en_data_reg, to store the input enable signal, data_en.\nOn the positive edge of clock signal A (clk_a) or the falling edge of reset signal A (arstn), the module updates the register. If the reset signal A (arstn) is low, the register (en_data_reg) is set to 0. If the reset signal A (arstn) is high, the register (en_data_reg) is updated with the input enable signal (data_en).\nEnable Control Registers:\nThe module includes two registers, en_clap_one and en_clap_two, to control the selection of the input data. On the positive edge of clock signal B (clk_b) or the falling edge of reset signal B (brstn), the module updates the registers. If the reset signal B (brstn) is low, indicating a reset condition, both registers (en_clap_one and en_clap_two) are set to 0.\nIf the reset signal B (brstn) is high, the registers (en_clap_one and en_clap_two) are updated based on the value of en_data_reg. The register en_clap_one is assigned the value of en_data_reg, and en_clap_two is assigned the previous value of en_clap_one.\nOutput Assignment:\nOn the positive edge of clock signal B (clk_b) or the falling edge of reset signal B (brstn), the module assigns the output data value. If the reset signal B (brstn) is low, indicating a reset condition, the output data (dataout) is set to 0. If the reset signal B (brstn) is high and the control signal (en_clap_two) is active, the output data (dataout) is assigned the value of the data register (data_reg). If the control signal (en_clap_two) is inactive, the output data (dataout) retains its previous value.\n\nGive me the complete code.\n"}, "clean_code": "module synchronizer(\n\tinput \t\t\t\tclk_a\t, \n\tinput \t\t\t\tclk_b\t,   \n\tinput \t\t\t\tarstn\t,\n\tinput\t\t\t\tbrstn   ,\n\tinput\t\t[3:0]\tdata_in\t,\n\tinput               data_en ,\n\n\toutput reg  [3:0] \tdataout\n);\n\nreg\t[3:0]\tdata_reg;\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!arstn)\tdata_reg <= 0;\n\t\telse\tdata_reg <= data_in;\nend\nreg en_data_reg;\t\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!brstn)\ten_data_reg <= 0;\n\t\telse\ten_data_reg <= data_en;   \nend\n\nreg\ten_clap_one;\t//1\nreg en_clap_two;\t//2\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_one <= 0;\n\t\telse\ten_clap_one <= en_data_reg;\t\nend\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_two <= 0;\n\t\telse\ten_clap_two <= en_clap_one;\nend\n\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\tdataout <= 0;\n\t\telse\tdataout <= (en_clap_two) ? data_reg : dataout;\nend\n\nendmodule\n", "corrupted_code": "module synchronizer(\n\tinput \t\t\t\tclk_a\t, \n\tinput \t\t\t\tclk_b\t,   \n\tinput \t\t\t\tarstn\t,\n\tinput\t\t\t\tbrstn   ,\n\tinput\t\t[3:0]\tdata_in\t,\n\tinput               data_en ,\n\n\toutput reg  [3:0] \tdataout\n);\n\nreg\t[3:0]\tdata_reg;\nalways@(posedge clk_a)\nbegin\n\tif(!arstn)\tdata_reg <= 0;\n\t\telse\tdata_reg <= data_in;\nend\nreg en_data_reg;\t\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!brstn)\ten_data_reg <= 0;\n\t\telse\ten_data_reg <= data_en;   \nend\n\nreg\ten_clap_one;\t//1\nreg en_clap_two;\t//2\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_one <= 0;\n\t\telse\ten_clap_one <= en_data_reg;\t\nend\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_two <= 0;\n\t\telse\ten_clap_two <= en_clap_one;\nend\n\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\tdataout <= 0;\n\t\telse\tdataout <= (en_clap_two) ? data_reg : dataout;\nend\n\nendmodule\n", "corruption_explanation": "Removed async reset from sensitivity list", "modification_type": "remove_async_reset", "modification_line": 13, "original_snippet": "always@(posedge clk_a or negedge arstn)", "modified_snippet": "always@(posedge clk_a)", "issue_description": "The buggy code has removed async reset from the sensitivity list. The always block only triggers on clock edges, not reset. This causes metastability on power-up and removes the ability to asynchronously reset the design.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_async_reset modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed async reset from sensitivity list\n   \u2022 Line 13: Original: always@(posedge clk_a or negedge arstn)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 13.\n   \u2022 Restore the original code: always@(posedge clk_a or negedge arstn)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove async reset.", "complexity": 14, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_async_reset"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.485000", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "synchronizer", "module_name": "synchronizer", "description": "Please act as a professional verilog designer.\n\nImplement a multi-bit MUX-based synchronizer, data_in will remain constant during the period when data_en is high, and data_en is high for at least 3 clk_b clock cycles. When the value of data_en is high, data can be synchronized. The data change frequency of data_in is very low. The change interval between two adjacent data is at least 10 clk_b clock cycles.\nThe clock clk_a is responsible for: input data_in is refer to clock a. enable signal data_en is refer to clock a.\nThe clock clk_b is responsible for the enable signal data_en delays two cycles, that is, two D flip-flops. This is done with reference to clock b. And the data is finally output dataout, and the output refers to clock b.\n\nModule name:  \n    synchronizer  \n\nInput ports:\n\tclk_a: Clock signal A used for synchronous operations.\n\tclk_b: Clock signal B used for synchronous operations.\n\tarstn: Active-low reset signal A. Defined as 0 for reset and 1 for reset signal inactive.\n\tbrstn: Active-low reset signal B. Defined as 0 for reset and 1 for reset signal inactive.\n\tdata_in: Input data signal of size 4 bits.\n\tdata_en: Input enable signal that controls the selection operation.\n\nOutput ports:\n    dataout: Output data signal of size 4 bits.\n\nImplementation:\nData Register:\nThe module includes a register, data_reg, to store the input data signal, data_in.\nOn the positive edge of clock signal A (clk_a) or the falling edge of reset signal A (arstn), the module updates the register. If the reset signal A (arstn) is low, indicating a reset condition, the register (data_reg) is set to 0. If the reset signal A (arstn) is high, the register (data_reg) is updated with the input data signal (data_in).\nEnable Data Register:\nThe module includes a register, en_data_reg, to store the input enable signal, data_en.\nOn the positive edge of clock signal A (clk_a) or the falling edge of reset signal A (arstn), the module updates the register. If the reset signal A (arstn) is low, the register (en_data_reg) is set to 0. If the reset signal A (arstn) is high, the register (en_data_reg) is updated with the input enable signal (data_en).\nEnable Control Registers:\nThe module includes two registers, en_clap_one and en_clap_two, to control the selection of the input data. On the positive edge of clock signal B (clk_b) or the falling edge of reset signal B (brstn), the module updates the registers. If the reset signal B (brstn) is low, indicating a reset condition, both registers (en_clap_one and en_clap_two) are set to 0.\nIf the reset signal B (brstn) is high, the registers (en_clap_one and en_clap_two) are updated based on the value of en_data_reg. The register en_clap_one is assigned the value of en_data_reg, and en_clap_two is assigned the previous value of en_clap_one.\nOutput Assignment:\nOn the positive edge of clock signal B (clk_b) or the falling edge of reset signal B (brstn), the module assigns the output data value. If the reset signal B (brstn) is low, indicating a reset condition, the output data (dataout) is set to 0. If the reset signal B (brstn) is high and the control signal (en_clap_two) is active, the output data (dataout) is assigned the value of the data register (data_reg). If the control signal (en_clap_two) is inactive, the output data (dataout) retains its previous value.\n\nGive me the complete code.\n"}, "clean_code": "module synchronizer(\n\tinput \t\t\t\tclk_a\t, \n\tinput \t\t\t\tclk_b\t,   \n\tinput \t\t\t\tarstn\t,\n\tinput\t\t\t\tbrstn   ,\n\tinput\t\t[3:0]\tdata_in\t,\n\tinput               data_en ,\n\n\toutput reg  [3:0] \tdataout\n);\n\nreg\t[3:0]\tdata_reg;\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!arstn)\tdata_reg <= 0;\n\t\telse\tdata_reg <= data_in;\nend\nreg en_data_reg;\t\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!brstn)\ten_data_reg <= 0;\n\t\telse\ten_data_reg <= data_en;   \nend\n\nreg\ten_clap_one;\t//1\nreg en_clap_two;\t//2\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_one <= 0;\n\t\telse\ten_clap_one <= en_data_reg;\t\nend\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_two <= 0;\n\t\telse\ten_clap_two <= en_clap_one;\nend\n\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\tdataout <= 0;\n\t\telse\tdataout <= (en_clap_two) ? data_reg : dataout;\nend\n\nendmodule\n", "corrupted_code": "module synchronizer(\n\tinput \t\t\t\tclk_a\t, \n\tinput \t\t\t\tclk_b\t,   \n\tinput \t\t\t\tarstn\t,\n\tinput\t\t\t\tbrstn   ,\n\tinput\t\t[3:0]\tdata_in\t,\n\tinput               data_en ,\n\n\toutput reg  [3:0] \tdataout\n);\n\nreg\t[3:0]\tdata_reg;\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!arstn)\tdata_reg <= 0;\n\t\telse\tdata_reg <= data_in;\nend\nreg en_data_reg;\t\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!brstn)\ten_data_reg <= 0;\n\t\telse\ten_data_reg <= data_en;   \nend\n\nreg\ten_clap_one;\t//1\nreg en_clap_two;\t//2\n\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_two <= 0;\n\t\telse\ten_clap_two <= en_clap_one;\nend\n\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\tdataout <= 0;\n\t\telse\tdataout <= (en_clap_two) ? data_reg : dataout;\nend\n\nendmodule\n", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 27, "original_snippet": "always@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_one <= 0;\n\t\telse\ten_clap_one <= en_data_reg;\t\nend", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 27: Original: always@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_one <= 0;\n\t\telse\ten_clap_one <= en_data_reg;\t\nend\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 27.\n   \u2022 Restore the original code: always@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_one <= 0;\n\t\telse\ten_clap_one <= en_data_reg;\t\nend\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 14, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.486393", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "synchronizer", "module_name": "synchronizer", "description": "Please act as a professional verilog designer.\n\nImplement a multi-bit MUX-based synchronizer, data_in will remain constant during the period when data_en is high, and data_en is high for at least 3 clk_b clock cycles. When the value of data_en is high, data can be synchronized. The data change frequency of data_in is very low. The change interval between two adjacent data is at least 10 clk_b clock cycles.\nThe clock clk_a is responsible for: input data_in is refer to clock a. enable signal data_en is refer to clock a.\nThe clock clk_b is responsible for the enable signal data_en delays two cycles, that is, two D flip-flops. This is done with reference to clock b. And the data is finally output dataout, and the output refers to clock b.\n\nModule name:  \n    synchronizer  \n\nInput ports:\n\tclk_a: Clock signal A used for synchronous operations.\n\tclk_b: Clock signal B used for synchronous operations.\n\tarstn: Active-low reset signal A. Defined as 0 for reset and 1 for reset signal inactive.\n\tbrstn: Active-low reset signal B. Defined as 0 for reset and 1 for reset signal inactive.\n\tdata_in: Input data signal of size 4 bits.\n\tdata_en: Input enable signal that controls the selection operation.\n\nOutput ports:\n    dataout: Output data signal of size 4 bits.\n\nImplementation:\nData Register:\nThe module includes a register, data_reg, to store the input data signal, data_in.\nOn the positive edge of clock signal A (clk_a) or the falling edge of reset signal A (arstn), the module updates the register. If the reset signal A (arstn) is low, indicating a reset condition, the register (data_reg) is set to 0. If the reset signal A (arstn) is high, the register (data_reg) is updated with the input data signal (data_in).\nEnable Data Register:\nThe module includes a register, en_data_reg, to store the input enable signal, data_en.\nOn the positive edge of clock signal A (clk_a) or the falling edge of reset signal A (arstn), the module updates the register. If the reset signal A (arstn) is low, the register (en_data_reg) is set to 0. If the reset signal A (arstn) is high, the register (en_data_reg) is updated with the input enable signal (data_en).\nEnable Control Registers:\nThe module includes two registers, en_clap_one and en_clap_two, to control the selection of the input data. On the positive edge of clock signal B (clk_b) or the falling edge of reset signal B (brstn), the module updates the registers. If the reset signal B (brstn) is low, indicating a reset condition, both registers (en_clap_one and en_clap_two) are set to 0.\nIf the reset signal B (brstn) is high, the registers (en_clap_one and en_clap_two) are updated based on the value of en_data_reg. The register en_clap_one is assigned the value of en_data_reg, and en_clap_two is assigned the previous value of en_clap_one.\nOutput Assignment:\nOn the positive edge of clock signal B (clk_b) or the falling edge of reset signal B (brstn), the module assigns the output data value. If the reset signal B (brstn) is low, indicating a reset condition, the output data (dataout) is set to 0. If the reset signal B (brstn) is high and the control signal (en_clap_two) is active, the output data (dataout) is assigned the value of the data register (data_reg). If the control signal (en_clap_two) is inactive, the output data (dataout) retains its previous value.\n\nGive me the complete code.\n"}, "clean_code": "module synchronizer(\n\tinput \t\t\t\tclk_a\t, \n\tinput \t\t\t\tclk_b\t,   \n\tinput \t\t\t\tarstn\t,\n\tinput\t\t\t\tbrstn   ,\n\tinput\t\t[3:0]\tdata_in\t,\n\tinput               data_en ,\n\n\toutput reg  [3:0] \tdataout\n);\n\nreg\t[3:0]\tdata_reg;\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!arstn)\tdata_reg <= 0;\n\t\telse\tdata_reg <= data_in;\nend\nreg en_data_reg;\t\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!brstn)\ten_data_reg <= 0;\n\t\telse\ten_data_reg <= data_en;   \nend\n\nreg\ten_clap_one;\t//1\nreg en_clap_two;\t//2\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_one <= 0;\n\t\telse\ten_clap_one <= en_data_reg;\t\nend\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_two <= 0;\n\t\telse\ten_clap_two <= en_clap_one;\nend\n\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\tdataout <= 0;\n\t\telse\tdataout <= (en_clap_two) ? data_reg : dataout;\nend\n\nendmodule\n", "corrupted_code": "module synchronizer(\n\tinput \t\t\t\tclk_a\t, \n\tinput \t\t\t\tclk_b\t,   \n\tinput \t\t\t\tarstn\t,\n\tinput\t\t\t\tbrstn   ,\n\tinput\t\t[3:0]\tdata_in\t,\n\tinput               data_en ,\n\n\toutput reg  [3:0] \tdataout\n);\n\nreg\t[3:0]\tdata_reg;\nalways@(posedge clk_a)\nbegin\n\tif(!arstn)\tdata_reg <= 0;\n\t\telse\tdata_reg <= data_in;\nend\nreg en_data_reg;\t\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!brstn)\ten_data_reg <= 0;\n\t\telse\ten_data_reg <= data_en;   \nend\n\nreg\ten_clap_one;\t//1\nreg en_clap_two;\t//2\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_one <= 0;\n\t\telse\ten_clap_one <= en_data_reg;\t\nend\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_two <= 0;\n\t\telse\ten_clap_two <= en_clap_one;\nend\n\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\tdataout <= 0;\n\t\telse\tdataout <= (en_clap_two) ? data_reg : dataout;\nend\n\nendmodule\n", "corruption_explanation": "Removed async reset from sensitivity list", "modification_type": "remove_async_reset", "modification_line": 13, "original_snippet": "always@(posedge clk_a or negedge arstn)", "modified_snippet": "always@(posedge clk_a)", "issue_description": "The buggy code has removed async reset from the sensitivity list. The always block only triggers on clock edges, not reset. This causes metastability on power-up and removes the ability to asynchronously reset the design.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_async_reset modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed async reset from sensitivity list\n   \u2022 Line 13: Original: always@(posedge clk_a or negedge arstn)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 13.\n   \u2022 Restore the original code: always@(posedge clk_a or negedge arstn)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove async reset.", "complexity": 14, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_async_reset"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.487762", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "synchronizer", "module_name": "synchronizer", "description": "Please act as a professional verilog designer.\n\nImplement a multi-bit MUX-based synchronizer, data_in will remain constant during the period when data_en is high, and data_en is high for at least 3 clk_b clock cycles. When the value of data_en is high, data can be synchronized. The data change frequency of data_in is very low. The change interval between two adjacent data is at least 10 clk_b clock cycles.\nThe clock clk_a is responsible for: input data_in is refer to clock a. enable signal data_en is refer to clock a.\nThe clock clk_b is responsible for the enable signal data_en delays two cycles, that is, two D flip-flops. This is done with reference to clock b. And the data is finally output dataout, and the output refers to clock b.\n\nModule name:  \n    synchronizer  \n\nInput ports:\n\tclk_a: Clock signal A used for synchronous operations.\n\tclk_b: Clock signal B used for synchronous operations.\n\tarstn: Active-low reset signal A. Defined as 0 for reset and 1 for reset signal inactive.\n\tbrstn: Active-low reset signal B. Defined as 0 for reset and 1 for reset signal inactive.\n\tdata_in: Input data signal of size 4 bits.\n\tdata_en: Input enable signal that controls the selection operation.\n\nOutput ports:\n    dataout: Output data signal of size 4 bits.\n\nImplementation:\nData Register:\nThe module includes a register, data_reg, to store the input data signal, data_in.\nOn the positive edge of clock signal A (clk_a) or the falling edge of reset signal A (arstn), the module updates the register. If the reset signal A (arstn) is low, indicating a reset condition, the register (data_reg) is set to 0. If the reset signal A (arstn) is high, the register (data_reg) is updated with the input data signal (data_in).\nEnable Data Register:\nThe module includes a register, en_data_reg, to store the input enable signal, data_en.\nOn the positive edge of clock signal A (clk_a) or the falling edge of reset signal A (arstn), the module updates the register. If the reset signal A (arstn) is low, the register (en_data_reg) is set to 0. If the reset signal A (arstn) is high, the register (en_data_reg) is updated with the input enable signal (data_en).\nEnable Control Registers:\nThe module includes two registers, en_clap_one and en_clap_two, to control the selection of the input data. On the positive edge of clock signal B (clk_b) or the falling edge of reset signal B (brstn), the module updates the registers. If the reset signal B (brstn) is low, indicating a reset condition, both registers (en_clap_one and en_clap_two) are set to 0.\nIf the reset signal B (brstn) is high, the registers (en_clap_one and en_clap_two) are updated based on the value of en_data_reg. The register en_clap_one is assigned the value of en_data_reg, and en_clap_two is assigned the previous value of en_clap_one.\nOutput Assignment:\nOn the positive edge of clock signal B (clk_b) or the falling edge of reset signal B (brstn), the module assigns the output data value. If the reset signal B (brstn) is low, indicating a reset condition, the output data (dataout) is set to 0. If the reset signal B (brstn) is high and the control signal (en_clap_two) is active, the output data (dataout) is assigned the value of the data register (data_reg). If the control signal (en_clap_two) is inactive, the output data (dataout) retains its previous value.\n\nGive me the complete code.\n"}, "clean_code": "module synchronizer(\n\tinput \t\t\t\tclk_a\t, \n\tinput \t\t\t\tclk_b\t,   \n\tinput \t\t\t\tarstn\t,\n\tinput\t\t\t\tbrstn   ,\n\tinput\t\t[3:0]\tdata_in\t,\n\tinput               data_en ,\n\n\toutput reg  [3:0] \tdataout\n);\n\nreg\t[3:0]\tdata_reg;\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!arstn)\tdata_reg <= 0;\n\t\telse\tdata_reg <= data_in;\nend\nreg en_data_reg;\t\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!brstn)\ten_data_reg <= 0;\n\t\telse\ten_data_reg <= data_en;   \nend\n\nreg\ten_clap_one;\t//1\nreg en_clap_two;\t//2\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_one <= 0;\n\t\telse\ten_clap_one <= en_data_reg;\t\nend\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_two <= 0;\n\t\telse\ten_clap_two <= en_clap_one;\nend\n\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\tdataout <= 0;\n\t\telse\tdataout <= (en_clap_two) ? data_reg : dataout;\nend\n\nendmodule\n", "corrupted_code": "module synchronizer(\n\tinput \t\t\t\tclk_a\t, \n\tinput \t\t\t\tclk_b\t,   \n\tinput \t\t\t\tarstn\t,\n\tinput\t\t\t\tbrstn   ,\n\tinput\t\t[3:0]\tdata_in\t,\n\tinput               data_en ,\n\n\toutput reg  [3:0] \tdataout\n);\n\nreg\t[3:0]\tdata_reg;\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!arstn)\tdata_reg <= 0;\n\t\telse\tdata_reg <= data_in;\nend\nreg en_data_reg;\t\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!brstn)\ten_data_reg <= 0;\n\t\telse\ten_data_reg <= data_en;   \nend\n\nreg\ten_clap_one;\t//1\nreg en_clap_two;\t//2\n\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_two <= 0;\n\t\telse\ten_clap_two <= en_clap_one;\nend\n\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\tdataout <= 0;\n\t\telse\tdataout <= (en_clap_two) ? data_reg : dataout;\nend\n\nendmodule\n", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 27, "original_snippet": "always@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_one <= 0;\n\t\telse\ten_clap_one <= en_data_reg;\t\nend", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 27: Original: always@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_one <= 0;\n\t\telse\ten_clap_one <= en_data_reg;\t\nend\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 27.\n   \u2022 Restore the original code: always@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_one <= 0;\n\t\telse\ten_clap_one <= en_data_reg;\t\nend\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 14, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.489134", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "synchronizer", "module_name": "synchronizer", "description": "Please act as a professional verilog designer.\n\nImplement a multi-bit MUX-based synchronizer, data_in will remain constant during the period when data_en is high, and data_en is high for at least 3 clk_b clock cycles. When the value of data_en is high, data can be synchronized. The data change frequency of data_in is very low. The change interval between two adjacent data is at least 10 clk_b clock cycles.\nThe clock clk_a is responsible for: input data_in is refer to clock a. enable signal data_en is refer to clock a.\nThe clock clk_b is responsible for the enable signal data_en delays two cycles, that is, two D flip-flops. This is done with reference to clock b. And the data is finally output dataout, and the output refers to clock b.\n\nModule name:  \n    synchronizer  \n\nInput ports:\n\tclk_a: Clock signal A used for synchronous operations.\n\tclk_b: Clock signal B used for synchronous operations.\n\tarstn: Active-low reset signal A. Defined as 0 for reset and 1 for reset signal inactive.\n\tbrstn: Active-low reset signal B. Defined as 0 for reset and 1 for reset signal inactive.\n\tdata_in: Input data signal of size 4 bits.\n\tdata_en: Input enable signal that controls the selection operation.\n\nOutput ports:\n    dataout: Output data signal of size 4 bits.\n\nImplementation:\nData Register:\nThe module includes a register, data_reg, to store the input data signal, data_in.\nOn the positive edge of clock signal A (clk_a) or the falling edge of reset signal A (arstn), the module updates the register. If the reset signal A (arstn) is low, indicating a reset condition, the register (data_reg) is set to 0. If the reset signal A (arstn) is high, the register (data_reg) is updated with the input data signal (data_in).\nEnable Data Register:\nThe module includes a register, en_data_reg, to store the input enable signal, data_en.\nOn the positive edge of clock signal A (clk_a) or the falling edge of reset signal A (arstn), the module updates the register. If the reset signal A (arstn) is low, the register (en_data_reg) is set to 0. If the reset signal A (arstn) is high, the register (en_data_reg) is updated with the input enable signal (data_en).\nEnable Control Registers:\nThe module includes two registers, en_clap_one and en_clap_two, to control the selection of the input data. On the positive edge of clock signal B (clk_b) or the falling edge of reset signal B (brstn), the module updates the registers. If the reset signal B (brstn) is low, indicating a reset condition, both registers (en_clap_one and en_clap_two) are set to 0.\nIf the reset signal B (brstn) is high, the registers (en_clap_one and en_clap_two) are updated based on the value of en_data_reg. The register en_clap_one is assigned the value of en_data_reg, and en_clap_two is assigned the previous value of en_clap_one.\nOutput Assignment:\nOn the positive edge of clock signal B (clk_b) or the falling edge of reset signal B (brstn), the module assigns the output data value. If the reset signal B (brstn) is low, indicating a reset condition, the output data (dataout) is set to 0. If the reset signal B (brstn) is high and the control signal (en_clap_two) is active, the output data (dataout) is assigned the value of the data register (data_reg). If the control signal (en_clap_two) is inactive, the output data (dataout) retains its previous value.\n\nGive me the complete code.\n"}, "clean_code": "module synchronizer(\n\tinput \t\t\t\tclk_a\t, \n\tinput \t\t\t\tclk_b\t,   \n\tinput \t\t\t\tarstn\t,\n\tinput\t\t\t\tbrstn   ,\n\tinput\t\t[3:0]\tdata_in\t,\n\tinput               data_en ,\n\n\toutput reg  [3:0] \tdataout\n);\n\nreg\t[3:0]\tdata_reg;\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!arstn)\tdata_reg <= 0;\n\t\telse\tdata_reg <= data_in;\nend\nreg en_data_reg;\t\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!brstn)\ten_data_reg <= 0;\n\t\telse\ten_data_reg <= data_en;   \nend\n\nreg\ten_clap_one;\t//1\nreg en_clap_two;\t//2\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_one <= 0;\n\t\telse\ten_clap_one <= en_data_reg;\t\nend\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_two <= 0;\n\t\telse\ten_clap_two <= en_clap_one;\nend\n\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\tdataout <= 0;\n\t\telse\tdataout <= (en_clap_two) ? data_reg : dataout;\nend\n\nendmodule\n", "corrupted_code": "module synchronizer(\n\tinput \t\t\t\tclk_a\t, \n\tinput \t\t\t\tclk_b\t,   \n\tinput \t\t\t\tarstn\t,\n\tinput\t\t\t\tbrstn   ,\n\tinput\t\t[3:0]\tdata_in\t,\n\tinput               data_en ,\n\n\toutput reg  [3:0] \tdataout\n);\n\nreg\t[3:0]\tdata_reg;\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!arstn)\t <= data_in;\nend\nreg en_data_reg;\t\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!brstn)\ten_data_reg <= 0;\n\t\telse\ten_data_reg <= data_en;   \nend\n\nreg\ten_clap_one;\t//1\nreg en_clap_two;\t//2\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_one <= 0;\n\t\telse\ten_clap_one <= en_data_reg;\t\nend\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_two <= 0;\n\t\telse\ten_clap_two <= en_clap_one;\nend\n\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\tdataout <= 0;\n\t\telse\tdataout <= (en_clap_two) ? data_reg : dataout;\nend\n\nendmodule\n", "corruption_explanation": "Removed CDC synchronizer stage", "modification_type": "modify_cdc", "modification_line": 15, "original_snippet": "data_reg <= 0;\n\t\telse\tdata_reg", "modified_snippet": "(removed)", "issue_description": "The buggy code has a broken clock domain crossing synchronizer. A synchronizer flip-flop stage was removed, reducing metastability protection. This creates CDC violations that cause random data corruption in multi-clock domain designs.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a modify_cdc modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed CDC synchronizer stage\n   \u2022 Line 15: Original: data_reg <= 0;\n\t\telse\tdata_reg\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 15.\n   \u2022 Restore the original code: data_reg <= 0;\n\t\telse\tdata_reg\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to modify cdc.", "complexity": 14, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["modify_cdc"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.490663", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "synchronizer", "module_name": "synchronizer", "description": "Please act as a professional verilog designer.\n\nImplement a multi-bit MUX-based synchronizer, data_in will remain constant during the period when data_en is high, and data_en is high for at least 3 clk_b clock cycles. When the value of data_en is high, data can be synchronized. The data change frequency of data_in is very low. The change interval between two adjacent data is at least 10 clk_b clock cycles.\nThe clock clk_a is responsible for: input data_in is refer to clock a. enable signal data_en is refer to clock a.\nThe clock clk_b is responsible for the enable signal data_en delays two cycles, that is, two D flip-flops. This is done with reference to clock b. And the data is finally output dataout, and the output refers to clock b.\n\nModule name:  \n    synchronizer  \n\nInput ports:\n\tclk_a: Clock signal A used for synchronous operations.\n\tclk_b: Clock signal B used for synchronous operations.\n\tarstn: Active-low reset signal A. Defined as 0 for reset and 1 for reset signal inactive.\n\tbrstn: Active-low reset signal B. Defined as 0 for reset and 1 for reset signal inactive.\n\tdata_in: Input data signal of size 4 bits.\n\tdata_en: Input enable signal that controls the selection operation.\n\nOutput ports:\n    dataout: Output data signal of size 4 bits.\n\nImplementation:\nData Register:\nThe module includes a register, data_reg, to store the input data signal, data_in.\nOn the positive edge of clock signal A (clk_a) or the falling edge of reset signal A (arstn), the module updates the register. If the reset signal A (arstn) is low, indicating a reset condition, the register (data_reg) is set to 0. If the reset signal A (arstn) is high, the register (data_reg) is updated with the input data signal (data_in).\nEnable Data Register:\nThe module includes a register, en_data_reg, to store the input enable signal, data_en.\nOn the positive edge of clock signal A (clk_a) or the falling edge of reset signal A (arstn), the module updates the register. If the reset signal A (arstn) is low, the register (en_data_reg) is set to 0. If the reset signal A (arstn) is high, the register (en_data_reg) is updated with the input enable signal (data_en).\nEnable Control Registers:\nThe module includes two registers, en_clap_one and en_clap_two, to control the selection of the input data. On the positive edge of clock signal B (clk_b) or the falling edge of reset signal B (brstn), the module updates the registers. If the reset signal B (brstn) is low, indicating a reset condition, both registers (en_clap_one and en_clap_two) are set to 0.\nIf the reset signal B (brstn) is high, the registers (en_clap_one and en_clap_two) are updated based on the value of en_data_reg. The register en_clap_one is assigned the value of en_data_reg, and en_clap_two is assigned the previous value of en_clap_one.\nOutput Assignment:\nOn the positive edge of clock signal B (clk_b) or the falling edge of reset signal B (brstn), the module assigns the output data value. If the reset signal B (brstn) is low, indicating a reset condition, the output data (dataout) is set to 0. If the reset signal B (brstn) is high and the control signal (en_clap_two) is active, the output data (dataout) is assigned the value of the data register (data_reg). If the control signal (en_clap_two) is inactive, the output data (dataout) retains its previous value.\n\nGive me the complete code.\n"}, "clean_code": "module synchronizer(\n\tinput \t\t\t\tclk_a\t, \n\tinput \t\t\t\tclk_b\t,   \n\tinput \t\t\t\tarstn\t,\n\tinput\t\t\t\tbrstn   ,\n\tinput\t\t[3:0]\tdata_in\t,\n\tinput               data_en ,\n\n\toutput reg  [3:0] \tdataout\n);\n\nreg\t[3:0]\tdata_reg;\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!arstn)\tdata_reg <= 0;\n\t\telse\tdata_reg <= data_in;\nend\nreg en_data_reg;\t\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!brstn)\ten_data_reg <= 0;\n\t\telse\ten_data_reg <= data_en;   \nend\n\nreg\ten_clap_one;\t//1\nreg en_clap_two;\t//2\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_one <= 0;\n\t\telse\ten_clap_one <= en_data_reg;\t\nend\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_two <= 0;\n\t\telse\ten_clap_two <= en_clap_one;\nend\n\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\tdataout <= 0;\n\t\telse\tdataout <= (en_clap_two) ? data_reg : dataout;\nend\n\nendmodule\n", "corrupted_code": "module synchronizer(\n\tinput \t\t\t\tclk_a\t, \n\tinput \t\t\t\tclk_b\t,   \n\tinput \t\t\t\tarstn\t,\n\tinput\t\t\t\tbrstn   ,\n\tinput\t\t[3:0]\tdata_in\t,\n\tinput               data_en ,\n\n\toutput reg  [3:0] \tdataout\n);\n\nreg\t[3:0]\tdata_reg;\n\nreg en_data_reg;\t\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!brstn)\ten_data_reg <= 0;\n\t\telse\ten_data_reg <= data_en;   \nend\n\nreg\ten_clap_one;\t//1\nreg en_clap_two;\t//2\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_one <= 0;\n\t\telse\ten_clap_one <= en_data_reg;\t\nend\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_two <= 0;\n\t\telse\ten_clap_two <= en_clap_one;\nend\n\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\tdataout <= 0;\n\t\telse\tdataout <= (en_clap_two) ? data_reg : dataout;\nend\n\nendmodule\n", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 13, "original_snippet": "always@(posedge clk_a or negedge arstn)\nbegin\n\tif(!arstn)\tdata_reg <= 0;\n\t\telse\tdata_reg <= data_in;\nend", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 13: Original: always@(posedge clk_a or negedge arstn)\nbegin\n\tif(!arstn)\tdata_reg <= 0;\n\t\telse\tdata_reg <= data_in;\nend\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 13.\n   \u2022 Restore the original code: always@(posedge clk_a or negedge arstn)\nbegin\n\tif(!arstn)\tdata_reg <= 0;\n\t\telse\tdata_reg <= data_in;\nend\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 14, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.491963", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "synchronizer", "module_name": "synchronizer", "description": "Please act as a professional verilog designer.\n\nImplement a multi-bit MUX-based synchronizer, data_in will remain constant during the period when data_en is high, and data_en is high for at least 3 clk_b clock cycles. When the value of data_en is high, data can be synchronized. The data change frequency of data_in is very low. The change interval between two adjacent data is at least 10 clk_b clock cycles.\nThe clock clk_a is responsible for: input data_in is refer to clock a. enable signal data_en is refer to clock a.\nThe clock clk_b is responsible for the enable signal data_en delays two cycles, that is, two D flip-flops. This is done with reference to clock b. And the data is finally output dataout, and the output refers to clock b.\n\nModule name:  \n    synchronizer  \n\nInput ports:\n\tclk_a: Clock signal A used for synchronous operations.\n\tclk_b: Clock signal B used for synchronous operations.\n\tarstn: Active-low reset signal A. Defined as 0 for reset and 1 for reset signal inactive.\n\tbrstn: Active-low reset signal B. Defined as 0 for reset and 1 for reset signal inactive.\n\tdata_in: Input data signal of size 4 bits.\n\tdata_en: Input enable signal that controls the selection operation.\n\nOutput ports:\n    dataout: Output data signal of size 4 bits.\n\nImplementation:\nData Register:\nThe module includes a register, data_reg, to store the input data signal, data_in.\nOn the positive edge of clock signal A (clk_a) or the falling edge of reset signal A (arstn), the module updates the register. If the reset signal A (arstn) is low, indicating a reset condition, the register (data_reg) is set to 0. If the reset signal A (arstn) is high, the register (data_reg) is updated with the input data signal (data_in).\nEnable Data Register:\nThe module includes a register, en_data_reg, to store the input enable signal, data_en.\nOn the positive edge of clock signal A (clk_a) or the falling edge of reset signal A (arstn), the module updates the register. If the reset signal A (arstn) is low, the register (en_data_reg) is set to 0. If the reset signal A (arstn) is high, the register (en_data_reg) is updated with the input enable signal (data_en).\nEnable Control Registers:\nThe module includes two registers, en_clap_one and en_clap_two, to control the selection of the input data. On the positive edge of clock signal B (clk_b) or the falling edge of reset signal B (brstn), the module updates the registers. If the reset signal B (brstn) is low, indicating a reset condition, both registers (en_clap_one and en_clap_two) are set to 0.\nIf the reset signal B (brstn) is high, the registers (en_clap_one and en_clap_two) are updated based on the value of en_data_reg. The register en_clap_one is assigned the value of en_data_reg, and en_clap_two is assigned the previous value of en_clap_one.\nOutput Assignment:\nOn the positive edge of clock signal B (clk_b) or the falling edge of reset signal B (brstn), the module assigns the output data value. If the reset signal B (brstn) is low, indicating a reset condition, the output data (dataout) is set to 0. If the reset signal B (brstn) is high and the control signal (en_clap_two) is active, the output data (dataout) is assigned the value of the data register (data_reg). If the control signal (en_clap_two) is inactive, the output data (dataout) retains its previous value.\n\nGive me the complete code.\n"}, "clean_code": "module synchronizer(\n\tinput \t\t\t\tclk_a\t, \n\tinput \t\t\t\tclk_b\t,   \n\tinput \t\t\t\tarstn\t,\n\tinput\t\t\t\tbrstn   ,\n\tinput\t\t[3:0]\tdata_in\t,\n\tinput               data_en ,\n\n\toutput reg  [3:0] \tdataout\n);\n\nreg\t[3:0]\tdata_reg;\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!arstn)\tdata_reg <= 0;\n\t\telse\tdata_reg <= data_in;\nend\nreg en_data_reg;\t\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!brstn)\ten_data_reg <= 0;\n\t\telse\ten_data_reg <= data_en;   \nend\n\nreg\ten_clap_one;\t//1\nreg en_clap_two;\t//2\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_one <= 0;\n\t\telse\ten_clap_one <= en_data_reg;\t\nend\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_two <= 0;\n\t\telse\ten_clap_two <= en_clap_one;\nend\n\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\tdataout <= 0;\n\t\telse\tdataout <= (en_clap_two) ? data_reg : dataout;\nend\n\nendmodule\n", "corrupted_code": "module synchronizer(\n\tinput \t\t\t\tclk_a\t, \n\tinput \t\t\t\tclk_b\t,   \n\tinput \t\t\t\tarstn\t,\n\tinput\t\t\t\tbrstn   ,\n\tinput\t\t[3:0]\tdata_in\t,\n\tinput               data_en ,\n\n\toutput reg  [3:0] \tdataout\n);\n\nreg\t[3:0]\tdata_reg;\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!arstn)\tdata_reg <= 0;\n\t\telse\tdata_reg <= data_in;\nend\nreg en_data_reg;\t\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!brstn)\ten_data_reg <= 0;\n\t\telse\ten_data_reg <= data_en;   \nend\n\nreg\ten_clap_one;\t//1\nreg en_clap_two;\t//2\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_one <= 0;\n\t\telse\ten_clap_one <= en_data_reg;\t\nend\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_two >= 0;\n\t\telse\ten_clap_two <= en_clap_one;\nend\n\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\tdataout <= 0;\n\t\telse\tdataout <= (en_clap_two) ? data_reg : dataout;\nend\n\nendmodule\n", "corruption_explanation": "Changed operator from '<=' to '>='", "modification_type": "change_operator", "modification_line": 34, "original_snippet": "o <= 0", "modified_snippet": "o >= 0", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '<=' to '>='\n   \u2022 Line 34: Original: o <= 0\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 34.\n   \u2022 Restore the original code: o <= 0\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 14, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.493352", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "serial2parallel", "module_name": "serial2parallel", "description": "Please act as a professional verilog designer.\n\nImplement a series-parallel conversion circuit. It receives a serial input signal \"din_serial\" along with a control signal \"din_valid\" indicating the validity of the input data. The module operates on the rising edge of the clock signal \"clk\" and uses a synchronous design. The input din_serial is a single-bit data, and when the module receives 8 input data, the output dout_parallel outputs the 8-bit data(The serial input values are sequentially placed in dout_parallel from the most significant bit to the least significant bit), and the dout_valid is set to 1.\n\nModule name:  \n    serial2parallel          \n\nInput ports:\n\tclk: Clock signal.\n\trst_n: Reset signal (active low).\n\tdin_serial: Serial input data.\n\tdin_valid: Validity signal for input data.\t\n\nOutput ports:\n\tdout_parallel: Parallel output data (8 bits wide).\n\tdout_valid: Validity signal for the output data.\n\nImplementation:\nThe module utilizes a 4-bit counter (cnt) to keep track of the number of serial input data bits received. Every eight din_serial input, dout_parallel will output. When all 8 serial data bits have been received, the valid output signal is set to 1, indicating that the parallel output data is valid. Otherwise, the valid output signal is set to 0, indicating that the parallel output data is not valid.\n\nGive me the complete code.\n"}, "clean_code": "\nmodule serial2parallel(\n\tinput clk,\n\tinput rst_n,\n\tinput din_serial,\n\tinput din_valid,\n\toutput reg [7:0]dout_parallel,\n\toutput reg dout_valid\n);\n\n\treg[7:0]din_tmp;\n\treg[3:0]cnt;\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tcnt <= 0;\n\t\telse if(din_valid)\n\t\t\tcnt <= (cnt == 4'd8)?0:cnt+1'b1;\n\t\telse\t\n\t\t\tcnt <= 0;\n\tend\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tdin_tmp <= 8'b0;\n\t\telse if(din_valid && cnt <= 4'd7)\n\t\t\tdin_tmp <= {din_tmp[6:0],din_serial};\n\t\n\tend \n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tdout_valid <= 1'b0;\n\t\t\tdout_parallel <= 8'b0;\n\t\tend\n\t\telse if(cnt == 4'd8)begin\n\t\t\tdout_valid <= 1'b1;\n\t\t\tdout_parallel <= din_tmp;\n\t\tend\n\t\telse begin\n\t\t\tdout_valid <= 1'b0;\n\t\tend\n\tend \n\t\nendmodule\n", "corrupted_code": "\nmodule serial2parallel(\n\tinput clk,\n\tinput rst_n,\n\tinput din_serial,\n\tinput din_valid,\n\toutput reg [7:0]dout_parallel,\n\toutput reg dout_valid\n);\n\n\treg[7:0]din_tmp;\n\treg[3:0]cnt;\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tcnt = 0;\n\t\telse if(din_valid)\n\t\t\tcnt <= (cnt == 4'd8)?0:cnt+1'b1;\n\t\telse\t\n\t\t\tcnt <= 0;\n\tend\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tdin_tmp <= 8'b0;\n\t\telse if(din_valid && cnt <= 4'd7)\n\t\t\tdin_tmp <= {din_tmp[6:0],din_serial};\n\t\n\tend \n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tdout_valid <= 1'b0;\n\t\t\tdout_parallel <= 8'b0;\n\t\tend\n\t\telse if(cnt == 4'd8)begin\n\t\t\tdout_valid <= 1'b1;\n\t\t\tdout_parallel <= din_tmp;\n\t\tend\n\t\telse begin\n\t\t\tdout_valid <= 1'b0;\n\t\tend\n\tend \n\t\nendmodule\n", "corruption_explanation": "Changed non-blocking (<=) to blocking (=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 16, "original_snippet": "cnt <= 0;", "modified_snippet": "cnt = 0;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 18, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.496451", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "serial2parallel", "module_name": "serial2parallel", "description": "Please act as a professional verilog designer.\n\nImplement a series-parallel conversion circuit. It receives a serial input signal \"din_serial\" along with a control signal \"din_valid\" indicating the validity of the input data. The module operates on the rising edge of the clock signal \"clk\" and uses a synchronous design. The input din_serial is a single-bit data, and when the module receives 8 input data, the output dout_parallel outputs the 8-bit data(The serial input values are sequentially placed in dout_parallel from the most significant bit to the least significant bit), and the dout_valid is set to 1.\n\nModule name:  \n    serial2parallel          \n\nInput ports:\n\tclk: Clock signal.\n\trst_n: Reset signal (active low).\n\tdin_serial: Serial input data.\n\tdin_valid: Validity signal for input data.\t\n\nOutput ports:\n\tdout_parallel: Parallel output data (8 bits wide).\n\tdout_valid: Validity signal for the output data.\n\nImplementation:\nThe module utilizes a 4-bit counter (cnt) to keep track of the number of serial input data bits received. Every eight din_serial input, dout_parallel will output. When all 8 serial data bits have been received, the valid output signal is set to 1, indicating that the parallel output data is valid. Otherwise, the valid output signal is set to 0, indicating that the parallel output data is not valid.\n\nGive me the complete code.\n"}, "clean_code": "\nmodule serial2parallel(\n\tinput clk,\n\tinput rst_n,\n\tinput din_serial,\n\tinput din_valid,\n\toutput reg [7:0]dout_parallel,\n\toutput reg dout_valid\n);\n\n\treg[7:0]din_tmp;\n\treg[3:0]cnt;\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tcnt <= 0;\n\t\telse if(din_valid)\n\t\t\tcnt <= (cnt == 4'd8)?0:cnt+1'b1;\n\t\telse\t\n\t\t\tcnt <= 0;\n\tend\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tdin_tmp <= 8'b0;\n\t\telse if(din_valid && cnt <= 4'd7)\n\t\t\tdin_tmp <= {din_tmp[6:0],din_serial};\n\t\n\tend \n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tdout_valid <= 1'b0;\n\t\t\tdout_parallel <= 8'b0;\n\t\tend\n\t\telse if(cnt == 4'd8)begin\n\t\t\tdout_valid <= 1'b1;\n\t\t\tdout_parallel <= din_tmp;\n\t\tend\n\t\telse begin\n\t\t\tdout_valid <= 1'b0;\n\t\tend\n\tend \n\t\nendmodule\n", "corrupted_code": "\nmodule serial2parallel(\n\tinput clk,\n\tinput rst_n,\n\tinput din_serial,\n\tinput din_valid,\n\toutput reg [7:0]dout_parallel,\n\toutput reg dout_valid\n);\n\n\treg[7:0]din_tmp;\n\treg[3:0]cnt;\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tcnt <= 0;\n\t\telse if(din_valid)\n\t\t\tcnt <= (cnt == 4'd8)?0:cnt+1'b1;\n\t\telse\t\n\t\t\tcnt <= 0;\n\tend\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tdin_tmp <= 8'b0;\n\t\telse if(din_valid && cnt <= 4'd7)\n\t\t\tdin_tmp <= {din_tmp[6:0],din_serial};\n\t\n\tend \n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tdout_valid <= 1'b0;\n\t\tend\n\t\telse begin\n\t\t\tdout_valid <= 1'b0;\n\t\t\tdout_parallel <= 8'b0;\n\t\tend\n\t\telse if(cnt == 4'd8)begin\n\t\t\tdout_valid <= 1'b1;\n\t\t\tdout_parallel <= din_tmp;\n\t\tend\n\tend \n\t\nendmodule\n", "corruption_explanation": "Swapped if and else bodies", "modification_type": "invert_if_else", "modification_line": 32, "original_snippet": "if(!rst_n)begin\n\t\t\tdout_valid <= 1'b0;\n\t\t\tdout_parallel <= 8'b0;\n\t\tend\n\t\telse if(cnt == 4'd8)begin\n\t\t\tdout_valid <= 1'b1;\n\t\t\tdout_parallel <= din_tmp;\n\t\tend\n\t\telse begin\n\t\t\tdout_valid <= 1'b0;\n\t\tend", "modified_snippet": "if(!rst_n)begin\n\t\t\tdout_valid <= 1'b0;\n\t\tend\n\t\telse begin\n\t\t\tdout_valid <= 1'b0;\n\t\t\tdout_parallel <= 8'b0;\n\t\tend\n\t\telse if(cnt == 4'd8)begin\n\t\t\tdout_valid <= 1'b1;\n\t\t\tdout_parallel <= din_tmp;\n\t\tend", "issue_description": "The buggy code has swapped if and else bodies in a conditional block. This causes the logic to execute the opposite branch for each condition, leading to incorrect behavior when the condition is true vs false. Test cases that depend on the conditional logic will fail because the intended branch is not executed.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module contains conditional logic that should execute different code paths based on a condition.\n   \u2022 The if branch should handle the true case, and the else branch should handle the false case.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Identified a conditional block with both if and else branches.\n   \u2022 The branches contain different assignments or logic operations.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The if and else bodies have been swapped.\n   \u2022 Logic that should execute when condition is true now executes when false, and vice versa.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The conditional bodies are inverted.\n   \u2022 Impact: All conditional behavior is reversed, causing incorrect outputs for all test cases.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Swap the if and else bodies back to their correct positions.\n   \u2022 Verify that the condition evaluates correctly and executes the intended branch.\n\n6. RTL Design Principle Violated:\n   \u2022 Correct conditional logic requires matching the intended behavior with the branch bodies.", "complexity": 18, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_if_else"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.497667", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "serial2parallel", "module_name": "serial2parallel", "description": "Please act as a professional verilog designer.\n\nImplement a series-parallel conversion circuit. It receives a serial input signal \"din_serial\" along with a control signal \"din_valid\" indicating the validity of the input data. The module operates on the rising edge of the clock signal \"clk\" and uses a synchronous design. The input din_serial is a single-bit data, and when the module receives 8 input data, the output dout_parallel outputs the 8-bit data(The serial input values are sequentially placed in dout_parallel from the most significant bit to the least significant bit), and the dout_valid is set to 1.\n\nModule name:  \n    serial2parallel          \n\nInput ports:\n\tclk: Clock signal.\n\trst_n: Reset signal (active low).\n\tdin_serial: Serial input data.\n\tdin_valid: Validity signal for input data.\t\n\nOutput ports:\n\tdout_parallel: Parallel output data (8 bits wide).\n\tdout_valid: Validity signal for the output data.\n\nImplementation:\nThe module utilizes a 4-bit counter (cnt) to keep track of the number of serial input data bits received. Every eight din_serial input, dout_parallel will output. When all 8 serial data bits have been received, the valid output signal is set to 1, indicating that the parallel output data is valid. Otherwise, the valid output signal is set to 0, indicating that the parallel output data is not valid.\n\nGive me the complete code.\n"}, "clean_code": "\nmodule serial2parallel(\n\tinput clk,\n\tinput rst_n,\n\tinput din_serial,\n\tinput din_valid,\n\toutput reg [7:0]dout_parallel,\n\toutput reg dout_valid\n);\n\n\treg[7:0]din_tmp;\n\treg[3:0]cnt;\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tcnt <= 0;\n\t\telse if(din_valid)\n\t\t\tcnt <= (cnt == 4'd8)?0:cnt+1'b1;\n\t\telse\t\n\t\t\tcnt <= 0;\n\tend\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tdin_tmp <= 8'b0;\n\t\telse if(din_valid && cnt <= 4'd7)\n\t\t\tdin_tmp <= {din_tmp[6:0],din_serial};\n\t\n\tend \n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tdout_valid <= 1'b0;\n\t\t\tdout_parallel <= 8'b0;\n\t\tend\n\t\telse if(cnt == 4'd8)begin\n\t\t\tdout_valid <= 1'b1;\n\t\t\tdout_parallel <= din_tmp;\n\t\tend\n\t\telse begin\n\t\t\tdout_valid <= 1'b0;\n\t\tend\n\tend \n\t\nendmodule\n", "corrupted_code": "\nmodule serial2parallel(\n\tinput clk,\n\tinput rst_n,\n\tinput din_serial,\n\tinput din_valid,\n\toutput reg [7:0]dout_parallel,\n\toutput reg dout_valid\n);\n\n\treg[7:0]din_tmp;\n\treg[3:0]cnt;\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tcnt <= 0;\n\t\telse if(din_valid)\n\t\t\tcnt <= (cnt == 4'd8)?0:cnt+1'b1;\n\t\telse\t\n\t\t\tcnt <= 0;\n\tend\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tdin_tmp <= 8'b0;\n\t\telse if(din_valid && cnt <= 4'd7)\n\t\t\tdin_tmp <= {din_tmp[6:0],din_serial};\n\t\n\tend \n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tdout_valid <= 1'b0;\n\t\t\tdout_parallel <= 8'b0;\n\t\tend\n\t\telse if(!(cnt == 4'd8))begin\n\t\t\tdout_valid <= 1'b1;\n\t\t\tdout_parallel <= din_tmp;\n\t\tend\n\t\telse begin\n\t\t\tdout_valid <= 1'b0;\n\t\tend\n\tend \n\t\nendmodule\n", "corruption_explanation": "Inverted condition: 'cnt == 4'd8' -> '!(cnt == 4'd8)'", "modification_type": "invert_condition", "modification_line": 36, "original_snippet": "if(cnt == 4'd8)begin", "modified_snippet": "if(!(cnt == 4'd8))begin", "issue_description": "The buggy code has an inverted condition in an if statement. Instead of checking if(x), it checks if(!x), causing the logic to execute when it shouldn't and skip execution when it should. All conditional behavior is reversed from intended functionality.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_condition modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted condition: 'cnt == 4'd8' -> '!(cnt == 4'd8)'\n   \u2022 Line 36: Original: if(cnt == 4'd8)begin\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 36.\n   \u2022 Restore the original code: if(cnt == 4'd8)begin\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert condition.", "complexity": 18, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_condition"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.498849", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "serial2parallel", "module_name": "serial2parallel", "description": "Please act as a professional verilog designer.\n\nImplement a series-parallel conversion circuit. It receives a serial input signal \"din_serial\" along with a control signal \"din_valid\" indicating the validity of the input data. The module operates on the rising edge of the clock signal \"clk\" and uses a synchronous design. The input din_serial is a single-bit data, and when the module receives 8 input data, the output dout_parallel outputs the 8-bit data(The serial input values are sequentially placed in dout_parallel from the most significant bit to the least significant bit), and the dout_valid is set to 1.\n\nModule name:  \n    serial2parallel          \n\nInput ports:\n\tclk: Clock signal.\n\trst_n: Reset signal (active low).\n\tdin_serial: Serial input data.\n\tdin_valid: Validity signal for input data.\t\n\nOutput ports:\n\tdout_parallel: Parallel output data (8 bits wide).\n\tdout_valid: Validity signal for the output data.\n\nImplementation:\nThe module utilizes a 4-bit counter (cnt) to keep track of the number of serial input data bits received. Every eight din_serial input, dout_parallel will output. When all 8 serial data bits have been received, the valid output signal is set to 1, indicating that the parallel output data is valid. Otherwise, the valid output signal is set to 0, indicating that the parallel output data is not valid.\n\nGive me the complete code.\n"}, "clean_code": "\nmodule serial2parallel(\n\tinput clk,\n\tinput rst_n,\n\tinput din_serial,\n\tinput din_valid,\n\toutput reg [7:0]dout_parallel,\n\toutput reg dout_valid\n);\n\n\treg[7:0]din_tmp;\n\treg[3:0]cnt;\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tcnt <= 0;\n\t\telse if(din_valid)\n\t\t\tcnt <= (cnt == 4'd8)?0:cnt+1'b1;\n\t\telse\t\n\t\t\tcnt <= 0;\n\tend\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tdin_tmp <= 8'b0;\n\t\telse if(din_valid && cnt <= 4'd7)\n\t\t\tdin_tmp <= {din_tmp[6:0],din_serial};\n\t\n\tend \n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tdout_valid <= 1'b0;\n\t\t\tdout_parallel <= 8'b0;\n\t\tend\n\t\telse if(cnt == 4'd8)begin\n\t\t\tdout_valid <= 1'b1;\n\t\t\tdout_parallel <= din_tmp;\n\t\tend\n\t\telse begin\n\t\t\tdout_valid <= 1'b0;\n\t\tend\n\tend \n\t\nendmodule\n", "corrupted_code": "\nmodule serial2parallel(\n\tinput clk,\n\tinput rst_n,\n\tinput din_serial,\n\tinput din_valid,\n\toutput reg [7:0]dout_parallel,\n\toutput reg dout_valid\n);\n\n\treg[7:0]din_tmp;\n\treg[3:0]cnt;\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tcnt <= 0;\n\t\telse if(din_valid)\n\t\t\tcnt <= (cnt == 4'd8)?0:cnt+1'b1;\n\t\telse\t\n\t\t\tcnt <= 0;\n\tend\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tdin_tmp <= 8'b0;\n\t\telse if(din_valid && cnt <= 4'd7)\n\t\t\tdin_tmp <= {din_tmp[6:0],din_serial};\n\t\n\tend \n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tdout_valid <= 1'b0;\n\t\t\tdout_parallel <= 8'b0;\n\t\tend\n\t\telse if(!(cnt == 4'd8))begin\n\t\t\tdout_valid <= 1'b1;\n\t\t\tdout_parallel <= din_tmp;\n\t\tend\n\t\telse begin\n\t\t\tdout_valid <= 1'b0;\n\t\tend\n\tend \n\t\nendmodule\n", "corruption_explanation": "Inverted condition: 'cnt == 4'd8' -> '!(cnt == 4'd8)'", "modification_type": "invert_condition", "modification_line": 36, "original_snippet": "if(cnt == 4'd8)begin", "modified_snippet": "if(!(cnt == 4'd8))begin", "issue_description": "The buggy code has an inverted condition in an if statement. Instead of checking if(x), it checks if(!x), causing the logic to execute when it shouldn't and skip execution when it should. All conditional behavior is reversed from intended functionality.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_condition modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted condition: 'cnt == 4'd8' -> '!(cnt == 4'd8)'\n   \u2022 Line 36: Original: if(cnt == 4'd8)begin\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 36.\n   \u2022 Restore the original code: if(cnt == 4'd8)begin\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert condition.", "complexity": 18, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_condition"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.500010", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "serial2parallel", "module_name": "serial2parallel", "description": "Please act as a professional verilog designer.\n\nImplement a series-parallel conversion circuit. It receives a serial input signal \"din_serial\" along with a control signal \"din_valid\" indicating the validity of the input data. The module operates on the rising edge of the clock signal \"clk\" and uses a synchronous design. The input din_serial is a single-bit data, and when the module receives 8 input data, the output dout_parallel outputs the 8-bit data(The serial input values are sequentially placed in dout_parallel from the most significant bit to the least significant bit), and the dout_valid is set to 1.\n\nModule name:  \n    serial2parallel          \n\nInput ports:\n\tclk: Clock signal.\n\trst_n: Reset signal (active low).\n\tdin_serial: Serial input data.\n\tdin_valid: Validity signal for input data.\t\n\nOutput ports:\n\tdout_parallel: Parallel output data (8 bits wide).\n\tdout_valid: Validity signal for the output data.\n\nImplementation:\nThe module utilizes a 4-bit counter (cnt) to keep track of the number of serial input data bits received. Every eight din_serial input, dout_parallel will output. When all 8 serial data bits have been received, the valid output signal is set to 1, indicating that the parallel output data is valid. Otherwise, the valid output signal is set to 0, indicating that the parallel output data is not valid.\n\nGive me the complete code.\n"}, "clean_code": "\nmodule serial2parallel(\n\tinput clk,\n\tinput rst_n,\n\tinput din_serial,\n\tinput din_valid,\n\toutput reg [7:0]dout_parallel,\n\toutput reg dout_valid\n);\n\n\treg[7:0]din_tmp;\n\treg[3:0]cnt;\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tcnt <= 0;\n\t\telse if(din_valid)\n\t\t\tcnt <= (cnt == 4'd8)?0:cnt+1'b1;\n\t\telse\t\n\t\t\tcnt <= 0;\n\tend\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tdin_tmp <= 8'b0;\n\t\telse if(din_valid && cnt <= 4'd7)\n\t\t\tdin_tmp <= {din_tmp[6:0],din_serial};\n\t\n\tend \n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tdout_valid <= 1'b0;\n\t\t\tdout_parallel <= 8'b0;\n\t\tend\n\t\telse if(cnt == 4'd8)begin\n\t\t\tdout_valid <= 1'b1;\n\t\t\tdout_parallel <= din_tmp;\n\t\tend\n\t\telse begin\n\t\t\tdout_valid <= 1'b0;\n\t\tend\n\tend \n\t\nendmodule\n", "corrupted_code": "\nmodule serial2parallel(\n\tinput clk,\n\tinput rst_n,\n\tinput din_serial,\n\tinput din_valid,\n\toutput reg [7:0]dout_parallel,\n\toutput reg dout_valid\n);\n\n\treg[7:0]din_tmp;\n\treg[3:0]cnt;\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tcnt <= 0;\n\t\telse if(din_valid)\n\t\t\tcnt <= (cnt == 4'd8)?0:cnt+1'b1;\n\t\telse\t\n\t\t\tcnt <= 0;\n\tend\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tdin_tmp <= 8'b0;\n\t\telse if(din_valid && cnt <= 4'd7)\n\t\t\tdin_tmp <= {din_tmp[6:0],din_serial};\n\t\n\tend \n\t\n\t\n\t\telse if(cnt == 4'd8)begin\n\t\t\tdout_valid <= 1'b1;\n\t\t\tdout_parallel <= din_tmp;\n\t\tend\n\t\telse begin\n\t\t\tdout_valid <= 1'b0;\n\t\tend\n\tend \n\t\nendmodule\n", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 31, "original_snippet": "always@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tdout_valid <= 1'b0;\n\t\t\tdout_parallel <= 8'b0;\n\t\tend", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 31: Original: always@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tdout_valid <= 1'b0;\n\t\t\tdout_parallel <= 8'b0;\n\t\tend\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 31.\n   \u2022 Restore the original code: always@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tdout_valid <= 1'b0;\n\t\t\tdout_parallel <= 8'b0;\n\t\tend\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 18, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.501164", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "serial2parallel", "module_name": "serial2parallel", "description": "Please act as a professional verilog designer.\n\nImplement a series-parallel conversion circuit. It receives a serial input signal \"din_serial\" along with a control signal \"din_valid\" indicating the validity of the input data. The module operates on the rising edge of the clock signal \"clk\" and uses a synchronous design. The input din_serial is a single-bit data, and when the module receives 8 input data, the output dout_parallel outputs the 8-bit data(The serial input values are sequentially placed in dout_parallel from the most significant bit to the least significant bit), and the dout_valid is set to 1.\n\nModule name:  \n    serial2parallel          \n\nInput ports:\n\tclk: Clock signal.\n\trst_n: Reset signal (active low).\n\tdin_serial: Serial input data.\n\tdin_valid: Validity signal for input data.\t\n\nOutput ports:\n\tdout_parallel: Parallel output data (8 bits wide).\n\tdout_valid: Validity signal for the output data.\n\nImplementation:\nThe module utilizes a 4-bit counter (cnt) to keep track of the number of serial input data bits received. Every eight din_serial input, dout_parallel will output. When all 8 serial data bits have been received, the valid output signal is set to 1, indicating that the parallel output data is valid. Otherwise, the valid output signal is set to 0, indicating that the parallel output data is not valid.\n\nGive me the complete code.\n"}, "clean_code": "\nmodule serial2parallel(\n\tinput clk,\n\tinput rst_n,\n\tinput din_serial,\n\tinput din_valid,\n\toutput reg [7:0]dout_parallel,\n\toutput reg dout_valid\n);\n\n\treg[7:0]din_tmp;\n\treg[3:0]cnt;\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tcnt <= 0;\n\t\telse if(din_valid)\n\t\t\tcnt <= (cnt == 4'd8)?0:cnt+1'b1;\n\t\telse\t\n\t\t\tcnt <= 0;\n\tend\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tdin_tmp <= 8'b0;\n\t\telse if(din_valid && cnt <= 4'd7)\n\t\t\tdin_tmp <= {din_tmp[6:0],din_serial};\n\t\n\tend \n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tdout_valid <= 1'b0;\n\t\t\tdout_parallel <= 8'b0;\n\t\tend\n\t\telse if(cnt == 4'd8)begin\n\t\t\tdout_valid <= 1'b1;\n\t\t\tdout_parallel <= din_tmp;\n\t\tend\n\t\telse begin\n\t\t\tdout_valid <= 1'b0;\n\t\tend\n\tend \n\t\nendmodule\n", "corrupted_code": "\nmodule serial2parallel(\n\tinput clk,\n\tinput rst_n,\n\tinput din_serial,\n\tinput din_valid,\n\toutput reg [7:0]dout_parallel,\n\toutput reg dout_valid\n);\n\n\treg[7:0]din_tmp;\n\treg[3:0]cnt;\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif (rst_n)\n\t\t\tcnt <= 0;\n\t\telse if(din_valid)\n\t\t\tcnt <= (cnt == 4'd8)?0:cnt+1'b1;\n\t\telse\t\n\t\t\tcnt <= 0;\n\tend\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tdin_tmp <= 8'b0;\n\t\telse if(din_valid && cnt <= 4'd7)\n\t\t\tdin_tmp <= {din_tmp[6:0],din_serial};\n\t\n\tend \n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tdout_valid <= 1'b0;\n\t\t\tdout_parallel <= 8'b0;\n\t\tend\n\t\telse if(cnt == 4'd8)begin\n\t\t\tdout_valid <= 1'b1;\n\t\t\tdout_parallel <= din_tmp;\n\t\tend\n\t\telse begin\n\t\t\tdout_valid <= 1'b0;\n\t\tend\n\tend \n\t\nendmodule\n", "corruption_explanation": "Inverted reset polarity in condition", "modification_type": "invert_reset_polarity", "modification_line": 15, "original_snippet": "if(!rst_n)", "modified_snippet": "if (rst_n)", "issue_description": "The buggy code has inverted reset polarity. If the design expects active-low reset (!rst), it now uses active-high, or vice versa. This causes the reset logic to activate during normal operation and deactivate during actual reset, breaking initialization.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_reset_polarity modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted reset polarity in condition\n   \u2022 Line 15: Original: if(!rst_n)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 15.\n   \u2022 Restore the original code: if(!rst_n)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert reset polarity.", "complexity": 18, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_reset_polarity"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.502342", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "serial2parallel", "module_name": "serial2parallel", "description": "Please act as a professional verilog designer.\n\nImplement a series-parallel conversion circuit. It receives a serial input signal \"din_serial\" along with a control signal \"din_valid\" indicating the validity of the input data. The module operates on the rising edge of the clock signal \"clk\" and uses a synchronous design. The input din_serial is a single-bit data, and when the module receives 8 input data, the output dout_parallel outputs the 8-bit data(The serial input values are sequentially placed in dout_parallel from the most significant bit to the least significant bit), and the dout_valid is set to 1.\n\nModule name:  \n    serial2parallel          \n\nInput ports:\n\tclk: Clock signal.\n\trst_n: Reset signal (active low).\n\tdin_serial: Serial input data.\n\tdin_valid: Validity signal for input data.\t\n\nOutput ports:\n\tdout_parallel: Parallel output data (8 bits wide).\n\tdout_valid: Validity signal for the output data.\n\nImplementation:\nThe module utilizes a 4-bit counter (cnt) to keep track of the number of serial input data bits received. Every eight din_serial input, dout_parallel will output. When all 8 serial data bits have been received, the valid output signal is set to 1, indicating that the parallel output data is valid. Otherwise, the valid output signal is set to 0, indicating that the parallel output data is not valid.\n\nGive me the complete code.\n"}, "clean_code": "\nmodule serial2parallel(\n\tinput clk,\n\tinput rst_n,\n\tinput din_serial,\n\tinput din_valid,\n\toutput reg [7:0]dout_parallel,\n\toutput reg dout_valid\n);\n\n\treg[7:0]din_tmp;\n\treg[3:0]cnt;\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tcnt <= 0;\n\t\telse if(din_valid)\n\t\t\tcnt <= (cnt == 4'd8)?0:cnt+1'b1;\n\t\telse\t\n\t\t\tcnt <= 0;\n\tend\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tdin_tmp <= 8'b0;\n\t\telse if(din_valid && cnt <= 4'd7)\n\t\t\tdin_tmp <= {din_tmp[6:0],din_serial};\n\t\n\tend \n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tdout_valid <= 1'b0;\n\t\t\tdout_parallel <= 8'b0;\n\t\tend\n\t\telse if(cnt == 4'd8)begin\n\t\t\tdout_valid <= 1'b1;\n\t\t\tdout_parallel <= din_tmp;\n\t\tend\n\t\telse begin\n\t\t\tdout_valid <= 1'b0;\n\t\tend\n\tend \n\t\nendmodule\n", "corrupted_code": "\nmodule serial2parallel(\n\tinput clk,\n\tinput rst_n,\n\tinput din_serial,\n\tinput din_valid,\n\toutput reg [8:0]dout_parallel,\n\toutput reg dout_valid\n);\n\n\treg[7:0]din_tmp;\n\treg[3:0]cnt;\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tcnt <= 0;\n\t\telse if(din_valid)\n\t\t\tcnt <= (cnt == 4'd8)?0:cnt+1'b1;\n\t\telse\t\n\t\t\tcnt <= 0;\n\tend\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tdin_tmp <= 8'b0;\n\t\telse if(din_valid && cnt <= 4'd7)\n\t\t\tdin_tmp <= {din_tmp[6:0],din_serial};\n\t\n\tend \n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tdout_valid <= 1'b0;\n\t\t\tdout_parallel <= 8'b0;\n\t\tend\n\t\telse if(cnt == 4'd8)begin\n\t\t\tdout_valid <= 1'b1;\n\t\t\tdout_parallel <= din_tmp;\n\t\tend\n\t\telse begin\n\t\t\tdout_valid <= 1'b0;\n\t\tend\n\tend \n\t\nendmodule\n", "corruption_explanation": "Changed bit width from [7:0] to [8:0]", "modification_type": "change_bit_width", "modification_line": 7, "original_snippet": "[7:0]", "modified_snippet": "[8:0]", "issue_description": "The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_bit_width modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed bit width from [7:0] to [8:0]\n   \u2022 Line 7: Original: [7:0]\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 7.\n   \u2022 Restore the original code: [7:0]\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change bit width.", "complexity": 18, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_bit_width"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.503470", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "serial2parallel", "module_name": "serial2parallel", "description": "Please act as a professional verilog designer.\n\nImplement a series-parallel conversion circuit. It receives a serial input signal \"din_serial\" along with a control signal \"din_valid\" indicating the validity of the input data. The module operates on the rising edge of the clock signal \"clk\" and uses a synchronous design. The input din_serial is a single-bit data, and when the module receives 8 input data, the output dout_parallel outputs the 8-bit data(The serial input values are sequentially placed in dout_parallel from the most significant bit to the least significant bit), and the dout_valid is set to 1.\n\nModule name:  \n    serial2parallel          \n\nInput ports:\n\tclk: Clock signal.\n\trst_n: Reset signal (active low).\n\tdin_serial: Serial input data.\n\tdin_valid: Validity signal for input data.\t\n\nOutput ports:\n\tdout_parallel: Parallel output data (8 bits wide).\n\tdout_valid: Validity signal for the output data.\n\nImplementation:\nThe module utilizes a 4-bit counter (cnt) to keep track of the number of serial input data bits received. Every eight din_serial input, dout_parallel will output. When all 8 serial data bits have been received, the valid output signal is set to 1, indicating that the parallel output data is valid. Otherwise, the valid output signal is set to 0, indicating that the parallel output data is not valid.\n\nGive me the complete code.\n"}, "clean_code": "\nmodule serial2parallel(\n\tinput clk,\n\tinput rst_n,\n\tinput din_serial,\n\tinput din_valid,\n\toutput reg [7:0]dout_parallel,\n\toutput reg dout_valid\n);\n\n\treg[7:0]din_tmp;\n\treg[3:0]cnt;\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tcnt <= 0;\n\t\telse if(din_valid)\n\t\t\tcnt <= (cnt == 4'd8)?0:cnt+1'b1;\n\t\telse\t\n\t\t\tcnt <= 0;\n\tend\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tdin_tmp <= 8'b0;\n\t\telse if(din_valid && cnt <= 4'd7)\n\t\t\tdin_tmp <= {din_tmp[6:0],din_serial};\n\t\n\tend \n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tdout_valid <= 1'b0;\n\t\t\tdout_parallel <= 8'b0;\n\t\tend\n\t\telse if(cnt == 4'd8)begin\n\t\t\tdout_valid <= 1'b1;\n\t\t\tdout_parallel <= din_tmp;\n\t\tend\n\t\telse begin\n\t\t\tdout_valid <= 1'b0;\n\t\tend\n\tend \n\t\nendmodule\n", "corrupted_code": "\nmodule serial2parallel(\n\tinput clk,\n\tinput rst_n,\n\tinput din_serial,\n\tinput din_valid,\n\toutput reg [7:0]dout_parallel,\n\toutput reg dout_valid\n);\n\n\treg[7:0]din_tmp;\n\treg[3:0]cnt;\n\t\n\talways@(posedge clk)begin\n\t\tif(!rst_n)\n\t\t\tcnt <= 0;\n\t\telse if(din_valid)\n\t\t\tcnt <= (cnt == 4'd8)?0:cnt+1'b1;\n\t\telse\t\n\t\t\tcnt <= 0;\n\tend\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tdin_tmp <= 8'b0;\n\t\telse if(din_valid && cnt <= 4'd7)\n\t\t\tdin_tmp <= {din_tmp[6:0],din_serial};\n\t\n\tend \n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tdout_valid <= 1'b0;\n\t\t\tdout_parallel <= 8'b0;\n\t\tend\n\t\telse if(cnt == 4'd8)begin\n\t\t\tdout_valid <= 1'b1;\n\t\t\tdout_parallel <= din_tmp;\n\t\tend\n\t\telse begin\n\t\t\tdout_valid <= 1'b0;\n\t\tend\n\tend \n\t\nendmodule\n", "corruption_explanation": "Removed async reset from sensitivity list", "modification_type": "remove_async_reset", "modification_line": 14, "original_snippet": "always@(posedge clk or negedge rst_n)", "modified_snippet": "always@(posedge clk)", "issue_description": "The buggy code has removed async reset from the sensitivity list. The always block only triggers on clock edges, not reset. This causes metastability on power-up and removes the ability to asynchronously reset the design.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_async_reset modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed async reset from sensitivity list\n   \u2022 Line 14: Original: always@(posedge clk or negedge rst_n)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 14.\n   \u2022 Restore the original code: always@(posedge clk or negedge rst_n)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove async reset.", "complexity": 18, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_async_reset"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.504528", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "serial2parallel", "module_name": "serial2parallel", "description": "Please act as a professional verilog designer.\n\nImplement a series-parallel conversion circuit. It receives a serial input signal \"din_serial\" along with a control signal \"din_valid\" indicating the validity of the input data. The module operates on the rising edge of the clock signal \"clk\" and uses a synchronous design. The input din_serial is a single-bit data, and when the module receives 8 input data, the output dout_parallel outputs the 8-bit data(The serial input values are sequentially placed in dout_parallel from the most significant bit to the least significant bit), and the dout_valid is set to 1.\n\nModule name:  \n    serial2parallel          \n\nInput ports:\n\tclk: Clock signal.\n\trst_n: Reset signal (active low).\n\tdin_serial: Serial input data.\n\tdin_valid: Validity signal for input data.\t\n\nOutput ports:\n\tdout_parallel: Parallel output data (8 bits wide).\n\tdout_valid: Validity signal for the output data.\n\nImplementation:\nThe module utilizes a 4-bit counter (cnt) to keep track of the number of serial input data bits received. Every eight din_serial input, dout_parallel will output. When all 8 serial data bits have been received, the valid output signal is set to 1, indicating that the parallel output data is valid. Otherwise, the valid output signal is set to 0, indicating that the parallel output data is not valid.\n\nGive me the complete code.\n"}, "clean_code": "\nmodule serial2parallel(\n\tinput clk,\n\tinput rst_n,\n\tinput din_serial,\n\tinput din_valid,\n\toutput reg [7:0]dout_parallel,\n\toutput reg dout_valid\n);\n\n\treg[7:0]din_tmp;\n\treg[3:0]cnt;\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tcnt <= 0;\n\t\telse if(din_valid)\n\t\t\tcnt <= (cnt == 4'd8)?0:cnt+1'b1;\n\t\telse\t\n\t\t\tcnt <= 0;\n\tend\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tdin_tmp <= 8'b0;\n\t\telse if(din_valid && cnt <= 4'd7)\n\t\t\tdin_tmp <= {din_tmp[6:0],din_serial};\n\t\n\tend \n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tdout_valid <= 1'b0;\n\t\t\tdout_parallel <= 8'b0;\n\t\tend\n\t\telse if(cnt == 4'd8)begin\n\t\t\tdout_valid <= 1'b1;\n\t\t\tdout_parallel <= din_tmp;\n\t\tend\n\t\telse begin\n\t\t\tdout_valid <= 1'b0;\n\t\tend\n\tend \n\t\nendmodule\n", "corrupted_code": "\nmodule serial2parallel(\n\tinput clk,\n\tinput rst_n,\n\tinput din_serial,\n\tinput din_valid,\n\toutput reg [7:0]dout_parallel,\n\toutput reg dout_valid\n);\n\n\treg[7:0]din_tmp;\n\treg[3:0]cnt;\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tcnt <= 0;\n\t\telse if(din_valid)\n\t\t\tcnt <= (cnt == 4'd8)?0:cnt+1'b1;\n\t\telse\t\n\t\t\tcnt <= 0;\n\tend\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tdin_tmp <= 8'b0;\n\t\telse if(din_valid && cnt <= 4'd7)\n\t\t\tdin_tmp <= {din_tmp[6:0],din_serial};\n\t\n\tend \n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tdout_valid <= 1'b0;\n\t\t\tdout_parallel <= 8'b0;\n\t\tend\n\t\telse if(cnt == 4'd8)begin\n\t\t\t1 <= dout_valid'b1;\n\t\t\tdout_parallel <= din_tmp;\n\t\tend\n\t\telse begin\n\t\t\tdout_valid <= 1'b0;\n\t\tend\n\tend \n\t\nendmodule\n", "corruption_explanation": "Swapped operands: 'dout_valid <= 1' -> '1 <= dout_valid'", "modification_type": "swap_operands", "modification_line": 37, "original_snippet": "dout_valid <= 1", "modified_snippet": "1 <= dout_valid", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'dout_valid <= 1' -> '1 <= dout_valid'\n   \u2022 Line 37: Original: dout_valid <= 1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 37.\n   \u2022 Restore the original code: dout_valid <= 1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 18, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_operands"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.505670", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "Others", "design_name": "serial2parallel", "module_name": "serial2parallel", "description": "Please act as a professional verilog designer.\n\nImplement a series-parallel conversion circuit. It receives a serial input signal \"din_serial\" along with a control signal \"din_valid\" indicating the validity of the input data. The module operates on the rising edge of the clock signal \"clk\" and uses a synchronous design. The input din_serial is a single-bit data, and when the module receives 8 input data, the output dout_parallel outputs the 8-bit data(The serial input values are sequentially placed in dout_parallel from the most significant bit to the least significant bit), and the dout_valid is set to 1.\n\nModule name:  \n    serial2parallel          \n\nInput ports:\n\tclk: Clock signal.\n\trst_n: Reset signal (active low).\n\tdin_serial: Serial input data.\n\tdin_valid: Validity signal for input data.\t\n\nOutput ports:\n\tdout_parallel: Parallel output data (8 bits wide).\n\tdout_valid: Validity signal for the output data.\n\nImplementation:\nThe module utilizes a 4-bit counter (cnt) to keep track of the number of serial input data bits received. Every eight din_serial input, dout_parallel will output. When all 8 serial data bits have been received, the valid output signal is set to 1, indicating that the parallel output data is valid. Otherwise, the valid output signal is set to 0, indicating that the parallel output data is not valid.\n\nGive me the complete code.\n"}, "clean_code": "\nmodule serial2parallel(\n\tinput clk,\n\tinput rst_n,\n\tinput din_serial,\n\tinput din_valid,\n\toutput reg [7:0]dout_parallel,\n\toutput reg dout_valid\n);\n\n\treg[7:0]din_tmp;\n\treg[3:0]cnt;\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tcnt <= 0;\n\t\telse if(din_valid)\n\t\t\tcnt <= (cnt == 4'd8)?0:cnt+1'b1;\n\t\telse\t\n\t\t\tcnt <= 0;\n\tend\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tdin_tmp <= 8'b0;\n\t\telse if(din_valid && cnt <= 4'd7)\n\t\t\tdin_tmp <= {din_tmp[6:0],din_serial};\n\t\n\tend \n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tdout_valid <= 1'b0;\n\t\t\tdout_parallel <= 8'b0;\n\t\tend\n\t\telse if(cnt == 4'd8)begin\n\t\t\tdout_valid <= 1'b1;\n\t\t\tdout_parallel <= din_tmp;\n\t\tend\n\t\telse begin\n\t\t\tdout_valid <= 1'b0;\n\t\tend\n\tend \n\t\nendmodule\n", "corrupted_code": "\nmodule serial2parallel(\n\tinput clk,\n\tinput rst_n,\n\tinput din_serial,\n\tinput din_valid,\n\toutput reg [7:0]dout_parallel,\n\toutput reg dout_valid\n);\n\n\treg[7:0]din_tmp;\n\treg[3:0]cnt;\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tcnt <= 0;\n\t\telse if(din_valid)\n\t\t\tcnt <= (cnt == 4'd8)?0:cnt+1'b1;\n\t\telse\t\n\t\t\tcnt <= 0;\n\tend\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tdin_tmp <= 8'b0;\n\t\telse if(din_valid && cnt <= 4'd7)\n\t\t\tdin_tmp <= {din_tmp[6:0],din_serial};\n\t\n\tend \n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\t\n\tend \n\t\nendmodule\n", "corruption_explanation": "Removed a conditional block", "modification_type": "remove_conditional", "modification_line": 32, "original_snippet": "if(!rst_n)begin\n\t\t\tdout_valid <= 1'b0;\n\t\t\tdout_parallel <= 8'b0;\n\t\tend\n\t\telse if(cnt == 4'd8)begin\n\t\t\tdout_valid <= 1'b1;\n\t\t\tdout_parallel <= din_tmp;\n\t\tend\n\t\telse begin\n\t\t\tdout_valid <= 1'b0;\n\t\tend", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing a conditional block. This removes important control logic, causing the design to skip necessary state transitions or data processing. Test cases that depend on the conditional behavior will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_conditional modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed a conditional block\n   \u2022 Line 32: Original: if(!rst_n)begin\n\t\t\tdout_valid <= 1'b0;\n\t\t\tdout_parallel <= 8'b0;\n\t\tend\n\t\telse if(cnt == 4'd8)begin\n\t\t\tdout_valid <= 1'b1;\n\t\t\tdout_parallel <= din_tmp;\n\t\tend\n\t\telse begin\n\t\t\tdout_valid <= 1'b0;\n\t\tend\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 32.\n   \u2022 Restore the original code: if(!rst_n)begin\n\t\t\tdout_valid <= 1'b0;\n\t\t\tdout_parallel <= 8'b0;\n\t\tend\n\t\telse if(cnt == 4'd8)begin\n\t\t\tdout_valid <= 1'b1;\n\t\t\tdout_parallel <= din_tmp;\n\t\tend\n\t\telse begin\n\t\t\tdout_valid <= 1'b0;\n\t\tend\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove conditional.", "complexity": 18, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_conditional"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.506752", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "RAM", "module_name": "RAM", "description": "Please act as a professional verilog designer.\n\nImplement a dual-port RAM with a depth of 8 and a bit width of 6 bits, with all data initialized to 000000. It has two groups of ports, respectively for reading data and writing data, and read and write operations can be carried out at the same time. When the read_en signal is 1, the read_data of the corresponding position is read through the read_addr signal and output; When the write_en signal is 1, data is written to the corresponding position through the write_addr signal and write-data signal.\n\nModule name:  \n    RAM               \nInput ports:\n\tclk: Clock signal used for synchronous operation.\n\trst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\twrite_en: Write enable signal to initiate a write operation.\n\twrite_addr: Address for the write operation.\n\twrite_data: Data to be written to the RAM.\n\tread_en: Read enable signal to initiate a read operation.\n\tread_addr: Address for the read operation.\n\nOutput ports:\n    read_data: Output signal representing the data read from the RAM.\n\nParameter: \n\tWIDTH = 6;\n    DEPTH = 8;\n\nImplementation:\nRAM Array:\nThe module includes a register array, RAM. The array is defined as reg [DEPTH - 1 : 0] RAM [2**WIDTH-1:0], allowing for 2^6 memory locations, each with a width of 6 bits.\nWrite Operation:\nThe first always block triggers on the positive edge of the clock signal (posedge clk) or the negative edge of the reset signal (negedge rst_n).\nOn reset, indicated by !rst_n, all memory locations in the RAM array are cleared to 0.\nIf the write enable signal (write_en) is active, the data (write_data) is written to the RAM array at the specified address (write_addr).\nRead Operation:\nThe second always block triggers on the positive edge of the clock signal (posedge clk) or the negative edge of the reset signal (negedge rst_n).\nOn reset, indicated by !rst_n, the read_data register is cleared to 0.\nIf the read enable signal (read_en) is active, the data at the specified address (read_addr) in the RAM array is assigned to the read_data register.\nIf the read enable signal is not active, the read_data register is cleared to 0.\n\nGive me the complete code.\n"}, "clean_code": "module RAM (\n\tinput clk,\n\tinput rst_n,\n\t\n\tinput write_en,\n\tinput [7:0]write_addr,\n\tinput [5:0]write_data,\n\t\n\tinput read_en,\n\tinput [7:0]read_addr,\n\toutput reg [5:0]read_data\n);\n    \n    //defination\n    reg [7 : 0] RAM [11:0];\n\n    //output \n    integer i;\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) begin\n               for(i = 0; i < 8; i = i + 1) begin\n                   RAM[i] <= 'd0;\n               end\n        end\n        else if(write_en) \n            RAM[write_addr] <= write_data;\n    end\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) \n            read_data <= 'd0;\n        else if(read_en) \n            read_data <= RAM[read_addr];\n        else \n            read_data <= 'd0;\n    end\nendmodule\n", "corrupted_code": "module RAM (\n\tinput clk,\n\tinput rst_n,\n\t\n\tinput write_en,\n\tinput [7:0]write_addr,\n\tinput [5:0]write_data,\n\t\n\tinput read_en,\n\tinput [7:0]read_addr,\n\toutput reg [5:0]read_data\n);\n    \n    //defination\n    reg [7 : 0] RAM [11:0];\n\n    //output \n    integer i;\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) begin\n               for(i = 0; i < 8; i = i + 1) begin\n                   RAM[i] <= 'd0;\n               end\n        end\n        else if(write_en) \n            RAM[write_addr] <= write_data;\n    end\n    \nendmodule\n", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 28, "original_snippet": "always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) \n            read_data <= 'd0;\n        else if(read_en) \n            read_data <= RAM[read_addr];\n        else \n            read_data <= '", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 28: Original: always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) \n            read_data <= 'd0;\n        else if(read_en) \n            read_data <= RAM[read_addr];\n        else \n            read_data <= '\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 28.\n   \u2022 Restore the original code: always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) \n            read_data <= 'd0;\n        else if(read_en) \n            read_data <= RAM[read_addr];\n        else \n            read_data <= '\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 7, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.630683", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "RAM", "module_name": "RAM", "description": "Please act as a professional verilog designer.\n\nImplement a dual-port RAM with a depth of 8 and a bit width of 6 bits, with all data initialized to 000000. It has two groups of ports, respectively for reading data and writing data, and read and write operations can be carried out at the same time. When the read_en signal is 1, the read_data of the corresponding position is read through the read_addr signal and output; When the write_en signal is 1, data is written to the corresponding position through the write_addr signal and write-data signal.\n\nModule name:  \n    RAM               \nInput ports:\n\tclk: Clock signal used for synchronous operation.\n\trst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\twrite_en: Write enable signal to initiate a write operation.\n\twrite_addr: Address for the write operation.\n\twrite_data: Data to be written to the RAM.\n\tread_en: Read enable signal to initiate a read operation.\n\tread_addr: Address for the read operation.\n\nOutput ports:\n    read_data: Output signal representing the data read from the RAM.\n\nParameter: \n\tWIDTH = 6;\n    DEPTH = 8;\n\nImplementation:\nRAM Array:\nThe module includes a register array, RAM. The array is defined as reg [DEPTH - 1 : 0] RAM [2**WIDTH-1:0], allowing for 2^6 memory locations, each with a width of 6 bits.\nWrite Operation:\nThe first always block triggers on the positive edge of the clock signal (posedge clk) or the negative edge of the reset signal (negedge rst_n).\nOn reset, indicated by !rst_n, all memory locations in the RAM array are cleared to 0.\nIf the write enable signal (write_en) is active, the data (write_data) is written to the RAM array at the specified address (write_addr).\nRead Operation:\nThe second always block triggers on the positive edge of the clock signal (posedge clk) or the negative edge of the reset signal (negedge rst_n).\nOn reset, indicated by !rst_n, the read_data register is cleared to 0.\nIf the read enable signal (read_en) is active, the data at the specified address (read_addr) in the RAM array is assigned to the read_data register.\nIf the read enable signal is not active, the read_data register is cleared to 0.\n\nGive me the complete code.\n"}, "clean_code": "module RAM (\n\tinput clk,\n\tinput rst_n,\n\t\n\tinput write_en,\n\tinput [7:0]write_addr,\n\tinput [5:0]write_data,\n\t\n\tinput read_en,\n\tinput [7:0]read_addr,\n\toutput reg [5:0]read_data\n);\n    \n    //defination\n    reg [7 : 0] RAM [11:0];\n\n    //output \n    integer i;\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) begin\n               for(i = 0; i < 8; i = i + 1) begin\n                   RAM[i] <= 'd0;\n               end\n        end\n        else if(write_en) \n            RAM[write_addr] <= write_data;\n    end\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) \n            read_data <= 'd0;\n        else if(read_en) \n            read_data <= RAM[read_addr];\n        else \n            read_data <= 'd0;\n    end\nendmodule\n", "corrupted_code": "module RAM (\n\tinput clk,\n\tinput rst_n,\n\t\n\tinput write_en,\n\tinput [7:0]write_addr,\n\tinput [5:0]write_data,\n\t\n\tinput read_en,\n\tinput [7:0]read_addr,\n\toutput reg [5:0]read_data\n);\n    \n    //defination\n    reg [7 : 0] RAM [11:0];\n\n    //output \n    integer i;\n    always@(posedge clk or negedge rst_n)begin\n        if(rst_n) begin\n               for(i = 0; i < 8; i = i + 1) begin\n                   RAM[i] <= 'd0;\n               end\n        end\n        else if(write_en) \n            RAM[write_addr] <= write_data;\n    end\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) \n            read_data <= 'd0;\n        else if(read_en) \n            read_data <= RAM[read_addr];\n        else \n            read_data <= 'd0;\n    end\nendmodule\n", "corruption_explanation": "Inverted condition: '!rst_n' -> 'rst_n'", "modification_type": "invert_condition", "modification_line": 20, "original_snippet": "if(!rst_n) begin", "modified_snippet": "if(rst_n) begin", "issue_description": "The buggy code has an inverted condition in an if statement. Instead of checking if(x), it checks if(!x), causing the logic to execute when it shouldn't and skip execution when it should. All conditional behavior is reversed from intended functionality.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_condition modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted condition: '!rst_n' -> 'rst_n'\n   \u2022 Line 20: Original: if(!rst_n) begin\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 20.\n   \u2022 Restore the original code: if(!rst_n) begin\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert condition.", "complexity": 7, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_condition"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.631975", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "RAM", "module_name": "RAM", "description": "Please act as a professional verilog designer.\n\nImplement a dual-port RAM with a depth of 8 and a bit width of 6 bits, with all data initialized to 000000. It has two groups of ports, respectively for reading data and writing data, and read and write operations can be carried out at the same time. When the read_en signal is 1, the read_data of the corresponding position is read through the read_addr signal and output; When the write_en signal is 1, data is written to the corresponding position through the write_addr signal and write-data signal.\n\nModule name:  \n    RAM               \nInput ports:\n\tclk: Clock signal used for synchronous operation.\n\trst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\twrite_en: Write enable signal to initiate a write operation.\n\twrite_addr: Address for the write operation.\n\twrite_data: Data to be written to the RAM.\n\tread_en: Read enable signal to initiate a read operation.\n\tread_addr: Address for the read operation.\n\nOutput ports:\n    read_data: Output signal representing the data read from the RAM.\n\nParameter: \n\tWIDTH = 6;\n    DEPTH = 8;\n\nImplementation:\nRAM Array:\nThe module includes a register array, RAM. The array is defined as reg [DEPTH - 1 : 0] RAM [2**WIDTH-1:0], allowing for 2^6 memory locations, each with a width of 6 bits.\nWrite Operation:\nThe first always block triggers on the positive edge of the clock signal (posedge clk) or the negative edge of the reset signal (negedge rst_n).\nOn reset, indicated by !rst_n, all memory locations in the RAM array are cleared to 0.\nIf the write enable signal (write_en) is active, the data (write_data) is written to the RAM array at the specified address (write_addr).\nRead Operation:\nThe second always block triggers on the positive edge of the clock signal (posedge clk) or the negative edge of the reset signal (negedge rst_n).\nOn reset, indicated by !rst_n, the read_data register is cleared to 0.\nIf the read enable signal (read_en) is active, the data at the specified address (read_addr) in the RAM array is assigned to the read_data register.\nIf the read enable signal is not active, the read_data register is cleared to 0.\n\nGive me the complete code.\n"}, "clean_code": "module RAM (\n\tinput clk,\n\tinput rst_n,\n\t\n\tinput write_en,\n\tinput [7:0]write_addr,\n\tinput [5:0]write_data,\n\t\n\tinput read_en,\n\tinput [7:0]read_addr,\n\toutput reg [5:0]read_data\n);\n    \n    //defination\n    reg [7 : 0] RAM [11:0];\n\n    //output \n    integer i;\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) begin\n               for(i = 0; i < 8; i = i + 1) begin\n                   RAM[i] <= 'd0;\n               end\n        end\n        else if(write_en) \n            RAM[write_addr] <= write_data;\n    end\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) \n            read_data <= 'd0;\n        else if(read_en) \n            read_data <= RAM[read_addr];\n        else \n            read_data <= 'd0;\n    end\nendmodule\n", "corrupted_code": "module RAM (\n\tinput clk,\n\tinput rst_n,\n\t\n\tinput write_en,\n\tinput [7:0]write_addr,\n\tinput [5:0]write_data,\n\t\n\tinput read_en,\n\tinput [8:0]read_addr,\n\toutput reg [5:0]read_data\n);\n    \n    //defination\n    reg [7 : 0] RAM [11:0];\n\n    //output \n    integer i;\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) begin\n               for(i = 0; i < 8; i = i + 1) begin\n                   RAM[i] <= 'd0;\n               end\n        end\n        else if(write_en) \n            RAM[write_addr] <= write_data;\n    end\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) \n            read_data <= 'd0;\n        else if(read_en) \n            read_data <= RAM[read_addr];\n        else \n            read_data <= 'd0;\n    end\nendmodule\n", "corruption_explanation": "Changed bit width from [7:0] to [8:0]", "modification_type": "change_bit_width", "modification_line": 10, "original_snippet": "[7:0]", "modified_snippet": "[8:0]", "issue_description": "The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_bit_width modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed bit width from [7:0] to [8:0]\n   \u2022 Line 10: Original: [7:0]\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 10.\n   \u2022 Restore the original code: [7:0]\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change bit width.", "complexity": 7, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_bit_width"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.634240", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "RAM", "module_name": "RAM", "description": "Please act as a professional verilog designer.\n\nImplement a dual-port RAM with a depth of 8 and a bit width of 6 bits, with all data initialized to 000000. It has two groups of ports, respectively for reading data and writing data, and read and write operations can be carried out at the same time. When the read_en signal is 1, the read_data of the corresponding position is read through the read_addr signal and output; When the write_en signal is 1, data is written to the corresponding position through the write_addr signal and write-data signal.\n\nModule name:  \n    RAM               \nInput ports:\n\tclk: Clock signal used for synchronous operation.\n\trst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\twrite_en: Write enable signal to initiate a write operation.\n\twrite_addr: Address for the write operation.\n\twrite_data: Data to be written to the RAM.\n\tread_en: Read enable signal to initiate a read operation.\n\tread_addr: Address for the read operation.\n\nOutput ports:\n    read_data: Output signal representing the data read from the RAM.\n\nParameter: \n\tWIDTH = 6;\n    DEPTH = 8;\n\nImplementation:\nRAM Array:\nThe module includes a register array, RAM. The array is defined as reg [DEPTH - 1 : 0] RAM [2**WIDTH-1:0], allowing for 2^6 memory locations, each with a width of 6 bits.\nWrite Operation:\nThe first always block triggers on the positive edge of the clock signal (posedge clk) or the negative edge of the reset signal (negedge rst_n).\nOn reset, indicated by !rst_n, all memory locations in the RAM array are cleared to 0.\nIf the write enable signal (write_en) is active, the data (write_data) is written to the RAM array at the specified address (write_addr).\nRead Operation:\nThe second always block triggers on the positive edge of the clock signal (posedge clk) or the negative edge of the reset signal (negedge rst_n).\nOn reset, indicated by !rst_n, the read_data register is cleared to 0.\nIf the read enable signal (read_en) is active, the data at the specified address (read_addr) in the RAM array is assigned to the read_data register.\nIf the read enable signal is not active, the read_data register is cleared to 0.\n\nGive me the complete code.\n"}, "clean_code": "module RAM (\n\tinput clk,\n\tinput rst_n,\n\t\n\tinput write_en,\n\tinput [7:0]write_addr,\n\tinput [5:0]write_data,\n\t\n\tinput read_en,\n\tinput [7:0]read_addr,\n\toutput reg [5:0]read_data\n);\n    \n    //defination\n    reg [7 : 0] RAM [11:0];\n\n    //output \n    integer i;\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) begin\n               for(i = 0; i < 8; i = i + 1) begin\n                   RAM[i] <= 'd0;\n               end\n        end\n        else if(write_en) \n            RAM[write_addr] <= write_data;\n    end\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) \n            read_data <= 'd0;\n        else if(read_en) \n            read_data <= RAM[read_addr];\n        else \n            read_data <= 'd0;\n    end\nendmodule\n", "corrupted_code": "module RAM (\n\tinput clk,\n\tinput rst_n,\n\t\n\tinput write_en,\n\tinput [7:0]write_addr,\n\tinput [5:0]write_data,\n\t\n\tinput read_en,\n\tinput [7:0]read_addr,\n\toutput reg [5:0]read_data\n);\n    \n    //defination\n    reg [7 : 0] RAM [11:0];\n\n    //output \n    integer i;\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) begin\n               for(i = 0; i < 8; i = i + 1) begin\n                   RAM[i] <= 'd0;\n               end\n        end\n        else if(write_en) \n            RAM[write_addr] <= write_data;\n    end\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) \n            read_data <= 'd0;\n        else if(read_en) \n            read_data <= RAM[read_addr];\n        else \n            read_data <= 'd0;\n    end\n\n    wire clk_dup;\n    assign clk_dup = clk;\nendmodule\n", "corruption_explanation": "Added duplicate clock signal clk_dup", "modification_type": "duplicate_clock_signal", "modification_line": 15, "original_snippet": "(none)", "modified_snippet": "wire clk_dup;\n    assign clk_dup = clk;", "issue_description": "The buggy code has a duplicate clock signal. A phantom clock domain is created, which may confuse CDC analysis tools and create subtle timing issues in synthesis. This violates clock domain design best practices.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a duplicate_clock_signal modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added duplicate clock signal clk_dup\n   \u2022 Line 15: Original: (none)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 15.\n   \u2022 Restore the original code: (none)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to duplicate clock signal.", "complexity": 7, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["duplicate_clock_signal"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.636352", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "RAM", "module_name": "RAM", "description": "Please act as a professional verilog designer.\n\nImplement a dual-port RAM with a depth of 8 and a bit width of 6 bits, with all data initialized to 000000. It has two groups of ports, respectively for reading data and writing data, and read and write operations can be carried out at the same time. When the read_en signal is 1, the read_data of the corresponding position is read through the read_addr signal and output; When the write_en signal is 1, data is written to the corresponding position through the write_addr signal and write-data signal.\n\nModule name:  \n    RAM               \nInput ports:\n\tclk: Clock signal used for synchronous operation.\n\trst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\twrite_en: Write enable signal to initiate a write operation.\n\twrite_addr: Address for the write operation.\n\twrite_data: Data to be written to the RAM.\n\tread_en: Read enable signal to initiate a read operation.\n\tread_addr: Address for the read operation.\n\nOutput ports:\n    read_data: Output signal representing the data read from the RAM.\n\nParameter: \n\tWIDTH = 6;\n    DEPTH = 8;\n\nImplementation:\nRAM Array:\nThe module includes a register array, RAM. The array is defined as reg [DEPTH - 1 : 0] RAM [2**WIDTH-1:0], allowing for 2^6 memory locations, each with a width of 6 bits.\nWrite Operation:\nThe first always block triggers on the positive edge of the clock signal (posedge clk) or the negative edge of the reset signal (negedge rst_n).\nOn reset, indicated by !rst_n, all memory locations in the RAM array are cleared to 0.\nIf the write enable signal (write_en) is active, the data (write_data) is written to the RAM array at the specified address (write_addr).\nRead Operation:\nThe second always block triggers on the positive edge of the clock signal (posedge clk) or the negative edge of the reset signal (negedge rst_n).\nOn reset, indicated by !rst_n, the read_data register is cleared to 0.\nIf the read enable signal (read_en) is active, the data at the specified address (read_addr) in the RAM array is assigned to the read_data register.\nIf the read enable signal is not active, the read_data register is cleared to 0.\n\nGive me the complete code.\n"}, "clean_code": "module RAM (\n\tinput clk,\n\tinput rst_n,\n\t\n\tinput write_en,\n\tinput [7:0]write_addr,\n\tinput [5:0]write_data,\n\t\n\tinput read_en,\n\tinput [7:0]read_addr,\n\toutput reg [5:0]read_data\n);\n    \n    //defination\n    reg [7 : 0] RAM [11:0];\n\n    //output \n    integer i;\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) begin\n               for(i = 0; i < 8; i = i + 1) begin\n                   RAM[i] <= 'd0;\n               end\n        end\n        else if(write_en) \n            RAM[write_addr] <= write_data;\n    end\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) \n            read_data <= 'd0;\n        else if(read_en) \n            read_data <= RAM[read_addr];\n        else \n            read_data <= 'd0;\n    end\nendmodule\n", "corrupted_code": "module RAM (\n\tinput clk,\n\tinput rst_n,\n\t\n\tinput write_en,\n\tinput [7:0]write_addr,\n\tinput [5:0]write_data,\n\t\n\tinput read_en,\n\tinput [7:0]read_addr,\n\toutput reg [5:0]read_data\n);\n    \n    //defination\n    reg [7 : 0] RAM [11:0];\n\n    //output \n    integer i;\n    always@(posedge clk or negedge rst_n)begin\n        \n        end\n        else if(write_en) \n            RAM[write_addr] <= write_data;\n    end\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) \n            read_data <= 'd0;\n        else if(read_en) \n            read_data <= RAM[read_addr];\n        else \n            read_data <= 'd0;\n    end\nendmodule\n", "corruption_explanation": "Removed a conditional block", "modification_type": "remove_conditional", "modification_line": 20, "original_snippet": "if(!rst_n) begin\n               for(i = 0; i < 8; i = i + 1) begin\n                   RAM[i] <= 'd0;\n               end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing a conditional block. This removes important control logic, causing the design to skip necessary state transitions or data processing. Test cases that depend on the conditional behavior will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_conditional modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed a conditional block\n   \u2022 Line 20: Original: if(!rst_n) begin\n               for(i = 0; i < 8; i = i + 1) begin\n                   RAM[i] <= 'd0;\n               end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 20.\n   \u2022 Restore the original code: if(!rst_n) begin\n               for(i = 0; i < 8; i = i + 1) begin\n                   RAM[i] <= 'd0;\n               end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove conditional.", "complexity": 7, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_conditional"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.637512", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "RAM", "module_name": "RAM", "description": "Please act as a professional verilog designer.\n\nImplement a dual-port RAM with a depth of 8 and a bit width of 6 bits, with all data initialized to 000000. It has two groups of ports, respectively for reading data and writing data, and read and write operations can be carried out at the same time. When the read_en signal is 1, the read_data of the corresponding position is read through the read_addr signal and output; When the write_en signal is 1, data is written to the corresponding position through the write_addr signal and write-data signal.\n\nModule name:  \n    RAM               \nInput ports:\n\tclk: Clock signal used for synchronous operation.\n\trst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\twrite_en: Write enable signal to initiate a write operation.\n\twrite_addr: Address for the write operation.\n\twrite_data: Data to be written to the RAM.\n\tread_en: Read enable signal to initiate a read operation.\n\tread_addr: Address for the read operation.\n\nOutput ports:\n    read_data: Output signal representing the data read from the RAM.\n\nParameter: \n\tWIDTH = 6;\n    DEPTH = 8;\n\nImplementation:\nRAM Array:\nThe module includes a register array, RAM. The array is defined as reg [DEPTH - 1 : 0] RAM [2**WIDTH-1:0], allowing for 2^6 memory locations, each with a width of 6 bits.\nWrite Operation:\nThe first always block triggers on the positive edge of the clock signal (posedge clk) or the negative edge of the reset signal (negedge rst_n).\nOn reset, indicated by !rst_n, all memory locations in the RAM array are cleared to 0.\nIf the write enable signal (write_en) is active, the data (write_data) is written to the RAM array at the specified address (write_addr).\nRead Operation:\nThe second always block triggers on the positive edge of the clock signal (posedge clk) or the negative edge of the reset signal (negedge rst_n).\nOn reset, indicated by !rst_n, the read_data register is cleared to 0.\nIf the read enable signal (read_en) is active, the data at the specified address (read_addr) in the RAM array is assigned to the read_data register.\nIf the read enable signal is not active, the read_data register is cleared to 0.\n\nGive me the complete code.\n"}, "clean_code": "module RAM (\n\tinput clk,\n\tinput rst_n,\n\t\n\tinput write_en,\n\tinput [7:0]write_addr,\n\tinput [5:0]write_data,\n\t\n\tinput read_en,\n\tinput [7:0]read_addr,\n\toutput reg [5:0]read_data\n);\n    \n    //defination\n    reg [7 : 0] RAM [11:0];\n\n    //output \n    integer i;\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) begin\n               for(i = 0; i < 8; i = i + 1) begin\n                   RAM[i] <= 'd0;\n               end\n        end\n        else if(write_en) \n            RAM[write_addr] <= write_data;\n    end\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) \n            read_data <= 'd0;\n        else if(read_en) \n            read_data <= RAM[read_addr];\n        else \n            read_data <= 'd0;\n    end\nendmodule\n", "corrupted_code": "module RAM (\n\tinput clk,\n\tinput rst_n,\n\t\n\tinput write_en,\n\tinput [7:0]write_addr,\n\tinput [5:0]write_data,\n\t\n\tinput read_en,\n\tinput [7:0]read_addr,\n\toutput reg [5:0]read_data\n);\n    \n    //defination\n    reg [7 : 0] RAM [11:0];\n\n    //output \n    integer i;\n    always@(posedge clk or negedge rst_n)begin\n        \n        end\n        else if(write_en) \n            RAM[write_addr] <= write_data;\n    end\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) \n            read_data <= 'd0;\n        else if(read_en) \n            read_data <= RAM[read_addr];\n        else \n            read_data <= 'd0;\n    end\nendmodule\n", "corruption_explanation": "Removed a conditional block", "modification_type": "remove_conditional", "modification_line": 20, "original_snippet": "if(!rst_n) begin\n               for(i = 0; i < 8; i = i + 1) begin\n                   RAM[i] <= 'd0;\n               end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing a conditional block. This removes important control logic, causing the design to skip necessary state transitions or data processing. Test cases that depend on the conditional behavior will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_conditional modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed a conditional block\n   \u2022 Line 20: Original: if(!rst_n) begin\n               for(i = 0; i < 8; i = i + 1) begin\n                   RAM[i] <= 'd0;\n               end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 20.\n   \u2022 Restore the original code: if(!rst_n) begin\n               for(i = 0; i < 8; i = i + 1) begin\n                   RAM[i] <= 'd0;\n               end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove conditional.", "complexity": 7, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_conditional"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.638689", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "RAM", "module_name": "RAM", "description": "Please act as a professional verilog designer.\n\nImplement a dual-port RAM with a depth of 8 and a bit width of 6 bits, with all data initialized to 000000. It has two groups of ports, respectively for reading data and writing data, and read and write operations can be carried out at the same time. When the read_en signal is 1, the read_data of the corresponding position is read through the read_addr signal and output; When the write_en signal is 1, data is written to the corresponding position through the write_addr signal and write-data signal.\n\nModule name:  \n    RAM               \nInput ports:\n\tclk: Clock signal used for synchronous operation.\n\trst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\twrite_en: Write enable signal to initiate a write operation.\n\twrite_addr: Address for the write operation.\n\twrite_data: Data to be written to the RAM.\n\tread_en: Read enable signal to initiate a read operation.\n\tread_addr: Address for the read operation.\n\nOutput ports:\n    read_data: Output signal representing the data read from the RAM.\n\nParameter: \n\tWIDTH = 6;\n    DEPTH = 8;\n\nImplementation:\nRAM Array:\nThe module includes a register array, RAM. The array is defined as reg [DEPTH - 1 : 0] RAM [2**WIDTH-1:0], allowing for 2^6 memory locations, each with a width of 6 bits.\nWrite Operation:\nThe first always block triggers on the positive edge of the clock signal (posedge clk) or the negative edge of the reset signal (negedge rst_n).\nOn reset, indicated by !rst_n, all memory locations in the RAM array are cleared to 0.\nIf the write enable signal (write_en) is active, the data (write_data) is written to the RAM array at the specified address (write_addr).\nRead Operation:\nThe second always block triggers on the positive edge of the clock signal (posedge clk) or the negative edge of the reset signal (negedge rst_n).\nOn reset, indicated by !rst_n, the read_data register is cleared to 0.\nIf the read enable signal (read_en) is active, the data at the specified address (read_addr) in the RAM array is assigned to the read_data register.\nIf the read enable signal is not active, the read_data register is cleared to 0.\n\nGive me the complete code.\n"}, "clean_code": "module RAM (\n\tinput clk,\n\tinput rst_n,\n\t\n\tinput write_en,\n\tinput [7:0]write_addr,\n\tinput [5:0]write_data,\n\t\n\tinput read_en,\n\tinput [7:0]read_addr,\n\toutput reg [5:0]read_data\n);\n    \n    //defination\n    reg [7 : 0] RAM [11:0];\n\n    //output \n    integer i;\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) begin\n               for(i = 0; i < 8; i = i + 1) begin\n                   RAM[i] <= 'd0;\n               end\n        end\n        else if(write_en) \n            RAM[write_addr] <= write_data;\n    end\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) \n            read_data <= 'd0;\n        else if(read_en) \n            read_data <= RAM[read_addr];\n        else \n            read_data <= 'd0;\n    end\nendmodule\n", "corrupted_code": "module RAM (\n\tinput clk,\n\tinput rst_n,\n\t\n\tinput write_en,\n\tinput [7:0]write_addr,\n\tinput [5:0]write_data,\n\t\n\tinput read_en,\n\tinput [7:0]read_addr,\n\toutput reg [5:0]read_data\n);\n    \n    //defination\n    reg [7 : 0] RAM [11:0];\n\n    //output \n    integer i;\n    always@(posedge clk or posedge rst_n)begin\n        if(!rst_n) begin\n               for(i = 0; i < 8; i = i + 1) begin\n                   RAM[i] <= 'd0;\n               end\n        end\n        else if(write_en) \n            RAM[write_addr] <= write_data;\n    end\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) \n            read_data <= 'd0;\n        else if(read_en) \n            read_data <= RAM[read_addr];\n        else \n            read_data <= 'd0;\n    end\nendmodule\n", "corruption_explanation": "Inverted reset polarity in sensitivity", "modification_type": "invert_reset_polarity", "modification_line": 19, "original_snippet": "always@(posedge clk or negedge rst_n)", "modified_snippet": "always@(posedge clk or posedge rst_n)", "issue_description": "The buggy code has inverted reset polarity. If the design expects active-low reset (!rst), it now uses active-high, or vice versa. This causes the reset logic to activate during normal operation and deactivate during actual reset, breaking initialization.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_reset_polarity modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted reset polarity in sensitivity\n   \u2022 Line 19: Original: always@(posedge clk or negedge rst_n)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 19.\n   \u2022 Restore the original code: always@(posedge clk or negedge rst_n)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert reset polarity.", "complexity": 7, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_reset_polarity"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.639938", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "RAM", "module_name": "RAM", "description": "Please act as a professional verilog designer.\n\nImplement a dual-port RAM with a depth of 8 and a bit width of 6 bits, with all data initialized to 000000. It has two groups of ports, respectively for reading data and writing data, and read and write operations can be carried out at the same time. When the read_en signal is 1, the read_data of the corresponding position is read through the read_addr signal and output; When the write_en signal is 1, data is written to the corresponding position through the write_addr signal and write-data signal.\n\nModule name:  \n    RAM               \nInput ports:\n\tclk: Clock signal used for synchronous operation.\n\trst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\twrite_en: Write enable signal to initiate a write operation.\n\twrite_addr: Address for the write operation.\n\twrite_data: Data to be written to the RAM.\n\tread_en: Read enable signal to initiate a read operation.\n\tread_addr: Address for the read operation.\n\nOutput ports:\n    read_data: Output signal representing the data read from the RAM.\n\nParameter: \n\tWIDTH = 6;\n    DEPTH = 8;\n\nImplementation:\nRAM Array:\nThe module includes a register array, RAM. The array is defined as reg [DEPTH - 1 : 0] RAM [2**WIDTH-1:0], allowing for 2^6 memory locations, each with a width of 6 bits.\nWrite Operation:\nThe first always block triggers on the positive edge of the clock signal (posedge clk) or the negative edge of the reset signal (negedge rst_n).\nOn reset, indicated by !rst_n, all memory locations in the RAM array are cleared to 0.\nIf the write enable signal (write_en) is active, the data (write_data) is written to the RAM array at the specified address (write_addr).\nRead Operation:\nThe second always block triggers on the positive edge of the clock signal (posedge clk) or the negative edge of the reset signal (negedge rst_n).\nOn reset, indicated by !rst_n, the read_data register is cleared to 0.\nIf the read enable signal (read_en) is active, the data at the specified address (read_addr) in the RAM array is assigned to the read_data register.\nIf the read enable signal is not active, the read_data register is cleared to 0.\n\nGive me the complete code.\n"}, "clean_code": "module RAM (\n\tinput clk,\n\tinput rst_n,\n\t\n\tinput write_en,\n\tinput [7:0]write_addr,\n\tinput [5:0]write_data,\n\t\n\tinput read_en,\n\tinput [7:0]read_addr,\n\toutput reg [5:0]read_data\n);\n    \n    //defination\n    reg [7 : 0] RAM [11:0];\n\n    //output \n    integer i;\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) begin\n               for(i = 0; i < 8; i = i + 1) begin\n                   RAM[i] <= 'd0;\n               end\n        end\n        else if(write_en) \n            RAM[write_addr] <= write_data;\n    end\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) \n            read_data <= 'd0;\n        else if(read_en) \n            read_data <= RAM[read_addr];\n        else \n            read_data <= 'd0;\n    end\nendmodule\n", "corrupted_code": "module RAM (\n\tinput clk,\n\tinput rst_n,\n\t\n\tinput write_en,\n\tinput [7:0]write_addr,\n\tinput [5:0]write_data,\n\t\n\tinput read_en,\n\tinput [7:0]read_addr,\n\toutput reg [5:0]read_data\n);\n    \n    //defination\n    reg [7 : 0] RAM [11:0];\n\n    //output \n    integer i;\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) begin\n               for(i = 0; i < 8; i = i + 1) begin\n                   RAM[i] <= 'd0;\n               end\n        end\n        else if(write_en) \n            RAM[write_addr] <= write_data;\n    end\n    always@(posedge clk)begin\n        if(!rst_n) \n            read_data <= 'd0;\n        else if(read_en) \n            read_data <= RAM[read_addr];\n        else \n            read_data <= 'd0;\n    end\nendmodule\n", "corruption_explanation": "Removed async reset from sensitivity list", "modification_type": "remove_async_reset", "modification_line": 28, "original_snippet": "always@(posedge clk or negedge rst_n)", "modified_snippet": "always@(posedge clk)", "issue_description": "The buggy code has removed async reset from the sensitivity list. The always block only triggers on clock edges, not reset. This causes metastability on power-up and removes the ability to asynchronously reset the design.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_async_reset modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed async reset from sensitivity list\n   \u2022 Line 28: Original: always@(posedge clk or negedge rst_n)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 28.\n   \u2022 Restore the original code: always@(posedge clk or negedge rst_n)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove async reset.", "complexity": 7, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_async_reset"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.641097", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "alu", "module_name": "alu", "description": "Please act as a professional verilog designer.\n\nImplement an ALU for a 32-bit MIPS-ISA CPU. The \u201ca\u201d and \u201cb\u201d are the two operands of the ALU, the \u201caluc\u201d is the opcode, and the \u201cr\u201d gives out the result. \u201czero\u201d means if the result is zero, \u201ccarry\u201d means if there is a carry bit, \u201cnegative\u201d means if the result is negative, \u201coverflow\u201d means if the computation is overflow, the \u201cflag\u201d is the result of \u201cslt\u201d and \u201csltu\u201d instructions. The supported operations and corresponding opcode are shown below:\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter LUI = 6'b001111;\n\nModule name:  \n    alu               \nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n\nImplementation:\nThe module uses parameters to define the control signals for various operations, such as ADD, SUB, AND, OR, etc. \nThe module assigns the input operands to the signed wires and the output result (r) to the lower 32 bits of the register (res[31:0]). The flag output is determined based on the control signal (aluc) and is set to '1' when the operation is SLT or SLTU, and 'z' (high-impedance) otherwise. The zero output is set to '1' when the result is all zeros, and '0' otherwise.\nInside the always block, a case statement is used to perform the appropriate operation based on the control signal (aluc). The result is assigned to the register (res) accordingly. For shift operations (SLL, SRL, SRA, SLLV, SRLV, SRAV), the shift amount is determined by the value of 'a' or 'a[4:0]'. For the LUI operation, the upper 16 bits of 'a' are concatenated with 16 zeros to form the result.\nIf the control signal (aluc) does not match any defined operation, the result is assigned as 'z' (high-impedance).\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns / 1ps\n\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n    );\n    \n\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter JR = 6'b001000;\n    \n    parameter LUI = 6'b001111;\n      \n    \n    wire signed [31:0] a_signed;\n    wire signed [31:0] b_signed;\n    \n  \n    reg [32:0] res;\n    \n    \n    assign a_signed = a;\n    assign b_signed = b;\n    assign r = res[31:0];\n    \n    assign flag = (aluc == SLT || aluc == SLTU) ? ((aluc == SLT) ? (a_signed < b_signed) : (a < b)) : 1'bz; \n    assign zero = (res == 32'b0) ? 1'b1 : 1'b0;\n    \n    always @ (a or b or aluc)\n    begin\n        case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n                res <= a_signed - b_signed;\n            end\n            SUBU: begin \n                res <= a - b;\n            end\n            AND: begin\n                res <= a & b;\n            end\n            OR: begin\n                res <= a | b;\n            end\n            XOR: begin\n                res <= a ^ b;\n            end\n            NOR: begin\n                res <= ~(a | b);\n            end\n            SLT: begin\n                res <= a_signed < b_signed ? 1 : 0;\n            end\n            SLTU: begin\n                res <= a < b ? 1 : 0;\n            end\n            SLL: begin\n                res <= b << a;\n            end\n            SRL: begin\n                res <= b >> a;\n            end\n            SRA: begin\n                res <= b_signed >>> a_signed;\n            end\n            SLLV: begin\n                res <= b << a[4:0];\n            end\n            SRLV: begin\n                res <= b >> a[4:0];\n            end\n            SRAV: begin\n                res <= b_signed >>> a_signed[4:0];\n            end\n            LUI: begin\n                res <= {a[15:0], 16'h0000};\n            end\n            default:\n            begin\n                res <= 32'bz;\n            end\n        endcase\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns / 1ps\n\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n    );\n    \n\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter JR = 6'b001000;\n    \n    parameter LUI = 6'b001111;\n      \n    \n    wire signed [31:0] a_signed;\n    wire signed [31:0] b_signed;\n    \n  \n    reg [32:0] res;\n    \n    \n    assign a_signed = a;\n    assign b_signed = b;\n    assign r = res[31:0];\n    \n    assign flag = (aluc == SLT || aluc == SLTU) ? ((aluc == SLT) ? (a_signed < b_signed) : (a < b)) : 1'bz; \n    assign zero = (res == 32'b0) ? 1'b1 : 1'b0;\n    \n    \n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n                res <= a_signed - b_signed;\n            end\n            SUBU: begin \n                res <= a - b;\n            end\n            AND: begin\n                res <= a & b;\n            end\n            OR: begin\n                res <= a | b;\n            end\n            XOR: begin\n                res <= a ^ b;\n            end\n            NOR: begin\n                res <= ~(a | b);\n            end\n            SLT: begin\n                res <= a_signed < b_signed ? 1 : 0;\n            end\n            SLTU: begin\n                res <= a < b ? 1 : 0;\n            end\n            SLL: begin\n                res <= b << a;\n            end\n            SRL: begin\n                res <= b >> a;\n            end\n            SRA: begin\n                res <= b_signed >>> a_signed;\n            end\n            SLLV: begin\n                res <= b << a[4:0];\n            end\n            SRLV: begin\n                res <= b >> a[4:0];\n            end\n            SRAV: begin\n                res <= b_signed >>> a_signed[4:0];\n            end\n            LUI: begin\n                res <= {a[15:0], 16'h0000};\n            end\n            default:\n            begin\n                res <= 32'bz;\n            end\n        endcase\n    end\nendmodule\n", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 51, "original_snippet": "always @ (a or b or aluc)\n    begin\n        case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 51: Original: always @ (a or b or aluc)\n    begin\n        case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 51.\n   \u2022 Restore the original code: always @ (a or b or aluc)\n    begin\n        case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 38, "applicable_modifications": ["remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "shuffle_case_items", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.711488", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "alu", "module_name": "alu", "description": "Please act as a professional verilog designer.\n\nImplement an ALU for a 32-bit MIPS-ISA CPU. The \u201ca\u201d and \u201cb\u201d are the two operands of the ALU, the \u201caluc\u201d is the opcode, and the \u201cr\u201d gives out the result. \u201czero\u201d means if the result is zero, \u201ccarry\u201d means if there is a carry bit, \u201cnegative\u201d means if the result is negative, \u201coverflow\u201d means if the computation is overflow, the \u201cflag\u201d is the result of \u201cslt\u201d and \u201csltu\u201d instructions. The supported operations and corresponding opcode are shown below:\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter LUI = 6'b001111;\n\nModule name:  \n    alu               \nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n\nImplementation:\nThe module uses parameters to define the control signals for various operations, such as ADD, SUB, AND, OR, etc. \nThe module assigns the input operands to the signed wires and the output result (r) to the lower 32 bits of the register (res[31:0]). The flag output is determined based on the control signal (aluc) and is set to '1' when the operation is SLT or SLTU, and 'z' (high-impedance) otherwise. The zero output is set to '1' when the result is all zeros, and '0' otherwise.\nInside the always block, a case statement is used to perform the appropriate operation based on the control signal (aluc). The result is assigned to the register (res) accordingly. For shift operations (SLL, SRL, SRA, SLLV, SRLV, SRAV), the shift amount is determined by the value of 'a' or 'a[4:0]'. For the LUI operation, the upper 16 bits of 'a' are concatenated with 16 zeros to form the result.\nIf the control signal (aluc) does not match any defined operation, the result is assigned as 'z' (high-impedance).\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns / 1ps\n\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n    );\n    \n\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter JR = 6'b001000;\n    \n    parameter LUI = 6'b001111;\n      \n    \n    wire signed [31:0] a_signed;\n    wire signed [31:0] b_signed;\n    \n  \n    reg [32:0] res;\n    \n    \n    assign a_signed = a;\n    assign b_signed = b;\n    assign r = res[31:0];\n    \n    assign flag = (aluc == SLT || aluc == SLTU) ? ((aluc == SLT) ? (a_signed < b_signed) : (a < b)) : 1'bz; \n    assign zero = (res == 32'b0) ? 1'b1 : 1'b0;\n    \n    always @ (a or b or aluc)\n    begin\n        case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n                res <= a_signed - b_signed;\n            end\n            SUBU: begin \n                res <= a - b;\n            end\n            AND: begin\n                res <= a & b;\n            end\n            OR: begin\n                res <= a | b;\n            end\n            XOR: begin\n                res <= a ^ b;\n            end\n            NOR: begin\n                res <= ~(a | b);\n            end\n            SLT: begin\n                res <= a_signed < b_signed ? 1 : 0;\n            end\n            SLTU: begin\n                res <= a < b ? 1 : 0;\n            end\n            SLL: begin\n                res <= b << a;\n            end\n            SRL: begin\n                res <= b >> a;\n            end\n            SRA: begin\n                res <= b_signed >>> a_signed;\n            end\n            SLLV: begin\n                res <= b << a[4:0];\n            end\n            SRLV: begin\n                res <= b >> a[4:0];\n            end\n            SRAV: begin\n                res <= b_signed >>> a_signed[4:0];\n            end\n            LUI: begin\n                res <= {a[15:0], 16'h0000};\n            end\n            default:\n            begin\n                res <= 32'bz;\n            end\n        endcase\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns / 1ps\n\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n    );\n    \n\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB <= 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter JR = 6'b001000;\n    \n    parameter LUI = 6'b001111;\n      \n    \n    wire signed [31:0] a_signed;\n    wire signed [31:0] b_signed;\n    \n  \n    reg [32:0] res;\n    \n    \n    assign a_signed = a;\n    assign b_signed = b;\n    assign r = res[31:0];\n    \n    assign flag = (aluc == SLT || aluc == SLTU) ? ((aluc == SLT) ? (a_signed < b_signed) : (a < b)) : 1'bz; \n    assign zero = (res == 32'b0) ? 1'b1 : 1'b0;\n    \n    always @ (a or b or aluc)\n    begin\n        case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n                res <= a_signed - b_signed;\n            end\n            SUBU: begin \n                res <= a - b;\n            end\n            AND: begin\n                res <= a & b;\n            end\n            OR: begin\n                res <= a | b;\n            end\n            XOR: begin\n                res <= a ^ b;\n            end\n            NOR: begin\n                res <= ~(a | b);\n            end\n            SLT: begin\n                res <= a_signed < b_signed ? 1 : 0;\n            end\n            SLTU: begin\n                res <= a < b ? 1 : 0;\n            end\n            SLL: begin\n                res <= b << a;\n            end\n            SRL: begin\n                res <= b >> a;\n            end\n            SRA: begin\n                res <= b_signed >>> a_signed;\n            end\n            SLLV: begin\n                res <= b << a[4:0];\n            end\n            SRLV: begin\n                res <= b >> a[4:0];\n            end\n            SRAV: begin\n                res <= b_signed >>> a_signed[4:0];\n            end\n            LUI: begin\n                res <= {a[15:0], 16'h0000};\n            end\n            default:\n            begin\n                res <= 32'bz;\n            end\n        endcase\n    end\nendmodule\n", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 18, "original_snippet": "SUB = 6'b100010;", "modified_snippet": "SUB <= 6'b100010;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 38, "applicable_modifications": ["remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "shuffle_case_items", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.715749", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "alu", "module_name": "alu", "description": "Please act as a professional verilog designer.\n\nImplement an ALU for a 32-bit MIPS-ISA CPU. The \u201ca\u201d and \u201cb\u201d are the two operands of the ALU, the \u201caluc\u201d is the opcode, and the \u201cr\u201d gives out the result. \u201czero\u201d means if the result is zero, \u201ccarry\u201d means if there is a carry bit, \u201cnegative\u201d means if the result is negative, \u201coverflow\u201d means if the computation is overflow, the \u201cflag\u201d is the result of \u201cslt\u201d and \u201csltu\u201d instructions. The supported operations and corresponding opcode are shown below:\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter LUI = 6'b001111;\n\nModule name:  \n    alu               \nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n\nImplementation:\nThe module uses parameters to define the control signals for various operations, such as ADD, SUB, AND, OR, etc. \nThe module assigns the input operands to the signed wires and the output result (r) to the lower 32 bits of the register (res[31:0]). The flag output is determined based on the control signal (aluc) and is set to '1' when the operation is SLT or SLTU, and 'z' (high-impedance) otherwise. The zero output is set to '1' when the result is all zeros, and '0' otherwise.\nInside the always block, a case statement is used to perform the appropriate operation based on the control signal (aluc). The result is assigned to the register (res) accordingly. For shift operations (SLL, SRL, SRA, SLLV, SRLV, SRAV), the shift amount is determined by the value of 'a' or 'a[4:0]'. For the LUI operation, the upper 16 bits of 'a' are concatenated with 16 zeros to form the result.\nIf the control signal (aluc) does not match any defined operation, the result is assigned as 'z' (high-impedance).\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns / 1ps\n\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n    );\n    \n\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter JR = 6'b001000;\n    \n    parameter LUI = 6'b001111;\n      \n    \n    wire signed [31:0] a_signed;\n    wire signed [31:0] b_signed;\n    \n  \n    reg [32:0] res;\n    \n    \n    assign a_signed = a;\n    assign b_signed = b;\n    assign r = res[31:0];\n    \n    assign flag = (aluc == SLT || aluc == SLTU) ? ((aluc == SLT) ? (a_signed < b_signed) : (a < b)) : 1'bz; \n    assign zero = (res == 32'b0) ? 1'b1 : 1'b0;\n    \n    always @ (a or b or aluc)\n    begin\n        case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n                res <= a_signed - b_signed;\n            end\n            SUBU: begin \n                res <= a - b;\n            end\n            AND: begin\n                res <= a & b;\n            end\n            OR: begin\n                res <= a | b;\n            end\n            XOR: begin\n                res <= a ^ b;\n            end\n            NOR: begin\n                res <= ~(a | b);\n            end\n            SLT: begin\n                res <= a_signed < b_signed ? 1 : 0;\n            end\n            SLTU: begin\n                res <= a < b ? 1 : 0;\n            end\n            SLL: begin\n                res <= b << a;\n            end\n            SRL: begin\n                res <= b >> a;\n            end\n            SRA: begin\n                res <= b_signed >>> a_signed;\n            end\n            SLLV: begin\n                res <= b << a[4:0];\n            end\n            SRLV: begin\n                res <= b >> a[4:0];\n            end\n            SRAV: begin\n                res <= b_signed >>> a_signed[4:0];\n            end\n            LUI: begin\n                res <= {a[15:0], 16'h0000};\n            end\n            default:\n            begin\n                res <= 32'bz;\n            end\n        endcase\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns / 1ps\n\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n    );\n    \n\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter JR = 6'b001000;\n    \n    parameter LUI = 6'b001111;\n      \n    \n    wire signed [31:0] a_signed;\n    wire signed [31:0] b_signed;\n    \n  \n    reg [32:0] res;\n    \n    \n    assign a_signed = a;\n    assign b_signed = b;\n    assign r = res[31:0];\n    \n    assign flag = (aluc == SLT || aluc == SLTU) ? ((aluc == SLT) ? (a_signed < b_signed) : (a < b)) : 1'bz; \n    assign zero = (res == 32'b0) ? 1'b1 : 1'b0;\n    \n    always @(a or b)\n    begin\n        case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n                res <= a_signed - b_signed;\n            end\n            SUBU: begin \n                res <= a - b;\n            end\n            AND: begin\n                res <= a & b;\n            end\n            OR: begin\n                res <= a | b;\n            end\n            XOR: begin\n                res <= a ^ b;\n            end\n            NOR: begin\n                res <= ~(a | b);\n            end\n            SLT: begin\n                res <= a_signed < b_signed ? 1 : 0;\n            end\n            SLTU: begin\n                res <= a < b ? 1 : 0;\n            end\n            SLL: begin\n                res <= b << a;\n            end\n            SRL: begin\n                res <= b >> a;\n            end\n            SRA: begin\n                res <= b_signed >>> a_signed;\n            end\n            SLLV: begin\n                res <= b << a[4:0];\n            end\n            SRLV: begin\n                res <= b >> a[4:0];\n            end\n            SRAV: begin\n                res <= b_signed >>> a_signed[4:0];\n            end\n            LUI: begin\n                res <= {a[15:0], 16'h0000};\n            end\n            default:\n            begin\n                res <= 32'bz;\n            end\n        endcase\n    end\nendmodule\n", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 51, "original_snippet": "always @ (a or b or aluc)", "modified_snippet": "always @(a or b)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 51: Original: always @ (a or b or aluc)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 51.\n   \u2022 Restore the original code: always @ (a or b or aluc)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 38, "applicable_modifications": ["remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "shuffle_case_items", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["change_sensitivity_list"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.719543", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "alu", "module_name": "alu", "description": "Please act as a professional verilog designer.\n\nImplement an ALU for a 32-bit MIPS-ISA CPU. The \u201ca\u201d and \u201cb\u201d are the two operands of the ALU, the \u201caluc\u201d is the opcode, and the \u201cr\u201d gives out the result. \u201czero\u201d means if the result is zero, \u201ccarry\u201d means if there is a carry bit, \u201cnegative\u201d means if the result is negative, \u201coverflow\u201d means if the computation is overflow, the \u201cflag\u201d is the result of \u201cslt\u201d and \u201csltu\u201d instructions. The supported operations and corresponding opcode are shown below:\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter LUI = 6'b001111;\n\nModule name:  \n    alu               \nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n\nImplementation:\nThe module uses parameters to define the control signals for various operations, such as ADD, SUB, AND, OR, etc. \nThe module assigns the input operands to the signed wires and the output result (r) to the lower 32 bits of the register (res[31:0]). The flag output is determined based on the control signal (aluc) and is set to '1' when the operation is SLT or SLTU, and 'z' (high-impedance) otherwise. The zero output is set to '1' when the result is all zeros, and '0' otherwise.\nInside the always block, a case statement is used to perform the appropriate operation based on the control signal (aluc). The result is assigned to the register (res) accordingly. For shift operations (SLL, SRL, SRA, SLLV, SRLV, SRAV), the shift amount is determined by the value of 'a' or 'a[4:0]'. For the LUI operation, the upper 16 bits of 'a' are concatenated with 16 zeros to form the result.\nIf the control signal (aluc) does not match any defined operation, the result is assigned as 'z' (high-impedance).\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns / 1ps\n\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n    );\n    \n\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter JR = 6'b001000;\n    \n    parameter LUI = 6'b001111;\n      \n    \n    wire signed [31:0] a_signed;\n    wire signed [31:0] b_signed;\n    \n  \n    reg [32:0] res;\n    \n    \n    assign a_signed = a;\n    assign b_signed = b;\n    assign r = res[31:0];\n    \n    assign flag = (aluc == SLT || aluc == SLTU) ? ((aluc == SLT) ? (a_signed < b_signed) : (a < b)) : 1'bz; \n    assign zero = (res == 32'b0) ? 1'b1 : 1'b0;\n    \n    always @ (a or b or aluc)\n    begin\n        case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n                res <= a_signed - b_signed;\n            end\n            SUBU: begin \n                res <= a - b;\n            end\n            AND: begin\n                res <= a & b;\n            end\n            OR: begin\n                res <= a | b;\n            end\n            XOR: begin\n                res <= a ^ b;\n            end\n            NOR: begin\n                res <= ~(a | b);\n            end\n            SLT: begin\n                res <= a_signed < b_signed ? 1 : 0;\n            end\n            SLTU: begin\n                res <= a < b ? 1 : 0;\n            end\n            SLL: begin\n                res <= b << a;\n            end\n            SRL: begin\n                res <= b >> a;\n            end\n            SRA: begin\n                res <= b_signed >>> a_signed;\n            end\n            SLLV: begin\n                res <= b << a[4:0];\n            end\n            SRLV: begin\n                res <= b >> a[4:0];\n            end\n            SRAV: begin\n                res <= b_signed >>> a_signed[4:0];\n            end\n            LUI: begin\n                res <= {a[15:0], 16'h0000};\n            end\n            default:\n            begin\n                res <= 32'bz;\n            end\n        endcase\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns / 1ps\n\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n    );\n    \n\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR <= 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter JR = 6'b001000;\n    \n    parameter LUI = 6'b001111;\n      \n    \n    wire signed [31:0] a_signed;\n    wire signed [31:0] b_signed;\n    \n  \n    reg [32:0] res;\n    \n    \n    assign a_signed = a;\n    assign b_signed = b;\n    assign r = res[31:0];\n    \n    assign flag = (aluc == SLT || aluc == SLTU) ? ((aluc == SLT) ? (a_signed < b_signed) : (a < b)) : 1'bz; \n    assign zero = (res == 32'b0) ? 1'b1 : 1'b0;\n    \n    always @ (a or b or aluc)\n    begin\n        case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n                res <= a_signed - b_signed;\n            end\n            SUBU: begin \n                res <= a - b;\n            end\n            AND: begin\n                res <= a & b;\n            end\n            OR: begin\n                res <= a | b;\n            end\n            XOR: begin\n                res <= a ^ b;\n            end\n            NOR: begin\n                res <= ~(a | b);\n            end\n            SLT: begin\n                res <= a_signed < b_signed ? 1 : 0;\n            end\n            SLTU: begin\n                res <= a < b ? 1 : 0;\n            end\n            SLL: begin\n                res <= b << a;\n            end\n            SRL: begin\n                res <= b >> a;\n            end\n            SRA: begin\n                res <= b_signed >>> a_signed;\n            end\n            SLLV: begin\n                res <= b << a[4:0];\n            end\n            SRLV: begin\n                res <= b >> a[4:0];\n            end\n            SRAV: begin\n                res <= b_signed >>> a_signed[4:0];\n            end\n            LUI: begin\n                res <= {a[15:0], 16'h0000};\n            end\n            default:\n            begin\n                res <= 32'bz;\n            end\n        endcase\n    end\nendmodule\n", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 23, "original_snippet": "NOR = 6'b100111;", "modified_snippet": "NOR <= 6'b100111;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 38, "applicable_modifications": ["remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "shuffle_case_items", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.723891", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "alu", "module_name": "alu", "description": "Please act as a professional verilog designer.\n\nImplement an ALU for a 32-bit MIPS-ISA CPU. The \u201ca\u201d and \u201cb\u201d are the two operands of the ALU, the \u201caluc\u201d is the opcode, and the \u201cr\u201d gives out the result. \u201czero\u201d means if the result is zero, \u201ccarry\u201d means if there is a carry bit, \u201cnegative\u201d means if the result is negative, \u201coverflow\u201d means if the computation is overflow, the \u201cflag\u201d is the result of \u201cslt\u201d and \u201csltu\u201d instructions. The supported operations and corresponding opcode are shown below:\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter LUI = 6'b001111;\n\nModule name:  \n    alu               \nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n\nImplementation:\nThe module uses parameters to define the control signals for various operations, such as ADD, SUB, AND, OR, etc. \nThe module assigns the input operands to the signed wires and the output result (r) to the lower 32 bits of the register (res[31:0]). The flag output is determined based on the control signal (aluc) and is set to '1' when the operation is SLT or SLTU, and 'z' (high-impedance) otherwise. The zero output is set to '1' when the result is all zeros, and '0' otherwise.\nInside the always block, a case statement is used to perform the appropriate operation based on the control signal (aluc). The result is assigned to the register (res) accordingly. For shift operations (SLL, SRL, SRA, SLLV, SRLV, SRAV), the shift amount is determined by the value of 'a' or 'a[4:0]'. For the LUI operation, the upper 16 bits of 'a' are concatenated with 16 zeros to form the result.\nIf the control signal (aluc) does not match any defined operation, the result is assigned as 'z' (high-impedance).\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns / 1ps\n\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n    );\n    \n\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter JR = 6'b001000;\n    \n    parameter LUI = 6'b001111;\n      \n    \n    wire signed [31:0] a_signed;\n    wire signed [31:0] b_signed;\n    \n  \n    reg [32:0] res;\n    \n    \n    assign a_signed = a;\n    assign b_signed = b;\n    assign r = res[31:0];\n    \n    assign flag = (aluc == SLT || aluc == SLTU) ? ((aluc == SLT) ? (a_signed < b_signed) : (a < b)) : 1'bz; \n    assign zero = (res == 32'b0) ? 1'b1 : 1'b0;\n    \n    always @ (a or b or aluc)\n    begin\n        case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n                res <= a_signed - b_signed;\n            end\n            SUBU: begin \n                res <= a - b;\n            end\n            AND: begin\n                res <= a & b;\n            end\n            OR: begin\n                res <= a | b;\n            end\n            XOR: begin\n                res <= a ^ b;\n            end\n            NOR: begin\n                res <= ~(a | b);\n            end\n            SLT: begin\n                res <= a_signed < b_signed ? 1 : 0;\n            end\n            SLTU: begin\n                res <= a < b ? 1 : 0;\n            end\n            SLL: begin\n                res <= b << a;\n            end\n            SRL: begin\n                res <= b >> a;\n            end\n            SRA: begin\n                res <= b_signed >>> a_signed;\n            end\n            SLLV: begin\n                res <= b << a[4:0];\n            end\n            SRLV: begin\n                res <= b >> a[4:0];\n            end\n            SRAV: begin\n                res <= b_signed >>> a_signed[4:0];\n            end\n            LUI: begin\n                res <= {a[15:0], 16'h0000};\n            end\n            default:\n            begin\n                res <= 32'bz;\n            end\n        endcase\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns / 1ps\n\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n    );\n    \n\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter JR = 6'b001000;\n    \n    parameter LUI = 6'b001111;\n      \n    \n    wire signed [31:0] a_signed;\n    wire signed [31:0] b_signed;\n    \n  \n    reg [32:0] res;\n    \n    \n    assign a_signed = a;\n    assign b_signed = b;\n    assign r = res[31:0];\n    \n    assign flag = (aluc == SLT || aluc == SLTU) ? ((aluc == SLT) ? (a_signed < b_signed) : (a < b)) : 1'bz; \n    assign zero = (res == 32'b0) ? 1'b1 : 1'b0;\n    \n    always @ (a or b or aluc)\n    begin\n        case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n                res <= a_signed - b_signed;\n            end\n            SUBU: begin \n                res <= a - b;\n            end\n            AND: begin\n                res <= a & b;\n            end\n            OR: begin\n                res <= a | b;\n            end\n            XOR: begin\n                res <= a ^ b;\n            end\n            NOR: begin\n                res <= ~(a | b);\n            end\n            SLT: begin\n                res <= a_signed < b_signed ? 1 : 0;\n            end\n            SLTU: begin\n                res <= a < b ? 1 : 0;\n            end\n            SLL: begin\n                res <= b << a;\n            end\n            SRL: begin\n\n            end\n            SRA: begin\n                res <= b_signed >>> a_signed;\n            end\n            SLLV: begin\n                res <= b << a[4:0];\n            end\n            SRLV: begin\n                res <= b >> a[4:0];\n            end\n            SRAV: begin\n                res <= b_signed >>> a_signed[4:0];\n            end\n            LUI: begin\n                res <= {a[15:0], 16'h0000};\n            end\n            default:\n            begin\n                res <= 32'bz;\n            end\n        endcase\n    end\nendmodule\n", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 88, "original_snippet": "res <= b >> a;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 88: Original: res <= b >> a;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 88.\n   \u2022 Restore the original code: res <= b >> a;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 38, "applicable_modifications": ["remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "shuffle_case_items", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["remove_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.728304", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "alu", "module_name": "alu", "description": "Please act as a professional verilog designer.\n\nImplement an ALU for a 32-bit MIPS-ISA CPU. The \u201ca\u201d and \u201cb\u201d are the two operands of the ALU, the \u201caluc\u201d is the opcode, and the \u201cr\u201d gives out the result. \u201czero\u201d means if the result is zero, \u201ccarry\u201d means if there is a carry bit, \u201cnegative\u201d means if the result is negative, \u201coverflow\u201d means if the computation is overflow, the \u201cflag\u201d is the result of \u201cslt\u201d and \u201csltu\u201d instructions. The supported operations and corresponding opcode are shown below:\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter LUI = 6'b001111;\n\nModule name:  \n    alu               \nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n\nImplementation:\nThe module uses parameters to define the control signals for various operations, such as ADD, SUB, AND, OR, etc. \nThe module assigns the input operands to the signed wires and the output result (r) to the lower 32 bits of the register (res[31:0]). The flag output is determined based on the control signal (aluc) and is set to '1' when the operation is SLT or SLTU, and 'z' (high-impedance) otherwise. The zero output is set to '1' when the result is all zeros, and '0' otherwise.\nInside the always block, a case statement is used to perform the appropriate operation based on the control signal (aluc). The result is assigned to the register (res) accordingly. For shift operations (SLL, SRL, SRA, SLLV, SRLV, SRAV), the shift amount is determined by the value of 'a' or 'a[4:0]'. For the LUI operation, the upper 16 bits of 'a' are concatenated with 16 zeros to form the result.\nIf the control signal (aluc) does not match any defined operation, the result is assigned as 'z' (high-impedance).\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns / 1ps\n\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n    );\n    \n\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter JR = 6'b001000;\n    \n    parameter LUI = 6'b001111;\n      \n    \n    wire signed [31:0] a_signed;\n    wire signed [31:0] b_signed;\n    \n  \n    reg [32:0] res;\n    \n    \n    assign a_signed = a;\n    assign b_signed = b;\n    assign r = res[31:0];\n    \n    assign flag = (aluc == SLT || aluc == SLTU) ? ((aluc == SLT) ? (a_signed < b_signed) : (a < b)) : 1'bz; \n    assign zero = (res == 32'b0) ? 1'b1 : 1'b0;\n    \n    always @ (a or b or aluc)\n    begin\n        case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n                res <= a_signed - b_signed;\n            end\n            SUBU: begin \n                res <= a - b;\n            end\n            AND: begin\n                res <= a & b;\n            end\n            OR: begin\n                res <= a | b;\n            end\n            XOR: begin\n                res <= a ^ b;\n            end\n            NOR: begin\n                res <= ~(a | b);\n            end\n            SLT: begin\n                res <= a_signed < b_signed ? 1 : 0;\n            end\n            SLTU: begin\n                res <= a < b ? 1 : 0;\n            end\n            SLL: begin\n                res <= b << a;\n            end\n            SRL: begin\n                res <= b >> a;\n            end\n            SRA: begin\n                res <= b_signed >>> a_signed;\n            end\n            SLLV: begin\n                res <= b << a[4:0];\n            end\n            SRLV: begin\n                res <= b >> a[4:0];\n            end\n            SRAV: begin\n                res <= b_signed >>> a_signed[4:0];\n            end\n            LUI: begin\n                res <= {a[15:0], 16'h0000};\n            end\n            default:\n            begin\n                res <= 32'bz;\n            end\n        endcase\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns / 1ps\n\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n    );\n    \n\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter JR = 6'b001000;\n    \n    parameter LUI = 6'b001111;\n      \n    \n    wire signed [31:0] a_signed;\n    wire signed [31:0] b_signed;\n    \n  \n    reg [32:0] res;\n    \n    \n    assign a_signed = a;\n    assign b_signed = b;\n    assign r = res[31:0];\n    \n    assign flag = (aluc == SLT || aluc == SLTU) ? ((aluc == SLT) ? (a_signed < b_signed) : (a < b)) : 1'bz; \n    assign zero = (res == 32'b0) ? 1'b1 : 1'b0;\n    \n    always @ (a or b or aluc)\n    begin\n        case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n                res <= a_signed - b_signed;\n            end\n            SUBU: begin \n                res <= a - b;\n            end\n            AND: begin\n                res <= a & b;\n            end\n            OR: begin\n                res <= a | b;\n            end\n            XOR: begin\n                res <= a ^ b;\n            end\n            NOR: begin\n                res <= ~(a | b);\n            end\n            SLT: begin\n                res <= a_signed < b_signed ? 1 : 0;\n            end\n            SLTU: begin\n                res <= a < b ? 1 : 0;\n            end\n            SLL: begin\n                res <= b << a;\n            end\n            SRL: begin\n                res <= b >> a;\n            end\n            SRA: begin\n                res <= b_signed >>> a_signed;\n            end\n            SLLV: begin\n                res <= b << a[4:0];\n            end\n            SRLV: begin\n                res <= b >> a[4:0];\n            end\n            SRAV: begin\n                res <= b_signed >>> a_signed[4:0];\n            end\n            LUI: begin\n                res <= {a[15:0], 16'h0000};\n            end\n            endcase\n    end\nendmodule\n", "corruption_explanation": "Removed default case (may cause incomplete case warning)", "modification_type": "remove_case_default", "modification_line": 53, "original_snippet": "case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n            ", "modified_snippet": "case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n            ", "issue_description": "The buggy code is missing the default case in a case statement. This creates an incomplete case statement that can infer latches in combinational blocks or cause undefined behavior for unhandled values. Linting tools will flag this as CASEINCOMPLETE or LATCH warning.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_case_default modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed default case (may cause incomplete case warning)\n   \u2022 Line 53: Original: case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n            \n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 53.\n   \u2022 Restore the original code: case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n            \n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove case default.", "complexity": 38, "applicable_modifications": ["remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "shuffle_case_items", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["remove_case_default"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.732477", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "alu", "module_name": "alu", "description": "Please act as a professional verilog designer.\n\nImplement an ALU for a 32-bit MIPS-ISA CPU. The \u201ca\u201d and \u201cb\u201d are the two operands of the ALU, the \u201caluc\u201d is the opcode, and the \u201cr\u201d gives out the result. \u201czero\u201d means if the result is zero, \u201ccarry\u201d means if there is a carry bit, \u201cnegative\u201d means if the result is negative, \u201coverflow\u201d means if the computation is overflow, the \u201cflag\u201d is the result of \u201cslt\u201d and \u201csltu\u201d instructions. The supported operations and corresponding opcode are shown below:\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter LUI = 6'b001111;\n\nModule name:  \n    alu               \nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n\nImplementation:\nThe module uses parameters to define the control signals for various operations, such as ADD, SUB, AND, OR, etc. \nThe module assigns the input operands to the signed wires and the output result (r) to the lower 32 bits of the register (res[31:0]). The flag output is determined based on the control signal (aluc) and is set to '1' when the operation is SLT or SLTU, and 'z' (high-impedance) otherwise. The zero output is set to '1' when the result is all zeros, and '0' otherwise.\nInside the always block, a case statement is used to perform the appropriate operation based on the control signal (aluc). The result is assigned to the register (res) accordingly. For shift operations (SLL, SRL, SRA, SLLV, SRLV, SRAV), the shift amount is determined by the value of 'a' or 'a[4:0]'. For the LUI operation, the upper 16 bits of 'a' are concatenated with 16 zeros to form the result.\nIf the control signal (aluc) does not match any defined operation, the result is assigned as 'z' (high-impedance).\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns / 1ps\n\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n    );\n    \n\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter JR = 6'b001000;\n    \n    parameter LUI = 6'b001111;\n      \n    \n    wire signed [31:0] a_signed;\n    wire signed [31:0] b_signed;\n    \n  \n    reg [32:0] res;\n    \n    \n    assign a_signed = a;\n    assign b_signed = b;\n    assign r = res[31:0];\n    \n    assign flag = (aluc == SLT || aluc == SLTU) ? ((aluc == SLT) ? (a_signed < b_signed) : (a < b)) : 1'bz; \n    assign zero = (res == 32'b0) ? 1'b1 : 1'b0;\n    \n    always @ (a or b or aluc)\n    begin\n        case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n                res <= a_signed - b_signed;\n            end\n            SUBU: begin \n                res <= a - b;\n            end\n            AND: begin\n                res <= a & b;\n            end\n            OR: begin\n                res <= a | b;\n            end\n            XOR: begin\n                res <= a ^ b;\n            end\n            NOR: begin\n                res <= ~(a | b);\n            end\n            SLT: begin\n                res <= a_signed < b_signed ? 1 : 0;\n            end\n            SLTU: begin\n                res <= a < b ? 1 : 0;\n            end\n            SLL: begin\n                res <= b << a;\n            end\n            SRL: begin\n                res <= b >> a;\n            end\n            SRA: begin\n                res <= b_signed >>> a_signed;\n            end\n            SLLV: begin\n                res <= b << a[4:0];\n            end\n            SRLV: begin\n                res <= b >> a[4:0];\n            end\n            SRAV: begin\n                res <= b_signed >>> a_signed[4:0];\n            end\n            LUI: begin\n                res <= {a[15:0], 16'h0000};\n            end\n            default:\n            begin\n                res <= 32'bz;\n            end\n        endcase\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns / 1ps\n\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n    );\n    \n\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter JR = 6'b001000;\n    \n    parameter LUI = 6'b001111;\n      \n    \n    wire signed [31:0] a_signed;\n    wire signed [31:0] b_signed;\n    \n  \n    reg [32:0] res;\n    \n    \n    assign a_signed = a;\n    assign b_signed = b;\n    assign r = res[31:0];\n    \n    assign flag = (aluc == SLT || aluc == SLTU) ? ((aluc == SLT) ? (a_signed < b_signed) : (a < b)) : 1'bz; \n    assign zero = (res == 32'b0) ? 1'b1 : 1'b0;\n    \n    always @ (a or b or aluc)\n    begin\n        case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n                res <= a_signed - b_signed;\n            end\n            SUBU: begin \n                res <= a - b;\n            end\n            AND: begin\n                res <= a & b;\n            end\n            OR: begin\n                res <= a | b;\n            end\n            XOR: begin\n                res >= a ^ b;\n            end\n            NOR: begin\n                res <= ~(a | b);\n            end\n            SLT: begin\n                res <= a_signed < b_signed ? 1 : 0;\n            end\n            SLTU: begin\n                res <= a < b ? 1 : 0;\n            end\n            SLL: begin\n                res <= b << a;\n            end\n            SRL: begin\n                res <= b >> a;\n            end\n            SRA: begin\n                res <= b_signed >>> a_signed;\n            end\n            SLLV: begin\n                res <= b << a[4:0];\n            end\n            SRLV: begin\n                res <= b >> a[4:0];\n            end\n            SRAV: begin\n                res <= b_signed >>> a_signed[4:0];\n            end\n            LUI: begin\n                res <= {a[15:0], 16'h0000};\n            end\n            default:\n            begin\n                res <= 32'bz;\n            end\n        endcase\n    end\nendmodule\n", "corruption_explanation": "Changed operator from '<=' to '>='", "modification_type": "change_operator", "modification_line": 73, "original_snippet": "s <= a", "modified_snippet": "s >= a", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '<=' to '>='\n   \u2022 Line 73: Original: s <= a\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 73.\n   \u2022 Restore the original code: s <= a\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 38, "applicable_modifications": ["remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "shuffle_case_items", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.737054", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "alu", "module_name": "alu", "description": "Please act as a professional verilog designer.\n\nImplement an ALU for a 32-bit MIPS-ISA CPU. The \u201ca\u201d and \u201cb\u201d are the two operands of the ALU, the \u201caluc\u201d is the opcode, and the \u201cr\u201d gives out the result. \u201czero\u201d means if the result is zero, \u201ccarry\u201d means if there is a carry bit, \u201cnegative\u201d means if the result is negative, \u201coverflow\u201d means if the computation is overflow, the \u201cflag\u201d is the result of \u201cslt\u201d and \u201csltu\u201d instructions. The supported operations and corresponding opcode are shown below:\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter LUI = 6'b001111;\n\nModule name:  \n    alu               \nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n\nImplementation:\nThe module uses parameters to define the control signals for various operations, such as ADD, SUB, AND, OR, etc. \nThe module assigns the input operands to the signed wires and the output result (r) to the lower 32 bits of the register (res[31:0]). The flag output is determined based on the control signal (aluc) and is set to '1' when the operation is SLT or SLTU, and 'z' (high-impedance) otherwise. The zero output is set to '1' when the result is all zeros, and '0' otherwise.\nInside the always block, a case statement is used to perform the appropriate operation based on the control signal (aluc). The result is assigned to the register (res) accordingly. For shift operations (SLL, SRL, SRA, SLLV, SRLV, SRAV), the shift amount is determined by the value of 'a' or 'a[4:0]'. For the LUI operation, the upper 16 bits of 'a' are concatenated with 16 zeros to form the result.\nIf the control signal (aluc) does not match any defined operation, the result is assigned as 'z' (high-impedance).\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns / 1ps\n\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n    );\n    \n\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter JR = 6'b001000;\n    \n    parameter LUI = 6'b001111;\n      \n    \n    wire signed [31:0] a_signed;\n    wire signed [31:0] b_signed;\n    \n  \n    reg [32:0] res;\n    \n    \n    assign a_signed = a;\n    assign b_signed = b;\n    assign r = res[31:0];\n    \n    assign flag = (aluc == SLT || aluc == SLTU) ? ((aluc == SLT) ? (a_signed < b_signed) : (a < b)) : 1'bz; \n    assign zero = (res == 32'b0) ? 1'b1 : 1'b0;\n    \n    always @ (a or b or aluc)\n    begin\n        case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n                res <= a_signed - b_signed;\n            end\n            SUBU: begin \n                res <= a - b;\n            end\n            AND: begin\n                res <= a & b;\n            end\n            OR: begin\n                res <= a | b;\n            end\n            XOR: begin\n                res <= a ^ b;\n            end\n            NOR: begin\n                res <= ~(a | b);\n            end\n            SLT: begin\n                res <= a_signed < b_signed ? 1 : 0;\n            end\n            SLTU: begin\n                res <= a < b ? 1 : 0;\n            end\n            SLL: begin\n                res <= b << a;\n            end\n            SRL: begin\n                res <= b >> a;\n            end\n            SRA: begin\n                res <= b_signed >>> a_signed;\n            end\n            SLLV: begin\n                res <= b << a[4:0];\n            end\n            SRLV: begin\n                res <= b >> a[4:0];\n            end\n            SRAV: begin\n                res <= b_signed >>> a_signed[4:0];\n            end\n            LUI: begin\n                res <= {a[15:0], 16'h0000};\n            end\n            default:\n            begin\n                res <= 32'bz;\n            end\n        endcase\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns / 1ps\n\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n    );\n    \n\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter JR = 6'b001000;\n    \n    parameter LUI = 6'b001111;\n      \n    \n    wire signed [31:0] a_signed;\n    wire signed [31:0] b_signed;\n    \n  \n    reg [32:0] res;\n    \n    \n    assign a_signed = a;\n    assign b_signed = b;\n    assign r = res[31:0];\n    \n    assign flag = (aluc == SLT || aluc == SLTU) ? ((aluc == SLT) ? (a_signed < b_signed) : (a < b)) : 1'bz; \n    assign zero = (res == 32'b0) ? 1'b1 : 1'b0;\n    \n    always @ (a or b or aluc)\n    begin\n        case(aluc)\n            SLLV: begin\n                res <= b <<\n            SLL: begin\n                res <= b << a;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SRLV: begin\n                res <= b >>\n            SRL: begin\n                res <= b >> a;\n            end\n            NOR: begin\n                res <= ~(a | b);\n            end {a[15:0], 16'h0000};\n            end\n            SLTU: begin\n                res <= a < b ?\n            SRAV: begin\n                res <= b_signed >>> 1 : 0;\n            end\n            SLT: begin\n                res <= a_signed < b_signed ?\n            AND: begin\n                res <= a & b;\n            end\n            LUI: begin\n                res <=\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            XOR: begin\n                res <= a ^ b;\n            end\n            SUBU: begin \n                res <= a - b;\n            end a[4:0];\n            end a[4:0];\n            end a_signed[4:0];\n            end\n            SUB: begin \n                res <= a_signed - b_signed;\n            end\n            OR: begin\n                res <= a | b;\n            end\n            SRA: begin\n                res <= b_signed >>> a_signed;\n            end 1 : 0;\n            end\n            default:\n            begin\n                res <= 32'bz;\n            end\n        endcase\n    end\nendmodule\n", "corruption_explanation": "Shuffled case items order", "modification_type": "shuffle_case_items", "modification_line": 53, "original_snippet": "case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n            ", "modified_snippet": "case(aluc)\n            SLLV: begin\n                res <= b <<\n            SLL: begin\n                res <= b << a;\n            end\n            ADDU: begin\n                res <= a + b;\n            e", "issue_description": "The buggy code has reordered case items in a case statement. For priority-encoded case statements (casex, casez), the order matters. Reordering breaks the intended priority, causing incorrect item matching. Test cases may pass for some inputs but fail for overlapping patterns.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a shuffle_case_items modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Shuffled case items order\n   \u2022 Line 53: Original: case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n            \n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 53.\n   \u2022 Restore the original code: case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n            \n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to shuffle case items.", "complexity": 38, "applicable_modifications": ["remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "shuffle_case_items", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["shuffle_case_items"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.741151", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "alu", "module_name": "alu", "description": "Please act as a professional verilog designer.\n\nImplement an ALU for a 32-bit MIPS-ISA CPU. The \u201ca\u201d and \u201cb\u201d are the two operands of the ALU, the \u201caluc\u201d is the opcode, and the \u201cr\u201d gives out the result. \u201czero\u201d means if the result is zero, \u201ccarry\u201d means if there is a carry bit, \u201cnegative\u201d means if the result is negative, \u201coverflow\u201d means if the computation is overflow, the \u201cflag\u201d is the result of \u201cslt\u201d and \u201csltu\u201d instructions. The supported operations and corresponding opcode are shown below:\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter LUI = 6'b001111;\n\nModule name:  \n    alu               \nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n\nImplementation:\nThe module uses parameters to define the control signals for various operations, such as ADD, SUB, AND, OR, etc. \nThe module assigns the input operands to the signed wires and the output result (r) to the lower 32 bits of the register (res[31:0]). The flag output is determined based on the control signal (aluc) and is set to '1' when the operation is SLT or SLTU, and 'z' (high-impedance) otherwise. The zero output is set to '1' when the result is all zeros, and '0' otherwise.\nInside the always block, a case statement is used to perform the appropriate operation based on the control signal (aluc). The result is assigned to the register (res) accordingly. For shift operations (SLL, SRL, SRA, SLLV, SRLV, SRAV), the shift amount is determined by the value of 'a' or 'a[4:0]'. For the LUI operation, the upper 16 bits of 'a' are concatenated with 16 zeros to form the result.\nIf the control signal (aluc) does not match any defined operation, the result is assigned as 'z' (high-impedance).\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns / 1ps\n\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n    );\n    \n\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter JR = 6'b001000;\n    \n    parameter LUI = 6'b001111;\n      \n    \n    wire signed [31:0] a_signed;\n    wire signed [31:0] b_signed;\n    \n  \n    reg [32:0] res;\n    \n    \n    assign a_signed = a;\n    assign b_signed = b;\n    assign r = res[31:0];\n    \n    assign flag = (aluc == SLT || aluc == SLTU) ? ((aluc == SLT) ? (a_signed < b_signed) : (a < b)) : 1'bz; \n    assign zero = (res == 32'b0) ? 1'b1 : 1'b0;\n    \n    always @ (a or b or aluc)\n    begin\n        case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n                res <= a_signed - b_signed;\n            end\n            SUBU: begin \n                res <= a - b;\n            end\n            AND: begin\n                res <= a & b;\n            end\n            OR: begin\n                res <= a | b;\n            end\n            XOR: begin\n                res <= a ^ b;\n            end\n            NOR: begin\n                res <= ~(a | b);\n            end\n            SLT: begin\n                res <= a_signed < b_signed ? 1 : 0;\n            end\n            SLTU: begin\n                res <= a < b ? 1 : 0;\n            end\n            SLL: begin\n                res <= b << a;\n            end\n            SRL: begin\n                res <= b >> a;\n            end\n            SRA: begin\n                res <= b_signed >>> a_signed;\n            end\n            SLLV: begin\n                res <= b << a[4:0];\n            end\n            SRLV: begin\n                res <= b >> a[4:0];\n            end\n            SRAV: begin\n                res <= b_signed >>> a_signed[4:0];\n            end\n            LUI: begin\n                res <= {a[15:0], 16'h0000};\n            end\n            default:\n            begin\n                res <= 32'bz;\n            end\n        endcase\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns / 1ps\n\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n    );\n    \n\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter JR = 6'b001000;\n    \n    parameter LUI = 6'b001111;\n      \n    \n    wire signed [31:0] a_signed;\n    wire signed [31:0] b_signed;\n    \n  \n    reg [32:0] res;\n    \n    \n    assign a_signed = a;\n    assign b_signed = b;\n    assign r = res[31:0];\n    \n    assign flag = (aluc == SLT || aluc == SLTU) ? ((aluc == SLT) ? (a_signed < b_signed) : (a < b)) : 1'bz; \n    assign zero = (res == 32'b0) ? 1'b1 : 1'b0;\n    \n    always @ (a or b or aluc)\n    begin\n        case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n                res <= a_signed - b_signed;\n            end\n            SUBU: begin \n                res <= a - b;\n            end\n            AND: begin\n                res <= a & b;\n            end\n            OR: begin\n                res <= a | b;\n            end\n            XOR: begin\n                res <= a ^ b;\n            end\n            NOR: begin\n                res <= ~(a | b);\n            end\n            SLT: begin\n                res <= a_signed < b_signed ? 1 : 0;\n            end\n            SLTU: begin\n                res <= a < b ? 1 : 0;\n            end\n            SLL: begin\n                res <= b << a;\n            end\n            SRL: begin\n                res <= b >> a;\n            end\n            SRA: begin\n                res <= b_signed >>> a_signed;\n            end\n            SLLV: begin\n                res <= b << a[4:0];\n            end\n            SRLV: begin\n                res <= b >> a[4:0];\n            end\n            SRAV: begin\n                res <= b_signed >>> a_signed[4:0];\n            end\n            LUI: begin\n                res <= {a[15:0], 16'h0000};\n            end\n            endcase\n    end\nendmodule\n", "corruption_explanation": "Removed default case (may cause incomplete case warning)", "modification_type": "remove_case_default", "modification_line": 53, "original_snippet": "case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n            ", "modified_snippet": "case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n            ", "issue_description": "The buggy code is missing the default case in a case statement. This creates an incomplete case statement that can infer latches in combinational blocks or cause undefined behavior for unhandled values. Linting tools will flag this as CASEINCOMPLETE or LATCH warning.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_case_default modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed default case (may cause incomplete case warning)\n   \u2022 Line 53: Original: case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n            \n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 53.\n   \u2022 Restore the original code: case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n            \n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove case default.", "complexity": 38, "applicable_modifications": ["remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "shuffle_case_items", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["remove_case_default"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.744967", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "alu", "module_name": "alu", "description": "Please act as a professional verilog designer.\n\nImplement an ALU for a 32-bit MIPS-ISA CPU. The \u201ca\u201d and \u201cb\u201d are the two operands of the ALU, the \u201caluc\u201d is the opcode, and the \u201cr\u201d gives out the result. \u201czero\u201d means if the result is zero, \u201ccarry\u201d means if there is a carry bit, \u201cnegative\u201d means if the result is negative, \u201coverflow\u201d means if the computation is overflow, the \u201cflag\u201d is the result of \u201cslt\u201d and \u201csltu\u201d instructions. The supported operations and corresponding opcode are shown below:\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter LUI = 6'b001111;\n\nModule name:  \n    alu               \nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n\nImplementation:\nThe module uses parameters to define the control signals for various operations, such as ADD, SUB, AND, OR, etc. \nThe module assigns the input operands to the signed wires and the output result (r) to the lower 32 bits of the register (res[31:0]). The flag output is determined based on the control signal (aluc) and is set to '1' when the operation is SLT or SLTU, and 'z' (high-impedance) otherwise. The zero output is set to '1' when the result is all zeros, and '0' otherwise.\nInside the always block, a case statement is used to perform the appropriate operation based on the control signal (aluc). The result is assigned to the register (res) accordingly. For shift operations (SLL, SRL, SRA, SLLV, SRLV, SRAV), the shift amount is determined by the value of 'a' or 'a[4:0]'. For the LUI operation, the upper 16 bits of 'a' are concatenated with 16 zeros to form the result.\nIf the control signal (aluc) does not match any defined operation, the result is assigned as 'z' (high-impedance).\n\nGive me the complete code.\n"}, "clean_code": "`timescale 1ns / 1ps\n\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n    );\n    \n\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter JR = 6'b001000;\n    \n    parameter LUI = 6'b001111;\n      \n    \n    wire signed [31:0] a_signed;\n    wire signed [31:0] b_signed;\n    \n  \n    reg [32:0] res;\n    \n    \n    assign a_signed = a;\n    assign b_signed = b;\n    assign r = res[31:0];\n    \n    assign flag = (aluc == SLT || aluc == SLTU) ? ((aluc == SLT) ? (a_signed < b_signed) : (a < b)) : 1'bz; \n    assign zero = (res == 32'b0) ? 1'b1 : 1'b0;\n    \n    always @ (a or b or aluc)\n    begin\n        case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n                res <= a_signed - b_signed;\n            end\n            SUBU: begin \n                res <= a - b;\n            end\n            AND: begin\n                res <= a & b;\n            end\n            OR: begin\n                res <= a | b;\n            end\n            XOR: begin\n                res <= a ^ b;\n            end\n            NOR: begin\n                res <= ~(a | b);\n            end\n            SLT: begin\n                res <= a_signed < b_signed ? 1 : 0;\n            end\n            SLTU: begin\n                res <= a < b ? 1 : 0;\n            end\n            SLL: begin\n                res <= b << a;\n            end\n            SRL: begin\n                res <= b >> a;\n            end\n            SRA: begin\n                res <= b_signed >>> a_signed;\n            end\n            SLLV: begin\n                res <= b << a[4:0];\n            end\n            SRLV: begin\n                res <= b >> a[4:0];\n            end\n            SRAV: begin\n                res <= b_signed >>> a_signed[4:0];\n            end\n            LUI: begin\n                res <= {a[15:0], 16'h0000};\n            end\n            default:\n            begin\n                res <= 32'bz;\n            end\n        endcase\n    end\nendmodule\n", "corrupted_code": "`timescale 1ns / 1ps\n\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n    );\n    \n\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter JR = 6'b001000;\n    \n    parameter LUI = 6'b001111;\n      \n    \n    wire signed [31:0] a_signed;\n    wire signed [31:0] b_signed;\n    \n  \n    reg [32:0] res;\n    \n    \n    assign a_signed = a;\n    assign b_signed = b;\n    assign r = res[31:0];\n    \n    assign flag = (aluc == SLT || aluc == SLTU) ? ((aluc == SLT) ? (a_signed < b_signed) : (a < b)) : 1'bz; \n    assign zero = (res == 32'b0) ? 1'b1 : 1'b0;\n    \n    always @ (a or b or aluc)\n    begin\n        case(aluc) {a[15:0], 16'h0000};\n            end\n            SUBU: begin \n                res <= a - b;\n            end\n            OR: begin\n                res <= a | b;\n            end\n            AND: begin\n                res <= a & b;\n            end\n            SLL: begin\n                res <= b << a;\n            end a_signed[4:0];\n            end\n            ADD: begin\n                res <= a_signed + b_signed;\n            end 1 : 0;\n            end\n            SRAV: begin\n                res <= b_signed >>>\n            XOR: begin\n                res <= a ^ b;\n            end\n            SRA: begin\n                res <= b_signed >>> a_signed;\n            end\n            SRL: begin\n                res <= b >> a;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SLT: begin\n                res <= a_signed < b_signed ?\n            LUI: begin\n                res <=\n            NOR: begin\n                res <= ~(a | b);\n            end a[4:0];\n            end\n            SLTU: begin\n                res <= a < b ?\n            SUB: begin \n                res <= a_signed - b_signed;\n            end 1 : 0;\n            end\n            SRLV: begin\n                res <= b >> a[4:0];\n            end\n            SLLV: begin\n                res <= b <<\n            default:\n            begin\n                res <= 32'bz;\n            end\n        endcase\n    end\nendmodule\n", "corruption_explanation": "Shuffled case items order", "modification_type": "shuffle_case_items", "modification_line": 53, "original_snippet": "case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n            ", "modified_snippet": "case(aluc) {a[15:0], 16'h0000};\n            end\n            SUBU: begin \n                res <= a - b;\n            end\n            OR: begin\n                res <= a | b;\n            end\n            A", "issue_description": "The buggy code has reordered case items in a case statement. For priority-encoded case statements (casex, casez), the order matters. Reordering breaks the intended priority, causing incorrect item matching. Test cases may pass for some inputs but fail for overlapping patterns.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a shuffle_case_items modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Shuffled case items order\n   \u2022 Line 53: Original: case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n            \n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 53.\n   \u2022 Restore the original code: case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n            \n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to shuffle case items.", "complexity": 38, "applicable_modifications": ["remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "shuffle_case_items", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["shuffle_case_items"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.748844", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "ROM", "module_name": "ROM", "description": "Please act as a professional Verilog designer.\n\nA Read-Only Memory (ROM) module designed for storing fixed data. This module provides a way to access predefined data based on an 8-bit address input.\n\nModule name:\n    ROM\n\nInput ports:\n    addr [7:0]: 8-bit address input used to select the data location in memory.\n\nOutput ports:\n    dout [15:0]: 16-bit output that delivers the data stored in the ROM at the specified address.\nMemory Array:\n    reg [15:0] mem [0:255]: Defines a ROM with 256 locations, each 16 bits wide.\nInitial Block:\n    The initial block is used to pre-load the ROM with fixed data. In this example, memory locations 0 through 3 are initialized with specific values (16'hA0A0, 16'hB1B1, 16'hC2C2, 16'hD3D3). Other locations can be initialized as needed.\nBehavior:\n    The always @(*) block continuously outputs the data stored in the ROM at the memory location specified by addr.\nSince ROM is read-only, this module includes only read operations.\n\nGive me the complete code."}, "clean_code": "module ROM (\n    input wire [7:0] addr,        // 8-bit Address input\n    output reg [15:0] dout        // 16-bit Data output\n);\n\n    // Declare a memory array of 256 locations, each 16 bits wide, initialized with fixed data\n    reg [15:0] mem [0:255];\n\n    // Initial block to initialize the ROM with data\n    initial begin\n        mem[0] = 16'hA0A0;\n        mem[1] = 16'hB1B1;\n        mem[2] = 16'hC2C2;\n        mem[3] = 16'hD3D3;\n        // Initialize other memory locations as needed\n    end\n\n    // Combinational logic: Read data from the ROM at the specified address\n    always @(*) begin\n        dout = mem[addr];\n    end\nendmodule", "corrupted_code": "module ROM (\n    input wire [7:0] addr,        // 8-bit Address input\n    output reg [15:0] dout        // 16-bit Data output\n);\n\n    // Declare a memory array of 256 locations, each 16 bits wide, initialized with fixed data\n    reg [15:0] mem [0:255];\n\n    // Initial block to initialize the ROM with data\n    initial begin\n        mem[0] <= 16'hA0A0;\n        mem[1] = 16'hB1B1;\n        mem[2] = 16'hC2C2;\n        mem[3] = 16'hD3D3;\n        // Initialize other memory locations as needed\n    end\n\n    // Combinational logic: Read data from the ROM at the specified address\n    always @(*) begin\n        dout = mem[addr];\n    end\nendmodule", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 11, "original_snippet": "mem[0] = 16'hA0A0;", "modified_snippet": "mem[0] <= 16'hA0A0;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 3, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.782786", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "ROM", "module_name": "ROM", "description": "Please act as a professional Verilog designer.\n\nA Read-Only Memory (ROM) module designed for storing fixed data. This module provides a way to access predefined data based on an 8-bit address input.\n\nModule name:\n    ROM\n\nInput ports:\n    addr [7:0]: 8-bit address input used to select the data location in memory.\n\nOutput ports:\n    dout [15:0]: 16-bit output that delivers the data stored in the ROM at the specified address.\nMemory Array:\n    reg [15:0] mem [0:255]: Defines a ROM with 256 locations, each 16 bits wide.\nInitial Block:\n    The initial block is used to pre-load the ROM with fixed data. In this example, memory locations 0 through 3 are initialized with specific values (16'hA0A0, 16'hB1B1, 16'hC2C2, 16'hD3D3). Other locations can be initialized as needed.\nBehavior:\n    The always @(*) block continuously outputs the data stored in the ROM at the memory location specified by addr.\nSince ROM is read-only, this module includes only read operations.\n\nGive me the complete code."}, "clean_code": "module ROM (\n    input wire [7:0] addr,        // 8-bit Address input\n    output reg [15:0] dout        // 16-bit Data output\n);\n\n    // Declare a memory array of 256 locations, each 16 bits wide, initialized with fixed data\n    reg [15:0] mem [0:255];\n\n    // Initial block to initialize the ROM with data\n    initial begin\n        mem[0] = 16'hA0A0;\n        mem[1] = 16'hB1B1;\n        mem[2] = 16'hC2C2;\n        mem[3] = 16'hD3D3;\n        // Initialize other memory locations as needed\n    end\n\n    // Combinational logic: Read data from the ROM at the specified address\n    always @(*) begin\n        dout = mem[addr];\n    end\nendmodule", "corrupted_code": "module ROM (\n    input wire [7:0] addr,        // 8-bit Address input\n    output reg [15:0] dout        // 16-bit Data output\n);\n\n    // Declare a memory array of 256 locations, each 16 bits wide, initialized with fixed data\n    reg [15:0] mem [0:255];\n\n    // Initial block to initialize the ROM with data\n    initial begin\n        mem[0] <= 16'hA0A0;\n        mem[1] = 16'hB1B1;\n        mem[2] = 16'hC2C2;\n        mem[3] = 16'hD3D3;\n        // Initialize other memory locations as needed\n    end\n\n    // Combinational logic: Read data from the ROM at the specified address\n    always @(*) begin\n        dout = mem[addr];\n    end\nendmodule", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 11, "original_snippet": "mem[0] = 16'hA0A0;", "modified_snippet": "mem[0] <= 16'hA0A0;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 3, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.784915", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "ROM", "module_name": "ROM", "description": "Please act as a professional Verilog designer.\n\nA Read-Only Memory (ROM) module designed for storing fixed data. This module provides a way to access predefined data based on an 8-bit address input.\n\nModule name:\n    ROM\n\nInput ports:\n    addr [7:0]: 8-bit address input used to select the data location in memory.\n\nOutput ports:\n    dout [15:0]: 16-bit output that delivers the data stored in the ROM at the specified address.\nMemory Array:\n    reg [15:0] mem [0:255]: Defines a ROM with 256 locations, each 16 bits wide.\nInitial Block:\n    The initial block is used to pre-load the ROM with fixed data. In this example, memory locations 0 through 3 are initialized with specific values (16'hA0A0, 16'hB1B1, 16'hC2C2, 16'hD3D3). Other locations can be initialized as needed.\nBehavior:\n    The always @(*) block continuously outputs the data stored in the ROM at the memory location specified by addr.\nSince ROM is read-only, this module includes only read operations.\n\nGive me the complete code."}, "clean_code": "module ROM (\n    input wire [7:0] addr,        // 8-bit Address input\n    output reg [15:0] dout        // 16-bit Data output\n);\n\n    // Declare a memory array of 256 locations, each 16 bits wide, initialized with fixed data\n    reg [15:0] mem [0:255];\n\n    // Initial block to initialize the ROM with data\n    initial begin\n        mem[0] = 16'hA0A0;\n        mem[1] = 16'hB1B1;\n        mem[2] = 16'hC2C2;\n        mem[3] = 16'hD3D3;\n        // Initialize other memory locations as needed\n    end\n\n    // Combinational logic: Read data from the ROM at the specified address\n    always @(*) begin\n        dout = mem[addr];\n    end\nendmodule", "corrupted_code": "module ROM (\n    input wire [7:0] addr,        // 8-bit Address input\n    output reg [15:0] dout        // 16-bit Data output\n);\n\n    // Declare a memory array of 256 locations, each 16 bits wide, initialized with fixed data\n    reg [15:0] mem [0:255];\n\n    // Initial block to initialize the ROM with data\n    initial begin\n        mem[0] = 16'hA0A0;\n        mem[1] = 16'hB1B1;\n        mem[2] = 16'hC2C2;\n        mem[3] = 16'hD3D3;\n        // Initialize other memory locations as needed\n    end\n\n    // Combinational logic: Read data from the ROM at the specified address\n    always @(a) begin\n        dout = mem[addr];\n    end\nendmodule", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 19, "original_snippet": "always @(*)", "modified_snippet": "always @(a)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 19: Original: always @(*)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 19.\n   \u2022 Restore the original code: always @(*)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 3, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["change_sensitivity_list"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.785953", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "ROM", "module_name": "ROM", "description": "Please act as a professional Verilog designer.\n\nA Read-Only Memory (ROM) module designed for storing fixed data. This module provides a way to access predefined data based on an 8-bit address input.\n\nModule name:\n    ROM\n\nInput ports:\n    addr [7:0]: 8-bit address input used to select the data location in memory.\n\nOutput ports:\n    dout [15:0]: 16-bit output that delivers the data stored in the ROM at the specified address.\nMemory Array:\n    reg [15:0] mem [0:255]: Defines a ROM with 256 locations, each 16 bits wide.\nInitial Block:\n    The initial block is used to pre-load the ROM with fixed data. In this example, memory locations 0 through 3 are initialized with specific values (16'hA0A0, 16'hB1B1, 16'hC2C2, 16'hD3D3). Other locations can be initialized as needed.\nBehavior:\n    The always @(*) block continuously outputs the data stored in the ROM at the memory location specified by addr.\nSince ROM is read-only, this module includes only read operations.\n\nGive me the complete code."}, "clean_code": "module ROM (\n    input wire [7:0] addr,        // 8-bit Address input\n    output reg [15:0] dout        // 16-bit Data output\n);\n\n    // Declare a memory array of 256 locations, each 16 bits wide, initialized with fixed data\n    reg [15:0] mem [0:255];\n\n    // Initial block to initialize the ROM with data\n    initial begin\n        mem[0] = 16'hA0A0;\n        mem[1] = 16'hB1B1;\n        mem[2] = 16'hC2C2;\n        mem[3] = 16'hD3D3;\n        // Initialize other memory locations as needed\n    end\n\n    // Combinational logic: Read data from the ROM at the specified address\n    always @(*) begin\n        dout = mem[addr];\n    end\nendmodule", "corrupted_code": "module ROM (\n    input wire [7:0] addr,        // 8-bit Address input\n    output reg [15:0] dout        // 16-bit Data output\n);\n\n    // Declare a memory array of 256 locations, each 16 bits wide, initialized with fixed data\n    reg [15:0] mem [0:255];\n\n    // Initial block to initialize the ROM with data\n    initial begin\n        mem[0] = 16'hA0A0;\n        mem[1] = 16'hB1B1;\n        mem[2] = 16'hC2C2;\n        mem[3] = 16'hD3D3;\n        // Initialize other memory locations as needed\n    end\n\n    // Combinational logic: Read data from the ROM at the specified address\n    always @(*) begin\n\n    end\nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 20, "original_snippet": "dout = mem[addr];", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 20: Original: dout = mem[addr];\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 20.\n   \u2022 Restore the original code: dout = mem[addr];\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 3, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["remove_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.786984", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "ROM", "module_name": "ROM", "description": "Please act as a professional Verilog designer.\n\nA Read-Only Memory (ROM) module designed for storing fixed data. This module provides a way to access predefined data based on an 8-bit address input.\n\nModule name:\n    ROM\n\nInput ports:\n    addr [7:0]: 8-bit address input used to select the data location in memory.\n\nOutput ports:\n    dout [15:0]: 16-bit output that delivers the data stored in the ROM at the specified address.\nMemory Array:\n    reg [15:0] mem [0:255]: Defines a ROM with 256 locations, each 16 bits wide.\nInitial Block:\n    The initial block is used to pre-load the ROM with fixed data. In this example, memory locations 0 through 3 are initialized with specific values (16'hA0A0, 16'hB1B1, 16'hC2C2, 16'hD3D3). Other locations can be initialized as needed.\nBehavior:\n    The always @(*) block continuously outputs the data stored in the ROM at the memory location specified by addr.\nSince ROM is read-only, this module includes only read operations.\n\nGive me the complete code."}, "clean_code": "module ROM (\n    input wire [7:0] addr,        // 8-bit Address input\n    output reg [15:0] dout        // 16-bit Data output\n);\n\n    // Declare a memory array of 256 locations, each 16 bits wide, initialized with fixed data\n    reg [15:0] mem [0:255];\n\n    // Initial block to initialize the ROM with data\n    initial begin\n        mem[0] = 16'hA0A0;\n        mem[1] = 16'hB1B1;\n        mem[2] = 16'hC2C2;\n        mem[3] = 16'hD3D3;\n        // Initialize other memory locations as needed\n    end\n\n    // Combinational logic: Read data from the ROM at the specified address\n    always @(*) begin\n        dout = mem[addr];\n    end\nendmodule", "corrupted_code": "module ROM (\n    input wire [7:0] addr,        // 8-bit Address input\n    output reg [15:0] dout        // 16-bit Data output\n);\n\n    // Declare a memory array of 256 locations, each 16 bits wide, initialized with fixed data\n    reg [15:0] mem [0:255];\n\n    // Initial block to initialize the ROM with data\n    initial begin\n        mem[0] = 16'hA0A0;\n        mem[1] = 16'hB1B1;\n        mem[2] = 16'hC2C2;\n        mem[3] = 16'hD3D3;\n        // Initialize other memory locations as needed\n    end\n\n    // Combinational logic: Read data from the ROM at the specified address\n    \nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 19, "original_snippet": "always @(*) begin\n        dout = mem[addr];\n    end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 19: Original: always @(*) begin\n        dout = mem[addr];\n    end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 19.\n   \u2022 Restore the original code: always @(*) begin\n        dout = mem[addr];\n    end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 3, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.787998", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "ROM", "module_name": "ROM", "description": "Please act as a professional Verilog designer.\n\nA Read-Only Memory (ROM) module designed for storing fixed data. This module provides a way to access predefined data based on an 8-bit address input.\n\nModule name:\n    ROM\n\nInput ports:\n    addr [7:0]: 8-bit address input used to select the data location in memory.\n\nOutput ports:\n    dout [15:0]: 16-bit output that delivers the data stored in the ROM at the specified address.\nMemory Array:\n    reg [15:0] mem [0:255]: Defines a ROM with 256 locations, each 16 bits wide.\nInitial Block:\n    The initial block is used to pre-load the ROM with fixed data. In this example, memory locations 0 through 3 are initialized with specific values (16'hA0A0, 16'hB1B1, 16'hC2C2, 16'hD3D3). Other locations can be initialized as needed.\nBehavior:\n    The always @(*) block continuously outputs the data stored in the ROM at the memory location specified by addr.\nSince ROM is read-only, this module includes only read operations.\n\nGive me the complete code."}, "clean_code": "module ROM (\n    input wire [7:0] addr,        // 8-bit Address input\n    output reg [15:0] dout        // 16-bit Data output\n);\n\n    // Declare a memory array of 256 locations, each 16 bits wide, initialized with fixed data\n    reg [15:0] mem [0:255];\n\n    // Initial block to initialize the ROM with data\n    initial begin\n        mem[0] = 16'hA0A0;\n        mem[1] = 16'hB1B1;\n        mem[2] = 16'hC2C2;\n        mem[3] = 16'hD3D3;\n        // Initialize other memory locations as needed\n    end\n\n    // Combinational logic: Read data from the ROM at the specified address\n    always @(*) begin\n        dout = mem[addr];\n    end\nendmodule", "corrupted_code": "module ROM (\n    input wire [7:0] addr,        // 8-bit Address input\n    output reg [15:0] dout        // 16-bit Data output\n);\n\n    // Declare a memory array of 256 locations, each 16 bits wide, initialized with fixed data\n    reg [15:0] mem [1:255];\n\n    // Initial block to initialize the ROM with data\n    initial begin\n        mem[0] = 16'hA0A0;\n        mem[1] = 16'hB1B1;\n        mem[2] = 16'hC2C2;\n        mem[3] = 16'hD3D3;\n        // Initialize other memory locations as needed\n    end\n\n    // Combinational logic: Read data from the ROM at the specified address\n    always @(*) begin\n        dout = mem[addr];\n    end\nendmodule", "corruption_explanation": "Changed bit width from [0:255] to [1:255]", "modification_type": "change_bit_width", "modification_line": 7, "original_snippet": "[0:255]", "modified_snippet": "[1:255]", "issue_description": "The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_bit_width modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed bit width from [0:255] to [1:255]\n   \u2022 Line 7: Original: [0:255]\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 7.\n   \u2022 Restore the original code: [0:255]\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change bit width.", "complexity": 3, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_always_block"], "stacked_count": 1, "applied_modifications": ["change_bit_width"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.789808", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "pe", "module_name": "pe", "description": "Please act as a professional verilog designer.\n\nImplement a Multiplying Accumulator for 32bit integer. In the MAC_PE, there is a register that stores the partial sum (the intermediate accumulation result), and in each cycle, the result of \u201ca multiplied by b\u201d will be accumulated in this register, and the \u201cc\u201d shows the value of the register.\n\nModule name:  \n    pe   \n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module implements a parallel multiplier and accumulator using registers and an always block. It multiplies the input operands and accumulates the result into an output register.\nAccumulator Register:\nThe module includes a register, c, to store the accumulated result.\nOn the positive edge of the clock signal (clk) or the positive edge of the reset signal (rst), the module updates the register.\nIf the reset signal (rst) is high, indicating a reset condition, the register (c) is set to 0. If the reset signal (rst) is low, the register (c) is updated by adding the product of the input operands (a and b) to its current value.\nMultiplication and Accumulation:\nInside the always block, the module performs the multiplication and accumulation operation. If the reset signal (rst) is high, the register (c) is set to 0. If the reset signal (rst) is low, the module adds the product of the input operands (a and b) to the register (c).\n\nGive me the complete code.\n"}, "clean_code": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n\n    output [31:0] c\n);\n\nreg [31:0] cc;\nassign c = cc;\nalways@(posedge clk or posedge rst)\nbegin\n\n  if(rst)\n  begin\n    cc <= 0;\n  end\n\n  else\n  begin\n    cc <= cc + a*b;\n  end\n\nend\n\nendmodule", "corrupted_code": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n\n    output [31:0] c\n);\n\nreg [31:0] cc;\nassign c = cc;\nalways@(posedge clk or posedge rst)\nbegin\n\n  if(rst)\n  begin\n    cc <= 1;\n  end\n\n  else\n  begin\n    cc <= cc + a*b;\n  end\n\nend\n\nendmodule", "corruption_explanation": "Changed constant from 0 to 1", "modification_type": "change_constant", "modification_line": 17, "original_snippet": "0", "modified_snippet": "1", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 0 to 1\n   \u2022 Line 17: Original: 0\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 17.\n   \u2022 Restore the original code: 0\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 5, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_constant"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.825265", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "pe", "module_name": "pe", "description": "Please act as a professional verilog designer.\n\nImplement a Multiplying Accumulator for 32bit integer. In the MAC_PE, there is a register that stores the partial sum (the intermediate accumulation result), and in each cycle, the result of \u201ca multiplied by b\u201d will be accumulated in this register, and the \u201cc\u201d shows the value of the register.\n\nModule name:  \n    pe   \n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module implements a parallel multiplier and accumulator using registers and an always block. It multiplies the input operands and accumulates the result into an output register.\nAccumulator Register:\nThe module includes a register, c, to store the accumulated result.\nOn the positive edge of the clock signal (clk) or the positive edge of the reset signal (rst), the module updates the register.\nIf the reset signal (rst) is high, indicating a reset condition, the register (c) is set to 0. If the reset signal (rst) is low, the register (c) is updated by adding the product of the input operands (a and b) to its current value.\nMultiplication and Accumulation:\nInside the always block, the module performs the multiplication and accumulation operation. If the reset signal (rst) is high, the register (c) is set to 0. If the reset signal (rst) is low, the module adds the product of the input operands (a and b) to the register (c).\n\nGive me the complete code.\n"}, "clean_code": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n\n    output [31:0] c\n);\n\nreg [31:0] cc;\nassign c = cc;\nalways@(posedge clk or posedge rst)\nbegin\n\n  if(rst)\n  begin\n    cc <= 0;\n  end\n\n  else\n  begin\n    cc <= cc + a*b;\n  end\n\nend\n\nendmodule", "corrupted_code": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n\n    output [31:0] c\n);\n\nreg [31:0] cc;\nassign c = cc;\nalways@(posedge clk or posedge rst)\nbegin\n\n  if(rst)\n  begin\n     <= cc + a*b;\n  end\n\nend\n\nendmodule", "corruption_explanation": "Removed CDC synchronizer stage", "modification_type": "modify_cdc", "modification_line": 17, "original_snippet": "cc <= 0;\n  end\n\n  else\n  begin\n    cc", "modified_snippet": "(removed)", "issue_description": "The buggy code has a broken clock domain crossing synchronizer. A synchronizer flip-flop stage was removed, reducing metastability protection. This creates CDC violations that cause random data corruption in multi-clock domain designs.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a modify_cdc modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed CDC synchronizer stage\n   \u2022 Line 17: Original: cc <= 0;\n  end\n\n  else\n  begin\n    cc\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 17.\n   \u2022 Restore the original code: cc <= 0;\n  end\n\n  else\n  begin\n    cc\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to modify cdc.", "complexity": 5, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["modify_cdc"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.825813", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "pe", "module_name": "pe", "description": "Please act as a professional verilog designer.\n\nImplement a Multiplying Accumulator for 32bit integer. In the MAC_PE, there is a register that stores the partial sum (the intermediate accumulation result), and in each cycle, the result of \u201ca multiplied by b\u201d will be accumulated in this register, and the \u201cc\u201d shows the value of the register.\n\nModule name:  \n    pe   \n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module implements a parallel multiplier and accumulator using registers and an always block. It multiplies the input operands and accumulates the result into an output register.\nAccumulator Register:\nThe module includes a register, c, to store the accumulated result.\nOn the positive edge of the clock signal (clk) or the positive edge of the reset signal (rst), the module updates the register.\nIf the reset signal (rst) is high, indicating a reset condition, the register (c) is set to 0. If the reset signal (rst) is low, the register (c) is updated by adding the product of the input operands (a and b) to its current value.\nMultiplication and Accumulation:\nInside the always block, the module performs the multiplication and accumulation operation. If the reset signal (rst) is high, the register (c) is set to 0. If the reset signal (rst) is low, the module adds the product of the input operands (a and b) to the register (c).\n\nGive me the complete code.\n"}, "clean_code": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n\n    output [31:0] c\n);\n\nreg [31:0] cc;\nassign c = cc;\nalways@(posedge clk or posedge rst)\nbegin\n\n  if(rst)\n  begin\n    cc <= 0;\n  end\n\n  else\n  begin\n    cc <= cc + a*b;\n  end\n\nend\n\nendmodule", "corrupted_code": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n\n    output [31:0] c\n);\n\nreg [31:0] cc;\nassign c = cc;\nalways@(posedge clk or posedge rst)\nbegin\n\n  if(rst)\n  begin\n    cc <= 0;\n  end\n\n  else\n  begin\n    cc = cc + a*b;\n  end\n\nend\n\nendmodule", "corruption_explanation": "Changed non-blocking (<=) to blocking (=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 22, "original_snippet": "cc <= cc + a*b;", "modified_snippet": "cc = cc + a*b;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 5, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.826362", "corruption_index": 2}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "pe", "module_name": "pe", "description": "Please act as a professional verilog designer.\n\nImplement a Multiplying Accumulator for 32bit integer. In the MAC_PE, there is a register that stores the partial sum (the intermediate accumulation result), and in each cycle, the result of \u201ca multiplied by b\u201d will be accumulated in this register, and the \u201cc\u201d shows the value of the register.\n\nModule name:  \n    pe   \n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module implements a parallel multiplier and accumulator using registers and an always block. It multiplies the input operands and accumulates the result into an output register.\nAccumulator Register:\nThe module includes a register, c, to store the accumulated result.\nOn the positive edge of the clock signal (clk) or the positive edge of the reset signal (rst), the module updates the register.\nIf the reset signal (rst) is high, indicating a reset condition, the register (c) is set to 0. If the reset signal (rst) is low, the register (c) is updated by adding the product of the input operands (a and b) to its current value.\nMultiplication and Accumulation:\nInside the always block, the module performs the multiplication and accumulation operation. If the reset signal (rst) is high, the register (c) is set to 0. If the reset signal (rst) is low, the module adds the product of the input operands (a and b) to the register (c).\n\nGive me the complete code.\n"}, "clean_code": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n\n    output [31:0] c\n);\n\nreg [31:0] cc;\nassign c = cc;\nalways@(posedge clk or posedge rst)\nbegin\n\n  if(rst)\n  begin\n    cc <= 0;\n  end\n\n  else\n  begin\n    cc <= cc + a*b;\n  end\n\nend\n\nendmodule", "corrupted_code": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n\n    output [31:0] c\n);\n\nreg [31:0] cc;\nassign c = cc;\n\n\n  else\n  begin\n    cc <= cc + a*b;\n  end\n\nend\n\nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 12, "original_snippet": "always@(posedge clk or posedge rst)\nbegin\n\n  if(rst)\n  begin\n    cc <= 0;\n  end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 12: Original: always@(posedge clk or posedge rst)\nbegin\n\n  if(rst)\n  begin\n    cc <= 0;\n  end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 12.\n   \u2022 Restore the original code: always@(posedge clk or posedge rst)\nbegin\n\n  if(rst)\n  begin\n    cc <= 0;\n  end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 5, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_always_block"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.826846", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "pe", "module_name": "pe", "description": "Please act as a professional verilog designer.\n\nImplement a Multiplying Accumulator for 32bit integer. In the MAC_PE, there is a register that stores the partial sum (the intermediate accumulation result), and in each cycle, the result of \u201ca multiplied by b\u201d will be accumulated in this register, and the \u201cc\u201d shows the value of the register.\n\nModule name:  \n    pe   \n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module implements a parallel multiplier and accumulator using registers and an always block. It multiplies the input operands and accumulates the result into an output register.\nAccumulator Register:\nThe module includes a register, c, to store the accumulated result.\nOn the positive edge of the clock signal (clk) or the positive edge of the reset signal (rst), the module updates the register.\nIf the reset signal (rst) is high, indicating a reset condition, the register (c) is set to 0. If the reset signal (rst) is low, the register (c) is updated by adding the product of the input operands (a and b) to its current value.\nMultiplication and Accumulation:\nInside the always block, the module performs the multiplication and accumulation operation. If the reset signal (rst) is high, the register (c) is set to 0. If the reset signal (rst) is low, the module adds the product of the input operands (a and b) to the register (c).\n\nGive me the complete code.\n"}, "clean_code": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n\n    output [31:0] c\n);\n\nreg [31:0] cc;\nassign c = cc;\nalways@(posedge clk or posedge rst)\nbegin\n\n  if(rst)\n  begin\n    cc <= 0;\n  end\n\n  else\n  begin\n    cc <= cc + a*b;\n  end\n\nend\n\nendmodule", "corrupted_code": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n\n    output [31:0] c\n);\n\nreg [31:0] cc;\nassign c = cc;\nalways@(posedge clk or posedge rst)\nbegin\n\n  if(rst)\n  begin\n    cc <= 0;\n  end\n\n  else\n  begin\n    cc >= cc + a*b;\n  end\n\nend\n\nendmodule", "corruption_explanation": "Changed operator from '<=' to '>='", "modification_type": "change_operator", "modification_line": 22, "original_snippet": "c <= c", "modified_snippet": "c >= c", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '<=' to '>='\n   \u2022 Line 22: Original: c <= c\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 22.\n   \u2022 Restore the original code: c <= c\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 5, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.827439", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "pe", "module_name": "pe", "description": "Please act as a professional verilog designer.\n\nImplement a Multiplying Accumulator for 32bit integer. In the MAC_PE, there is a register that stores the partial sum (the intermediate accumulation result), and in each cycle, the result of \u201ca multiplied by b\u201d will be accumulated in this register, and the \u201cc\u201d shows the value of the register.\n\nModule name:  \n    pe   \n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module implements a parallel multiplier and accumulator using registers and an always block. It multiplies the input operands and accumulates the result into an output register.\nAccumulator Register:\nThe module includes a register, c, to store the accumulated result.\nOn the positive edge of the clock signal (clk) or the positive edge of the reset signal (rst), the module updates the register.\nIf the reset signal (rst) is high, indicating a reset condition, the register (c) is set to 0. If the reset signal (rst) is low, the register (c) is updated by adding the product of the input operands (a and b) to its current value.\nMultiplication and Accumulation:\nInside the always block, the module performs the multiplication and accumulation operation. If the reset signal (rst) is high, the register (c) is set to 0. If the reset signal (rst) is low, the module adds the product of the input operands (a and b) to the register (c).\n\nGive me the complete code.\n"}, "clean_code": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n\n    output [31:0] c\n);\n\nreg [31:0] cc;\nassign c = cc;\nalways@(posedge clk or posedge rst)\nbegin\n\n  if(rst)\n  begin\n    cc <= 0;\n  end\n\n  else\n  begin\n    cc <= cc + a*b;\n  end\n\nend\n\nendmodule", "corrupted_code": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n\n    output [31:0] c\n);\n\nreg [31:0] cc;\nassign c = cc;\nalways@(posedge clk or posedge rst)\nbegin\n\n  if(rst)\n  begin\n    cc <= 1;\n  end\n\n  else\n  begin\n    cc <= cc + a*b;\n  end\n\nend\n\nendmodule", "corruption_explanation": "Changed constant from 0 to 1", "modification_type": "change_constant", "modification_line": 17, "original_snippet": "0", "modified_snippet": "1", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 0 to 1\n   \u2022 Line 17: Original: 0\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 17.\n   \u2022 Restore the original code: 0\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 5, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_constant"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.827957", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "pe", "module_name": "pe", "description": "Please act as a professional verilog designer.\n\nImplement a Multiplying Accumulator for 32bit integer. In the MAC_PE, there is a register that stores the partial sum (the intermediate accumulation result), and in each cycle, the result of \u201ca multiplied by b\u201d will be accumulated in this register, and the \u201cc\u201d shows the value of the register.\n\nModule name:  \n    pe   \n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module implements a parallel multiplier and accumulator using registers and an always block. It multiplies the input operands and accumulates the result into an output register.\nAccumulator Register:\nThe module includes a register, c, to store the accumulated result.\nOn the positive edge of the clock signal (clk) or the positive edge of the reset signal (rst), the module updates the register.\nIf the reset signal (rst) is high, indicating a reset condition, the register (c) is set to 0. If the reset signal (rst) is low, the register (c) is updated by adding the product of the input operands (a and b) to its current value.\nMultiplication and Accumulation:\nInside the always block, the module performs the multiplication and accumulation operation. If the reset signal (rst) is high, the register (c) is set to 0. If the reset signal (rst) is low, the module adds the product of the input operands (a and b) to the register (c).\n\nGive me the complete code.\n"}, "clean_code": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n\n    output [31:0] c\n);\n\nreg [31:0] cc;\nassign c = cc;\nalways@(posedge clk or posedge rst)\nbegin\n\n  if(rst)\n  begin\n    cc <= 0;\n  end\n\n  else\n  begin\n    cc <= cc + a*b;\n  end\n\nend\n\nendmodule", "corrupted_code": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n\n    output [31:0] c\n);\n\nreg [31:0] cc;\nassign c = cc;\nalways @(clk or rst)\nbegin\n\n  if(rst)\n  begin\n    cc <= 0;\n  end\n\n  else\n  begin\n    cc <= cc + a*b;\n  end\n\nend\n\nendmodule", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 12, "original_snippet": "always@(posedge clk or posedge rst)", "modified_snippet": "always @(clk or rst)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 12: Original: always@(posedge clk or posedge rst)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 12.\n   \u2022 Restore the original code: always@(posedge clk or posedge rst)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 5, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_sensitivity_list"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.828422", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "pe", "module_name": "pe", "description": "Please act as a professional verilog designer.\n\nImplement a Multiplying Accumulator for 32bit integer. In the MAC_PE, there is a register that stores the partial sum (the intermediate accumulation result), and in each cycle, the result of \u201ca multiplied by b\u201d will be accumulated in this register, and the \u201cc\u201d shows the value of the register.\n\nModule name:  \n    pe   \n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module implements a parallel multiplier and accumulator using registers and an always block. It multiplies the input operands and accumulates the result into an output register.\nAccumulator Register:\nThe module includes a register, c, to store the accumulated result.\nOn the positive edge of the clock signal (clk) or the positive edge of the reset signal (rst), the module updates the register.\nIf the reset signal (rst) is high, indicating a reset condition, the register (c) is set to 0. If the reset signal (rst) is low, the register (c) is updated by adding the product of the input operands (a and b) to its current value.\nMultiplication and Accumulation:\nInside the always block, the module performs the multiplication and accumulation operation. If the reset signal (rst) is high, the register (c) is set to 0. If the reset signal (rst) is low, the module adds the product of the input operands (a and b) to the register (c).\n\nGive me the complete code.\n"}, "clean_code": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n\n    output [31:0] c\n);\n\nreg [31:0] cc;\nassign c = cc;\nalways@(posedge clk or posedge rst)\nbegin\n\n  if(rst)\n  begin\n    cc <= 0;\n  end\n\n  else\n  begin\n    cc <= cc + a*b;\n  end\n\nend\n\nendmodule", "corrupted_code": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n\n    output [31:0] c\n);\n\nreg [31:0] cc;\nassign c = cc;\nalways@(posedge clk or posedge rst)\nbegin\n\n  if(!(rst))\n  begin\n    cc <= 0;\n  end\n\n  else\n  begin\n    cc <= cc + a*b;\n  end\n\nend\n\nendmodule", "corruption_explanation": "Inverted condition: 'rst' -> '!(rst)'", "modification_type": "invert_condition", "modification_line": 15, "original_snippet": "if(rst)\n  begin", "modified_snippet": "if(!(rst))\n  begin", "issue_description": "The buggy code has an inverted condition in an if statement. Instead of checking if(x), it checks if(!x), causing the logic to execute when it shouldn't and skip execution when it should. All conditional behavior is reversed from intended functionality.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_condition modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted condition: 'rst' -> '!(rst)'\n   \u2022 Line 15: Original: if(rst)\n  begin\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 15.\n   \u2022 Restore the original code: if(rst)\n  begin\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert condition.", "complexity": 5, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_condition"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.828891", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "pe", "module_name": "pe", "description": "Please act as a professional verilog designer.\n\nImplement a Multiplying Accumulator for 32bit integer. In the MAC_PE, there is a register that stores the partial sum (the intermediate accumulation result), and in each cycle, the result of \u201ca multiplied by b\u201d will be accumulated in this register, and the \u201cc\u201d shows the value of the register.\n\nModule name:  \n    pe   \n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module implements a parallel multiplier and accumulator using registers and an always block. It multiplies the input operands and accumulates the result into an output register.\nAccumulator Register:\nThe module includes a register, c, to store the accumulated result.\nOn the positive edge of the clock signal (clk) or the positive edge of the reset signal (rst), the module updates the register.\nIf the reset signal (rst) is high, indicating a reset condition, the register (c) is set to 0. If the reset signal (rst) is low, the register (c) is updated by adding the product of the input operands (a and b) to its current value.\nMultiplication and Accumulation:\nInside the always block, the module performs the multiplication and accumulation operation. If the reset signal (rst) is high, the register (c) is set to 0. If the reset signal (rst) is low, the module adds the product of the input operands (a and b) to the register (c).\n\nGive me the complete code.\n"}, "clean_code": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n\n    output [31:0] c\n);\n\nreg [31:0] cc;\nassign c = cc;\nalways@(posedge clk or posedge rst)\nbegin\n\n  if(rst)\n  begin\n    cc <= 0;\n  end\n\n  else\n  begin\n    cc <= cc + a*b;\n  end\n\nend\n\nendmodule", "corrupted_code": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n\n    output [31:0] c\n);\n\nreg [31:0] cc;\nassign c = cc;\nalways @(posedge clk)\nbegin\n\n  if(rst)\n  begin\n    cc <= 0;\n  end\n\n  else\n  begin\n    cc <= cc + a*b;\n  end\n\nend\n\nendmodule", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 12, "original_snippet": "always@(posedge clk or posedge rst)", "modified_snippet": "always @(posedge clk)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 12: Original: always@(posedge clk or posedge rst)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 12.\n   \u2022 Restore the original code: always@(posedge clk or posedge rst)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 5, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_sensitivity_list"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.829717", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "clkgenerator", "module_name": "clkgenerator", "description": "Please act as a professional Verilog designer.\n\nA clock generator module that produces a periodic clock signal, toggling its output state at regular intervals defined by the PERIOD parameter.\n\nModule name:\n    clkgenerator\n\nParameter:\n    PERIOD = 10\n\nOutput ports:\n    clk: The output clock signal generated by the module.\n\nImplementation:\nThis module uses an initial block to set the initial state of the clock signal to 0. The clock toggles every half of the specified PERIOD, creating a square wave clock signal with the desired frequency.\n\nGive me the complete code."}, "clean_code": "module clkgenerator (\n    output reg clk\n);\n\n    parameter PERIOD = 10; // Clock period in time units\n\n    // Initial block to set the initial state of the clock\n    initial begin\n        clk = 0; // Initialize the clock signal to 0\n    end\n\n    always begin\n        # (PERIOD / 2) clk = ~clk; // Toggle the clock every half period\n    end\n\nendmodule\n", "corrupted_code": "module clkgenerator (\n    output reg clk\n);\n\n    parameter PERIOD = 11; // Clock period in time units\n\n    // Initial block to set the initial state of the clock\n    initial begin\n        clk = 0; // Initialize the clock signal to 0\n    end\n\n    always begin\n        # (PERIOD / 2) clk = ~clk; // Toggle the clock every half period\n    end\n\nendmodule\n", "corruption_explanation": "Changed constant from 10 to 11", "modification_type": "change_constant", "modification_line": 5, "original_snippet": "10", "modified_snippet": "11", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 10 to 11\n   \u2022 Line 5: Original: 10\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 5.\n   \u2022 Restore the original code: 10\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 1, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "remove_assignment", "swap_blocking_nonblocking"], "stacked_count": 1, "applied_modifications": ["change_constant"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.859645", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "clkgenerator", "module_name": "clkgenerator", "description": "Please act as a professional Verilog designer.\n\nA clock generator module that produces a periodic clock signal, toggling its output state at regular intervals defined by the PERIOD parameter.\n\nModule name:\n    clkgenerator\n\nParameter:\n    PERIOD = 10\n\nOutput ports:\n    clk: The output clock signal generated by the module.\n\nImplementation:\nThis module uses an initial block to set the initial state of the clock signal to 0. The clock toggles every half of the specified PERIOD, creating a square wave clock signal with the desired frequency.\n\nGive me the complete code."}, "clean_code": "module clkgenerator (\n    output reg clk\n);\n\n    parameter PERIOD = 10; // Clock period in time units\n\n    // Initial block to set the initial state of the clock\n    initial begin\n        clk = 0; // Initialize the clock signal to 0\n    end\n\n    always begin\n        # (PERIOD / 2) clk = ~clk; // Toggle the clock every half period\n    end\n\nendmodule\n", "corrupted_code": "module clkgenerator (\n    output reg clk\n);\n\n    parameter PERIOD = 10; // Clock period in time units\n\n    // Initial block to set the initial state of the clock\n    initial begin\n        clk = 0; // Initialize the clock signal to 0\n    end\n\n    always begin\n        # (PERIOD * 2) clk = ~clk; // Toggle the clock every half period\n    end\n\nendmodule\n", "corruption_explanation": "Changed operator from '/' to '*'", "modification_type": "change_operator", "modification_line": 13, "original_snippet": "/", "modified_snippet": "*", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '/' to '*'\n   \u2022 Line 13: Original: /\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 13.\n   \u2022 Restore the original code: /\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 1, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "remove_assignment", "swap_blocking_nonblocking"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.860452", "corruption_index": 1}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "clkgenerator", "module_name": "clkgenerator", "description": "Please act as a professional Verilog designer.\n\nA clock generator module that produces a periodic clock signal, toggling its output state at regular intervals defined by the PERIOD parameter.\n\nModule name:\n    clkgenerator\n\nParameter:\n    PERIOD = 10\n\nOutput ports:\n    clk: The output clock signal generated by the module.\n\nImplementation:\nThis module uses an initial block to set the initial state of the clock signal to 0. The clock toggles every half of the specified PERIOD, creating a square wave clock signal with the desired frequency.\n\nGive me the complete code."}, "clean_code": "module clkgenerator (\n    output reg clk\n);\n\n    parameter PERIOD = 10; // Clock period in time units\n\n    // Initial block to set the initial state of the clock\n    initial begin\n        clk = 0; // Initialize the clock signal to 0\n    end\n\n    always begin\n        # (PERIOD / 2) clk = ~clk; // Toggle the clock every half period\n    end\n\nendmodule\n", "corrupted_code": "module clkgenerator (\n    output reg clk\n);\n\n    parameter PERIOD = 10; // Clock period in time units\n\n    // Initial block to set the initial state of the clock\n    initial begin\n        clk <= 0; // Initialize the clock signal to 0\n    end\n\n    always begin\n        # (PERIOD / 2) clk = ~clk; // Toggle the clock every half period\n    end\n\nendmodule\n", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 9, "original_snippet": "clk = 0;", "modified_snippet": "clk <= 0;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 1, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "remove_assignment", "swap_blocking_nonblocking"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.861697", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "clkgenerator", "module_name": "clkgenerator", "description": "Please act as a professional Verilog designer.\n\nA clock generator module that produces a periodic clock signal, toggling its output state at regular intervals defined by the PERIOD parameter.\n\nModule name:\n    clkgenerator\n\nParameter:\n    PERIOD = 10\n\nOutput ports:\n    clk: The output clock signal generated by the module.\n\nImplementation:\nThis module uses an initial block to set the initial state of the clock signal to 0. The clock toggles every half of the specified PERIOD, creating a square wave clock signal with the desired frequency.\n\nGive me the complete code."}, "clean_code": "module clkgenerator (\n    output reg clk\n);\n\n    parameter PERIOD = 10; // Clock period in time units\n\n    // Initial block to set the initial state of the clock\n    initial begin\n        clk = 0; // Initialize the clock signal to 0\n    end\n\n    always begin\n        # (PERIOD / 2) clk = ~clk; // Toggle the clock every half period\n    end\n\nendmodule\n", "corrupted_code": "module clkgenerator (\n    output reg clk\n);\n\n    parameter PERIOD = 10; // Clock period in time units\n\n    // Initial block to set the initial state of the clock\n    initial begin\n        clk = 0; // Initialize the clock signal to 0\n    end\n\n    always begin\n        # (PERIOD * 2) clk = ~clk; // Toggle the clock every half period\n    end\n\nendmodule\n", "corruption_explanation": "Changed operator from '/' to '*'", "modification_type": "change_operator", "modification_line": 13, "original_snippet": "/", "modified_snippet": "*", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '/' to '*'\n   \u2022 Line 13: Original: /\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 13.\n   \u2022 Restore the original code: /\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 1, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "remove_assignment", "swap_blocking_nonblocking"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.862506", "corruption_index": 4}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "clkgenerator", "module_name": "clkgenerator", "description": "Please act as a professional Verilog designer.\n\nA clock generator module that produces a periodic clock signal, toggling its output state at regular intervals defined by the PERIOD parameter.\n\nModule name:\n    clkgenerator\n\nParameter:\n    PERIOD = 10\n\nOutput ports:\n    clk: The output clock signal generated by the module.\n\nImplementation:\nThis module uses an initial block to set the initial state of the clock signal to 0. The clock toggles every half of the specified PERIOD, creating a square wave clock signal with the desired frequency.\n\nGive me the complete code."}, "clean_code": "module clkgenerator (\n    output reg clk\n);\n\n    parameter PERIOD = 10; // Clock period in time units\n\n    // Initial block to set the initial state of the clock\n    initial begin\n        clk = 0; // Initialize the clock signal to 0\n    end\n\n    always begin\n        # (PERIOD / 2) clk = ~clk; // Toggle the clock every half period\n    end\n\nendmodule\n", "corrupted_code": "module clkgenerator (\n    output reg clk\n);\n\n    parameter PERIOD <= 10; // Clock period in time units\n\n    // Initial block to set the initial state of the clock\n    initial begin\n        clk = 0; // Initialize the clock signal to 0\n    end\n\n    always begin\n        # (PERIOD / 2) clk = ~clk; // Toggle the clock every half period\n    end\n\nendmodule\n", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 5, "original_snippet": "PERIOD = 10;", "modified_snippet": "PERIOD <= 10;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 1, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "remove_assignment", "swap_blocking_nonblocking"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.863377", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "clkgenerator", "module_name": "clkgenerator", "description": "Please act as a professional Verilog designer.\n\nA clock generator module that produces a periodic clock signal, toggling its output state at regular intervals defined by the PERIOD parameter.\n\nModule name:\n    clkgenerator\n\nParameter:\n    PERIOD = 10\n\nOutput ports:\n    clk: The output clock signal generated by the module.\n\nImplementation:\nThis module uses an initial block to set the initial state of the clock signal to 0. The clock toggles every half of the specified PERIOD, creating a square wave clock signal with the desired frequency.\n\nGive me the complete code."}, "clean_code": "module clkgenerator (\n    output reg clk\n);\n\n    parameter PERIOD = 10; // Clock period in time units\n\n    // Initial block to set the initial state of the clock\n    initial begin\n        clk = 0; // Initialize the clock signal to 0\n    end\n\n    always begin\n        # (PERIOD / 2) clk = ~clk; // Toggle the clock every half period\n    end\n\nendmodule\n", "corrupted_code": "module clkgenerator (\n    output reg clk\n);\n\n    parameter PERIOD = 10; // Clock period in time units\n\n    // Initial block to set the initial state of the clock\n    initial begin\n        clk = 0; // Initialize the clock signal to 0\n    end\n\n    always begin\n        # (2 / PERIOD) clk = ~clk; // Toggle the clock every half period\n    end\n\nendmodule\n", "corruption_explanation": "Swapped operands: 'PERIOD / 2' -> '2 / PERIOD'", "modification_type": "swap_operands", "modification_line": 13, "original_snippet": "PERIOD / 2", "modified_snippet": "2 / PERIOD", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'PERIOD / 2' -> '2 / PERIOD'\n   \u2022 Line 13: Original: PERIOD / 2\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 13.\n   \u2022 Restore the original code: PERIOD / 2\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 1, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "remove_assignment", "swap_blocking_nonblocking"], "stacked_count": 1, "applied_modifications": ["swap_operands"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.864191", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "clkgenerator", "module_name": "clkgenerator", "description": "Please act as a professional Verilog designer.\n\nA clock generator module that produces a periodic clock signal, toggling its output state at regular intervals defined by the PERIOD parameter.\n\nModule name:\n    clkgenerator\n\nParameter:\n    PERIOD = 10\n\nOutput ports:\n    clk: The output clock signal generated by the module.\n\nImplementation:\nThis module uses an initial block to set the initial state of the clock signal to 0. The clock toggles every half of the specified PERIOD, creating a square wave clock signal with the desired frequency.\n\nGive me the complete code."}, "clean_code": "module clkgenerator (\n    output reg clk\n);\n\n    parameter PERIOD = 10; // Clock period in time units\n\n    // Initial block to set the initial state of the clock\n    initial begin\n        clk = 0; // Initialize the clock signal to 0\n    end\n\n    always begin\n        # (PERIOD / 2) clk = ~clk; // Toggle the clock every half period\n    end\n\nendmodule\n", "corrupted_code": "module clkgenerator (\n    output reg clk\n);\n\n    parameter PERIOD = 10; // Clock period in time units\n\n    // Initial block to set the initial state of the clock\n    initial begin\n        clk = 0; // Initialize the clock signal to 0\n    end\n\n    always begin\n        # (2 / PERIOD) clk = ~clk; // Toggle the clock every half period\n    end\n\nendmodule\n", "corruption_explanation": "Swapped operands: 'PERIOD / 2' -> '2 / PERIOD'", "modification_type": "swap_operands", "modification_line": 13, "original_snippet": "PERIOD / 2", "modified_snippet": "2 / PERIOD", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'PERIOD / 2' -> '2 / PERIOD'\n   \u2022 Line 13: Original: PERIOD / 2\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 13.\n   \u2022 Restore the original code: PERIOD / 2\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 1, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "remove_assignment", "swap_blocking_nonblocking"], "stacked_count": 1, "applied_modifications": ["swap_operands"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.864981", "corruption_index": 7}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "clkgenerator", "module_name": "clkgenerator", "description": "Please act as a professional Verilog designer.\n\nA clock generator module that produces a periodic clock signal, toggling its output state at regular intervals defined by the PERIOD parameter.\n\nModule name:\n    clkgenerator\n\nParameter:\n    PERIOD = 10\n\nOutput ports:\n    clk: The output clock signal generated by the module.\n\nImplementation:\nThis module uses an initial block to set the initial state of the clock signal to 0. The clock toggles every half of the specified PERIOD, creating a square wave clock signal with the desired frequency.\n\nGive me the complete code."}, "clean_code": "module clkgenerator (\n    output reg clk\n);\n\n    parameter PERIOD = 10; // Clock period in time units\n\n    // Initial block to set the initial state of the clock\n    initial begin\n        clk = 0; // Initialize the clock signal to 0\n    end\n\n    always begin\n        # (PERIOD / 2) clk = ~clk; // Toggle the clock every half period\n    end\n\nendmodule\n", "corrupted_code": "module clkgenerator (\n    output reg clk\n);\n\n    parameter PERIOD <= 10; // Clock period in time units\n\n    // Initial block to set the initial state of the clock\n    initial begin\n        clk = 0; // Initialize the clock signal to 0\n    end\n\n    always begin\n        # (PERIOD / 2) clk = ~clk; // Toggle the clock every half period\n    end\n\nendmodule\n", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 5, "original_snippet": "PERIOD = 10;", "modified_snippet": "PERIOD <= 10;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 1, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "remove_assignment", "swap_blocking_nonblocking"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.866416", "corruption_index": 9}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "instr_reg", "module_name": "instr_reg", "description": "Please act as a professional Verilog designer.\n\nAn instruction register module designed to hold and process CPU instructions. It captures incoming instructions from various sources and separates them into distinct fields for further processing.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register contains two 8-bit registers (ins_p1 and ins_p2) to store instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both registers are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into ins_p1.\n    If fetch is 2'b10, the instruction is fetched from the data input into ins_p2.\n    If neither condition is met, the previous values in both registers are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions.\n\n\nGive me the complete code.\n\n"}, "clean_code": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    reg [7:0] ins_p1, ins_p2;\n    reg [2:0] state;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1 <= 8'd0;\n            ins_p2 <= 8'd0;\n        end else begin\n            if (fetch == 2'b01) begin // Fetch operation 1, from REG\n                ins_p1 <= data;\n                ins_p2 <= ins_p2;\n            end else if (fetch == 2'b10) begin // Fetch operation 2, from RAM/ROM\n                ins_p1 <= ins_p1;\n                ins_p2 <= data;\n            end else begin\n                ins_p1 <= ins_p1;\n                ins_p2 <= ins_p2;\n            end\n        end\n    end\n\n    assign ins = ins_p1[7:5]; // High 3 bits, instructions\n    assign ad1 = ins_p1[4:0];  // Low 5 bits, register address\n    assign ad2 = ins_p2;\nendmodule", "corrupted_code": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [8:0] ad2\n);\n\n    reg [7:0] ins_p1, ins_p2;\n    reg [2:0] state;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1 <= 8'd0;\n            ins_p2 <= 8'd0;\n        end else begin\n            if (fetch == 2'b01) begin // Fetch operation 1, from REG\n                ins_p1 <= data;\n                ins_p2 <= ins_p2;\n            end else if (fetch == 2'b10) begin // Fetch operation 2, from RAM/ROM\n                ins_p1 <= ins_p1;\n                ins_p2 <= data;\n            end else begin\n                ins_p1 <= ins_p1;\n                ins_p2 <= ins_p2;\n            end\n        end\n    end\n\n    assign ins = ins_p1[7:5]; // High 3 bits, instructions\n    assign ad1 = ins_p1[4:0];  // Low 5 bits, register address\n    assign ad2 = ins_p2;\nendmodule", "corruption_explanation": "Changed bit width from [7:0] to [8:0]", "modification_type": "change_bit_width", "modification_line": 8, "original_snippet": "[7:0]", "modified_snippet": "[8:0]", "issue_description": "The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_bit_width modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed bit width from [7:0] to [8:0]\n   \u2022 Line 8: Original: [7:0]\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 8.\n   \u2022 Restore the original code: [7:0]\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change bit width.", "complexity": 15, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_bit_width"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.888685", "corruption_index": 0}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "instr_reg", "module_name": "instr_reg", "description": "Please act as a professional Verilog designer.\n\nAn instruction register module designed to hold and process CPU instructions. It captures incoming instructions from various sources and separates them into distinct fields for further processing.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register contains two 8-bit registers (ins_p1 and ins_p2) to store instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both registers are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into ins_p1.\n    If fetch is 2'b10, the instruction is fetched from the data input into ins_p2.\n    If neither condition is met, the previous values in both registers are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions.\n\n\nGive me the complete code.\n\n"}, "clean_code": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    reg [7:0] ins_p1, ins_p2;\n    reg [2:0] state;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1 <= 8'd0;\n            ins_p2 <= 8'd0;\n        end else begin\n            if (fetch == 2'b01) begin // Fetch operation 1, from REG\n                ins_p1 <= data;\n                ins_p2 <= ins_p2;\n            end else if (fetch == 2'b10) begin // Fetch operation 2, from RAM/ROM\n                ins_p1 <= ins_p1;\n                ins_p2 <= data;\n            end else begin\n                ins_p1 <= ins_p1;\n                ins_p2 <= ins_p2;\n            end\n        end\n    end\n\n    assign ins = ins_p1[7:5]; // High 3 bits, instructions\n    assign ad1 = ins_p1[4:0];  // Low 5 bits, register address\n    assign ad2 = ins_p2;\nendmodule", "corrupted_code": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    reg [7:0] ins_p1, ins_p2;\n    reg [2:0] state;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1 <= 8'd0;\n            ins_p2 <= 8'd0;\n        end else begin\n            if (fetch != 2'b01) begin // Fetch operation 1, from REG\n                ins_p1 <= data;\n                ins_p2 <= ins_p2;\n            end else if (fetch == 2'b10) begin // Fetch operation 2, from RAM/ROM\n                ins_p1 <= ins_p1;\n                ins_p2 <= data;\n            end else begin\n                ins_p1 <= ins_p1;\n                ins_p2 <= ins_p2;\n            end\n        end\n    end\n\n    assign ins = ins_p1[7:5]; // High 3 bits, instructions\n    assign ad1 = ins_p1[4:0];  // Low 5 bits, register address\n    assign ad2 = ins_p2;\nendmodule", "corruption_explanation": "Changed operator from '==' to '!='", "modification_type": "change_operator", "modification_line": 19, "original_snippet": "==", "modified_snippet": "!=", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '==' to '!='\n   \u2022 Line 19: Original: ==\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 19.\n   \u2022 Restore the original code: ==\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 15, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_operator"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.890811", "corruption_index": 3}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "instr_reg", "module_name": "instr_reg", "description": "Please act as a professional Verilog designer.\n\nAn instruction register module designed to hold and process CPU instructions. It captures incoming instructions from various sources and separates them into distinct fields for further processing.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register contains two 8-bit registers (ins_p1 and ins_p2) to store instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both registers are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into ins_p1.\n    If fetch is 2'b10, the instruction is fetched from the data input into ins_p2.\n    If neither condition is met, the previous values in both registers are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions.\n\n\nGive me the complete code.\n\n"}, "clean_code": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    reg [7:0] ins_p1, ins_p2;\n    reg [2:0] state;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1 <= 8'd0;\n            ins_p2 <= 8'd0;\n        end else begin\n            if (fetch == 2'b01) begin // Fetch operation 1, from REG\n                ins_p1 <= data;\n                ins_p2 <= ins_p2;\n            end else if (fetch == 2'b10) begin // Fetch operation 2, from RAM/ROM\n                ins_p1 <= ins_p1;\n                ins_p2 <= data;\n            end else begin\n                ins_p1 <= ins_p1;\n                ins_p2 <= ins_p2;\n            end\n        end\n    end\n\n    assign ins = ins_p1[7:5]; // High 3 bits, instructions\n    assign ad1 = ins_p1[4:0];  // Low 5 bits, register address\n    assign ad2 = ins_p2;\nendmodule", "corrupted_code": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    reg [7:0] ins_p1, ins_p2;\n    reg [2:0] state;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1 <= 8'd0;\n            ins_p2 <= 8'd0;\n        end else begin\n            if (fetch == 2'b01) begin // Fetch operation 1, from REG\n                ins_p1 <= data;\n                ins_p2 <= ins_p2;\n            end else if (fetch == 2'b10) begin // Fetch operation 2, from RAM/ROM\n                ins_p1 <= ins_p1;\n                ins_p2 <= data;\n            end else begin\n                ins_p1 <= ins_p1;\n                ins_p2 <= ins_p2;\n            end\n        end\n    end\n\n    assign ins = ins_p1[7:5]; // High 3 bits, instructions\n    assign ad1 = ins_p1[4:0];  // Low 5 bits, register address\n    assign ad2 = ins_p2;\n\n    wire clk_dup;\n    assign clk_dup = clk;\nendmodule", "corruption_explanation": "Added duplicate clock signal clk_dup", "modification_type": "duplicate_clock_signal", "modification_line": 19, "original_snippet": "(none)", "modified_snippet": "wire clk_dup;\n    assign clk_dup = clk;", "issue_description": "The buggy code has a duplicate clock signal. A phantom clock domain is created, which may confuse CDC analysis tools and create subtle timing issues in synthesis. This violates clock domain design best practices.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a duplicate_clock_signal modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added duplicate clock signal clk_dup\n   \u2022 Line 19: Original: (none)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 19.\n   \u2022 Restore the original code: (none)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to duplicate clock signal.", "complexity": 15, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["duplicate_clock_signal"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.892109", "corruption_index": 5}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "instr_reg", "module_name": "instr_reg", "description": "Please act as a professional Verilog designer.\n\nAn instruction register module designed to hold and process CPU instructions. It captures incoming instructions from various sources and separates them into distinct fields for further processing.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register contains two 8-bit registers (ins_p1 and ins_p2) to store instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both registers are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into ins_p1.\n    If fetch is 2'b10, the instruction is fetched from the data input into ins_p2.\n    If neither condition is met, the previous values in both registers are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions.\n\n\nGive me the complete code.\n\n"}, "clean_code": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    reg [7:0] ins_p1, ins_p2;\n    reg [2:0] state;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1 <= 8'd0;\n            ins_p2 <= 8'd0;\n        end else begin\n            if (fetch == 2'b01) begin // Fetch operation 1, from REG\n                ins_p1 <= data;\n                ins_p2 <= ins_p2;\n            end else if (fetch == 2'b10) begin // Fetch operation 2, from RAM/ROM\n                ins_p1 <= ins_p1;\n                ins_p2 <= data;\n            end else begin\n                ins_p1 <= ins_p1;\n                ins_p2 <= ins_p2;\n            end\n        end\n    end\n\n    assign ins = ins_p1[7:5]; // High 3 bits, instructions\n    assign ad1 = ins_p1[4:0];  // Low 5 bits, register address\n    assign ad2 = ins_p2;\nendmodule", "corrupted_code": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    reg [7:0] ins_p1, ins_p2;\n    reg [2:0] state;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            if (fetch == 2'b01) begin // Fetch operation 1, from REG\n                ins_p1 <= data;\n                ins_p2 <= ins_p2;\n            end else begin\n            ins_p1 <= 8'd0;\n            ins_p2 <= 8'd0;\n        end else if (fetch == 2'b10) begin // Fetch operation 2, from RAM/ROM\n                ins_p1 <= ins_p1;\n                ins_p2 <= data;\n            end else begin\n                ins_p1 <= ins_p1;\n                ins_p2 <= ins_p2;\n            end\n        end\n    end\n\n    assign ins = ins_p1[7:5]; // High 3 bits, instructions\n    assign ad1 = ins_p1[4:0];  // Low 5 bits, register address\n    assign ad2 = ins_p2;\nendmodule", "corruption_explanation": "Swapped if and else bodies", "modification_type": "invert_if_else", "modification_line": 15, "original_snippet": "if (!rst) begin\n            ins_p1 <= 8'd0;\n            ins_p2 <= 8'd0;\n        end else begin\n            if (fetch == 2'b01) begin // Fetch operation 1, from REG\n                ins_p1 <= data;\n    ", "modified_snippet": "if (!rst) begin\n            if (fetch == 2'b01) begin // Fetch operation 1, from REG\n                ins_p1 <= data;\n                ins_p2 <= ins_p2;\n            end else begin\n            ins_p1 <= ", "issue_description": "The buggy code has swapped if and else bodies in a conditional block. This causes the logic to execute the opposite branch for each condition, leading to incorrect behavior when the condition is true vs false. Test cases that depend on the conditional logic will fail because the intended branch is not executed.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module contains conditional logic that should execute different code paths based on a condition.\n   \u2022 The if branch should handle the true case, and the else branch should handle the false case.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Identified a conditional block with both if and else branches.\n   \u2022 The branches contain different assignments or logic operations.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The if and else bodies have been swapped.\n   \u2022 Logic that should execute when condition is true now executes when false, and vice versa.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The conditional bodies are inverted.\n   \u2022 Impact: All conditional behavior is reversed, causing incorrect outputs for all test cases.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Swap the if and else bodies back to their correct positions.\n   \u2022 Verify that the condition evaluates correctly and executes the intended branch.\n\n6. RTL Design Principle Violated:\n   \u2022 Correct conditional logic requires matching the intended behavior with the branch bodies.", "complexity": 15, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["invert_if_else"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.892778", "corruption_index": 6}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "instr_reg", "module_name": "instr_reg", "description": "Please act as a professional Verilog designer.\n\nAn instruction register module designed to hold and process CPU instructions. It captures incoming instructions from various sources and separates them into distinct fields for further processing.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register contains two 8-bit registers (ins_p1 and ins_p2) to store instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both registers are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into ins_p1.\n    If fetch is 2'b10, the instruction is fetched from the data input into ins_p2.\n    If neither condition is met, the previous values in both registers are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions.\n\n\nGive me the complete code.\n\n"}, "clean_code": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    reg [7:0] ins_p1, ins_p2;\n    reg [2:0] state;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1 <= 8'd0;\n            ins_p2 <= 8'd0;\n        end else begin\n            if (fetch == 2'b01) begin // Fetch operation 1, from REG\n                ins_p1 <= data;\n                ins_p2 <= ins_p2;\n            end else if (fetch == 2'b10) begin // Fetch operation 2, from RAM/ROM\n                ins_p1 <= ins_p1;\n                ins_p2 <= data;\n            end else begin\n                ins_p1 <= ins_p1;\n                ins_p2 <= ins_p2;\n            end\n        end\n    end\n\n    assign ins = ins_p1[7:5]; // High 3 bits, instructions\n    assign ad1 = ins_p1[4:0];  // Low 5 bits, register address\n    assign ad2 = ins_p2;\nendmodule", "corrupted_code": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    reg [7:0] ins_p1, ins_p2;\n    reg [2:0] state;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1 <= 8'd0;\n            ins_p2 <= 8'd0;\n        end else begin\n            if (fetch == 2'b01) begin // Fetch operation 1, from REG\n                ins_p1 <= data;\n                ins_p2 <= ins_p2;\n            end else if (fetch == 2'b10) begin // Fetch operation 2, from RAM/ROM\n                ins_p1 <= ins_p1;\n                ins_p2 <= data;\n            end else begin\n                ins_p1 <= ins_p1;\n                ins_p2 <= ins_p2;\n            end\n        end\n    end\n\n    assign ins <= ins_p1[7:5]; // High 3 bits, instructions\n    assign ad1 = ins_p1[4:0];  // Low 5 bits, register address\n    assign ad2 = ins_p2;\nendmodule", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 32, "original_snippet": "ns = ins_p1[7:5];", "modified_snippet": "ns <= ins_p1[7:5];", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 15, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["swap_blocking_nonblocking"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.894227", "corruption_index": 8}
{"source": "rtllm", "rtllm_info": {"category": "Miscellaneous", "subcategory": "RISC-V", "design_name": "instr_reg", "module_name": "instr_reg", "description": "Please act as a professional Verilog designer.\n\nAn instruction register module designed to hold and process CPU instructions. It captures incoming instructions from various sources and separates them into distinct fields for further processing.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register contains two 8-bit registers (ins_p1 and ins_p2) to store instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both registers are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into ins_p1.\n    If fetch is 2'b10, the instruction is fetched from the data input into ins_p2.\n    If neither condition is met, the previous values in both registers are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions.\n\n\nGive me the complete code.\n\n"}, "clean_code": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    reg [7:0] ins_p1, ins_p2;\n    reg [2:0] state;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1 <= 8'd0;\n            ins_p2 <= 8'd0;\n        end else begin\n            if (fetch == 2'b01) begin // Fetch operation 1, from REG\n                ins_p1 <= data;\n                ins_p2 <= ins_p2;\n            end else if (fetch == 2'b10) begin // Fetch operation 2, from RAM/ROM\n                ins_p1 <= ins_p1;\n                ins_p2 <= data;\n            end else begin\n                ins_p1 <= ins_p1;\n                ins_p2 <= ins_p2;\n            end\n        end\n    end\n\n    assign ins = ins_p1[7:5]; // High 3 bits, instructions\n    assign ad1 = ins_p1[4:0];  // Low 5 bits, register address\n    assign ad2 = ins_p2;\nendmodule", "corrupted_code": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    reg [7:0] ins_p1, ins_p2;\n    reg [2:0] state;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            \n            ins_p2 <= 8'd0;\n        end else begin\n            if (fetch == 2'b01) begin // Fetch operation 1, from REG\n                ins_p1 <= data;\n                ins_p2 <= ins_p2;\n            end else if (fetch == 2'b10) begin // Fetch operation 2, from RAM/ROM\n                ins_p1 <= ins_p1;\n                ins_p2 <= data;\n            end else begin\n                ins_p1 <= ins_p1;\n                ins_p2 <= ins_p2;\n            end\n        end\n    end\n\n    assign ins = ins_p1[7:5]; // High 3 bits, instructions\n    assign ad1 = ins_p1[4:0];  // Low 5 bits, register address\n    assign ad2 = ins_p2;\nendmodule", "corruption_explanation": "Removed assignment from reset block", "modification_type": "remove_reset_assignment", "modification_line": 15, "original_snippet": "ins_p1 <= 8'd0;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing a signal initialization in the reset block. This leaves registers with undefined initial values after reset, causing unpredictable behavior on startup. Simulation may pass but hardware behavior will be incorrect.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_reset_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed assignment from reset block\n   \u2022 Line 15: Original: ins_p1 <= 8'd0;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 15.\n   \u2022 Restore the original code: ins_p1 <= 8'd0;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove reset assignment.", "complexity": 15, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["remove_reset_assignment"], "verified_different": true, "testbench_verification": null, "corruption_verified_by_testbench": null, "timestamp": "2025-12-28T14:05:23.894913", "corruption_index": 9}
