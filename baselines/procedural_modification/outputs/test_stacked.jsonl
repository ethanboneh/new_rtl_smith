{"original_entry": {"instruction": "\nDesign and implement two Verilog modules:\n\n1.  A module named `full_adder` that performs a 1-bit binary addition of three inputs (two data bits and a carry-in) and produces a sum bit and a carry-out bit.\n    *   Module name: `full_adder`\n    *   Inputs: `input a`, `input b`, `input cin`\n    *   Outputs: `output s`, `output cout`\n\n2.  A module named `adder_4bit` that performs a 4-bit binary addition of two 4-bit inputs and a carry-in, producing a 4-bit sum and a carry-out. This module should be structured using instances of your `full_adder` module.\n    *   Module name: `adder_4bit`\n    *   Inputs: `input [3:0] A`, `input [3:0] B`, `input Cin`\n    *   Outputs: `output [3:0] S`, `output Cout`\n\nProvide the Verilog code for both modules.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule adder_4bit(\n\tinput [3:0] A,\n\tinput [3:0] B,\n\tinput Cin,\n\toutput [3:0] S,\n\toutput Cout\n\t);\n\nwire c1, c2, c3;\n\nfull_adder fa1(A[0], B[0], Cin, S[0], c1);\nfull_adder fa2(A[1], B[1], c1, S[1], c2);\nfull_adder fa3(A[2], B[2], c2, S[2], c3);\nfull_adder fa4(A[3], B[3], c3, S[3], Cout);\n\nendmodule\n\nmodule full_adder(\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput s,\n\toutput cout\n\t);\n\nassign s = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\nCODE END"}, "clean_code": "module adder_4bit(\n\tinput [3:0] A,\n\tinput [3:0] B,\n\tinput Cin,\n\toutput [3:0] S,\n\toutput Cout\n\t);\n\nwire c1, c2, c3;\n\nfull_adder fa1(A[0], B[0], Cin, S[0], c1);\nfull_adder fa2(A[1], B[1], c1, S[1], c2);\nfull_adder fa3(A[2], B[2], c2, S[2], c3);\nfull_adder fa4(A[3], B[3], c3, S[3], Cout);\n\nendmodule\n\nmodule full_adder(\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput s,\n\toutput cout\n\t);\n\nassign s = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "corrupted_code": "module adder_4bit(\n\tinput [3:0] A,\n\tinput [3:0] B,\n\tinput Cin,\n\toutput [3:0] S,\n\toutput Cout\n\t);\n\nwire c1, c2, c3;\n\nfull_adder fa1(A[0], B[0], Cin, S[0], c1);\nfull_adder fa2(A[1], B[1], c1, S[1], c2);\nfull_adder fa3(A[2], B[2], c2, S[2], c3);\nfull_adder fa4(A[3], B[3], c3, S[3], Cout);\n\nendmodule\n\nmodule full_adder(\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput s,\n\toutput cout\n\t);\n\nassign s = a ^ b ^ cin;\nassign s = 1'b0;  // Conflicting assignment\nassign cout = (a | b) | (cin & (a ^ b));\n\nendmodule", "corruption_explanation": "Changed operator from '&' to '|' | Added conflicting driver for signal 's'", "modification_type": "change_operator+add_multiple_driver", "modification_line": [27, 25], "original_snippet": ["&", "assign s = a ^ b ^ cin;"], "modified_snippet": ["|", "assign s = a ^ b ^ cin;\nassign s = 1'b0;  // Conflicting assignment"], "issue_description": "The buggy code has 2 stacked bugs:\n\nBug 1 (change_operator): The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.\n\nBug 2 (add_multiple_driver): The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "This code contains 2 stacked bugs that need to be fixed:\n\n\n--- Bug 1: change_operator (line 27) ---\nDescription: Changed operator from '&' to '|'\nOriginal: &\nModified: |\n\n--- Bug 2: add_multiple_driver (line 25) ---\nDescription: Added conflicting driver for signal 's'\nOriginal: assign s = a ^ b ^ cin;\nModified: assign s = a ^ b ^ cin;\nassign s = 1'b0;  // Conflicting assignment", "complexity": 3, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "stacked_count": 2, "applied_modifications": ["change_operator", "add_multiple_driver"], "verified_different": true, "timestamp": "2025-12-25T16:42:03.724796", "corruption_index": 0}
{"original_entry": {"instruction": "\nWrite a Verilog module named `bitwise_or_twos_complement`. The module should implement combinational logic based on the following interface and behavior:\n\nModule Name: `bitwise_or_twos_complement`\n\nInterface:\n- Input: `input [3:0] a`\n- Input: `input [3:0] b`\n- Output: `output reg [3:0] out`\n\nFunctionality:\nThe module should perform the bitwise OR operation on inputs `a` and `b`. It should then calculate the two's complement of this bitwise OR result. Additionally, the module should compute the difference between `a` and `b` (`a - b`). The final output `out` should be assigned the value of the two's complement of the bitwise OR result.\n\nEnsure the module name and the input/output port declarations (names, widths, and type for the output) match exactly as specified above.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule bitwise_or_twos_complement (\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] out\n);\n\n// Bitwise OR block\nreg [3:0] or_result;\nalways @* begin\n    or_result = a | b;\nend\n\n// 2's complement block\nreg [3:0] twos_comp_result;\nalways @* begin\n    twos_comp_result = ~or_result + 1;\nend\n\n// Difference block\nreg [3:0] diff;\nalways @* begin\n    diff = a - b;\nend\n\n// Output assignment\nalways @* begin\n    out = twos_comp_result;\nend\n\nendmodule\nCODE END"}, "clean_code": "module bitwise_or_twos_complement (\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] out\n);\n\n// Bitwise OR block\nreg [3:0] or_result;\nalways @* begin\n    or_result = a | b;\nend\n\n// 2's complement block\nreg [3:0] twos_comp_result;\nalways @* begin\n    twos_comp_result = ~or_result + 1;\nend\n\n// Difference block\nreg [3:0] diff;\nalways @* begin\n    diff = a - b;\nend\n\n// Output assignment\nalways @* begin\n    out = twos_comp_result;\nend\n\nendmodule", "corrupted_code": "module bitwise_or_twos_complement (\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:1] out\n);\n\n// Bitwise OR block\nreg [3:0] or_result;\nalways @* begin\n\nend\n\n// 2's complement block\nreg [3:0] twos_comp_result;\nalways @* begin\n    twos_comp_result = ~or_result + 1;\nend\n\n// Difference block\nreg [3:0] diff;\nalways @* begin\n    diff = a - b;\nend\n\n// Output assignment\nalways @* begin\n    out = twos_comp_result;\nend\n\nendmodule", "corruption_explanation": "Changed bit width from [3:0] to [3:1] | Removed an assignment statement", "modification_type": "change_bit_width+remove_assignment", "modification_line": [4, 10], "original_snippet": ["[3:0]", "or_result = a | b;"], "modified_snippet": ["[3:1]", "(removed)"], "issue_description": "The buggy code has 2 stacked bugs:\n\nBug 1 (change_bit_width): The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.\n\nBug 2 (remove_assignment): The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "This code contains 2 stacked bugs that need to be fixed:\n\n\n--- Bug 1: change_bit_width (line 4) ---\nDescription: Changed bit width from [3:0] to [3:1]\nOriginal: [3:0]\nModified: [3:1]\n\n--- Bug 2: remove_assignment (line 10) ---\nDescription: Removed an assignment statement\nOriginal: or_result = a | b;\nModified: (removed)", "complexity": 7, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_always_block"], "stacked_count": 2, "applied_modifications": ["change_bit_width", "remove_assignment"], "verified_different": true, "timestamp": "2025-12-25T16:42:03.727496", "corruption_index": 0}
{"original_entry": {"instruction": "\nWrite a Verilog module named `bitwise_or_twos_complement`. The module should implement combinational logic based on the following interface and behavior:\n\nModule Name: `bitwise_or_twos_complement`\n\nInterface:\n- Input: `input [3:0] a`\n- Input: `input [3:0] b`\n- Output: `output reg [3:0] out`\n\nFunctionality:\nThe module should perform the bitwise OR operation on inputs `a` and `b`. It should then calculate the two's complement of this bitwise OR result. Additionally, the module should compute the difference between `a` and `b` (`a - b`). The final output `out` should be assigned the value of the two's complement of the bitwise OR result.\n\nEnsure the module name and the input/output port declarations (names, widths, and type for the output) match exactly as specified above.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule bitwise_or_twos_complement (\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] out\n);\n\n// Bitwise OR block\nreg [3:0] or_result;\nalways @* begin\n    or_result = a | b;\nend\n\n// 2's complement block\nreg [3:0] twos_comp_result;\nalways @* begin\n    twos_comp_result = ~or_result + 1;\nend\n\n// Difference block\nreg [3:0] diff;\nalways @* begin\n    diff = a - b;\nend\n\n// Output assignment\nalways @* begin\n    out = twos_comp_result;\nend\n\nendmodule\nCODE END"}, "clean_code": "module bitwise_or_twos_complement (\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] out\n);\n\n// Bitwise OR block\nreg [3:0] or_result;\nalways @* begin\n    or_result = a | b;\nend\n\n// 2's complement block\nreg [3:0] twos_comp_result;\nalways @* begin\n    twos_comp_result = ~or_result + 1;\nend\n\n// Difference block\nreg [3:0] diff;\nalways @* begin\n    diff = a - b;\nend\n\n// Output assignment\nalways @* begin\n    out = twos_comp_result;\nend\n\nendmodule", "corrupted_code": "module bitwise_or_twos_complement (\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] out\n);\n\n// Bitwise OR block\nreg [3:0] or_result;\nalways @* begin\n    or_result <= a | b;\nend\n\n// 2's complement block\nreg [3:0] twos_comp_result;\nalways @* begin\n    twos_comp_result = ~or_result + 1;\nend\n\n// Difference block\nreg [3:0] diff;\nalways @* begin\n    diff = a + b;\nend\n\n// Output assignment\nalways @* begin\n    out = twos_comp_result;\nend\n\nendmodule", "corruption_explanation": "Changed blocking (=) to non-blocking (<=) | Changed operator from '-' to '+'", "modification_type": "swap_blocking_nonblocking+change_operator", "modification_line": [10, 22], "original_snippet": ["or_result = a | b;", "-"], "modified_snippet": ["or_result <= a | b;", "+"], "issue_description": "The buggy code has 2 stacked bugs:\n\nBug 1 (swap_blocking_nonblocking): The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.\n\nBug 2 (change_operator): The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "This code contains 2 stacked bugs that need to be fixed:\n\n\n--- Bug 1: swap_blocking_nonblocking (line 10) ---\nDescription: Changed blocking (=) to non-blocking (<=)\nOriginal: or_result = a | b;\nModified: or_result <= a | b;\n\n--- Bug 2: change_operator (line 22) ---\nDescription: Changed operator from '-' to '+'\nOriginal: -\nModified: +", "complexity": 7, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_always_block"], "stacked_count": 2, "applied_modifications": ["swap_blocking_nonblocking", "change_operator"], "verified_different": true, "timestamp": "2025-12-25T16:42:03.729388", "corruption_index": 1}
{"original_entry": {"instruction": "\nDesign a Verilog module named `addfxp` that implements a synchronous fixed-point adder with configurable latency. The module should have the following interface:\n\nInputs:\n*   `input signed [width-1:0] a`\n*   `input signed [width-1:0] b`\n*   `input clk`\n\nOutput:\n*   `output signed [width-1:0] q`\n\nParameters:\n*   `parameter width = 16` (Data width)\n*   `parameter cycles = 1` (Latency in clock cycles)\n\nThe module should compute the sum `a + b` and output the result `q` exactly `cycles` clock cycles after the inputs `a` and `b` are sampled on a positive edge of `clk`. The inputs and output are signed fixed-point numbers of size `width`.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule addfxp(a, b, q, clk);\n\n   parameter width = 16, cycles=1;\n   \n   input signed [width-1:0]  a, b;\n   input                     clk;   \n   output signed [width-1:0] q;\n   reg signed [width-1:0]    res[cycles-1:0];\n\n   assign                    q = res[cycles-1];\n   \n   integer                   i;   \n   \n   always @(posedge clk) begin\n     res[0] <= a+b;\n      for (i=1; i < cycles; i = i+1)\n        res[i] <= res[i-1];\n      \n   end\n   \nendmodule\nCODE END"}, "clean_code": "module addfxp(a, b, q, clk);\n\n   parameter width = 16, cycles=1;\n   \n   input signed [width-1:0]  a, b;\n   input                     clk;   \n   output signed [width-1:0] q;\n   reg signed [width-1:0]    res[cycles-1:0];\n\n   assign                    q = res[cycles-1];\n   \n   integer                   i;   \n   \n   always @(posedge clk) begin\n     res[0] <= a+b;\n      for (i=1; i < cycles; i = i+1)\n        res[i] <= res[i-1];\n      \n   end\n   \nendmodule", "corrupted_code": "module addfxp(a, b, q, clk);\n\n   parameter width = 17, cycles=1;\n   \n   input signed [width-1:0]  a, b;\n   input                     clk;   \n   output signed [width-1:0] q;\n   reg signed [width-1:0]    res[cycles-1:0];\n\n   assign                    q = res[cycles-1];\n   \n   integer                   i;   \n   \n   always @(posedge clk) begin\n     res[0] <= a+b;\n      for (i=1; i < cycles; i = i+1)\n        res[i] <= res[i-1];\n      \n   end\n   \nendmodule", "corruption_explanation": "Changed constant from 16 to 17", "modification_type": "change_constant", "modification_line": 3, "original_snippet": "16", "modified_snippet": "17", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 16 to 17\n   \u2022 Line 3: Original: 16\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 3.\n   \u2022 Restore the original code: 16\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 10, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "stacked_count": 1, "applied_modifications": ["change_constant"], "verified_different": true, "timestamp": "2025-12-25T16:42:03.730925", "corruption_index": 0}
