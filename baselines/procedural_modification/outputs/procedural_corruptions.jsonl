{"original_entry": {"instruction": "\nDesign and implement two Verilog modules:\n\n1.  A module named `full_adder` that performs a 1-bit binary addition of three inputs (two data bits and a carry-in) and produces a sum bit and a carry-out bit.\n    *   Module name: `full_adder`\n    *   Inputs: `input a`, `input b`, `input cin`\n    *   Outputs: `output s`, `output cout`\n\n2.  A module named `adder_4bit` that performs a 4-bit binary addition of two 4-bit inputs and a carry-in, producing a 4-bit sum and a carry-out. This module should be structured using instances of your `full_adder` module.\n    *   Module name: `adder_4bit`\n    *   Inputs: `input [3:0] A`, `input [3:0] B`, `input Cin`\n    *   Outputs: `output [3:0] S`, `output Cout`\n\nProvide the Verilog code for both modules.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule adder_4bit(\n\tinput [3:0] A,\n\tinput [3:0] B,\n\tinput Cin,\n\toutput [3:0] S,\n\toutput Cout\n\t);\n\nwire c1, c2, c3;\n\nfull_adder fa1(A[0], B[0], Cin, S[0], c1);\nfull_adder fa2(A[1], B[1], c1, S[1], c2);\nfull_adder fa3(A[2], B[2], c2, S[2], c3);\nfull_adder fa4(A[3], B[3], c3, S[3], Cout);\n\nendmodule\n\nmodule full_adder(\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput s,\n\toutput cout\n\t);\n\nassign s = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\nCODE END"}, "clean_code": "module adder_4bit(\n\tinput [3:0] A,\n\tinput [3:0] B,\n\tinput Cin,\n\toutput [3:0] S,\n\toutput Cout\n\t);\n\nwire c1, c2, c3;\n\nfull_adder fa1(A[0], B[0], Cin, S[0], c1);\nfull_adder fa2(A[1], B[1], c1, S[1], c2);\nfull_adder fa3(A[2], B[2], c2, S[2], c3);\nfull_adder fa4(A[3], B[3], c3, S[3], Cout);\n\nendmodule\n\nmodule full_adder(\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput s,\n\toutput cout\n\t);\n\nassign s = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule", "corrupted_code": "module adder_4bit(\n\tinput [3:0] A,\n\tinput [3:0] B,\n\tinput Cin,\n\toutput [3:0] S,\n\toutput Cout\n\t);\n\nwire c1, c2, c3;\n\nfull_adder fa1(A[0], B[0], Cin, S[0], c1);\nfull_adder fa2(A[1], B[1], c1, S[1], c2);\nfull_adder fa3(A[2], B[2], c2, S[2], c3);\nfull_adder fa4(A[3], B[3], c3, S[3], Cout);\n\nendmodule\n\nmodule full_adder(\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput s,\n\toutput cout\n\t);\n\nassign s = a ^ b ^ cin;\nassign cout = (a | b) | (cin & (a ^ b));\n\nendmodule", "corruption_explanation": "Changed operator from '&' to '|'", "modification_type": "change_operator", "modification_line": 27, "original_snippet": "&", "modified_snippet": "|", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '&' to '|'\n   \u2022 Line 27: Original: &\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 27.\n   \u2022 Restore the original code: &\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 3, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "timestamp": "2025-12-09T21:43:36.218383"}
{"original_entry": {"instruction": "\nDesign a Verilog module named `addfxp` that implements a synchronous fixed-point adder with configurable latency. The module should have the following interface:\n\nInputs:\n*   `input signed [width-1:0] a`\n*   `input signed [width-1:0] b`\n*   `input clk`\n\nOutput:\n*   `output signed [width-1:0] q`\n\nParameters:\n*   `parameter width = 16` (Data width)\n*   `parameter cycles = 1` (Latency in clock cycles)\n\nThe module should compute the sum `a + b` and output the result `q` exactly `cycles` clock cycles after the inputs `a` and `b` are sampled on a positive edge of `clk`. The inputs and output are signed fixed-point numbers of size `width`.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule addfxp(a, b, q, clk);\n\n   parameter width = 16, cycles=1;\n   \n   input signed [width-1:0]  a, b;\n   input                     clk;   \n   output signed [width-1:0] q;\n   reg signed [width-1:0]    res[cycles-1:0];\n\n   assign                    q = res[cycles-1];\n   \n   integer                   i;   \n   \n   always @(posedge clk) begin\n     res[0] <= a+b;\n      for (i=1; i < cycles; i = i+1)\n        res[i] <= res[i-1];\n      \n   end\n   \nendmodule\nCODE END"}, "clean_code": "module addfxp(a, b, q, clk);\n\n   parameter width = 16, cycles=1;\n   \n   input signed [width-1:0]  a, b;\n   input                     clk;   \n   output signed [width-1:0] q;\n   reg signed [width-1:0]    res[cycles-1:0];\n\n   assign                    q = res[cycles-1];\n   \n   integer                   i;   \n   \n   always @(posedge clk) begin\n     res[0] <= a+b;\n      for (i=1; i < cycles; i = i+1)\n        res[i] <= res[i-1];\n      \n   end\n   \nendmodule", "corrupted_code": "module addfxp(a, b, q, clk);\n\n   parameter width = 17, cycles=1;\n   \n   input signed [width-1:0]  a, b;\n   input                     clk;   \n   output signed [width-1:0] q;\n   reg signed [width-1:0]    res[cycles-1:0];\n\n   assign                    q = res[cycles-1];\n   \n   integer                   i;   \n   \n   always @(posedge clk) begin\n     res[0] <= a+b;\n      for (i=1; i < cycles; i = i+1)\n        res[i] <= res[i-1];\n      \n   end\n   \nendmodule", "corruption_explanation": "Changed constant from 16 to 17", "modification_type": "change_constant", "modification_line": 3, "original_snippet": "16", "modified_snippet": "17", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 16 to 17\n   \u2022 Line 3: Original: 16\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 3.\n   \u2022 Restore the original code: 16\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 10, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.220563"}
{"original_entry": {"instruction": "\nDesign two Verilog modules:\n\n1.  A single-bit full adder module named `full_adder`. It should have inputs `A`, `B`, and `Cin` (all single bits) and outputs `S` (sum) and `Cout` (carry-out) (both single bits).\n2.  A 4-bit ripple-carry adder module named `adder`. This module should utilize the `full_adder` module. It should have 4-bit inputs `A` and `B`, a single-bit input `Cin`, a 4-bit output `S` (sum), and a single-bit output `Cout` (final carry-out).\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule adder(A, B, Cin, S, Cout);\n    input [3:0] A, B;\n    input Cin;\n    output [3:0] S;\n    output Cout;\n\n    wire c1, c2, c3;\n\n    full_adder fa0(A[0], B[0], Cin, S[0], c1);\n    full_adder fa1(A[1], B[1], c1, S[1], c2);\n    full_adder fa2(A[2], B[2], c2, S[2], c3);\n    full_adder fa3(A[3], B[3], c3, S[3], Cout);\n\nendmodule\nmodule full_adder(A, B, Cin, S, Cout);\n    input A, B, Cin;\n    output S, Cout;\n    assign {Cout, S} = A + B + Cin;\nendmodule\nCODE END"}, "clean_code": "module adder(A, B, Cin, S, Cout);\n    input [3:0] A, B;\n    input Cin;\n    output [3:0] S;\n    output Cout;\n\n    wire c1, c2, c3;\n\n    full_adder fa0(A[0], B[0], Cin, S[0], c1);\n    full_adder fa1(A[1], B[1], c1, S[1], c2);\n    full_adder fa2(A[2], B[2], c2, S[2], c3);\n    full_adder fa3(A[3], B[3], c3, S[3], Cout);\n\nendmodule\nmodule full_adder(A, B, Cin, S, Cout);\n    input A, B, Cin;\n    output S, Cout;\n    assign {Cout, S} = A + B + Cin;\nendmodule", "corrupted_code": "module adder(A, B, Cin, S, Cout);\n    input [3:1] A, B;\n    input Cin;\n    output [3:0] S;\n    output Cout;\n\n    wire c1, c2, c3;\n\n    full_adder fa0(A[0], B[0], Cin, S[0], c1);\n    full_adder fa1(A[1], B[1], c1, S[1], c2);\n    full_adder fa2(A[2], B[2], c2, S[2], c3);\n    full_adder fa3(A[3], B[3], c3, S[3], Cout);\n\nendmodule\nmodule full_adder(A, B, Cin, S, Cout);\n    input A, B, Cin;\n    output S, Cout;\n    assign {Cout, S} = A + B + Cin;\nendmodule", "corruption_explanation": "Changed bit width from [3:0] to [3:1]", "modification_type": "change_bit_width", "modification_line": 2, "original_snippet": "[3:0]", "modified_snippet": "[3:1]", "issue_description": "The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_bit_width modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed bit width from [3:0] to [3:1]\n   \u2022 Line 2: Original: [3:0]\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 2.\n   \u2022 Restore the original code: [3:0]\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change bit width.", "complexity": 1, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "swap_port_signals"], "timestamp": "2025-12-09T21:43:36.222260"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `binary_counter`.\nThis module should implement a synchronous binary counter with an asynchronous reset.\nIt should include a parameter named `MAX_COUNT` with a default value of 15, which determines the maximum value the counter reaches before wrapping around.\n\nThe module interface should be defined as follows:\n-   Input `clk`: The clock signal.\n-   Input `reset`: The asynchronous reset signal (active high).\n-   Output `count`: A 4-bit register (`reg [3:0]`) holding the current count value.\n-   Output `overflow`: A register (`reg`) indicating when the counter has just wrapped around.\n\nThe behavior of the module should be:\n-   When the `reset` input is high, the `count` output should immediately reset to 0, and the `overflow` output should be cleared to 0.\n-   On the positive edge of the `clk` signal, when `reset` is low:\n    -   If the current value of `count` is equal to the `MAX_COUNT` parameter, the `count` should wrap around to 0 on the next clock cycle, and the `overflow` output should be set high for one clock cycle.\n    -   Otherwise (if the current value of `count` is less than `MAX_COUNT`), the `count` should increment by 1, and the `overflow` output should be cleared to 0.\n\nUse non-blocking assignments (`<=`) for all sequential logic updates.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule binary_counter\n#(parameter MAX_COUNT=15)\n(\n  input clk,\n  input reset,\n  output reg [3:0]count,  // 4 bits for 16 counts\n  output reg overflow\n);\n\n  always @(posedge clk or posedge reset)\n  begin\n    if (reset)\n    begin\n      count <= 0;\n      overflow <= 0;\n    end\n    else if (count == MAX_COUNT)\n    begin\n      count <= 0;\n      overflow <= 1;\n    end\n    else\n    begin\n      count <= count + 1;\n      overflow <= 0;\n    end\n  end\n\nendmodule\nCODE END"}, "clean_code": "module binary_counter\n#(parameter MAX_COUNT=15)\n(\n  input clk,\n  input reset,\n  output reg [3:0]count,  // 4 bits for 16 counts\n  output reg overflow\n);\n\n  always @(posedge clk or posedge reset)\n  begin\n    if (reset)\n    begin\n      count <= 0;\n      overflow <= 0;\n    end\n    else if (count == MAX_COUNT)\n    begin\n      count <= 0;\n      overflow <= 1;\n    end\n    else\n    begin\n      count <= count + 1;\n      overflow <= 0;\n    end\n  end\n\nendmodule", "corrupted_code": "module binary_counter\n#(parameter MAX_COUNT=15)\n(\n  input clk,\n  input reset,\n  output reg [3:0]count,  // 4 bits for 16 counts\n  output reg overflow\n);\n\n  always @(posedge clk or posedge reset)\n  begin\n    if (reset)\n    begin\n      count <= 0;\n\n    end\n    else if (count == MAX_COUNT)\n    begin\n      count <= 0;\n      overflow <= 1;\n    end\n    else\n    begin\n      count <= count + 1;\n      overflow <= 0;\n    end\n  end\n\nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 15, "original_snippet": "overflow <= 0;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 15: Original: overflow <= 0;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 15.\n   \u2022 Restore the original code: overflow <= 0;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 11, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.225134"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `ram_RAMB18E1` with the following interface and behavior.\n\n**Interface:**\n*   **Parameters:**\n    *   `LOC`: string type, default value \"RAMB18_X0Y0\"\n    *   `WRITE_MODE_A`: string type, default value \"WRITE_FIRST\"\n*   **Inputs:**\n    *   `clk`: 1-bit wire\n    *   `din`: 8-bit wire\n*   **Outputs:**\n    *   `dout`: 8-bit wire\n\n**Behavior:**\nThe module should contain an internal 8-bit state register (or equivalent storage) which is initialized to all zeros. On the positive edge of the `clk` signal, if the parameter `WRITE_MODE_A` has the string value 'WRITE_FIRST', this internal 8-bit state is updated. The update involves effectively shifting the current 8-bit state one position to the right. The most significant bit (bit 7) of the state is loaded with the value of the least significant bit of the `din` input (`din[0]`). The bit previously in the least significant position (bit 0) is discarded. The output `dout` should continuously reflect the current value of this internal 8-bit state.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule ram_RAMB18E1 #(parameter LOC = \"RAMB18_X0Y0\", parameter WRITE_MODE_A = \"WRITE_FIRST\")\n(\n    input wire clk,\n    input wire [7:0] din,\n    output wire [7:0] dout\n);\n\nreg [7:0] mem [0:31];\n\ninteger i;\n\ninitial begin\n    for (i = 0; i < 32; i = i + 1) begin\n        mem[i] = 8'h00;\n    end\nend\n\nalways @(posedge clk) begin\n    if (WRITE_MODE_A == \"WRITE_FIRST\") begin\n        mem[0] <= {din, mem[0][7:1]};\n    end\nend\n\nassign dout = mem[0];\n\nendmodule\nCODE END"}, "clean_code": "module ram_RAMB18E1 #(parameter LOC = \"RAMB18_X0Y0\", parameter WRITE_MODE_A = \"WRITE_FIRST\")\n(\n    input wire clk,\n    input wire [7:0] din,\n    output wire [7:0] dout\n);\n\nreg [7:0] mem [0:31];\n\ninteger i;\n\ninitial begin\n    for (i = 0; i < 32; i = i + 1) begin\n        mem[i] = 8'h00;\n    end\nend\n\nalways @(posedge clk) begin\n    if (WRITE_MODE_A == \"WRITE_FIRST\") begin\n        mem[0] <= {din, mem[0][7:1]};\n    end\nend\n\nassign dout = mem[0];\n\nendmodule", "corrupted_code": "module ram_RAMB18E1 #(parameter LOC = \"RAMB18_X0Y0\", parameter WRITE_MODE_A = \"WRITE_FIRST\")\n(\n    input wire clk,\n    input wire [7:0] din,\n    output wire [7:0] dout\n);\n\nreg [7:0] mem [0:31];\n\ninteger i;\n\ninitial begin\n    for (i = 0; i < 32; i = i + 1) begin\n        mem[i] = 8'h00;\n    end\nend\n\nalways @(posedge clk) begin\n    if (!(WRITE_MODE_A == \"WRITE_FIRST\")) begin\n        mem[0] <= {din, mem[0][7:1]};\n    end\nend\n\nassign dout = mem[0];\n\nendmodule", "corruption_explanation": "Inverted condition: 'WRITE_MODE_A == \"WRITE_FIRST\"' -> '!(WRITE_MODE_A == \"WRITE_FIRST\")'", "modification_type": "invert_condition", "modification_line": 19, "original_snippet": "if (WRITE_MODE_A == \"WRITE_FIRST\") begin", "modified_snippet": "if (!(WRITE_MODE_A == \"WRITE_FIRST\")) begin", "issue_description": "The buggy code has an inverted condition in an if statement. Instead of checking if(x), it checks if(!x), causing the logic to execute when it shouldn't and skip execution when it should. All conditional behavior is reversed from intended functionality.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_condition modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted condition: 'WRITE_MODE_A == \"WRITE_FIRST\"' -> '!(WRITE_MODE_A == \"WRITE_FIRST\")'\n   \u2022 Line 19: Original: if (WRITE_MODE_A == \"WRITE_FIRST\") begin\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 19.\n   \u2022 Restore the original code: if (WRITE_MODE_A == \"WRITE_FIRST\") begin\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert condition.", "complexity": 5, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.226153"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `random_num_gen` that generates an 8-bit pseudo-random number. The module should have the following interface: inputs `clk` (clock), `rst` (synchronous reset), `start` (enable), and an 8-bit output `rand_num`. The core of the generator is an 8-bit state register. On the positive edge of the clock, if `rst` is asserted, this state register should be cleared. If `rst` is not asserted and `start` is asserted, the state register should update to a new value calculated from its current state using a specific algorithm that shifts the state and incorporates feedback. The 8-bit output `rand_num` should continuously reflect the current value of this state register.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule random_num_gen (\n  input clk,\n  input rst,\n  input start,\n  output reg [7:0] rand_num\n);\n\nparameter n = 8; // width of the random number\n\nreg [7:0] lfsr_reg;\nreg feedback;\n\nalways @ (posedge clk) begin\n  if (rst) begin\n    lfsr_reg <= 8'b0;\n  end\n  else if (start) begin\n    feedback = lfsr_reg[0] ^ lfsr_reg[1] ^ lfsr_reg[3] ^ lfsr_reg[4];\n    lfsr_reg <= {lfsr_reg[6:0], feedback};\n  end\nend\n\nalways @* begin\n  rand_num = lfsr_reg;\nend\n\nendmodule\nCODE END"}, "clean_code": "module random_num_gen (\n  input clk,\n  input rst,\n  input start,\n  output reg [7:0] rand_num\n);\n\nparameter n = 8; // width of the random number\n\nreg [7:0] lfsr_reg;\nreg feedback;\n\nalways @ (posedge clk) begin\n  if (rst) begin\n    lfsr_reg <= 8'b0;\n  end\n  else if (start) begin\n    feedback = lfsr_reg[0] ^ lfsr_reg[1] ^ lfsr_reg[3] ^ lfsr_reg[4];\n    lfsr_reg <= {lfsr_reg[6:0], feedback};\n  end\nend\n\nalways @* begin\n  rand_num = lfsr_reg;\nend\n\nendmodule", "corrupted_code": "module random_num_gen (\n  input clk,\n  input rst,\n  input start,\n  output reg [7:0] rand_num\n);\n\nparameter n = 8; // width of the random number\n\nreg [7:0] lfsr_reg;\nreg feedback;\n\nalways @ (posedge clk) begin\n  if (rst) begin\n    lfsr_reg <= 8'b0;\n  end\n  else if (start) begin\n    feedback = lfsr_reg[0] ^ lfsr_reg[1] ^ lfsr_reg[3] ^ lfsr_reg[4];\n    lfsr_reg <= {lfsr_reg[6:0], feedback};\n  end\nend\n\n\n\nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 23, "original_snippet": "always @* begin\n  rand_num = lfsr_reg;\nend", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 23: Original: always @* begin\n  rand_num = lfsr_reg;\nend\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 23.\n   \u2022 Restore the original code: always @* begin\n  rand_num = lfsr_reg;\nend\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 5, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.227299"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `sync_load_counter` with the following interface:\nInputs:\n*   `clk`: Clock signal.\n*   `reset`: Synchronous reset signal.\n*   `load`: Synchronous load signal.\n*   `L [3:0]`: 4-bit data input for loading.\n*   `areset`: Asynchronous reset signal.\nOutputs:\n*   `count [3:0]`: 4-bit counter output.\n\nImplement a 4-bit up-counter that operates based on the positive edge of the `clk` signal, except for the asynchronous reset. The counter should prioritize operations as follows:\n1.  An active high `areset` signal should immediately (asynchronously) reset the `count` to 4'b0000, overriding all other conditions.\n2.  If `areset` is inactive, an active high `reset` signal should synchronously reset the `count` to 4'b0000 on the next clock edge.\n3.  If both `areset` and `reset` are inactive, an active high `load` signal should synchronously load the value from `L` into `count` on the next clock edge.\n4.  If `areset`, `reset`, and `load` are all inactive, the `count` should increment by 1 on the next clock edge.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule sync_load_counter (\n    input clk,\n    input reset,\n    input load,\n    input [3:0] L,\n    input areset,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            count <= 4'b0000;\n        end else if (reset) begin\n            count <= 4'b0000;\n        end else if (load) begin\n            count <= L;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\nCODE END"}, "clean_code": "module sync_load_counter (\n    input clk,\n    input reset,\n    input load,\n    input [3:0] L,\n    input areset,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            count <= 4'b0000;\n        end else if (reset) begin\n            count <= 4'b0000;\n        end else if (load) begin\n            count <= L;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule", "corrupted_code": "module sync_load_counter (\n    input clk,\n    input reset,\n    input load,\n    input [3:0] L,\n    input areset,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            count <= 4'b0000;\n        end else if (reset) begin\n\n        end else if (load) begin\n            count <= L;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 14, "original_snippet": "count <= 4'b0000;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 14: Original: count <= 4'b0000;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 14.\n   \u2022 Restore the original code: count <= 4'b0000;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 9, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.228120"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `synchronous_counter`. This module should implement a 4-bit binary-coded decimal (BCD) counter.\n\nThe module should have the following interface:\nInputs:\n- `clk`: Clock signal.\n- `reset`: Asynchronous reset signal.\n- `enable`: Counter enable signal.\n\nOutput:\n- `count_out`: A 4-bit register holding the current count value.\n\nThe counter should behave as follows:\n- When the `reset` signal is high, the counter should asynchronously reset its output `count_out` to 4'b0000.\n- On the positive edge of the `clk` signal, if `reset` is low and `enable` is high, the counter should increment its value.\n- The counter should count from 0 (4'b0000) up to 9 (4'b1001).\n- After reaching the value 9 (4'b1001) and being enabled on the next clock edge, the counter should wrap around and reset its value to 0 (4'b0000).\n- If `reset` is low and `enable` is low on the positive edge of `clk`, the counter should hold its current value.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule synchronous_counter(\n    input clk,\n    input reset,\n    input enable,\n    output reg [3:0] count_out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_out <= 4'b0000;\n        end else if (enable) begin\n            if (count_out == 4'b1001) begin\n                count_out <= 4'b0000;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\n\nendmodule\nCODE END"}, "clean_code": "module synchronous_counter(\n    input clk,\n    input reset,\n    input enable,\n    output reg [3:0] count_out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_out <= 4'b0000;\n        end else if (enable) begin\n            if (count_out == 4'b1001) begin\n                count_out <= 4'b0000;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\n\nendmodule", "corrupted_code": "module synchronous_counter(\n    input clk,\n    input reset,\n    input enable,\n    output reg [3:0] count_out\n);\n\n    always @(posedge clk or posedge reset) begin\n        \n        end\n    end\n\nendmodule", "corruption_explanation": "Removed a conditional block", "modification_type": "remove_conditional", "modification_line": 9, "original_snippet": "if (reset) begin\n            count_out <= 4'b0000;\n        end else if (enable) begin\n            if (count_out == 4'b1001) begin\n                count_out <= 4'b0000;\n            end else begin\n     ", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing a conditional block. This removes important control logic, causing the design to skip necessary state transitions or data processing. Test cases that depend on the conditional behavior will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_conditional modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed a conditional block\n   \u2022 Line 9: Original: if (reset) begin\n            count_out <= 4'b0000;\n        end else if (enable) begin\n            if (count_out == 4'b1001) begin\n                count_out <= 4'b0000;\n            end else begin\n     \n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 9.\n   \u2022 Restore the original code: if (reset) begin\n            count_out <= 4'b0000;\n        end else if (enable) begin\n            if (count_out == 4'b1001) begin\n                count_out <= 4'b0000;\n            end else begin\n     \n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove conditional.", "complexity": 9, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.229028"}
{"original_entry": {"instruction": "\nWrite a Verilog module that implements a simple logic function with a control signal.\nThe module must be named `my_module` and have the following interface:\nInputs: `A1`, `A2`, `A3`, `A4`, `B1`\nOutput: `X`\n\nThe module's behavior should be such that the output `X` is the result of one of two operations, selected by the input `B1`. Specifically:\n- If `B1` is true (logic 1), `X` should be the logical conjunction (AND) of inputs `A1` and `A2`.\n- If `B1` is false (logic 0), `X` should be the logical disjunction (OR) of inputs `A3` and `A4`.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule my_module (\n    input  A1,\n    input  A2,\n    input  A3,\n    input  A4,\n    input  B1,\n    output X\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // AND gate implementation\n    wire and_out;\n    assign and_out = A1 & A2;\n\n    // OR gate implementation\n    wire or_out;\n    assign or_out = A3 | A4;\n\n    // Output selection based on B1\n    assign X = B1 ? and_out : or_out;\n\nendmodule\nCODE END"}, "clean_code": "module my_module (\n    input  A1,\n    input  A2,\n    input  A3,\n    input  A4,\n    input  B1,\n    output X\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // AND gate implementation\n    wire and_out;\n    assign and_out = A1 & A2;\n\n    // OR gate implementation\n    wire or_out;\n    assign or_out = A3 | A4;\n\n    // Output selection based on B1\n    assign X = B1 ? and_out : or_out;\n\nendmodule", "corrupted_code": "module my_module (\n    input  A1,\n    input  A2,\n    input  A3,\n    input  A4,\n    input  B1,\n    output X\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // AND gate implementation\n    wire and_out;\n    assign and_out = A1 & A2;\n\n    // OR gate implementation\n    wire or_out;\n\n    // Output selection based on B1\n    assign X = B1 ? and_out : or_out;\n\nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 22, "original_snippet": "assign or_out = A3 | A4;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 22: Original: assign or_out = A3 | A4;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 22.\n   \u2022 Restore the original code: assign or_out = A3 | A4;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 2, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver"], "timestamp": "2025-12-09T21:43:36.229873"}
{"original_entry": {"instruction": "\nWrite the Verilog code for a 3-to-8 decoder module.\nThe module must be named `decoder_3to8`.\nIt has the following interface:\n-   Inputs: `input A`, `input B`, `input C` (single bits)\n-   Outputs: `output Y0`, `output Y1`, `output Y2`, `output Y3`, `output Y4`, `output Y5`, `output Y6`, `output Y7` (single bits)\n\nImplement the standard active-high decoder functionality where output `Yi` is asserted when the binary input `ABC` (with `A` as the most significant bit) represents the decimal value `i`. Your implementation should be purely combinational.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule decoder_3to8 (\n    input A,\n    input B,\n    input C,\n    output reg Y0,\n    output reg Y1,\n    output reg Y2,\n    output reg Y3,\n    output reg Y4,\n    output reg Y5,\n    output reg Y6,\n    output reg Y7\n);\n\nalways @ (A or B or C) begin\n    Y0 = ~(A | B | C);\n    Y1 = ~(A | B | ~C);\n    Y2 = ~(A | ~B | C);\n    Y3 = ~(A | ~B | ~C);\n    Y4 = ~(~A | B | C);\n    Y5 = ~(~A | B | ~C);\n    Y6 = ~(~A | ~B | C);\n    Y7 = ~(~A | ~B | ~C);\nend\n\nendmodule\nCODE END"}, "clean_code": "module decoder_3to8 (\n    input A,\n    input B,\n    input C,\n    output reg Y0,\n    output reg Y1,\n    output reg Y2,\n    output reg Y3,\n    output reg Y4,\n    output reg Y5,\n    output reg Y6,\n    output reg Y7\n);\n\nalways @ (A or B or C) begin\n    Y0 = ~(A | B | C);\n    Y1 = ~(A | B | ~C);\n    Y2 = ~(A | ~B | C);\n    Y3 = ~(A | ~B | ~C);\n    Y4 = ~(~A | B | C);\n    Y5 = ~(~A | B | ~C);\n    Y6 = ~(~A | ~B | C);\n    Y7 = ~(~A | ~B | ~C);\nend\n\nendmodule", "corrupted_code": "module decoder_3to8 (\n    input A,\n    input B,\n    input C,\n    output reg Y0,\n    output reg Y1,\n    output reg Y2,\n    output reg Y3,\n    output reg Y4,\n    output reg Y5,\n    output reg Y6,\n    output reg Y7\n);\n\nalways @(A or B) begin\n    Y0 = ~(A | B | C);\n    Y1 = ~(A | B | ~C);\n    Y2 = ~(A | ~B | C);\n    Y3 = ~(A | ~B | ~C);\n    Y4 = ~(~A | B | C);\n    Y5 = ~(~A | B | ~C);\n    Y6 = ~(~A | ~B | C);\n    Y7 = ~(~A | ~B | ~C);\nend\n\nendmodule", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 15, "original_snippet": "always @ (A or B or C)", "modified_snippet": "always @(A or B)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 15: Original: always @ (A or B or C)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 15.\n   \u2022 Restore the original code: always @ (A or B or C)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 7, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_always_block"], "timestamp": "2025-12-09T21:43:36.230630"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `accumulator` that implements a synchronous accumulator.\nModule Interface:\nInputs:\n  `clk` (single bit)\n  `reset` (single bit, synchronous reset)\n  `in` (8 bits, `[7:0]`)\nOutputs:\n  `out` (16 bits, `[15:0]`)\n\nBehavior:\nOn the positive edge of `clk`, if `reset` is asserted, the accumulator should be reset to 0. Otherwise, the 8-bit input `in` should be added to the current accumulated value, and the result should be stored as the new accumulated value. The output `out` should always represent the current accumulated value.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule accumulator (\n  input clk,\n  input reset,\n  input [7:0] in,\n  output [15:0] out\n);\n\n  reg [15:0] acc_reg; // register to hold the accumulated sum\n\n  always @(posedge clk) begin\n    if (reset) begin\n      acc_reg <= 16'd0; // clear the register to zero\n    end else begin\n      acc_reg <= acc_reg + in; // add the input signal to the register\n    end\n  end\n\n  assign out = acc_reg; // output the current value of the accumulator register\n\nendmodule\nCODE END"}, "clean_code": "module accumulator (\n  input clk,\n  input reset,\n  input [7:0] in,\n  output [15:0] out\n);\n\n  reg [15:0] acc_reg; // register to hold the accumulated sum\n\n  always @(posedge clk) begin\n    if (reset) begin\n      acc_reg <= 16'd0; // clear the register to zero\n    end else begin\n      acc_reg <= acc_reg + in; // add the input signal to the register\n    end\n  end\n\n  assign out = acc_reg; // output the current value of the accumulator register\n\nendmodule", "corrupted_code": "module accumulator (\n  input clk,\n  input reset,\n  input [7:0] in,\n  output [15:0] out\n);\n\n  reg [15:0] acc_reg; // register to hold the accumulated sum\n\n  always @(posedge clk) begin\n    \n  end\n\n  assign out = acc_reg; // output the current value of the accumulator register\n\nendmodule", "corruption_explanation": "Removed a conditional block", "modification_type": "remove_conditional", "modification_line": 11, "original_snippet": "if (reset) begin\n      acc_reg <= 16'd0; // clear the register to zero\n    end else begin\n      acc_reg <= acc_reg + in; // add the input signal to the register\n    end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing a conditional block. This removes important control logic, causing the design to skip necessary state transitions or data processing. Test cases that depend on the conditional behavior will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_conditional modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed a conditional block\n   \u2022 Line 11: Original: if (reset) begin\n      acc_reg <= 16'd0; // clear the register to zero\n    end else begin\n      acc_reg <= acc_reg + in; // add the input signal to the register\n    end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 11.\n   \u2022 Restore the original code: if (reset) begin\n      acc_reg <= 16'd0; // clear the register to zero\n    end else begin\n      acc_reg <= acc_reg + in; // add the input signal to the register\n    end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove conditional.", "complexity": 5, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.231457"}
{"original_entry": {"instruction": "\nWrite the Verilog code for a module named `BLOCK2A`. The module has inputs `PIN2`, `GIN1`, `GIN2`, and `PHI`, and an output `GOUT`. All inputs and outputs should have these exact names. The logic for the output `GOUT` should be evaluated and updated only on the positive edge of the `PHI` clock. The behavior of the module is as follows:\n\n*   If the input `GIN2` is high, the output `GOUT` must be forced to a low state (0), overriding any other logic.\n*   If the input `GIN2` is low, the output `GOUT` should reflect the result of an exclusive OR (XOR) operation between the inputs `PIN2` and `GIN1`.\n\nThe output `GOUT` should maintain its value between positive clock edges.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule BLOCK2A ( PIN2, GIN1, GIN2, PHI, GOUT );\ninput  PIN2;\ninput  GIN1;\ninput  GIN2;\ninput  PHI;\noutput GOUT;\n\nreg GOUT_reg;\n\nalways @(posedge PHI) begin\n    if (GIN2 == 1'b1) begin\n        GOUT_reg <= 1'b0;\n    end else begin\n        if ((PIN2 == 1'b0 && GIN1 == 1'b1) || (PIN2 == 1'b1 && GIN1 == 1'b0)) begin\n            GOUT_reg <= 1'b1;\n        end else begin\n            GOUT_reg <= 1'b0;\n        end\n    end\nend\n\nassign GOUT = GOUT_reg;\n\nendmodule\nCODE END"}, "clean_code": "module BLOCK2A ( PIN2, GIN1, GIN2, PHI, GOUT );\ninput  PIN2;\ninput  GIN1;\ninput  GIN2;\ninput  PHI;\noutput GOUT;\n\nreg GOUT_reg;\n\nalways @(posedge PHI) begin\n    if (GIN2 == 1'b1) begin\n        GOUT_reg <= 1'b0;\n    end else begin\n        if ((PIN2 == 1'b0 && GIN1 == 1'b1) || (PIN2 == 1'b1 && GIN1 == 1'b0)) begin\n            GOUT_reg <= 1'b1;\n        end else begin\n            GOUT_reg <= 1'b0;\n        end\n    end\nend\n\nassign GOUT = GOUT_reg;\n\nendmodule", "corrupted_code": "module BLOCK2A ( PIN2, GIN1, GIN2, PHI, GOUT );\ninput  PIN2;\ninput  GIN1;\ninput  GIN2;\ninput  PHI;\noutput GOUT;\n\nreg GOUT_reg;\n\nalways @(posedge PHI) begin\n    if (GIN2 == 1'b1) begin\n        GOUT_reg <= 1'b0;\n    end else begin\n        if ((PIN2 == 1'b0 && GIN1 == 1'b1) || (PIN2 == 1'b1 && GIN1 == 1'b0)) begin\n            GOUT_reg <= 1'b1;\n        end else begin\n            1 <= GOUT_reg'b0;\n        end\n    end\nend\n\nassign GOUT = GOUT_reg;\n\nendmodule", "corruption_explanation": "Swapped operands: 'GOUT_reg <= 1' -> '1 <= GOUT_reg'", "modification_type": "swap_operands", "modification_line": 17, "original_snippet": "GOUT_reg <= 1", "modified_snippet": "1 <= GOUT_reg", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'GOUT_reg <= 1' -> '1 <= GOUT_reg'\n   \u2022 Line 17: Original: GOUT_reg <= 1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 17.\n   \u2022 Restore the original code: GOUT_reg <= 1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 12, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.232332"}
{"original_entry": {"instruction": "\nDesign a Verilog module named `Span12Mux_v0`.\nThe module should have the following interface:\n-   Input `I`: 12 bits wide (`[11:0]`)\n-   Input `S`: 4 bits wide (`[3:0]`)\n-   Output `O`: 12 bits wide (`[11:0]`)\n\nThe module should implement the following behavior:\n-   The output `O` should be equal to the input `I` if the decimal value represented by the input `S` is between 0 and 11 (inclusive).\n-   If the decimal value of `S` is any other value (i.e., 12, 13, 14, or 15), the output `O` should be 0.\n-   The output should update combinatorially based on the inputs `S` and `I`.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule Span12Mux_v0(I, S, O);\n  input [11:0] I;\n  input [3:0] S;\n  output reg [11:0] O;\n\n  always @ (S or I) begin\n    case (S)\n      4'b0000: O <= I;\n      4'b0001: O <= I;\n      4'b0010: O <= I;\n      4'b0011: O <= I;\n      4'b0100: O <= I;\n      4'b0101: O <= I;\n      4'b0110: O <= I;\n      4'b0111: O <= I;\n      4'b1000: O <= I;\n      4'b1001: O <= I;\n      4'b1010: O <= I;\n      4'b1011: O <= I;\n      default: O <= 0;\n    endcase\n  end\nendmodule\nCODE END"}, "clean_code": "module Span12Mux_v0(I, S, O);\n  input [11:0] I;\n  input [3:0] S;\n  output reg [11:0] O;\n\n  always @ (S or I) begin\n    case (S)\n      4'b0000: O <= I;\n      4'b0001: O <= I;\n      4'b0010: O <= I;\n      4'b0011: O <= I;\n      4'b0100: O <= I;\n      4'b0101: O <= I;\n      4'b0110: O <= I;\n      4'b0111: O <= I;\n      4'b1000: O <= I;\n      4'b1001: O <= I;\n      4'b1010: O <= I;\n      4'b1011: O <= I;\n      default: O <= 0;\n    endcase\n  end\nendmodule", "corrupted_code": "module Span12Mux_v0(I, S, O);\n  input [11:0] I;\n  input [3:0] S;\n  output reg [11:0] O;\n\n  always @ (S or I) begin\n    case (S)\n      4'b0000: O <= I;\n      4'b0001: O <= I;\n      4'b0010: O <= I;\n      4'b0011: O <= I;\n      4'b0100: O <= I;\n      4'b0101: O <= I;\n      4'b0110: O <= I;\n      4'b0111: O <= I;\n      4'b1000: O <= I;\n      4'b1001: O <= I;\n      4'b1010: O <= I;\n      4'b1011: O <= I;\n      endcase\n  end\nendmodule", "corruption_explanation": "Removed default case (may cause incomplete case warning)", "modification_type": "remove_case_default", "modification_line": 7, "original_snippet": "case (S)\n      4'b0000: O <= I;\n      4'b0001: O <= I;\n      4'b0010: O <= I;\n      4'b0011: O <= I;\n      4'b0100: O <= I;\n      4'b0101: O <= I;\n      4'b0110: O <= I;\n      4'b0111: O <= I;\n      4", "modified_snippet": "case (S)\n      4'b0000: O <= I;\n      4'b0001: O <= I;\n      4'b0010: O <= I;\n      4'b0011: O <= I;\n      4'b0100: O <= I;\n      4'b0101: O <= I;\n      4'b0110: O <= I;\n      4'b0111: O <= I;\n      4", "issue_description": "The buggy code is missing the default case in a case statement. This creates an incomplete case statement that can infer latches in combinational blocks or cause undefined behavior for unhandled values. Linting tools will flag this as CASEINCOMPLETE or LATCH warning.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_case_default modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed default case (may cause incomplete case warning)\n   \u2022 Line 7: Original: case (S)\n      4'b0000: O <= I;\n      4'b0001: O <= I;\n      4'b0010: O <= I;\n      4'b0011: O <= I;\n      4'b0100: O <= I;\n      4'b0101: O <= I;\n      4'b0110: O <= I;\n      4'b0111: O <= I;\n      4\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 7.\n   \u2022 Restore the original code: case (S)\n      4'b0000: O <= I;\n      4'b0001: O <= I;\n      4'b0010: O <= I;\n      4'b0011: O <= I;\n      4'b0100: O <= I;\n      4'b0101: O <= I;\n      4'b0110: O <= I;\n      4'b0111: O <= I;\n      4\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove case default.", "complexity": 15, "applicable_modifications": ["remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "shuffle_case_items", "remove_always_block"], "timestamp": "2025-12-09T21:43:36.234841"}
{"original_entry": {"instruction": "\nWrite Verilog code for a module named `addsub_4bit`. The module has the following interface: inputs `input [3:0] O`, `input [3:0] A`, `input C`, and outputs `output reg [3:0] S`, `output reg [3:0] D`, `output reg B`.\n\nThe module should operate as follows:\n- When input `C` is high (1), it should perform a 4-bit addition of `O` and `A`. The 4-bit sum (ignoring any carry-out) should be assigned to output `S`. In this mode, outputs `D` and `B` should be cleared.\n- When input `C` is low (0), it should perform a 4-bit subtraction of `A` from `O` (`O - A`). The 4-bit difference should be assigned to output `D`. Output `B` should indicate if a borrow was required for this subtraction (i.e., `B` should be 1 if `O` is less than `A`, and 0 otherwise). In this mode, output `S` should be cleared.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule addsub_4bit (\n    input [3:0] O,\n    input [3:0] A,\n    input C,\n    output reg [3:0] S,\n    output reg [3:0] D,\n    output reg B\n);\n\nalways @(*) begin\n    if (C == 1'b1) begin\n        S = O + A;\n        D = 4'b0;\n        B = 1'b0;\n    end else begin\n        S = 4'b0;\n        if (O < A) begin\n            D = (O + 16) - A;\n            B = 1'b1;\n        end else begin\n            D = O - A;\n            B = 1'b0;\n        end\n    end\nend\n\nendmodule\nCODE END"}, "clean_code": "module addsub_4bit (\n    input [3:0] O,\n    input [3:0] A,\n    input C,\n    output reg [3:0] S,\n    output reg [3:0] D,\n    output reg B\n);\n\nalways @(*) begin\n    if (C == 1'b1) begin\n        S = O + A;\n        D = 4'b0;\n        B = 1'b0;\n    end else begin\n        S = 4'b0;\n        if (O < A) begin\n            D = (O + 16) - A;\n            B = 1'b1;\n        end else begin\n            D = O - A;\n            B = 1'b0;\n        end\n    end\nend\n\nendmodule", "corrupted_code": "module addsub_4bit (\n    input [3:0] O,\n    input [4:0] A,\n    input C,\n    output reg [3:0] S,\n    output reg [3:0] D,\n    output reg B\n);\n\nalways @(*) begin\n    if (C == 1'b1) begin\n        S = O + A;\n        D = 4'b0;\n        B = 1'b0;\n    end else begin\n        S = 4'b0;\n        if (O < A) begin\n            D = (O + 16) - A;\n            B = 1'b1;\n        end else begin\n            D = O - A;\n            B = 1'b0;\n        end\n    end\nend\n\nendmodule", "corruption_explanation": "Changed bit width from [3:0] to [4:0]", "modification_type": "change_bit_width", "modification_line": 3, "original_snippet": "[3:0]", "modified_snippet": "[4:0]", "issue_description": "The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_bit_width modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed bit width from [3:0] to [4:0]\n   \u2022 Line 3: Original: [3:0]\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 3.\n   \u2022 Restore the original code: [3:0]\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change bit width.", "complexity": 8, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "invert_condition", "remove_always_block"], "timestamp": "2025-12-09T21:43:36.235660"}
{"original_entry": {"instruction": "\nDesign a Verilog module named `starter_dut`.\nThis module should implement a simple synchronous register with an asynchronous reset.\nThe module should have the following interface:\nInputs:\n- `clk`: The clock signal.\n- `rst`: An active-high asynchronous reset signal.\n- `data_in` [7:0]: An 8-bit input data bus.\n- `valid_in`: A single-bit input validity flag.\nOutputs:\n- `data_out` [7:0]: An 8-bit output data bus representing the registered `data_in`.\n- `valid_out`: A single-bit output validity flag representing the registered `valid_in`.\n\nOn the positive edge of the clock, the outputs `data_out` and `valid_out` should be updated with the current values of the inputs `data_in` and `valid_in`, respectively.\nWhen the `rst` signal is asserted (high), both `data_out` and `valid_out` should be immediately reset to 0, regardless of the clock state.\nWrite the Verilog code for this module.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule starter_dut (\n   data_out, valid_out,\n   clk, rst, data_in, valid_in\n   ) ;\n   input clk;\n   input rst;\n   input [7:0] data_in;\n   input valid_in;\n   output [7:0] data_out;\n   output valid_out;\n\n   reg [7:0]\t\tdata_out;\n   reg\t\t\tvalid_out;\n\n   always @(posedge clk or posedge rst) begin\n      if (rst) begin\n\t data_out <= 'h0;\n\t valid_out <= 'h0;\n      end\n      else begin\n\t data_out <= data_in;\n\t valid_out <= valid_in;\n      end\n   end\nendmodule \nCODE END"}, "clean_code": "module starter_dut (\n   data_out, valid_out,\n   clk, rst, data_in, valid_in\n   ) ;\n   input clk;\n   input rst;\n   input [7:0] data_in;\n   input valid_in;\n   output [7:0] data_out;\n   output valid_out;\n\n   reg [7:0]\t\tdata_out;\n   reg\t\t\tvalid_out;\n\n   always @(posedge clk or posedge rst) begin\n      if (rst) begin\n\t data_out <= 'h0;\n\t valid_out <= 'h0;\n      end\n      else begin\n\t data_out <= data_in;\n\t valid_out <= valid_in;\n      end\n   end\nendmodule", "corrupted_code": "module starter_dut (\n   data_out, valid_out,\n   clk, rst, data_in, valid_in\n   ) ;\n   input clk;\n   input rst;\n   input [7:0] data_in;\n   input valid_in;\n   output [7:0] data_out;\n   output valid_out;\n\n   reg [7:0]\t\tdata_out;\n   reg\t\t\tvalid_out;\n\n   \n      else begin\n\t data_out <= data_in;\n\t valid_out <= valid_in;\n      end\n   end\nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 15, "original_snippet": "always @(posedge clk or posedge rst) begin\n      if (rst) begin\n\t data_out <= 'h0;\n\t valid_out <= 'h0;\n      end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 15: Original: always @(posedge clk or posedge rst) begin\n      if (rst) begin\n\t data_out <= 'h0;\n\t valid_out <= 'h0;\n      end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 15.\n   \u2022 Restore the original code: always @(posedge clk or posedge rst) begin\n      if (rst) begin\n\t data_out <= 'h0;\n\t valid_out <= 'h0;\n      end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 4, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.236453"}
{"original_entry": {"instruction": "\nDesign a Verilog module named `clock_control`.\nThe module should have the following interface:\n-   Input: `inclk` (clock signal)\n-   Input: `ena` (enable signal)\n-   Output: `outclk` (controlled output signal)\n\nThe module should operate synchronously to the positive edge of `inclk`.\nImplement the following behavior:\n-   When the `ena` input is high, the `outclk` output should follow the level of the `inclk` signal, but with a delay such that `outclk` transitions high one `inclk` clock cycle after `inclk` rises, and `outclk` transitions low one `inclk` clock cycle after `inclk` falls.\n-   When the `ena` input is low, the `outclk` output should be held at a logic low level, regardless of the state of `inclk`.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule clock_control(\n    input inclk,\n    input ena,\n    output outclk\n);\n\nreg [1:0] state;\nreg filtered_clk;\n\nalways @(posedge inclk) begin\n    if (ena) begin\n        state <= {state[0], inclk};\n        if (state == 2'b01) begin\n            filtered_clk <= 1'b1;\n        end else if (state == 2'b10) begin\n            filtered_clk <= 1'b0;\n        end\n    end else begin\n        filtered_clk <= 1'b0;\n    end\nend\n\nassign outclk = filtered_clk;\n\nendmodule\nCODE END"}, "clean_code": "module clock_control(\n    input inclk,\n    input ena,\n    output outclk\n);\n\nreg [1:0] state;\nreg filtered_clk;\n\nalways @(posedge inclk) begin\n    if (ena) begin\n        state <= {state[0], inclk};\n        if (state == 2'b01) begin\n            filtered_clk <= 1'b1;\n        end else if (state == 2'b10) begin\n            filtered_clk <= 1'b0;\n        end\n    end else begin\n        filtered_clk <= 1'b0;\n    end\nend\n\nassign outclk = filtered_clk;\n\nendmodule", "corrupted_code": "module clock_control(\n    input inclk,\n    input ena,\n    output outclk\n);\n\nreg [1:0] state;\nreg filtered_clk;\n\nalways @(posedge inclk) begin\n    if (ena) begin\n        state <= {state[0], inclk};\n        if (state == 2'b01) begin\n            filtered_clk <= 1'b1;\n        end else if (state == 2'b10) begin\n            filtered_clk <= 1'b0;\n        end\n    end else begin\n        filtered_clk <= 1'b0;\n    end\nend\n\nassign outclk <= filtered_clk;\n\nendmodule", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 23, "original_snippet": "utclk = filtered_clk;", "modified_snippet": "utclk <= filtered_clk;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 9, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.237490"}
{"original_entry": {"instruction": "\nWrite Verilog code for a module named `pipeline_module` with inputs `input wire [2:0] vec` and `input wire clk`, and outputs `output wire [2:0] outv`, `output wire o2`, `output wire o1`, and `output wire o0`.\n\nThis module should implement a 3-stage pipeline for the 3-bit input vector `vec`, synchronized by the `clk` signal.\n\nThe output `outv` should be the 3-bit vector value after passing through all three pipeline stages.\n\nThe single-bit outputs should tap specific bits from the pipeline stages:\n*   `o0` should be the least significant bit (`[0]`) of the vector in the *first* pipeline stage.\n*   `o1` should be the middle bit (`[1]`) of the vector in the *second* pipeline stage.\n*   `o2` should be the most significant bit (`[2]`) of the vector in the *third* (final) pipeline stage.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule pipeline_module (\n    input wire [2:0] vec,\n    input wire clk,\n    output wire [2:0] outv,\n    output wire o2,\n    output wire o1,\n    output wire o0\n);\n\nreg [2:0] reg1;\nreg [2:0] reg2;\nreg [2:0] reg3;\n\nassign outv = reg3;\nassign o2 = reg3[2];\nassign o1 = reg2[1];\nassign o0 = reg1[0];\n\nalways @(posedge clk) begin\n    reg1 <= vec;\nend\n\nalways @(posedge clk) begin\n    reg2 <= reg1;\nend\n\nalways @(posedge clk) begin\n    reg3 <= reg2;\nend\n\nendmodule\nCODE END"}, "clean_code": "module pipeline_module (\n    input wire [2:0] vec,\n    input wire clk,\n    output wire [2:0] outv,\n    output wire o2,\n    output wire o1,\n    output wire o0\n);\n\nreg [2:0] reg1;\nreg [2:0] reg2;\nreg [2:0] reg3;\n\nassign outv = reg3;\nassign o2 = reg3[2];\nassign o1 = reg2[1];\nassign o0 = reg1[0];\n\nalways @(posedge clk) begin\n    reg1 <= vec;\nend\n\nalways @(posedge clk) begin\n    reg2 <= reg1;\nend\n\nalways @(posedge clk) begin\n    reg3 <= reg2;\nend\n\nendmodule", "corrupted_code": "module pipeline_module (\n    input wire [2:0] vec,\n    input wire clk,\n    output wire [2:1] outv,\n    output wire o2,\n    output wire o1,\n    output wire o0\n);\n\nreg [2:0] reg1;\nreg [2:0] reg2;\nreg [2:0] reg3;\n\nassign outv = reg3;\nassign o2 = reg3[2];\nassign o1 = reg2[1];\nassign o0 = reg1[0];\n\nalways @(posedge clk) begin\n    reg1 <= vec;\nend\n\nalways @(posedge clk) begin\n    reg2 <= reg1;\nend\n\nalways @(posedge clk) begin\n    reg3 <= reg2;\nend\n\nendmodule", "corruption_explanation": "Changed bit width from [2:0] to [2:1]", "modification_type": "change_bit_width", "modification_line": 4, "original_snippet": "[2:0]", "modified_snippet": "[2:1]", "issue_description": "The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_bit_width modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed bit width from [2:0] to [2:1]\n   \u2022 Line 4: Original: [2:0]\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 4.\n   \u2022 Restore the original code: [2:0]\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change bit width.", "complexity": 6, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.239157"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `fifo_w16_d2_A_shiftReg`.\nThe module has the following interface:\nInputs:\n- `clk`: Clock signal.\n- `data`: A 16-bit input data bus.\n- `ce`: A clock enable signal.\n- `a`: A 2-bit address input.\nOutput:\n- `q`: A 16-bit output data bus.\n\nImplement a clocked structure where, on the positive edge of `clk`, if `ce` is high, the current value of `data` is captured and stored. This storage process should effectively push older stored values further back in time. The output `q` should provide access to one of the stored values based on the address `a`. Specifically, `a=0` should select the most recently stored value, `a=1` should select the second most recent, and `a=2` should select the third most recent value that was stored when `ce` was high.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule fifo_w16_d2_A_shiftReg (\n    input clk,\n    input [15:0] data,\n    input ce,\n    input [1:0] a,\n    output reg [15:0] q\n);\n\nparameter DATA_WIDTH = 16;\nparameter ADDR_WIDTH = 2;\nparameter DEPTH = 3;\n\nreg [15:0] SRL_SIG [0:2];\ninteger i;\n\nalways @ (posedge clk)\nbegin\n    if (ce)\n    begin\n        for (i=0; i<2; i=i+1)\n            SRL_SIG[i+1] <= SRL_SIG[i];\n        SRL_SIG[0] <= data;\n    end\nend\n\nalways @*\nbegin\n    q = SRL_SIG[a];\nend\n\nendmodule\nCODE END"}, "clean_code": "module fifo_w16_d2_A_shiftReg (\n    input clk,\n    input [15:0] data,\n    input ce,\n    input [1:0] a,\n    output reg [15:0] q\n);\n\nparameter DATA_WIDTH = 16;\nparameter ADDR_WIDTH = 2;\nparameter DEPTH = 3;\n\nreg [15:0] SRL_SIG [0:2];\ninteger i;\n\nalways @ (posedge clk)\nbegin\n    if (ce)\n    begin\n        for (i=0; i<2; i=i+1)\n            SRL_SIG[i+1] <= SRL_SIG[i];\n        SRL_SIG[0] <= data;\n    end\nend\n\nalways @*\nbegin\n    q = SRL_SIG[a];\nend\n\nendmodule", "corrupted_code": "module fifo_w16_d2_A_shiftReg (\n    input clk,\n    input [15:0] data,\n    input ce,\n    input [1:0] a,\n    output reg [15:0] q\n);\n\nparameter DATA_WIDTH = 16;\nparameter ADDR_WIDTH = 2;\nparameter DEPTH = 3;\n\nreg [15:0] SRL_SIG [0:2];\ninteger i;\n\nalways @ (posedge clk)\nbegin\n    if (ce)\n    begin\n        for (i <= 0; i<2; i=i+1)\n            SRL_SIG[i+1] <= SRL_SIG[i];\n        SRL_SIG[0] <= data;\n    end\nend\n\nalways @*\nbegin\n    q = SRL_SIG[a];\nend\n\nendmodule", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 20, "original_snippet": "i=0;", "modified_snippet": "i <= 0;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 6, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.241026"}
{"original_entry": {"instruction": "\nWrite Verilog code for a module named `flip_flop`. This module should implement a sequential logic element with the following behavior and interface:\n\nInputs:\n- `CLK`: Clock signal\n- `D`: Data input\n- `SCD`: Synchronous control input\n- `SCE`: Synchronous control input\n- `RESET_B`: Asynchronous active-low reset\n\nOutput:\n- `Q`: Data output\n\nThe module should operate as follows:\n1.  If `RESET_B` is low, the output `Q` is asynchronously reset to 0, regardless of other inputs.\n2.  When `RESET_B` is high, the output `Q` updates on the positive edge of `CLK`.\n3.  On the positive edge of `CLK` (when not in reset), the module exhibits the following prioritized synchronous behavior:\n    *   If `SCD` is high, `Q` is set to 1.\n    *   Else if `SCE` is high, `Q` is set to 0.\n    *   Otherwise, `Q` takes the value of the `D` input.\n\nEnsure the module definition and signal names exactly match those specified.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule flip_flop (\n    Q,\n    CLK,\n    D,\n    SCD,\n    SCE,\n    RESET_B\n);\n\n    output Q;\n    input CLK;\n    input D;\n    input SCD;\n    input SCE;\n    input RESET_B;\n\n    reg Q;\n\n    always @(posedge CLK or negedge RESET_B) begin\n        if (!RESET_B) begin\n            Q <= 0;\n        end else if (SCD) begin\n            Q <= 1;\n        end else if (SCE) begin\n            Q <= 0;\n        end else begin\n            Q <= D;\n        end\n    end\n\nendmodule\nCODE END"}, "clean_code": "module flip_flop (\n    Q,\n    CLK,\n    D,\n    SCD,\n    SCE,\n    RESET_B\n);\n\n    output Q;\n    input CLK;\n    input D;\n    input SCD;\n    input SCE;\n    input RESET_B;\n\n    reg Q;\n\n    always @(posedge CLK or negedge RESET_B) begin\n        if (!RESET_B) begin\n            Q <= 0;\n        end else if (SCD) begin\n            Q <= 1;\n        end else if (SCE) begin\n            Q <= 0;\n        end else begin\n            Q <= D;\n        end\n    end\n\nendmodule", "corrupted_code": "module flip_flop (\n    Q,\n    CLK,\n    D,\n    SCD,\n    SCE,\n    RESET_B\n);\n\n    output Q;\n    input CLK;\n    input D;\n    input SCD;\n    input SCE;\n    input RESET_B;\n\n    reg Q;\n\n    always @(posedge CLK or negedge RESET_B) begin\n        if (!RESET_B) begin\n            Q <= 0;\n        end else if (SCD) begin\n            Q <= 1;\n        end else if (SCE) begin\n            Q <= 0;\n        end else begin\n            Q <= D;\n        end\n    end\n\n\n    wire clk_dup;\n    assign clk_dup = CLK;\nendmodule", "corruption_explanation": "Added duplicate clock signal clk_dup", "modification_type": "duplicate_clock_signal", "modification_line": 9, "original_snippet": "(none)", "modified_snippet": "wire clk_dup;\n    assign clk_dup = CLK;", "issue_description": "The buggy code has a duplicate clock signal. A phantom clock domain is created, which may confuse CDC analysis tools and create subtle timing issues in synthesis. This violates clock domain design best practices.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a duplicate_clock_signal modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added duplicate clock signal clk_dup\n   \u2022 Line 9: Original: (none)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 9.\n   \u2022 Restore the original code: (none)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to duplicate clock signal.", "complexity": 8, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.242067"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `ad_iobuf` that implements a parameterized I/O buffer-like structure.\nThe module should have a parameter `DATA_WIDTH` specifying the bit width of the data paths.\nThe interface includes:\n- Inputs: `dio_t`, `dio_i` (both `DATA_WIDTH` bits wide)\n- Outputs: `dio_o`, `dio_p` (both `DATA_WIDTH` bits wide)\n\nFor each bit position `n` from 0 to `DATA_WIDTH-1`:\n- If the corresponding bit of the control input `dio_t` (`dio_t[n]`) is high (logic 1), the corresponding bit of the output `dio_p` (`dio_p[n]`) should be assigned the value of the corresponding bit of the data input `dio_i` (`dio_i[n]`).\n- If the corresponding bit of `dio_t` (`dio_t[n]`) is low (logic 0), the corresponding bit of `dio_p` (`dio_p[n]`) should be assigned a logic '1'.\n- The corresponding bit of the output `dio_o` (`dio_o[n]`) should always reflect the value assigned to `dio_p[n]`.\n\nImplement this functionality such that it scales correctly with the `DATA_WIDTH` parameter.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule ad_iobuf (\n  dio_t,\n  dio_i,\n  dio_o,\n  dio_p\n);\n\n  parameter DATA_WIDTH = 1;\n\n  input [(DATA_WIDTH-1):0] dio_t;\n  input [(DATA_WIDTH-1):0] dio_i;\n  output [(DATA_WIDTH-1):0] dio_o;\n  output [(DATA_WIDTH-1):0] dio_p;\n\n  genvar n;\n  generate\n    for (n = 0; n < DATA_WIDTH; n = n + 1) begin : g_iobuf\n      wire const1 = 1'b1;  \n      assign dio_o[n] = dio_p[n];\n      assign dio_p[n] = dio_t[n] ? dio_i[n] : const1;\n    end\n  endgenerate\n\nendmodule\nCODE END"}, "clean_code": "module ad_iobuf (\n  dio_t,\n  dio_i,\n  dio_o,\n  dio_p\n);\n\n  parameter DATA_WIDTH = 1;\n\n  input [(DATA_WIDTH-1):0] dio_t;\n  input [(DATA_WIDTH-1):0] dio_i;\n  output [(DATA_WIDTH-1):0] dio_o;\n  output [(DATA_WIDTH-1):0] dio_p;\n\n  genvar n;\n  generate\n    for (n = 0; n < DATA_WIDTH; n = n + 1) begin : g_iobuf\n      wire const1 = 1'b1;  \n      assign dio_o[n] = dio_p[n];\n      assign dio_p[n] = dio_t[n] ? dio_i[n] : const1;\n    end\n  endgenerate\n\nendmodule", "corrupted_code": "module ad_iobuf (\n  dio_t,\n  dio_i,\n  dio_o,\n  dio_p\n);\n\n  parameter DATA_WIDTH = 1;\n\n  input [(DATA_WIDTH-1):0] dio_t;\n  input [(DATA_WIDTH-1):0] dio_i;\n  output [(DATA_WIDTH-1):0] dio_o;\n  output [(DATA_WIDTH-1):0] dio_p;\n\n  genvar n;\n  generate\n    for (n = 0; n < DATA_WIDTH; n = n + 1) begin : g_iobuf\n      wire const1 <= 1'b1;  \n      assign dio_o[n] = dio_p[n];\n      assign dio_p[n] = dio_t[n] ? dio_i[n] : const1;\n    end\n  endgenerate\n\nendmodule", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 18, "original_snippet": "const1 = 1'b1;", "modified_snippet": "const1 <= 1'b1;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 7, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_loop", "swap_blocking_nonblocking", "add_multiple_driver"], "timestamp": "2025-12-09T21:43:36.243081"}
{"original_entry": {"instruction": "\nDesign a Verilog module named `add_sub_4bit` with the following interface:\nInputs: `clk`, `resetn`, `A` (4-bit), `B` (4-bit), `ctrl`.\nOutputs: `S` (4-bit, registered), `D` (4-bit, registered).\n\nThe module should implement a synchronous design sensitive to the positive edge of `clk`. It must include an asynchronous, active-low reset (`resetn`). When `resetn` is asserted low, both registered outputs `S` and `D` should be cleared to zero.\n\nWhen `resetn` is deasserted high, the module's behavior is controlled by the `ctrl` input:\n- If `ctrl` is 0, the module should perform a 4-bit addition of `A` and `B`, assigning the result to the registered output `S`. The registered output `D` should be set to zero in this mode.\n- If `ctrl` is 1, the module should perform a 4-bit subtraction of `B` from `A` (`A - B`), assigning the result to the registered output `D`. The registered output `S` should be set to zero in this mode.\n\nImplement this functionality in Verilog, ensuring `S` and `D` are registered outputs.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule add_sub_4bit (\n  input clk,\n  input resetn,\n  input [3:0] A,\n  input [3:0] B,\n  input ctrl,\n  output reg [3:0] S,\n  output reg [3:0] D\n);\n\n  always @(posedge clk or negedge resetn) begin\n    if (!resetn) begin\n      S <= 4'b0000;\n      D <= 4'b0000;\n    end\n    else begin\n      if (ctrl == 1'b0) begin\n        S <= A + B;\n        D <= 4'b0000;\n      end\n      else begin\n        S <= 4'b0000;\n        D <= A - B;\n      end\n    end\n  end\n\nendmodule\n\nCODE END"}, "clean_code": "module add_sub_4bit (\n  input clk,\n  input resetn,\n  input [3:0] A,\n  input [3:0] B,\n  input ctrl,\n  output reg [3:0] S,\n  output reg [3:0] D\n);\n\n  always @(posedge clk or negedge resetn) begin\n    if (!resetn) begin\n      S <= 4'b0000;\n      D <= 4'b0000;\n    end\n    else begin\n      if (ctrl == 1'b0) begin\n        S <= A + B;\n        D <= 4'b0000;\n      end\n      else begin\n        S <= 4'b0000;\n        D <= A - B;\n      end\n    end\n  end\n\nendmodule", "corrupted_code": "module add_sub_4bit (\n  input clk,\n  input resetn,\n  input [3:0] A,\n  input [3:0] B,\n  input ctrl,\n  output reg [3:0] S,\n  output reg [3:0] D\n);\n\n  always @(posedge clk or negedge resetn) begin\n    if (!resetn) begin\n      S <= 4'b0000;\n      D <= 4'b0000;\n    end\n    else begin\n      if (ctrl == 1'b0) begin\n        S = A + B;\n        D <= 4'b0000;\n      end\n      else begin\n        S <= 4'b0000;\n        D <= A - B;\n      end\n    end\n  end\n\nendmodule", "corruption_explanation": "Changed non-blocking (<=) to blocking (=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 18, "original_snippet": "S <= A + B;", "modified_snippet": "S = A + B;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 12, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.244056"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `dut` with the following interface:\nInputs:\n- `a`\n- `b`\n- `c`\n\nOutputs:\n- `true_val`\n- `false_val`\n- `and1`\n- `and2`\n- `and3`\n- `or1`\n- `or2`\n- `or3`\n- `not1`\n- `not2`\n\nThe module should implement the following logic:\n- `true_val` should always output a logic '1'.\n- `false_val` should always output a logic '0'.\n- `and1` should output the result of performing a logical AND operation on inputs `a`, `b`, and `c`.\n- `and2` should output the result of performing a logical AND operation on inputs `a` and `b`.\n- `and3` should output the result of performing a logical AND operation on inputs `a` and `c`.\n- `or1` should output the result of performing a logical OR operation on inputs `a`, `b`, and `c`.\n- `or2` should output the result of performing a logical OR operation on inputs `a` and `b`.\n- `or3` should output the result of performing a logical OR operation on inputs `a` and `c`.\n- `not1` should output the logical inverse of input `a`.\n- `not2` should output the logical inverse of input `b`.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule dut(\n    input a,\n    input b,\n    input c,\n    output true_val,\n    output false_val,\n    output and1,\n    output and2,\n    output and3,\n    output or1,\n    output or2,\n    output or3,\n    output not1,\n    output not2\n);\n\nassign true_val = 1'b1;\nassign false_val = 1'b0;\nassign and1 = a & b & c;\nassign and2 = a & b;\nassign and3 = a & c;\nassign or1 = a | b | c;\nassign or2 = a | b;\nassign or3 = a | c;\nassign not1 = !a;\nassign not2 = !b;\n\nendmodule\nCODE END"}, "clean_code": "module dut(\n    input a,\n    input b,\n    input c,\n    output true_val,\n    output false_val,\n    output and1,\n    output and2,\n    output and3,\n    output or1,\n    output or2,\n    output or3,\n    output not1,\n    output not2\n);\n\nassign true_val = 1'b1;\nassign false_val = 1'b0;\nassign and1 = a & b & c;\nassign and2 = a & b;\nassign and3 = a & c;\nassign or1 = a | b | c;\nassign or2 = a | b;\nassign or3 = a | c;\nassign not1 = !a;\nassign not2 = !b;\n\nendmodule", "corrupted_code": "module dut(\n    input a,\n    input b,\n    input c,\n    output true_val,\n    output false_val,\n    output and1,\n    output and2,\n    output and3,\n    output or1,\n    output or2,\n    output or3,\n    output not1,\n    output not2\n);\n\nassign true_val = 1'b1;\nassign false_val = 1'b0;\nassign and1 = a & b & c;\nassign and2 = a & b;\nassign and3 = a & c;\nassign or1 = a | b | c;\nassign or2 = a & b;\nassign or3 = a | c;\nassign not1 = !a;\nassign not2 = !b;\n\nendmodule", "corruption_explanation": "Changed operator from '|' to '&'", "modification_type": "change_operator", "modification_line": 23, "original_snippet": "|", "modified_snippet": "&", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '|' to '&'\n   \u2022 Line 23: Original: |\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 23.\n   \u2022 Restore the original code: |\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 6, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver"], "timestamp": "2025-12-09T21:43:36.244959"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `checksum`.\nThis module takes a collection of `n` individual data signals as input, defined by `input [n-1:0] data_in`, where `n` is a parameter with a default value of 4 (`parameter n = 4;`).\n\nThe module should calculate a checksum based on the input data. The checksum is determined by summing the numerical values of each individual signal within `data_in` and taking the lower 8 bits of this total sum. This 8-bit checksum should be output on `output reg [7:0] checksum_out`.\n\nAdditionally, the module should provide a validity signal, `output reg valid_out`. This signal should be high (`1`) if and only if the sum of the *full* calculated sum (before taking the lower 8 bits for the checksum) and the final 8-bit `checksum_out` equals the value 255 (8'hFF). Otherwise, `valid_out` should be low (`0`).\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule checksum (\n  input [n-1:0] data_in,\n  output reg [7:0] checksum_out,\n  output reg valid_out\n);\n\nparameter n = 4; // number of data signals\n\ninteger i;\nreg [7:0] sum;\nreg [7:0] check;\n\nalways @(*) begin\n  sum = 0;\n  for (i = 0; i < n; i = i + 1) begin\n    sum = sum + data_in[i];\n  end\n  checksum_out = sum % 256;\n  \n  check = sum + checksum_out;\n  if (check == 8'hFF) begin\n    valid_out = 1;\n  end else begin\n    valid_out = 0;\n  end\nend\n\nendmodule\nCODE END"}, "clean_code": "module checksum (\n  input [n-1:0] data_in,\n  output reg [7:0] checksum_out,\n  output reg valid_out\n);\n\nparameter n = 4; // number of data signals\n\ninteger i;\nreg [7:0] sum;\nreg [7:0] check;\n\nalways @(*) begin\n  sum = 0;\n  for (i = 0; i < n; i = i + 1) begin\n    sum = sum + data_in[i];\n  end\n  checksum_out = sum % 256;\n  \n  check = sum + checksum_out;\n  if (check == 8'hFF) begin\n    valid_out = 1;\n  end else begin\n    valid_out = 0;\n  end\nend\n\nendmodule", "corrupted_code": "module checksum (\n  input [n-1:0] data_in,\n  output reg [7:0] checksum_out,\n  output reg valid_out\n);\n\nparameter n = 4; // number of data signals\n\ninteger i;\nreg [7:0] sum;\nreg [7:0] check;\n\n\n  checksum_out = sum % 256;\n  \n  check = sum + checksum_out;\n  if (check == 8'hFF) begin\n    valid_out = 1;\n  end else begin\n    valid_out = 0;\n  end\nend\n\nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 13, "original_snippet": "always @(*) begin\n  sum = 0;\n  for (i = 0; i < n; i = i + 1) begin\n    sum = sum + data_in[i];\n  end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 13: Original: always @(*) begin\n  sum = 0;\n  for (i = 0; i < n; i = i + 1) begin\n    sum = sum + data_in[i];\n  end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 13.\n   \u2022 Restore the original code: always @(*) begin\n  sum = 0;\n  for (i = 0; i < n; i = i + 1) begin\n    sum = sum + data_in[i];\n  end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 10, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "invert_condition", "remove_always_block"], "timestamp": "2025-12-09T21:43:36.245864"}
{"original_entry": {"instruction": "\nWrite the Verilog code for an 8-bit binary counter. The counter should increment synchronously on the positive edge of the clock signal. It should also have an asynchronous, active-low reset that sets the count to zero. The module should be named `binary_counter` and have inputs `clk` and `reset`, and an 8-bit output register named `count`.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule binary_counter(clk, reset, count);\n\n  input clk, reset;\n  output reg [7:0] count;\n\n  always @(posedge clk or negedge reset) begin\n    if (reset == 0) begin\n      count <= 0;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule\nCODE END"}, "clean_code": "module binary_counter(clk, reset, count);\n\n  input clk, reset;\n  output reg [7:0] count;\n\n  always @(posedge clk or negedge reset) begin\n    if (reset == 0) begin\n      count <= 0;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule", "corrupted_code": "module binary_counter(clk, reset, count);\n\n  input clk, reset;\n  output reg [7:0] count;\n\n  always @(posedge clk or negedge reset) begin\n    \n  end\n\nendmodule", "corruption_explanation": "Removed a conditional block", "modification_type": "remove_conditional", "modification_line": 7, "original_snippet": "if (reset == 0) begin\n      count <= 0;\n    end else begin\n      count <= count + 1;\n    end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing a conditional block. This removes important control logic, causing the design to skip necessary state transitions or data processing. Test cases that depend on the conditional behavior will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_conditional modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed a conditional block\n   \u2022 Line 7: Original: if (reset == 0) begin\n      count <= 0;\n    end else begin\n      count <= count + 1;\n    end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 7.\n   \u2022 Restore the original code: if (reset == 0) begin\n      count <= 0;\n    end else begin\n      count <= count + 1;\n    end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove conditional.", "complexity": 6, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.246369"}
{"original_entry": {"instruction": "\nDesign a Verilog module named `DFFSR` with inputs `C`, `S`, `R`, `D` and output `Q`. This module should implement a synchronous D-flip flop. The flip-flop's state should update on the positive edge of the clock input `C`. It should include synchronous set (`S`) and reset (`R`) inputs. The reset input (`R`) should have priority over the set input (`S`). When neither the set nor reset inputs are active, the flip-flop should store the value of the data input `D`.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule DFFSR (output Q, input C, S, R, D);\n\n    reg Q;\n\n    always @(posedge C) begin\n        if (R) begin\n            Q <= 0;\n        end else if (S) begin\n            Q <= 1;\n        end else begin\n            Q <= D;\n        end\n    end\n\nendmodule\nCODE END"}, "clean_code": "module DFFSR (output Q, input C, S, R, D);\n\n    reg Q;\n\n    always @(posedge C) begin\n        if (R) begin\n            Q <= 0;\n        end else if (S) begin\n            Q <= 1;\n        end else begin\n            Q <= D;\n        end\n    end\n\nendmodule", "corrupted_code": "module DFFSR (output Q, input C, S, R, D);\n\n    reg Q;\n\n     else if (S) begin\n            Q <= 1;\n        end else begin\n            Q <= D;\n        end\n    end\n\nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 5, "original_snippet": "always @(posedge C) begin\n        if (R) begin\n            Q <= 0;\n        end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 5: Original: always @(posedge C) begin\n        if (R) begin\n            Q <= 0;\n        end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 5.\n   \u2022 Restore the original code: always @(posedge C) begin\n        if (R) begin\n            Q <= 0;\n        end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 6, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.246880"}
{"original_entry": {"instruction": "\nWrite the Verilog code for a module named `binary_to_gray`.\nThis module should implement a 4-bit combinatorial circuit that converts a binary input to a corresponding Gray code output.\nThe conversion logic is as follows:\n- The least significant bit (`gray[0]`) is the same as the least significant bit of the input (`binary[0]`).\n- For the higher bits (`gray[i]` where i > 0), the value is derived from a bitwise operation between `binary[i]` and `binary[i-1]`.\nThe module must have the following interface:\n- Input `clk` (single bit)\n- Input `binary` (4 bits, `[3:0]`)\n- Output `gray` (4 bits, `[3:0]`)\nEnsure the implementation is purely combinatorial, meaning the output depends only on the current input values and does not involve any state elements like flip-flops.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule binary_to_gray (\n  input clk,\n  input [3:0] binary,\n  output [3:0] gray\n);\n\n  assign gray[0] = binary[0];\n  assign gray[1] = binary[0] ^ binary[1];\n  assign gray[2] = binary[1] ^ binary[2];\n  assign gray[3] = binary[2] ^ binary[3];\n\nendmodule\n\nCODE END"}, "clean_code": "module binary_to_gray (\n  input clk,\n  input [3:0] binary,\n  output [3:0] gray\n);\n\n  assign gray[0] = binary[0];\n  assign gray[1] = binary[0] ^ binary[1];\n  assign gray[2] = binary[1] ^ binary[2];\n  assign gray[3] = binary[2] ^ binary[3];\n\nendmodule", "corrupted_code": "module binary_to_gray (\n  input clk,\n  input [3:0] binary,\n  output [3:0] gray\n);\n\n  assign gray[0] = binary[0];\n  assign gray[1] = binary[0] ^ binary[1];\n  assign gray[2] = binary[1] ^ binary[2];\nassign gray = 1'b0;  // Conflicting assignment\n  assign gray[3] = binary[2] ^ binary[3];\n\nendmodule", "corruption_explanation": "Added conflicting driver for signal 'gray'", "modification_type": "add_multiple_driver", "modification_line": 9, "original_snippet": "assign gray[2] = binary[1] ^ binary[2];", "modified_snippet": "assign gray[2] = binary[1] ^ binary[2];\nassign gray = 1'b0;  // Conflicting assignment", "issue_description": "The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_multiple_driver modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added conflicting driver for signal 'gray'\n   \u2022 Line 9: Original: assign gray[2] = binary[1] ^ binary[2];\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 9.\n   \u2022 Restore the original code: assign gray[2] = binary[1] ^ binary[2];\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add multiple driver.", "complexity": 0, "applicable_modifications": ["change_constant", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver"], "timestamp": "2025-12-09T21:43:36.247451"}
{"original_entry": {"instruction": "\nDesign a Verilog module named `counter`. This module should have the following interface:\nInputs: `clk`, `rst`\nOutput: an 8-bit output register named `count`\n\nImplement the following behavior:\nThe `count` register should be incremented by one on the positive edge of the `clk` signal.\nThe `count` register should be reset to zero asynchronously whenever the `rst` signal is high.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule counter (\n    clk,\n    rst,\n    count\n);\n\ninput clk;\ninput rst;\noutput reg [7:0] count;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        count <= 8'b0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nendmodule\nCODE END"}, "clean_code": "module counter (\n    clk,\n    rst,\n    count\n);\n\ninput clk;\ninput rst;\noutput reg [7:0] count;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        count <= 8'b0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nendmodule", "corrupted_code": "module counter (\n    clk,\n    rst,\n    count\n);\n\ninput clk;\ninput rst;\noutput reg [7:0] count;\n\nalways @(posedge clk or posedge rst) begin\n    if (!rst) begin\n        count <= 8'b0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nendmodule", "corruption_explanation": "Inverted reset polarity in condition", "modification_type": "invert_reset_polarity", "modification_line": 9, "original_snippet": "if (rst)", "modified_snippet": "if (!rst)", "issue_description": "The buggy code has inverted reset polarity. If the design expects active-low reset (!rst), it now uses active-high, or vice versa. This causes the reset logic to activate during normal operation and deactivate during actual reset, breaking initialization.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_reset_polarity modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted reset polarity in condition\n   \u2022 Line 9: Original: if (rst)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 9.\n   \u2022 Restore the original code: if (rst)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert reset polarity.", "complexity": 5, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.248774"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `bitwise_operator`. This module should have two single-bit inputs, `in1` and `in2`, and four single-bit outputs: `out_AND`, `out_OR`, `out_XOR`, and `out_NOT`. The module should implement the following logic:\n- `out_AND` should be the result of the bitwise AND operation between `in1` and `in2`.\n- `out_OR` should be the result of the bitwise OR operation between `in1` and `in2`.\n- `out_XOR` should be the result of the bitwise XOR operation between `in1` and `in2`.\n- `out_NOT` should be the result of the bitwise NOT operation applied to `in1`.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule bitwise_operator (\n  input in1,\n  input in2,\n  output out_AND,\n  output out_OR,\n  output out_XOR,\n  output out_NOT\n);\n\n  assign out_AND = in1 & in2;\n  assign out_OR = in1 | in2;\n  assign out_XOR = in1 ^ in2;\n  assign out_NOT = ~in1;\n\nendmodule\nCODE END"}, "clean_code": "module bitwise_operator (\n  input in1,\n  input in2,\n  output out_AND,\n  output out_OR,\n  output out_XOR,\n  output out_NOT\n);\n\n  assign out_AND = in1 & in2;\n  assign out_OR = in1 | in2;\n  assign out_XOR = in1 ^ in2;\n  assign out_NOT = ~in1;\n\nendmodule", "corrupted_code": "module bitwise_operator (\n  input in1,\n  input in2,\n  output out_AND,\n  output out_OR,\n  output out_XOR,\n  output out_NOT\n);\n\n  assign out_AND = in1 & in2;\n  assign out_OR = in1 | in2;\n  assign out_XOR = in1 & in2;\n  assign out_NOT = ~in1;\n\nendmodule", "corruption_explanation": "Changed operator from '^' to '&'", "modification_type": "change_operator", "modification_line": 12, "original_snippet": "^", "modified_snippet": "&", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '^' to '&'\n   \u2022 Line 12: Original: ^\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 12.\n   \u2022 Restore the original code: ^\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 3, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver"], "timestamp": "2025-12-09T21:43:36.249359"}
{"original_entry": {"instruction": "\nDesign a Verilog module named `binary_to_gray`.\nThe module should have a 9-bit input port named `binary` and a 4-bit output port named `gray`.\nImplement the logic such that the 4-bit output `gray` represents the Gray code equivalent of the most significant 4 bits of the input `binary` (i.e., `binary[8]` down to `binary[5]`). The lower bits of the `binary` input (`binary[4]` down to `binary[0]`) are not used in the conversion.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule binary_to_gray (\n    input [8:0] binary,\n    output [3:0] gray\n);\n\n    assign gray[3] = binary[8];\n    assign gray[2] = binary[8] ^ binary[7];\n    assign gray[1] = binary[7] ^ binary[6];\n    assign gray[0] = binary[6] ^ binary[5];\n\nendmodule\n\nCODE END"}, "clean_code": "module binary_to_gray (\n    input [8:0] binary,\n    output [3:0] gray\n);\n\n    assign gray[3] = binary[8];\n    assign gray[2] = binary[8] ^ binary[7];\n    assign gray[1] = binary[7] ^ binary[6];\n    assign gray[0] = binary[6] ^ binary[5];\n\nendmodule", "corrupted_code": "module binary_to_gray (\n    input [8:0] binary,\n    output [3:0] gray\n);\n\n    assign gray[3] = binary[8];\n    assign gray[2] = binary[8] ^ binary[7];\n    assign gray[1] <= binary[7] ^ binary[6];\n    assign gray[0] = binary[6] ^ binary[5];\n\nendmodule", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 8, "original_snippet": "ray[1] = binary[7] ^ binary[6];", "modified_snippet": "ray[1] <= binary[7] ^ binary[6];", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 0, "applicable_modifications": ["change_constant", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver"], "timestamp": "2025-12-09T21:43:36.249894"}
{"original_entry": {"instruction": "\nDesign the following Verilog modules:\n\n1.  **Module Name:** `up_down_counter`\n    *   **Inputs:**\n        *   `clk` (clock)\n        *   `reset` (synchronous reset)\n        *   `up_down` (control signal: 1 for up, 0 for down)\n    *   **Output:**\n        *   `out` (4-bit counter value)\n    *   **Behavior:** Implement a 4-bit synchronous counter. On the positive edge of `clk`, if `reset` is high, the counter should reset to 0. Otherwise, if `up_down` is high, the counter should increment its value. If `up_down` is low, the counter should decrement its value.\n\n2.  **Module Name:** `adder`\n    *   **Inputs:**\n        *   `a` (4-bit)\n        *   `b` (4-bit)\n    *   **Output:**\n        *   `sum` (4-bit result)\n    *   **Behavior:** Implement a combinational circuit that performs a 4-bit binary addition of inputs `a` and `b`, outputting the 4-bit sum.\n\n3.  **Module Name:** `top_module`\n    *   **Inputs:**\n        *   `clk` (clock)\n        *   `reset` (reset)\n        *   `up_down` (up/down control)\n        *   `add_value` (4-bit value to add)\n    *   **Output:**\n        *   `out` (4-bit final result)\n    *   **Behavior:** Create a top-level module that instantiates one instance of the `up_down_counter` and one instance of the `adder`. Connect the output of the `up_down_counter` to one input of the `adder`. Connect the `add_value` input of `top_module` to the other input of the `adder`. The output of the `adder` should be the final output `out` of `top_module`. The `clk`, `reset`, and `up_down` inputs of `top_module` should be connected to the corresponding inputs of the `up_down_counter` instance.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule up_down_counter(\n    input wire clk,        // Clock input\n    input wire reset,      // Reset input\n    input wire up_down,    // Control input for up or down counting\n    output wire [3:0] out  // Counter output\n);\n\n    reg [3:0] counter;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            counter <= 4'b0000;\n        end else begin\n            if (up_down) begin\n                counter <= counter + 1;\n            end else begin\n                counter <= counter - 1;\n            end\n        end\n    end\n\n    assign out = counter;\n\nendmodule\n\nmodule adder(\n    input wire [3:0] a,        // First input to the adder\n    input wire [3:0] b,        // Second input to the adder\n    output wire [3:0] sum      // Sum output\n);\n\n    assign sum = a + b;\n\nendmodule\n\nmodule top_module(\n    input wire clk,                // Clock input\n    input wire reset,              // Reset input\n    input wire up_down,            // Control input for up or down counting\n    input wire [3:0] add_value,    // Fixed value to be added to the counter output\n    output wire [3:0] out          // Final output, modified counter output\n);\n\n    wire [3:0] counter_out;\n    wire [3:0] adder_out;\n\n    up_down_counter udc(\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .out(counter_out)\n    );\n\n    adder add(\n        .a(counter_out),\n        .b(add_value),\n        .sum(adder_out)\n    );\n\n    assign out = adder_out;\n\nendmodule\nCODE END"}, "clean_code": "module up_down_counter(\n    input wire clk,        // Clock input\n    input wire reset,      // Reset input\n    input wire up_down,    // Control input for up or down counting\n    output wire [3:0] out  // Counter output\n);\n\n    reg [3:0] counter;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            counter <= 4'b0000;\n        end else begin\n            if (up_down) begin\n                counter <= counter + 1;\n            end else begin\n                counter <= counter - 1;\n            end\n        end\n    end\n\n    assign out = counter;\n\nendmodule\n\nmodule adder(\n    input wire [3:0] a,        // First input to the adder\n    input wire [3:0] b,        // Second input to the adder\n    output wire [3:0] sum      // Sum output\n);\n\n    assign sum = a + b;\n\nendmodule\n\nmodule top_module(\n    input wire clk,                // Clock input\n    input wire reset,              // Reset input\n    input wire up_down,            // Control input for up or down counting\n    input wire [3:0] add_value,    // Fixed value to be added to the counter output\n    output wire [3:0] out          // Final output, modified counter output\n);\n\n    wire [3:0] counter_out;\n    wire [3:0] adder_out;\n\n    up_down_counter udc(\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .out(counter_out)\n    );\n\n    adder add(\n        .a(counter_out),\n        .b(add_value),\n        .sum(adder_out)\n    );\n\n    assign out = adder_out;\n\nendmodule", "corrupted_code": "module up_down_counter(\n    input wire clk,        // Clock input\n    input wire reset,      // Reset input\n    input wire up_down,    // Control input for up or down counting\n    output wire [3:0] out  // Counter output\n);\n\n    reg [3:0] counter;\n\n    always @(posedge clk) begin\n        \n        end\n    end\n\n    assign out = counter;\n\nendmodule\n\nmodule adder(\n    input wire [3:0] a,        // First input to the adder\n    input wire [3:0] b,        // Second input to the adder\n    output wire [3:0] sum      // Sum output\n);\n\n    assign sum = a + b;\n\nendmodule\n\nmodule top_module(\n    input wire clk,                // Clock input\n    input wire reset,              // Reset input\n    input wire up_down,            // Control input for up or down counting\n    input wire [3:0] add_value,    // Fixed value to be added to the counter output\n    output wire [3:0] out          // Final output, modified counter output\n);\n\n    wire [3:0] counter_out;\n    wire [3:0] adder_out;\n\n    up_down_counter udc(\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .out(counter_out)\n    );\n\n    adder add(\n        .a(counter_out),\n        .b(add_value),\n        .sum(adder_out)\n    );\n\n    assign out = adder_out;\n\nendmodule", "corruption_explanation": "Removed a conditional block", "modification_type": "remove_conditional", "modification_line": 11, "original_snippet": "if (reset) begin\n            counter <= 4'b0000;\n        end else begin\n            if (up_down) begin\n                counter <= counter + 1;\n            end else begin\n                counter <= cou", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing a conditional block. This removes important control logic, causing the design to skip necessary state transitions or data processing. Test cases that depend on the conditional behavior will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_conditional modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed a conditional block\n   \u2022 Line 11: Original: if (reset) begin\n            counter <= 4'b0000;\n        end else begin\n            if (up_down) begin\n                counter <= counter + 1;\n            end else begin\n                counter <= cou\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 11.\n   \u2022 Restore the original code: if (reset) begin\n            counter <= 4'b0000;\n        end else begin\n            if (up_down) begin\n                counter <= counter + 1;\n            end else begin\n                counter <= cou\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove conditional.", "complexity": 9, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "swap_port_signals", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.252141"}
{"original_entry": {"instruction": "\nDesign a finite state machine (FSM) in Verilog for a simple vending machine controller. The module should be named `fsm_vending_machine`.\n\nThe module should have the following interface:\nInputs:\n- `clk`: Clock signal.\n- `reset`: Asynchronous reset signal.\n- `coin_inserted`: Indicates a coin has been inserted.\n- `item_selected` [1:0]: Indicates which item is selected (a non-zero value means an item is selected).\n- `item_dispensed`: Indicates the item has been successfully dispensed.\n\nOutputs:\n- `dispense_item`: Signal to initiate item dispensing (registered output).\n- `return_coin`: Signal to return the coin (registered output).\n\nImplement the following behavior:\n1.  Upon reset, the machine should enter an idle state, with both `dispense_item` and `return_coin` deasserted.\n2.  While in the idle state, if a coin is inserted (`coin_inserted` is high) and a valid item is selected (`item_selected` is non-zero), the machine should transition to a state where it signals to dispense the item.\n3.  In the state where dispensing is signaled, the `dispense_item` output should be asserted. The machine should remain in this state until the `item_dispensed` input is asserted.\n4.  Once `item_dispensed` is asserted, the machine should transition to a state where it signals to return the coin.\n5.  In the state where returning the coin is signaled, the `return_coin` output should be asserted, and the machine should immediately transition back to the idle state for the next transaction.\n6.  At all other times not explicitly described above, `dispense_item` and `return_coin` should be deasserted, and the machine should remain in its current state unless a valid transition condition is met.\n\nConsider using separate always blocks for the state register and the combinational next-state/output logic.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule fsm_vending_machine (\n  input clk,\n  input reset,\n  input coin_inserted,\n  input [1:0] item_selected,\n  input item_dispensed,\n  output reg dispense_item,\n  output reg return_coin\n);\n\n  // Define the states\n  parameter IDLE = 2'b00;\n  parameter ITEM_SELECTED = 2'b01;\n  parameter ITEM_DISPENSED = 2'b10;\n\n  // Define the current state\n  reg [1:0] state;\n\n  // Define the next state\n  reg [1:0] next_state;\n\n  // Define the state transition logic\n  always @ (posedge clk, posedge reset) begin\n    if (reset) begin\n      state <= IDLE;\n    end else begin\n      state <= next_state;\n    end\n  end\n\n  // Define the state output logic\n  always @ (state, coin_inserted, item_selected, item_dispensed) begin\n    case (state)\n      IDLE: begin\n        dispense_item <= 0;\n        return_coin <= 0;\n        if (coin_inserted && item_selected != 2'b00) begin\n          next_state <= ITEM_SELECTED;\n        end else begin\n          next_state <= IDLE;\n        end\n      end\n      ITEM_SELECTED: begin\n        dispense_item <= 1;\n        return_coin <= 0;\n        if (item_dispensed) begin\n          next_state <= ITEM_DISPENSED;\n        end else begin\n          next_state <= ITEM_SELECTED;\n        end\n      end\n      ITEM_DISPENSED: begin\n        dispense_item <= 0;\n        return_coin <= 1;\n        next_state <= IDLE;\n      end\n      default: begin\n        dispense_item <= 0;\n        return_coin <= 0;\n        next_state <= IDLE;\n      end\n    endcase\n  end\n\nendmodule\n\nCODE END"}, "clean_code": "module fsm_vending_machine (\n  input clk,\n  input reset,\n  input coin_inserted,\n  input [1:0] item_selected,\n  input item_dispensed,\n  output reg dispense_item,\n  output reg return_coin\n);\n\n  // Define the states\n  parameter IDLE = 2'b00;\n  parameter ITEM_SELECTED = 2'b01;\n  parameter ITEM_DISPENSED = 2'b10;\n\n  // Define the current state\n  reg [1:0] state;\n\n  // Define the next state\n  reg [1:0] next_state;\n\n  // Define the state transition logic\n  always @ (posedge clk, posedge reset) begin\n    if (reset) begin\n      state <= IDLE;\n    end else begin\n      state <= next_state;\n    end\n  end\n\n  // Define the state output logic\n  always @ (state, coin_inserted, item_selected, item_dispensed) begin\n    case (state)\n      IDLE: begin\n        dispense_item <= 0;\n        return_coin <= 0;\n        if (coin_inserted && item_selected != 2'b00) begin\n          next_state <= ITEM_SELECTED;\n        end else begin\n          next_state <= IDLE;\n        end\n      end\n      ITEM_SELECTED: begin\n        dispense_item <= 1;\n        return_coin <= 0;\n        if (item_dispensed) begin\n          next_state <= ITEM_DISPENSED;\n        end else begin\n          next_state <= ITEM_SELECTED;\n        end\n      end\n      ITEM_DISPENSED: begin\n        dispense_item <= 0;\n        return_coin <= 1;\n        next_state <= IDLE;\n      end\n      default: begin\n        dispense_item <= 0;\n        return_coin <= 0;\n        next_state <= IDLE;\n      end\n    endcase\n  end\n\nendmodule", "corrupted_code": "module fsm_vending_machine (\n  input clk,\n  input reset,\n  input coin_inserted,\n  input [1:0] item_selected,\n  input item_dispensed,\n  output reg dispense_item,\n  output reg return_coin\n);\n\n  // Define the states\n  parameter IDLE = 2'b00;\n  parameter ITEM_SELECTED = 2'b01;\n  parameter ITEM_DISPENSED = 2'b10;\n\n  // Define the current state\n  reg [1:0] state;\n\n  // Define the next state\n  reg [1:0] next_state;\n\n  // Define the state transition logic\n  always @ (posedge clk, posedge reset) begin\n    if (reset) begin\n      state <= IDLE;\n    end else begin\n      state <= next_state;\n    end\n  end\n\n  // Define the state output logic\n  always @ (state, coin_inserted, item_selected, item_dispensed) begin\n    case (state)\n      IDLE: begin\n        dispense_item <= 0;\n        return_coin <= 0;\n        if (coin_inserted && item_selected != 2'b00) begin\n          next_state <= IDLE;\n        end else begin\n          next_state <= ITEM_SELECTED;\n        end\n      end\n      ITEM_SELECTED: begin\n        dispense_item <= 1;\n        return_coin <= 0;\n        if (item_dispensed) begin\n          next_state <= ITEM_DISPENSED;\n        end else begin\n          next_state <= ITEM_SELECTED;\n        end\n      end\n      ITEM_DISPENSED: begin\n        dispense_item <= 0;\n        return_coin <= 1;\n        next_state <= IDLE;\n      end\n      default: begin\n        dispense_item <= 0;\n        return_coin <= 0;\n        next_state <= IDLE;\n      end\n    endcase\n  end\n\nendmodule", "corruption_explanation": "Swapped if and else bodies", "modification_type": "invert_if_else", "modification_line": 37, "original_snippet": "if (coin_inserted && item_selected != 2'b00) begin\n          next_state <= ITEM_SELECTED;\n        end else begin\n          next_state <= IDLE;\n        end", "modified_snippet": "if (coin_inserted && item_selected != 2'b00) begin\n          next_state <= IDLE;\n        end else begin\n          next_state <= ITEM_SELECTED;\n        end", "issue_description": "The buggy code has swapped if and else bodies in a conditional block. This causes the logic to execute the opposite branch for each condition, leading to incorrect behavior when the condition is true vs false. Test cases that depend on the conditional logic will fail because the intended branch is not executed.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module contains conditional logic that should execute different code paths based on a condition.\n   \u2022 The if branch should handle the true case, and the else branch should handle the false case.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Identified a conditional block with both if and else branches.\n   \u2022 The branches contain different assignments or logic operations.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The if and else bodies have been swapped.\n   \u2022 Logic that should execute when condition is true now executes when false, and vice versa.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The conditional bodies are inverted.\n   \u2022 Impact: All conditional behavior is reversed, causing incorrect outputs for all test cases.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Swap the if and else bodies back to their correct positions.\n   \u2022 Verify that the condition evaluates correctly and executes the intended branch.\n\n6. RTL Design Principle Violated:\n   \u2022 Correct conditional logic requires matching the intended behavior with the branch bodies.", "complexity": 24, "applicable_modifications": ["invert_if_else", "remove_else_branch", "remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.253979"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `iobus_1_connect` that serves as a simple connection block between a 'master' (m_) interface and a 'slave' (s0_) interface.\n\nThe module should have the following inputs and outputs:\nInputs:\n`clk` (wire)\n`reset` (wire)\n`m_iob_poweron` (wire)\n`m_iob_reset` (wire)\n`m_datao_clear` (wire)\n`m_datao_set` (wire)\n`m_cono_clear` (wire)\n`m_cono_set` (wire)\n`m_iob_fm_datai` (wire)\n`m_iob_fm_status` (wire)\n`m_rdi_pulse` (wire)\n`m_ios` (wire [3:9])\n`m_iob_write` (wire [0:35])\n`s0_pi_req` (wire [1:7])\n`s0_iob_read` (wire [0:35])\n`s0_dr_split` (wire)\n`s0_rdi_data` (wire)\n\nOutputs:\n`m_pi_req` (wire [1:7])\n`m_iob_read` (wire [0:35])\n`m_dr_split` (wire)\n`m_rdi_data` (wire)\n`s0_iob_poweron` (wire)\n`s0_iob_reset` (wire)\n`s0_datao_clear` (wire)\n`s0_datao_set` (wire)\n`s0_cono_clear` (wire)\n`s0_cono_set` (wire)\n`s0_iob_fm_datai` (wire)\n`s0_iob_fm_status` (wire)\n`s0_rdi_pulse` (wire)\n`s0_ios` (wire [3:9])\n`s0_iob_write` (wire [0:35])\n\nThe module should implement the following connectivity using continuous assignments:\n1.  Signals originating from the 'm' side that are inputs to this module (`m_iob_poweron`, `m_iob_reset`, `m_datao_clear`, `m_datao_set`, `m_cono_clear`, `m_cono_set`, `m_iob_fm_datai`, `m_iob_fm_status`, `m_rdi_pulse`, `m_ios`, `m_iob_write`) should be directly connected to their corresponding outputs prefixed with 's0_'.\n2.  Signals originating from the 's0' side that are inputs to this module (`s0_pi_req`, `s0_dr_split`, `s0_rdi_data`) should be directly connected to their corresponding outputs prefixed with 'm_'.\n3.  The `m_iob_read` output signal should be the bitwise OR of the `s0_iob_read` input signal and the `m_iob_write` input signal.\n\nNote: Clock and reset signals (`clk`, `reset`) are part of the interface but do not require specific logic within this passive connection module based on the requirements above.\n\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule iobus_1_connect(\n\tinput wire clk,\n\tinput wire reset,\n\n\tinput wire m_iob_poweron,\n\tinput wire m_iob_reset,\n\tinput wire m_datao_clear,\n\tinput wire m_datao_set,\n\tinput wire m_cono_clear,\n\tinput wire m_cono_set,\n\tinput wire m_iob_fm_datai,\n\tinput wire m_iob_fm_status,\n\tinput wire m_rdi_pulse,\n\tinput wire [3:9] m_ios,\n\tinput wire [0:35] m_iob_write,\n\toutput wire [1:7] m_pi_req,\n\toutput wire [0:35] m_iob_read,\n\toutput wire m_dr_split,\n\toutput wire m_rdi_data,\n\n\toutput wire s0_iob_poweron,\n\toutput wire s0_iob_reset,\n\toutput wire s0_datao_clear,\n\toutput wire s0_datao_set,\n\toutput wire s0_cono_clear,\n\toutput wire s0_cono_set,\n\toutput wire s0_iob_fm_datai,\n\toutput wire s0_iob_fm_status,\n\toutput wire s0_rdi_pulse,\n\toutput wire [3:9] s0_ios,\n\toutput wire [0:35] s0_iob_write,\n\tinput wire [1:7] s0_pi_req,\n\tinput wire [0:35] s0_iob_read,\n\tinput wire s0_dr_split,\n\tinput wire s0_rdi_data\n);\n\tassign m_pi_req = 0 | s0_pi_req;\n\tassign m_iob_read = m_iob_write | s0_iob_read;\n\tassign m_dr_split = 0 | s0_dr_split;\n\tassign m_rdi_data = 0 | s0_rdi_data;\n\n\n\tassign s0_iob_poweron = m_iob_poweron;\n\tassign s0_iob_reset = m_iob_reset;\n\tassign s0_datao_clear = m_datao_clear;\n\tassign s0_datao_set = m_datao_set;\n\tassign s0_cono_clear = m_cono_clear;\n\tassign s0_cono_set = m_cono_set;\n\tassign s0_iob_fm_datai = m_iob_fm_datai;\n\tassign s0_iob_fm_status = m_iob_fm_status;\n\tassign s0_rdi_pulse = m_rdi_pulse;\n\tassign s0_ios = m_ios;\n\tassign s0_iob_write = m_iob_write;\nendmodule\n\nCODE END"}, "clean_code": "module iobus_1_connect(\n\tinput wire clk,\n\tinput wire reset,\n\n\tinput wire m_iob_poweron,\n\tinput wire m_iob_reset,\n\tinput wire m_datao_clear,\n\tinput wire m_datao_set,\n\tinput wire m_cono_clear,\n\tinput wire m_cono_set,\n\tinput wire m_iob_fm_datai,\n\tinput wire m_iob_fm_status,\n\tinput wire m_rdi_pulse,\n\tinput wire [3:9] m_ios,\n\tinput wire [0:35] m_iob_write,\n\toutput wire [1:7] m_pi_req,\n\toutput wire [0:35] m_iob_read,\n\toutput wire m_dr_split,\n\toutput wire m_rdi_data,\n\n\toutput wire s0_iob_poweron,\n\toutput wire s0_iob_reset,\n\toutput wire s0_datao_clear,\n\toutput wire s0_datao_set,\n\toutput wire s0_cono_clear,\n\toutput wire s0_cono_set,\n\toutput wire s0_iob_fm_datai,\n\toutput wire s0_iob_fm_status,\n\toutput wire s0_rdi_pulse,\n\toutput wire [3:9] s0_ios,\n\toutput wire [0:35] s0_iob_write,\n\tinput wire [1:7] s0_pi_req,\n\tinput wire [0:35] s0_iob_read,\n\tinput wire s0_dr_split,\n\tinput wire s0_rdi_data\n);\n\tassign m_pi_req = 0 | s0_pi_req;\n\tassign m_iob_read = m_iob_write | s0_iob_read;\n\tassign m_dr_split = 0 | s0_dr_split;\n\tassign m_rdi_data = 0 | s0_rdi_data;\n\n\n\tassign s0_iob_poweron = m_iob_poweron;\n\tassign s0_iob_reset = m_iob_reset;\n\tassign s0_datao_clear = m_datao_clear;\n\tassign s0_datao_set = m_datao_set;\n\tassign s0_cono_clear = m_cono_clear;\n\tassign s0_cono_set = m_cono_set;\n\tassign s0_iob_fm_datai = m_iob_fm_datai;\n\tassign s0_iob_fm_status = m_iob_fm_status;\n\tassign s0_rdi_pulse = m_rdi_pulse;\n\tassign s0_ios = m_ios;\n\tassign s0_iob_write = m_iob_write;\nendmodule", "corrupted_code": "module iobus_1_connect(\n\tinput wire clk,\n\tinput wire reset,\n\n\tinput wire m_iob_poweron,\n\tinput wire m_iob_reset,\n\tinput wire m_datao_clear,\n\tinput wire m_datao_set,\n\tinput wire m_cono_clear,\n\tinput wire m_cono_set,\n\tinput wire m_iob_fm_datai,\n\tinput wire m_iob_fm_status,\n\tinput wire m_rdi_pulse,\n\tinput wire [3:9] m_ios,\n\tinput wire [0:35] m_iob_write,\n\toutput wire [1:7] m_pi_req,\n\toutput wire [0:35] m_iob_read,\n\toutput wire m_dr_split,\n\toutput wire m_rdi_data,\n\n\toutput wire s0_iob_poweron,\n\toutput wire s0_iob_reset,\n\toutput wire s0_datao_clear,\n\toutput wire s0_datao_set,\n\toutput wire s0_cono_clear,\n\toutput wire s0_cono_set,\n\toutput wire s0_iob_fm_datai,\n\toutput wire s0_iob_fm_status,\n\toutput wire s0_rdi_pulse,\n\toutput wire [3:9] s0_ios,\n\toutput wire [0:35] s0_iob_write,\n\tinput wire [1:7] s0_pi_req,\n\tinput wire [0:35] s0_iob_read,\n\tinput wire s0_dr_split,\n\tinput wire s0_rdi_data\n);\n\tassign m_pi_req = 0 | s0_pi_req;\n\tassign m_iob_read = m_iob_write | s0_iob_read;\n\tassign m_dr_split = 0 | s0_dr_split;\n\tassign m_rdi_data = 0 | s0_rdi_data;\n\n\n\tassign s0_iob_poweron = m_iob_poweron;\n\tassign s0_iob_reset = m_iob_reset;\n\tassign s0_datao_clear = m_datao_clear;\n\tassign s0_datao_set = m_datao_set;\n\tassign s0_cono_clear = m_cono_clear;\n\tassign s0_cono_set = m_cono_set;\n\tassign s0_iob_fm_datai = m_iob_fm_datai;\n\tassign s0_iob_fm_status = m_iob_fm_status;\n\tassign s0_rdi_pulse = m_rdi_pulse;\n\tassign s0_ios = m_ios;\n\tassign s0_iob_write = m_iob_write;\nendmodule", "corruption_explanation": "Changed constant from 0 to 0", "modification_type": "change_constant", "modification_line": 37, "original_snippet": "0", "modified_snippet": "0", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 0 to 0\n   \u2022 Line 37: Original: 0\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 37.\n   \u2022 Restore the original code: 0\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 4, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "invert_reset_polarity"], "timestamp": "2025-12-09T21:43:36.256531"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `alu8b` that implements an 8-bit Arithmetic Logic Unit (ALU) with the following interface:\n\nInputs:\n- `A_in`: 8-bit input operand A\n- `B_in`: 8-bit input operand B\n- `C_in`: 1-bit input carry-in for addition\n- `Opcode_in`: 3-bit input specifying the operation\n\nOutputs:\n- `Result_out`: 8-bit output result\n- `C_out`: 1-bit output carry/status flag\n\nThe module should be combinational logic and perform the following operations based on the value of `Opcode_in`:\n\n- If `Opcode_in` is `3'b000`: Perform 8-bit addition of `A_in`, `B_in`, and `C_in`. The 8-bit sum should be assigned to `Result_out`, and the carry-out should be assigned to `C_out`.\n- If `Opcode_in` is `3'b001`: Perform 8-bit subtraction `A_in - B_in`. The 8-bit difference should be assigned to `Result_out`. `C_out` should be set to 1 if `A_in` is less than `B_in` (indicating a borrow or negative result), otherwise 0.\n- If `Opcode_in` is `3'b010`: Perform the 8-bit bitwise AND of `A_in` and `B_in`. Assign the result to `Result_out`. `C_out` should be set to 0.\n- If `Opcode_in` is `3'b011`: Perform the 8-bit bitwise OR of `A_in` and `B_in`. Assign the result to `Result_out`. `C_out` should be set to 0.\n- If `Opcode_in` is `3'b100`: Perform the modulo operation (`A_in % B_in`). Assign the remainder to `Result_out`. `C_out` should be set to 0.\n- For any other value of `Opcode_in`: Set both `Result_out` to 8'h00 and `C_out` to 0.\n\nEnsure the outputs `Result_out` and `C_out` are declared appropriately for assignment within an `always` block.\n\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule alu8b (input wire [7:0] A_in,\n              input wire [7:0] B_in,\n              input wire       C_in,\n              input wire [2:0] Opcode_in,\n              output reg [7:0] Result_out,\n              output reg       C_out);\n\n  always @ ( * ) begin\n    case (Opcode_in)\n      3'b000: // A+B+Cin\n              begin\n                // perform addition with carry in\n                {C_out, Result_out} = A_in + B_in + C_in;\n              end\n      3'b001: // A-B\n              begin\n                // perform subtraction\n                Result_out = A_in - B_in;\n                C_out = (A_in < B_in) ? 1 : 0; // set carry out if A_in < B_in\n              end\n      3'b010: // A & B\n              begin\n                // perform bitwise AND\n                Result_out = A_in & B_in;\n                C_out = 0; // no carry out for bitwise AND\n              end\n      3'b011: // A|B\n              begin\n                // perform bitwise OR\n                Result_out = A_in | B_in;\n                C_out = 0; // no carry out for bitwise OR\n              end\n      3'b100: // A % B\n              begin\n                // perform modulo operation\n                Result_out = A_in % B_in;\n                C_out = 0; // no carry out for modulo operation\n              end\n      default:\n              begin\n                // default case: set result to 0\n                Result_out = 8'b0;\n                C_out = 0;\n              end\n    endcase\n  end\nendmodule\nCODE END"}, "clean_code": "module alu8b (input wire [7:0] A_in,\n              input wire [7:0] B_in,\n              input wire       C_in,\n              input wire [2:0] Opcode_in,\n              output reg [7:0] Result_out,\n              output reg       C_out);\n\n  always @ ( * ) begin\n    case (Opcode_in)\n      3'b000: // A+B+Cin\n              begin\n                // perform addition with carry in\n                {C_out, Result_out} = A_in + B_in + C_in;\n              end\n      3'b001: // A-B\n              begin\n                // perform subtraction\n                Result_out = A_in - B_in;\n                C_out = (A_in < B_in) ? 1 : 0; // set carry out if A_in < B_in\n              end\n      3'b010: // A & B\n              begin\n                // perform bitwise AND\n                Result_out = A_in & B_in;\n                C_out = 0; // no carry out for bitwise AND\n              end\n      3'b011: // A|B\n              begin\n                // perform bitwise OR\n                Result_out = A_in | B_in;\n                C_out = 0; // no carry out for bitwise OR\n              end\n      3'b100: // A % B\n              begin\n                // perform modulo operation\n                Result_out = A_in % B_in;\n                C_out = 0; // no carry out for modulo operation\n              end\n      default:\n              begin\n                // default case: set result to 0\n                Result_out = 8'b0;\n                C_out = 0;\n              end\n    endcase\n  end\nendmodule", "corrupted_code": "module alu8b (input wire [7:0] A_in,\n              input wire [7:0] B_in,\n              input wire       C_in,\n              input wire [3:0] Opcode_in,\n              output reg [7:0] Result_out,\n              output reg       C_out);\n\n  always @ ( * ) begin\n    case (Opcode_in)\n      3'b000: // A+B+Cin\n              begin\n                // perform addition with carry in\n                {C_out, Result_out} = A_in + B_in + C_in;\n              end\n      3'b001: // A-B\n              begin\n                // perform subtraction\n                Result_out = A_in - B_in;\n                C_out = (A_in < B_in) ? 1 : 0; // set carry out if A_in < B_in\n              end\n      3'b010: // A & B\n              begin\n                // perform bitwise AND\n                Result_out = A_in & B_in;\n                C_out = 0; // no carry out for bitwise AND\n              end\n      3'b011: // A|B\n              begin\n                // perform bitwise OR\n                Result_out = A_in | B_in;\n                C_out = 0; // no carry out for bitwise OR\n              end\n      3'b100: // A % B\n              begin\n                // perform modulo operation\n                Result_out = A_in % B_in;\n                C_out = 0; // no carry out for modulo operation\n              end\n      default:\n              begin\n                // default case: set result to 0\n                Result_out = 8'b0;\n                C_out = 0;\n              end\n    endcase\n  end\nendmodule", "corruption_explanation": "Changed bit width from [2:0] to [3:0]", "modification_type": "change_bit_width", "modification_line": 4, "original_snippet": "[2:0]", "modified_snippet": "[3:0]", "issue_description": "The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_bit_width modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed bit width from [2:0] to [3:0]\n   \u2022 Line 4: Original: [2:0]\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 4.\n   \u2022 Restore the original code: [2:0]\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change bit width.", "complexity": 14, "applicable_modifications": ["remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "shuffle_case_items", "remove_always_block"], "timestamp": "2025-12-09T21:43:36.259034"}
{"original_entry": {"instruction": "\nImplement the Verilog modules described below. You must use the exact module names and port names/widths provided for each module. The implementation of `four_bit_adder` must *only* use instantiations of the `xor_gate`, `and_gate`, and `or_gate` modules.\n\nThe interfaces are:\n*   `module four_bit_adder(output [3:0] S, output C_out, input [3:0] A, input [3:0] B);`\n*   `module xor_gate(output Y, input A, input B);`\n*   `module and_gate(output Y, input A, input B);`\n*   `module or_gate(output Y, input A, input B, input C);`\n\nThe logic for the `xor_gate`, `and_gate`, and `or_gate` modules should implement their standard boolean functions.\n\nThe `four_bit_adder` module implements a specific logic function. First, calculate the bitwise XOR of inputs `A` and `B` into a 4-bit intermediate signal (let's call it `intermediate_xor`). Second, calculate a second 4-bit intermediate signal (let's call it `intermediate_and`) where:\n*   `intermediate_and[0]` is the AND of `intermediate_xor[0]` and `intermediate_xor[1]`\n*   `intermediate_and[1]` is the AND of `intermediate_xor[2]` and `intermediate_xor[3]`\n*   `intermediate_and[2]` is the AND of `intermediate_xor[1]` and `intermediate_xor[2]`\n*   `intermediate_and[3]` is the AND of `intermediate_xor[0]` and `intermediate_xor[1]` (Note: this is the same logic as `intermediate_and[0]`)\n\nThe output `S` is calculated as follows:\n*   `S[0]` is the XOR of `intermediate_xor[0]` and `intermediate_xor[1]`\n*   `S[1]` is the XOR of `intermediate_xor[2]` and `intermediate_xor[3]`\n*   `S[2]` is the XOR of `intermediate_xor[1]` and `intermediate_xor[2]`\n*   `S[3]` is the XOR of `S[2]` and `intermediate_and[0]`\n\nThe output `C_out` is the OR of three terms:\n*   The first term is the AND of `intermediate_and[0]` and `intermediate_and[1]`\n*   The second term is the AND of `intermediate_and[2]` and `intermediate_and[3]`\n*   The third term is the AND of `intermediate_and[1]` and `intermediate_and[2]`\n\nWrite the Verilog code for all four modules.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule four_bit_adder(\n    output [3:0] S,\n    output C_out,\n    input [3:0] A,\n    input [3:0] B\n);\n\n    wire [3:0] XOR_out;\n    wire [3:0] AND_out;\n    wire [3:0] carry;\n\n    xor_gate XOR0(.Y(XOR_out[0]), .A(A[0]), .B(B[0]));\n    xor_gate XOR1(.Y(XOR_out[1]), .A(A[1]), .B(B[1]));\n    xor_gate XOR2(.Y(XOR_out[2]), .A(A[2]), .B(B[2]));\n    xor_gate XOR3(.Y(XOR_out[3]), .A(A[3]), .B(B[3]));\n\n    and_gate AND0(.Y(AND_out[0]), .A(XOR_out[0]), .B(XOR_out[1]));\n    and_gate AND1(.Y(AND_out[1]), .A(XOR_out[2]), .B(XOR_out[3]));\n    and_gate AND2(.Y(AND_out[2]), .A(XOR_out[1]), .B(XOR_out[2]));\n    and_gate AND3(.Y(AND_out[3]), .A(XOR_out[0]), .B(XOR_out[1]));\n\n    xor_gate XOR4(.Y(S[0]), .A(XOR_out[0]), .B(XOR_out[1]));\n    xor_gate XOR5(.Y(S[1]), .A(XOR_out[2]), .B(XOR_out[3]));\n    xor_gate XOR6(.Y(S[2]), .A(XOR_out[1]), .B(XOR_out[2]));\n    xor_gate XOR7(.Y(S[3]), .A(S[2]), .B(AND_out[0]));\n\n    and_gate AND4(.Y(carry[0]), .A(AND_out[0]), .B(AND_out[1]));\n    and_gate AND5(.Y(carry[1]), .A(AND_out[2]), .B(AND_out[3]));\n    and_gate AND6(.Y(carry[2]), .A(AND_out[1]), .B(AND_out[2]));\n    or_gate  OR0 (.Y(C_out), .A(carry[0]), .B(carry[1]), .C(carry[2]));\n\nendmodule\n\nmodule xor_gate(\n    output Y,\n    input A,\n    input B\n);\n    assign Y = A ^ B;\nendmodule\n\nmodule and_gate(\n    output Y,\n    input A,\n    input B\n);\n    assign Y = A & B;\nendmodule\n\nmodule or_gate(\n    output Y,\n    input A,\n    input B,\n    input C\n);\n    assign Y = A | B | C;\nendmodule\nCODE END"}, "clean_code": "module four_bit_adder(\n    output [3:0] S,\n    output C_out,\n    input [3:0] A,\n    input [3:0] B\n);\n\n    wire [3:0] XOR_out;\n    wire [3:0] AND_out;\n    wire [3:0] carry;\n\n    xor_gate XOR0(.Y(XOR_out[0]), .A(A[0]), .B(B[0]));\n    xor_gate XOR1(.Y(XOR_out[1]), .A(A[1]), .B(B[1]));\n    xor_gate XOR2(.Y(XOR_out[2]), .A(A[2]), .B(B[2]));\n    xor_gate XOR3(.Y(XOR_out[3]), .A(A[3]), .B(B[3]));\n\n    and_gate AND0(.Y(AND_out[0]), .A(XOR_out[0]), .B(XOR_out[1]));\n    and_gate AND1(.Y(AND_out[1]), .A(XOR_out[2]), .B(XOR_out[3]));\n    and_gate AND2(.Y(AND_out[2]), .A(XOR_out[1]), .B(XOR_out[2]));\n    and_gate AND3(.Y(AND_out[3]), .A(XOR_out[0]), .B(XOR_out[1]));\n\n    xor_gate XOR4(.Y(S[0]), .A(XOR_out[0]), .B(XOR_out[1]));\n    xor_gate XOR5(.Y(S[1]), .A(XOR_out[2]), .B(XOR_out[3]));\n    xor_gate XOR6(.Y(S[2]), .A(XOR_out[1]), .B(XOR_out[2]));\n    xor_gate XOR7(.Y(S[3]), .A(S[2]), .B(AND_out[0]));\n\n    and_gate AND4(.Y(carry[0]), .A(AND_out[0]), .B(AND_out[1]));\n    and_gate AND5(.Y(carry[1]), .A(AND_out[2]), .B(AND_out[3]));\n    and_gate AND6(.Y(carry[2]), .A(AND_out[1]), .B(AND_out[2]));\n    or_gate  OR0 (.Y(C_out), .A(carry[0]), .B(carry[1]), .C(carry[2]));\n\nendmodule\n\nmodule xor_gate(\n    output Y,\n    input A,\n    input B\n);\n    assign Y = A ^ B;\nendmodule\n\nmodule and_gate(\n    output Y,\n    input A,\n    input B\n);\n    assign Y = A & B;\nendmodule\n\nmodule or_gate(\n    output Y,\n    input A,\n    input B,\n    input C\n);\n    assign Y = A | B | C;\nendmodule", "corrupted_code": "module four_bit_adder(\n    output [3:0] S,\n    output C_out,\n    input [3:0] A,\n    input [3:0] B\n);\n\n    wire [3:0] XOR_out;\n    wire [3:0] AND_out;\n    wire [3:0] carry;\n\n    xor_gate XOR0(.Y(XOR_out[0]), .A(A[0]), .B(B[0]));\n    xor_gate XOR1(.Y(XOR_out[1]), .A(A[1]), .B(B[1]));\n    xor_gate XOR2(.Y(XOR_out[2]), .A(A[2]), .B(B[2]));\n    xor_gate XOR3(.Y(XOR_out[3]), .A(A[3]), .B(B[3]));\n\n    and_gate AND0(.Y(AND_out[0]), .A(XOR_out[0]), .B(XOR_out[1]));\n    and_gate AND1(.Y(AND_out[1]), .A(XOR_out[2]), .B(XOR_out[3]));\n    and_gate AND2(.Y(AND_out[2]), .A(XOR_out[1]), .B(XOR_out[2]));\n    and_gate AND3(.Y(AND_out[3]), .A(XOR_out[0]), .B(XOR_out[1]));\n\n    xor_gate XOR4(.Y(S[0]), .A(XOR_out[0]), .B(XOR_out[1]));\n    xor_gate XOR5(.Y(S[1]), .A(XOR_out[2]), .B(XOR_out[3]));\n    xor_gate XOR6(.Y(S[2]), .A(XOR_out[1]), .B(XOR_out[2]));\n    xor_gate XOR7(.Y(S[3]), .A(S[2]), .B(AND_out[0]));\n\n    and_gate AND4(.Y(carry[0]), .A(AND_out[0]), .B(AND_out[1]));\n    and_gate AND5(.Y(carry[1]), .A(AND_out[2]), .B(AND_out[3]));\n    and_gate AND6(.Y(carry[2]), .A(AND_out[1]), .B(AND_out[2]));\n    or_gate  OR0 (.Y(C_out), .A(carry[0]), .B(carry[1]), .C(carry[2]));\n\nendmodule\n\nmodule xor_gate(\n    output Y,\n    input A,\n    input B\n);\n    assign Y = A ^ B;\nendmodule\n\nmodule and_gate(\n    output Y,\n    input A,\n    input B\n);\n    assign Y = A & B;\nassign Y = 1'b0;  // Conflicting assignment\nendmodule\n\nmodule or_gate(\n    output Y,\n    input A,\n    input B,\n    input C\n);\n    assign Y = A | B | C;\nendmodule", "corruption_explanation": "Added conflicting driver for signal 'Y'", "modification_type": "add_multiple_driver", "modification_line": 47, "original_snippet": "assign Y = A & B;", "modified_snippet": "assign Y = A & B;\nassign Y = 1'b0;  // Conflicting assignment", "issue_description": "The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_multiple_driver modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added conflicting driver for signal 'Y'\n   \u2022 Line 47: Original: assign Y = A & B;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 47.\n   \u2022 Restore the original code: assign Y = A & B;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add multiple driver.", "complexity": 3, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "timestamp": "2025-12-09T21:43:36.261322"}
{"original_entry": {"instruction": "\nWrite the Verilog code for the following set of interconnected modules:\n\n1.  **Module `priority_encoder`**:\n    *   Inputs: `a`, `b`, `c`, `d` (all 8-bit vectors, `[7:0]`)\n    *   Output: `min` (a 3-bit register, `reg [2:0]`)\n    *   Functionality: This module should determine the minimum value among the four 8-bit inputs and output the lower 3 bits of this minimum value to the `min` output.\n\n2.  **Module `combinational_circuit`**:\n    *   Inputs: `in` (a 50-bit vector, `[49:0]`)\n    *   Outputs: `out_and`, `out_or`, `out_xnor` (all single-bit registers, `reg`)\n    *   Functionality: This module should compute the bitwise AND reduction of the `in` vector and assign it to `out_and`. It should compute the bitwise OR reduction of the `in` vector and assign it to `out_or`. It should compute the bitwise XNOR reduction (inverted XOR reduction) of the `in` vector and assign it to `out_xnor`.\n\n3.  **Module `control_logic`**:\n    *   Inputs: `a`, `b`, `c`, `d` (all 8-bit vectors, `[7:0]`), `in` (a 50-bit vector, `[49:0]`), `sel` (a single bit)\n    *   Outputs: `min` (a 3-bit register, `reg [2:0]`), `out_and`, `out_or`, `out_xnor` (all single-bit registers, `reg`)\n    *   Functionality: This module acts as a selector based on the `sel` input. It should instantiate the `priority_encoder` module internally.\n        *   If `sel` is high (1), the `min` output should be assigned the value from the instantiated `priority_encoder`'s output, and `out_and`, `out_or`, `out_xnor` should all be set to 0.\n        *   If `sel` is low (0), `out_and`, `out_or`, `out_xnor` should be assigned the bitwise AND, OR, and XNOR reductions of the `in` input, respectively (similar to the `combinational_circuit` module's operation), and `min` should be set to 0.\n\n4.  **Module `top_module`**:\n    *   Inputs: `a`, `b`, `c`, `d` (all 8-bit vectors, `[7:0]`), `in` (a 50-bit vector, `[49:0]`), `sel` (a single bit)\n    *   Outputs: `min` (a 3-bit vector, `[2:0]`), `out_and`, `out_or`, `out_xnor` (all single bits)\n    *   Functionality: This is the top-level module that should instantiate the `control_logic` module and connect its ports to the corresponding top-level inputs and outputs.\n\nImplement these modules in Verilog.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule priority_encoder (\n    input [7:0] a, b, c, d,\n    output reg [2:0] min\n);\n\nwire [7:0] ab_min, cd_min, abcd_min;\n\nassign ab_min = (a < b) ? a : b;\nassign cd_min = (c < d) ? c : d;\nassign abcd_min = (ab_min < cd_min) ? ab_min : cd_min;\n\nalways @(*) begin\n    min = abcd_min;\nend\n\nendmodule\nmodule combinational_circuit (\n    input [49:0] in,\n    output reg out_and,\n    output reg out_or,\n    output reg out_xnor\n);\n\nalways @(*) begin\n    out_and = &in;\n    out_or = |in;\n    out_xnor = ~(^in);\nend\n\nendmodule\nmodule control_logic (\n    input [7:0] a, b, c, d,\n    input [49:0] in,\n    input sel,\n    output reg [2:0] min,\n    output reg out_and,\n    output reg out_or,\n    output reg out_xnor\n);\n\nwire [2:0] priority_encoder_out;\n\npriority_encoder pe(\n    .a(a),\n    .b(b),\n    .c(c),\n    .d(d),\n    .min(priority_encoder_out)\n);\n\nalways @(*) begin\n    if (sel) begin\n        min = priority_encoder_out;\n        out_and = 1'b0;\n        out_or = 1'b0;\n        out_xnor = 1'b0;\n    end else begin\n        out_and = &in;\n        out_or = |in;\n        out_xnor = ~(^in);\n        min = 8'b0;\n    end\nend\n\nendmodule\nmodule top_module (\n    input [7:0] a, b, c, d,\n    input [49:0] in,\n    input sel,\n    output [2:0] min,\n    output out_and,\n    output out_or,\n    output out_xnor\n);\n\ncontrol_logic cl(\n    .a(a),\n    .b(b),\n    .c(c),\n    .d(d),\n    .in(in),\n    .sel(sel),\n    .min(min),\n    .out_and(out_and),\n    .out_or(out_or),\n    .out_xnor(out_xnor)\n);\n\nendmodule\nCODE END"}, "clean_code": "module priority_encoder (\n    input [7:0] a, b, c, d,\n    output reg [2:0] min\n);\n\nwire [7:0] ab_min, cd_min, abcd_min;\n\nassign ab_min = (a < b) ? a : b;\nassign cd_min = (c < d) ? c : d;\nassign abcd_min = (ab_min < cd_min) ? ab_min : cd_min;\n\nalways @(*) begin\n    min = abcd_min;\nend\n\nendmodule\nmodule combinational_circuit (\n    input [49:0] in,\n    output reg out_and,\n    output reg out_or,\n    output reg out_xnor\n);\n\nalways @(*) begin\n    out_and = &in;\n    out_or = |in;\n    out_xnor = ~(^in);\nend\n\nendmodule\nmodule control_logic (\n    input [7:0] a, b, c, d,\n    input [49:0] in,\n    input sel,\n    output reg [2:0] min,\n    output reg out_and,\n    output reg out_or,\n    output reg out_xnor\n);\n\nwire [2:0] priority_encoder_out;\n\npriority_encoder pe(\n    .a(a),\n    .b(b),\n    .c(c),\n    .d(d),\n    .min(priority_encoder_out)\n);\n\nalways @(*) begin\n    if (sel) begin\n        min = priority_encoder_out;\n        out_and = 1'b0;\n        out_or = 1'b0;\n        out_xnor = 1'b0;\n    end else begin\n        out_and = &in;\n        out_or = |in;\n        out_xnor = ~(^in);\n        min = 8'b0;\n    end\nend\n\nendmodule\nmodule top_module (\n    input [7:0] a, b, c, d,\n    input [49:0] in,\n    input sel,\n    output [2:0] min,\n    output out_and,\n    output out_or,\n    output out_xnor\n);\n\ncontrol_logic cl(\n    .a(a),\n    .b(b),\n    .c(c),\n    .d(d),\n    .in(in),\n    .sel(sel),\n    .min(min),\n    .out_and(out_and),\n    .out_or(out_or),\n    .out_xnor(out_xnor)\n);\n\nendmodule", "corrupted_code": "module priority_encoder (\n    input [7:0] a, b, c, d,\n    output reg [2:0] min\n);\n\nwire [7:0] ab_min, cd_min, abcd_min;\n\nassign ab_min = (a < b) ? a : b;\nassign cd_min = (c < d) ? c : d;\nassign abcd_min = (ab_min < cd_min) ? ab_min : cd_min;\n\nalways @(*) begin\n    min = abcd_min;\nend\n\nendmodule\nmodule combinational_circuit (\n    input [49:0] in,\n    output reg out_and,\n    output reg out_or,\n    output reg out_xnor\n);\n\nalways @(*) begin\n    out_and = &in;\n    out_or = |in;\n    out_xnor = ~(^in);\nend\n\nendmodule\nmodule control_logic (\n    input [7:0] a, b, c, d,\n    input [49:0] in,\n    input sel,\n    output reg [2:0] min,\n    output reg out_and,\n    output reg out_or,\n    output reg out_xnor\n);\n\nwire [2:0] priority_encoder_out;\n\npriority_encoder pe(\n    .a(a),\n    .b(b),\n    .c(c),\n    .d(d),\n    .min(priority_encoder_out)\n);\n\nalways @(*) begin\n    if (sel) begin\n        min = priority_encoder_out;\n        out_and = 1'b0;\n        out_or = 1'b0;\n        out_xnor = 1'b0;\n    end else begin\n\n        out_or = |in;\n        out_xnor = ~(^in);\n        min = 8'b0;\n    end\nend\n\nendmodule\nmodule top_module (\n    input [7:0] a, b, c, d,\n    input [49:0] in,\n    input sel,\n    output [2:0] min,\n    output out_and,\n    output out_or,\n    output out_xnor\n);\n\ncontrol_logic cl(\n    .a(a),\n    .b(b),\n    .c(c),\n    .d(d),\n    .in(in),\n    .sel(sel),\n    .min(min),\n    .out_and(out_and),\n    .out_or(out_or),\n    .out_xnor(out_xnor)\n);\n\nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 58, "original_snippet": "out_and = &in;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 58: Original: out_and = &in;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 58.\n   \u2022 Restore the original code: out_and = &in;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 7, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "invert_condition", "remove_always_block", "swap_port_signals"], "timestamp": "2025-12-09T21:43:36.263916"}
{"original_entry": {"instruction": "\n\nDesign a set of Verilog modules to perform specific arithmetic and logic operations.\n\nFirst, implement the following sub-modules with the specified interfaces and behavior:\n\n1.  Module `mux2to1`: An 8-bit 2-to-1 multiplexer.\n    *   Interface: `input [7:0] in0, input [7:0] in1, input sel, output reg [7:0] out`.\n    *   Behavior: Selects between the 8-bit inputs `in0` and `in1` based on the single-bit select input `sel`.\n\n2.  Module `adder8`: An 8-bit adder/subtracter.\n    *   Interface: `input [7:0] in1, input [7:0] in2, input sub, output reg [7:0] out`.\n    *   Behavior: Computes the sum of `in1` and `in2` if the `sub` input is 0, and the difference (`in1` minus `in2`) if `sub` is 1.\n\n3.  Module `and8`: An 8-bit bitwise AND gate.\n    *   Interface: `input [7:0] in1, input [7:0] in2, output reg [7:0] out`.\n    *   Behavior: Computes the bitwise AND of the two 8-bit inputs `in1` and `in2`.\n\nNext, implement the top-level module `add_sub_and`. This module should instantiate the previously defined sub-modules to achieve its functionality.\n\n*   Module `add_sub_and`:\n    *   Interface: `input wire [7:0] in1, input wire [7:0] in2, input wire ctrl, output wire [7:0] out, output wire [7:0] out_and`.\n    *   Behavior:\n        *   The output `out_and` should always be the bitwise AND of the top-level inputs `in1` and `in2`.\n        *   The output `out` depends on the `ctrl` input:\n            *   If `ctrl` is 0, `out` should be the sum of the top-level inputs `in1` and `in2`.\n            *   If `ctrl` is 1, `out` should be the result of subtracting the top-level input `in2` from itself.\n\nEnsure that all module names, input/output names, widths, and parameter names match the specifications exactly.\n\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule add_sub_and (\n    input wire [7:0] in1,\n    input wire [7:0] in2,\n    input wire ctrl,\n    output wire [7:0] out,\n    output wire [7:0] out_and\n);\n\n    wire [7:0] add_in;\n    wire [7:0] sub_in;\n    wire [7:0] add_out;\n    wire [7:0] and_out;\n\n    // 2-to-1 multiplexer to select input based on control input\n    mux2to1 mux (\n        .in0(in1),\n        .in1(in2),\n        .sel(ctrl),\n        .out(add_in)\n    );\n\n    assign sub_in = in2; // Assign sub_in to in2 for subtraction\n\n    // 8-bit adder to perform addition or subtraction\n    adder8 adder (\n        .in1(add_in),\n        .in2(sub_in),\n        .sub(ctrl),\n        .out(add_out)\n    );\n\n    // Bitwise AND module to perform AND operation on inputs\n    and8 and_gate (\n        .in1(in1),\n        .in2(in2),\n        .out(and_out)\n    );\n\n    assign out = add_out;\n    assign out_and = and_out;\n\nendmodule\n\nmodule mux2to1 (\n    input [7:0] in0,\n    input [7:0] in1,\n    input sel,\n    output reg [7:0] out\n);\n    always @(*) begin\n        if (sel == 1'b0)\n            out = in0;\n        else\n            out = in1;\n    end\nendmodule\n\nmodule adder8 (\n    input [7:0] in1,\n    input [7:0] in2,\n    input sub,\n    output reg [7:0] out\n);\n    always @(*) begin\n        if (sub)\n            out = in1 - in2;\n        else\n            out = in1 + in2;\n    end\nendmodule\n\nmodule and8 (\n    input [7:0] in1,\n    input [7:0] in2,\n    output reg [7:0] out\n);\n    always @* begin\n        out = in1 & in2;\n    end\nendmodule\nCODE END"}, "clean_code": "module add_sub_and (\n    input wire [7:0] in1,\n    input wire [7:0] in2,\n    input wire ctrl,\n    output wire [7:0] out,\n    output wire [7:0] out_and\n);\n\n    wire [7:0] add_in;\n    wire [7:0] sub_in;\n    wire [7:0] add_out;\n    wire [7:0] and_out;\n\n    // 2-to-1 multiplexer to select input based on control input\n    mux2to1 mux (\n        .in0(in1),\n        .in1(in2),\n        .sel(ctrl),\n        .out(add_in)\n    );\n\n    assign sub_in = in2; // Assign sub_in to in2 for subtraction\n\n    // 8-bit adder to perform addition or subtraction\n    adder8 adder (\n        .in1(add_in),\n        .in2(sub_in),\n        .sub(ctrl),\n        .out(add_out)\n    );\n\n    // Bitwise AND module to perform AND operation on inputs\n    and8 and_gate (\n        .in1(in1),\n        .in2(in2),\n        .out(and_out)\n    );\n\n    assign out = add_out;\n    assign out_and = and_out;\n\nendmodule\n\nmodule mux2to1 (\n    input [7:0] in0,\n    input [7:0] in1,\n    input sel,\n    output reg [7:0] out\n);\n    always @(*) begin\n        if (sel == 1'b0)\n            out = in0;\n        else\n            out = in1;\n    end\nendmodule\n\nmodule adder8 (\n    input [7:0] in1,\n    input [7:0] in2,\n    input sub,\n    output reg [7:0] out\n);\n    always @(*) begin\n        if (sub)\n            out = in1 - in2;\n        else\n            out = in1 + in2;\n    end\nendmodule\n\nmodule and8 (\n    input [7:0] in1,\n    input [7:0] in2,\n    output reg [7:0] out\n);\n    always @* begin\n        out = in1 & in2;\n    end\nendmodule", "corrupted_code": "module add_sub_and (\n    input wire [7:0] in1,\n    input wire [7:0] in2,\n    input wire ctrl,\n    output wire [7:0] out,\n    output wire [7:0] out_and\n);\n\n    wire [7:0] add_in;\n    wire [7:0] sub_in;\n    wire [7:0] add_out;\n    wire [7:0] and_out;\n\n    // 2-to-1 multiplexer to select input based on control input\n    mux2to1 mux (\n        .in0(in1),\n        .in1(in2),\n        .sel(ctrl),\n        .out(add_in)\n    );\n\n    assign sub_in = in2; // Assign sub_in to in2 for subtraction\n\n    // 8-bit adder to perform addition or subtraction\n    adder8 adder (\n        .in1(add_in),\n        .in2(sub_in),\n        .sub(ctrl),\n        .out(add_out)\n    );\n\n    // Bitwise AND module to perform AND operation on inputs\n    and8 and_gate (\n        .in1(in1),\n        .in2(in2),\n        .out(and_out)\n    );\n\n    assign out = add_out;\n    assign out_and = and_out;\n\nendmodule\n\nmodule mux2to1 (\n    input [7:0] in0,\n    input [7:0] in1,\n    input sel,\n    output reg [7:0] out\n);\n    \nendmodule\n\nmodule adder8 (\n    input [7:0] in1,\n    input [7:0] in2,\n    input sub,\n    output reg [7:0] out\n);\n    always @(*) begin\n        if (sub)\n            out = in1 - in2;\n        else\n            out = in1 + in2;\n    end\nendmodule\n\nmodule and8 (\n    input [7:0] in1,\n    input [7:0] in2,\n    output reg [7:0] out\n);\n    always @* begin\n        out = in1 & in2;\n    end\nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 50, "original_snippet": "always @(*) begin\n        if (sel == 1'b0)\n            out = in0;\n        else\n            out = in1;\n    end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 50: Original: always @(*) begin\n        if (sel == 1'b0)\n            out = in0;\n        else\n            out = in1;\n    end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 50.\n   \u2022 Restore the original code: always @(*) begin\n        if (sel == 1'b0)\n            out = in0;\n        else\n            out = in1;\n    end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 9, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_always_block", "swap_port_signals"], "timestamp": "2025-12-09T21:43:36.266208"}
{"original_entry": {"instruction": "\nWrite the Verilog code for a module named `top_module`.\nThe module has the following interface:\nInputs:\n- `a`: 16-bit wide\n- `b`: 16-bit wide\n- `shift`: 4-bit wide\n- `select`: 1-bit wide\nOutput:\n- `out`: 16-bit wide\n\nThe module should perform the following operations:\n1. Compute the sum of inputs `a` and `b`.\n2. Compute a value by left-shifting the sum from step 1 by the number of bit positions specified by the `shift` input. The `shift` value can range from 0 to 15.\n3. Compute the bitwise OR of the sum from step 1 and the shifted value from step 2.\n4. Assign the result of the bitwise OR from step 3 to the output `out`.\n\nYour implementation should match the behavior described.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule top_module (\n    input [15:0] a,\n    input [15:0] b,\n    input [3:0] shift,\n    input select,\n    output [15:0] out\n);\n\n    // 16-bit adder\n    wire [15:0] adder_out;\n    assign adder_out = a + b;\n\n    // 4-bit shifter\n    wire [15:0] shifter_out;\n    assign shifter_out = (shift == 4'd0) ? adder_out : (shift == 4'd1) ? {adder_out[14:0], 1'b0} :\n                         (shift == 4'd2) ? {adder_out[13:0], 2'b00} : (shift == 4'd3) ? {adder_out[12:0], 3'b000} :\n                         (shift == 4'd4) ? {adder_out[11:0], 4'b0000} : (shift == 4'd5) ? {adder_out[10:0], 5'b00000} :\n                         (shift == 4'd6) ? {adder_out[9:0], 6'b000000} : (shift == 4'd7) ? {adder_out[8:0], 7'b0000000} :\n                         (shift == 4'd8) ? {adder_out[7:0], 8'b00000000} : (shift == 4'd9) ? {adder_out[6:0], 9'b000000000} :\n                         (shift == 4'd10) ? {adder_out[5:0], 10'b0000000000} : (shift == 4'd11) ? {adder_out[4:0], 11'b00000000000} :\n                         (shift == 4'd12) ? {adder_out[3:0], 12'b000000000000} : (shift == 4'd13) ? {adder_out[2:0], 13'b0000000000000} :\n                         (shift == 4'd14) ? {adder_out[1:0], 14'b00000000000000} : (shift == 4'd15) ? {adder_out[0], 15'b000000000000000} : 16'b0;\n\n    // Functional module for bitwise OR\n    wire [15:0] or_out;\n    assign or_out = adder_out | shifter_out;\n\n    // Output selection\n    assign out = (select) ? shifter_out | or_out : adder_out | or_out;\n\nendmodule\nCODE END"}, "clean_code": "module top_module (\n    input [15:0] a,\n    input [15:0] b,\n    input [3:0] shift,\n    input select,\n    output [15:0] out\n);\n\n    // 16-bit adder\n    wire [15:0] adder_out;\n    assign adder_out = a + b;\n\n    // 4-bit shifter\n    wire [15:0] shifter_out;\n    assign shifter_out = (shift == 4'd0) ? adder_out : (shift == 4'd1) ? {adder_out[14:0], 1'b0} :\n                         (shift == 4'd2) ? {adder_out[13:0], 2'b00} : (shift == 4'd3) ? {adder_out[12:0], 3'b000} :\n                         (shift == 4'd4) ? {adder_out[11:0], 4'b0000} : (shift == 4'd5) ? {adder_out[10:0], 5'b00000} :\n                         (shift == 4'd6) ? {adder_out[9:0], 6'b000000} : (shift == 4'd7) ? {adder_out[8:0], 7'b0000000} :\n                         (shift == 4'd8) ? {adder_out[7:0], 8'b00000000} : (shift == 4'd9) ? {adder_out[6:0], 9'b000000000} :\n                         (shift == 4'd10) ? {adder_out[5:0], 10'b0000000000} : (shift == 4'd11) ? {adder_out[4:0], 11'b00000000000} :\n                         (shift == 4'd12) ? {adder_out[3:0], 12'b000000000000} : (shift == 4'd13) ? {adder_out[2:0], 13'b0000000000000} :\n                         (shift == 4'd14) ? {adder_out[1:0], 14'b00000000000000} : (shift == 4'd15) ? {adder_out[0], 15'b000000000000000} : 16'b0;\n\n    // Functional module for bitwise OR\n    wire [15:0] or_out;\n    assign or_out = adder_out | shifter_out;\n\n    // Output selection\n    assign out = (select) ? shifter_out | or_out : adder_out | or_out;\n\nendmodule", "corrupted_code": "module top_module (\n    input [15:0] a,\n    input [15:0] b,\n    input [3:0] shift,\n    input select,\n    output [15:0] out\n);\n\n    // 16-bit adder\n    wire [15:0] adder_out;\n    assign adder_out = a + b;\n\n    // 4-bit shifter\n    wire [15:0] shifter_out;\n    assign shifter_out = (shift == 4'd0) ? adder_out : (shift == 4'd1) ? {adder_out[14:0], 1'b0} :\n                         (shift == 4'd2) ? {adder_out[13:0], 2'b00} : (shift == 4'd2) ? {adder_out[12:0], 3'b000} :\n                         (shift == 4'd4) ? {adder_out[11:0], 4'b0000} : (shift == 4'd5) ? {adder_out[10:0], 5'b00000} :\n                         (shift == 4'd6) ? {adder_out[9:0], 6'b000000} : (shift == 4'd7) ? {adder_out[8:0], 7'b0000000} :\n                         (shift == 4'd8) ? {adder_out[7:0], 8'b00000000} : (shift == 4'd9) ? {adder_out[6:0], 9'b000000000} :\n                         (shift == 4'd10) ? {adder_out[5:0], 10'b0000000000} : (shift == 4'd11) ? {adder_out[4:0], 11'b00000000000} :\n                         (shift == 4'd12) ? {adder_out[3:0], 12'b000000000000} : (shift == 4'd13) ? {adder_out[2:0], 13'b0000000000000} :\n                         (shift == 4'd14) ? {adder_out[1:0], 14'b00000000000000} : (shift == 4'd15) ? {adder_out[0], 15'b000000000000000} : 16'b0;\n\n    // Functional module for bitwise OR\n    wire [15:0] or_out;\n    assign or_out = adder_out | shifter_out;\n\n    // Output selection\n    assign out = (select) ? shifter_out | or_out : adder_out | or_out;\n\nendmodule", "corruption_explanation": "Changed constant from 4'd3 to 4'd2", "modification_type": "change_constant", "modification_line": 16, "original_snippet": "4'd3", "modified_snippet": "4'd2", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 4'd3 to 4'd2\n   \u2022 Line 16: Original: 4'd3\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 16.\n   \u2022 Restore the original code: 4'd3\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 22, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver"], "timestamp": "2025-12-09T21:43:36.268497"}
{"original_entry": {"instruction": "\nWrite Verilog code for the following modules, ensuring they have the specified interfaces and implement the described functionality.\n\n1.  **`decoder_2to4`**\n    *   Inputs: `input [1:0] in`\n    *   Outputs: `output [3:0] out`\n    *   Functionality: A basic 2-to-4 decoder. The output `out` should be a one-hot encoding where the high bit corresponds to the binary value of the input `in`.\n\n2.  **`decoder_2to4_with_enable`**\n    *   Inputs: `input [1:0] in`, `input enable`\n    *   Outputs: `output [3:0] out`\n    *   Functionality: A 2-to-4 decoder with an active-high enable. When `enable` is high, the output `out` is the one-hot encoding based on `in` (as in `decoder_2to4`). When `enable` is low, the output `out` should be all zeros. This module should instantiate the `decoder_2to4` module.\n\n3.  **`and_gate_5input`**\n    *   Inputs: `input [4:0] in`, `input enable`\n    *   Outputs: `output out`\n    *   Functionality: A 5-input AND gate with an active-high enable. If `enable` is high, the output `out` is the logical AND of all 5 bits in `in`. If `enable` is low, the output `out` is 0.\n\n4.  **`or_gate_5input`**\n    *   Inputs: `input [4:0] in`, `input enable`\n    *   Outputs: `output out`\n    *   Functionality: A 5-input OR gate with an active-high enable. If `enable` is high, the output `out` is the logical OR of all 5 bits in `in`. If `enable` is low, the output `out` is 0.\n\n5.  **`nor_gate_5input`**\n    *   Inputs: `input [4:0] in`, `input enable`\n    *   Outputs: `output out`\n    *   Functionality: A 5-input NOR gate with an active-high enable. Implement this module by instantiating the `or_gate_5input` module and logically inverting its output. Note that due to this implementation method, when `enable` is low, the output `out` will be 1.\n\n6.  **`top_module`**\n    *   Inputs: `input [4:0] in`, `input select`\n    *   Outputs: `output out_and`, `output out_or`, `output out_nor`\n    *   Functionality: This module acts as a demultiplexer for logic operations. It uses the lower two bits of the input `in` (`in[1:0]`) to determine which of the three 5-input logic gates (AND, OR, NOR) is enabled, but only if the `select` signal is high.\n        *   If `select` is high and `in[1:0]` is `2'b00`, the `and_gate_5input` should be enabled.\n        *   If `select` is high and `in[1:0]` is `2'b01`, the `or_gate_5input` should be enabled.\n        *   If `select` is high and `in[1:0]` is `2'b10`, the `nor_gate_5input` should be enabled.\n        *   If `select` is low, or if `in[1:0]` is `2'b11` (when `select` is high), none of the logic gates should be enabled by this mechanism.\n    *   The outputs `out_and`, `out_or`, and `out_nor` should be connected to the outputs of the corresponding logic gates. This module must instantiate the `decoder_2to4_with_enable`, `and_gate_5input`, `or_gate_5input`, and `nor_gate_5input` modules and connect them appropriately to achieve the described behavior.\n\nProvide the Verilog code for all six modules.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule top_module(\n    input [4:0] in,\n    input select,\n    output out_and,\n    output out_or,\n    output out_nor\n);\n\nwire [3:0] decoder_out;\nwire en_and, en_or, en_nor;\n\ndecoder_2to4_with_enable dec(\n    .in(in[1:0]),\n    .enable(select),\n    .out(decoder_out)\n);\n\nand_gate_5input and_gate(\n    .in(in),\n    .enable(en_and),\n    .out(out_and)\n);\n\nor_gate_5input or_gate(\n    .in(in),\n    .enable(en_or),\n    .out(out_or)\n);\n\nnor_gate_5input nor_gate(\n    .in(in),\n    .enable(en_nor),\n    .out(out_nor)\n);\n\nassign en_and = decoder_out[0];\nassign en_or = decoder_out[1];\nassign en_nor = decoder_out[2];\n\nendmodule\n\nmodule decoder_2to4_with_enable(\n    input [1:0] in,\n    input enable,\n    output [3:0] out\n);\n\nwire [3:0] dec_out;\n\ndecoder_2to4 dec(\n    .in(in),\n    .out(dec_out)\n);\n\nassign out = enable ? dec_out : 4'b0000;\n\nendmodule\n\nmodule decoder_2to4(\n    input [1:0] in,\n    output [3:0] out\n);\n\nassign out = 4'b0001 << in;\n\nendmodule\n\nmodule and_gate_5input(\n    input [4:0] in,\n    input enable,\n    output out\n);\n\nassign out = enable ? (in[0] & in[1] & in[2] & in[3] & in[4]) : 1'b0;\n\nendmodule\n\nmodule or_gate_5input(\n    input [4:0] in,\n    input enable,\n    output out\n);\n\nassign out = enable ? (in[0] | in[1] | in[2] | in[3] | in[4]) : 1'b0;\n\nendmodule\n\nmodule nor_gate_5input(\n    input [4:0] in,\n    input enable,\n    output out\n);\n\nwire or_out;\n\nor_gate_5input or_gate(\n    .in(in),\n    .enable(enable),\n    .out(or_out)\n);\n\nassign out = ~or_out;\n\nendmodule\nCODE END"}, "clean_code": "module top_module(\n    input [4:0] in,\n    input select,\n    output out_and,\n    output out_or,\n    output out_nor\n);\n\nwire [3:0] decoder_out;\nwire en_and, en_or, en_nor;\n\ndecoder_2to4_with_enable dec(\n    .in(in[1:0]),\n    .enable(select),\n    .out(decoder_out)\n);\n\nand_gate_5input and_gate(\n    .in(in),\n    .enable(en_and),\n    .out(out_and)\n);\n\nor_gate_5input or_gate(\n    .in(in),\n    .enable(en_or),\n    .out(out_or)\n);\n\nnor_gate_5input nor_gate(\n    .in(in),\n    .enable(en_nor),\n    .out(out_nor)\n);\n\nassign en_and = decoder_out[0];\nassign en_or = decoder_out[1];\nassign en_nor = decoder_out[2];\n\nendmodule\n\nmodule decoder_2to4_with_enable(\n    input [1:0] in,\n    input enable,\n    output [3:0] out\n);\n\nwire [3:0] dec_out;\n\ndecoder_2to4 dec(\n    .in(in),\n    .out(dec_out)\n);\n\nassign out = enable ? dec_out : 4'b0000;\n\nendmodule\n\nmodule decoder_2to4(\n    input [1:0] in,\n    output [3:0] out\n);\n\nassign out = 4'b0001 << in;\n\nendmodule\n\nmodule and_gate_5input(\n    input [4:0] in,\n    input enable,\n    output out\n);\n\nassign out = enable ? (in[0] & in[1] & in[2] & in[3] & in[4]) : 1'b0;\n\nendmodule\n\nmodule or_gate_5input(\n    input [4:0] in,\n    input enable,\n    output out\n);\n\nassign out = enable ? (in[0] | in[1] | in[2] | in[3] | in[4]) : 1'b0;\n\nendmodule\n\nmodule nor_gate_5input(\n    input [4:0] in,\n    input enable,\n    output out\n);\n\nwire or_out;\n\nor_gate_5input or_gate(\n    .in(in),\n    .enable(enable),\n    .out(or_out)\n);\n\nassign out = ~or_out;\n\nendmodule", "corrupted_code": "module top_module(\n    input [4:0] in,\n    input select,\n    output out_and,\n    output out_or,\n    output out_nor\n);\n\nwire [3:0] decoder_out;\nwire en_and, en_or, en_nor;\n\ndecoder_2to4_with_enable dec(\n    .in(in[1:0]),\n    .enable(select),\n    .out(decoder_out)\n);\n\nand_gate_5input and_gate(\n    .in(in),\n    .enable(en_and),\n    .out(out_and)\n);\n\nor_gate_5input or_gate(\n    .in(in),\n    .enable(en_or),\n    .out(out_or)\n);\n\nnor_gate_5input nor_gate(\n    .in(in),\n    .enable(en_nor),\n    .out(out_nor)\n);\n\nassign en_and = decoder_out[0];\nassign en_or = decoder_out[1];\nassign en_nor = decoder_out[2];\n\nendmodule\n\nmodule decoder_2to4_with_enable(\n    input [1:0] in,\n    input enable,\n    output [3:0] out\n);\n\nwire [3:0] dec_out;\n\ndecoder_2to4 dec(\n    .in(in),\n    .out(dec_out)\n);\n\nassign out = enable ? dec_out : 4'b0000;\n\nendmodule\n\nmodule decoder_2to4(\n    input [1:0] in,\n    output [3:0] out\n);\n\nassign out = 4'b0000 << in;\n\nendmodule\n\nmodule and_gate_5input(\n    input [4:0] in,\n    input enable,\n    output out\n);\n\nassign out = enable ? (in[0] & in[1] & in[2] & in[3] & in[4]) : 1'b0;\n\nendmodule\n\nmodule or_gate_5input(\n    input [4:0] in,\n    input enable,\n    output out\n);\n\nassign out = enable ? (in[0] | in[1] | in[2] | in[3] | in[4]) : 1'b0;\n\nendmodule\n\nmodule nor_gate_5input(\n    input [4:0] in,\n    input enable,\n    output out\n);\n\nwire or_out;\n\nor_gate_5input or_gate(\n    .in(in),\n    .enable(enable),\n    .out(or_out)\n);\n\nassign out = ~or_out;\n\nendmodule", "corruption_explanation": "Changed constant from 4'b0001 to 4'b0000", "modification_type": "change_constant", "modification_line": 64, "original_snippet": "4'b0001", "modified_snippet": "4'b0000", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 4'b0001 to 4'b0000\n   \u2022 Line 64: Original: 4'b0001\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 64.\n   \u2022 Restore the original code: 4'b0001\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 1, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "timestamp": "2025-12-09T21:43:36.271063"}
{"original_entry": {"instruction": "\nDesign a Verilog module hierarchy consisting of three modules: `counter_4bit_sync_reset_load`, `decoder_4to16`, and `top_module`.\n\n1.  **Module: `counter_4bit_sync_reset_load`**\n    *   Interface:\n        *   Inputs: `CLK`, `RESET`, `LOAD`, `LOAD_VAL [3:0]`\n        *   Output: `Q [3:0]`\n    *   Functionality: Implement a 4-bit counter. The counter should increment on the positive edge of `CLK` unless reset or loaded. It should have a synchronous active-high reset (`RESET`) that forces the counter to 0. It should also have a synchronous active-high load (`LOAD`) that loads the value from `LOAD_VAL` when asserted. Reset should have the highest priority, followed by load, and then increment.\n\n2.  **Module: `decoder_4to16`**\n    *   Interface:\n        *   Input: `in [3:0]`\n        *   Output: `out [15:0]`\n    *   Functionality: Implement a 4-to-16 decoder. The output `out` should have exactly one bit set to '1', corresponding to the binary value of the `in` input. All other bits should be '0'.\n\n3.  **Module: `top_module`**\n    *   Interface:\n        *   Inputs: `CLK`, `RESET`, `LOAD`, `LOAD_VAL [3:0]`, `in [3:0]`\n        *   Outputs: `out [15:0]`, `Q [3:0]`\n    *   Functionality:\n        *   Instantiate one instance of the `counter_4bit_sync_reset_load` module. Connect its clock, reset, load, and load value inputs to the corresponding inputs of the `top_module`.\n        *   Instantiate one instance of the `decoder_4to16` module. Connect its input to the output (`Q`) of the `counter_4bit_sync_reset_load` instance. Connect its output (`out`) to the `out` output of the `top_module`.\n        *   The `Q` output of the `top_module` should be the result of a bitwise AND operation between the output (`Q`) of the `counter_4bit_sync_reset_load` instance and the bitwise NOT of the output (`out`) of the `decoder_4to16` instance.\n\nWrite the Verilog code for these three modules.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule counter_4bit_sync_reset_load (\n    input CLK,          // Clock input\n    input RESET,        // Synchronous active-high reset\n    input LOAD,         // Load input for the counter\n    input [3:0] LOAD_VAL, // Value to load into counter when LOAD is high\n    output [3:0] Q        // Output from the counter\n);\n\nreg [3:0] Q_reg;          // Internal register for counter\nassign Q = Q_reg;          // Output the value of Q_reg\n\nalways @(posedge CLK) begin\n    if (RESET) begin\n        Q_reg <= 0;\n    end else if (LOAD) begin\n        Q_reg <= LOAD_VAL;\n    end else begin\n        Q_reg <= Q_reg + 1;\n    end\nend\n\nendmodule\n\nmodule decoder_4to16 (\n    input [3:0] in,     // Input to the decoder\n    output [15:0] out  // Output from the decoder\n);\n\nassign out = 1 << in;\n\nendmodule\n\nmodule top_module (\n    input CLK,          // Clock input\n    input RESET,        // Synchronous active-high reset\n    input LOAD,         // Load input for the counter\n    input [3:0] LOAD_VAL, // Value to load into counter when LOAD is high\n    input [3:0] in,     // Input to the decoder\n    output [15:0] out,  // Output from the decoder\n    output [3:0] Q\n);\n\nwire [3:0] count;\n\ncounter_4bit_sync_reset_load counter (\n    .CLK(CLK),\n    .RESET(RESET),\n    .LOAD(LOAD),\n    .LOAD_VAL(LOAD_VAL),\n    .Q(count)\n);\n\ndecoder_4to16 decoder (\n    .in(count),\n    .out(out)\n);\n\n// Perform bitwise AND operation on the counter output and decoder output\nassign Q = count & ~out;\n\nendmodule\n\nCODE END"}, "clean_code": "module counter_4bit_sync_reset_load (\n    input CLK,          // Clock input\n    input RESET,        // Synchronous active-high reset\n    input LOAD,         // Load input for the counter\n    input [3:0] LOAD_VAL, // Value to load into counter when LOAD is high\n    output [3:0] Q        // Output from the counter\n);\n\nreg [3:0] Q_reg;          // Internal register for counter\nassign Q = Q_reg;          // Output the value of Q_reg\n\nalways @(posedge CLK) begin\n    if (RESET) begin\n        Q_reg <= 0;\n    end else if (LOAD) begin\n        Q_reg <= LOAD_VAL;\n    end else begin\n        Q_reg <= Q_reg + 1;\n    end\nend\n\nendmodule\n\nmodule decoder_4to16 (\n    input [3:0] in,     // Input to the decoder\n    output [15:0] out  // Output from the decoder\n);\n\nassign out = 1 << in;\n\nendmodule\n\nmodule top_module (\n    input CLK,          // Clock input\n    input RESET,        // Synchronous active-high reset\n    input LOAD,         // Load input for the counter\n    input [3:0] LOAD_VAL, // Value to load into counter when LOAD is high\n    input [3:0] in,     // Input to the decoder\n    output [15:0] out,  // Output from the decoder\n    output [3:0] Q\n);\n\nwire [3:0] count;\n\ncounter_4bit_sync_reset_load counter (\n    .CLK(CLK),\n    .RESET(RESET),\n    .LOAD(LOAD),\n    .LOAD_VAL(LOAD_VAL),\n    .Q(count)\n);\n\ndecoder_4to16 decoder (\n    .in(count),\n    .out(out)\n);\n\n// Perform bitwise AND operation on the counter output and decoder output\nassign Q = count & ~out;\n\nendmodule", "corrupted_code": "module counter_4bit_sync_reset_load (\n    input CLK,          // Clock input\n    input RESET,        // Synchronous active-high reset\n    input LOAD,         // Load input for the counter\n    input [3:0] LOAD_VAL, // Value to load into counter when LOAD is high\n    output [3:0] Q        // Output from the counter\n);\n\nreg [3:0] Q_reg;          // Internal register for counter\nassign Q = Q_reg;          // Output the value of Q_reg\n\nalways @(posedge CLK) begin\n    if (RESET) begin\n\n    end else if (LOAD) begin\n        Q_reg <= LOAD_VAL;\n    end else begin\n        Q_reg <= Q_reg + 1;\n    end\nend\n\nendmodule\n\nmodule decoder_4to16 (\n    input [3:0] in,     // Input to the decoder\n    output [15:0] out  // Output from the decoder\n);\n\nassign out = 1 << in;\n\nendmodule\n\nmodule top_module (\n    input CLK,          // Clock input\n    input RESET,        // Synchronous active-high reset\n    input LOAD,         // Load input for the counter\n    input [3:0] LOAD_VAL, // Value to load into counter when LOAD is high\n    input [3:0] in,     // Input to the decoder\n    output [15:0] out,  // Output from the decoder\n    output [3:0] Q\n);\n\nwire [3:0] count;\n\ncounter_4bit_sync_reset_load counter (\n    .CLK(CLK),\n    .RESET(RESET),\n    .LOAD(LOAD),\n    .LOAD_VAL(LOAD_VAL),\n    .Q(count)\n);\n\ndecoder_4to16 decoder (\n    .in(count),\n    .out(out)\n);\n\n// Perform bitwise AND operation on the counter output and decoder output\nassign Q = count & ~out;\n\nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 14, "original_snippet": "Q_reg <= 0;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 14: Original: Q_reg <= 0;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 14.\n   \u2022 Restore the original code: Q_reg <= 0;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 10, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "swap_port_signals", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.273429"}
{"original_entry": {"instruction": "\nDesign a Verilog module hierarchy consisting of four modules: `square_wave_generator`, `adder`, `final_module`, and `top_module`.\n\n1.  **`square_wave_generator` Module:**\n    *   Interface:\n        *   Inputs: `clk` (1-bit), `reset` (1-bit)\n        *   Output: `square_wave` (1-bit, registered)\n    *   Function: This module should generate a periodic square wave signal on the `square_wave` output. The signal should toggle its state based on the `clk` input. A high `reset` input should asynchronously set the `square_wave` output to 0. The specific frequency division factor should be implemented such that the square wave toggles its state after a fixed, large number of clock cycles (e.g., suitable for generating a very slow signal like 1Hz from a typical clock frequency).\n\n2.  **`adder` Module:**\n    *   Interface:\n        *   Inputs: `A` (16-bit), `B` (16-bit), `Cin` (1-bit)\n        *   Outputs: `S` (16-bit), `Cout` (1-bit)\n    *   Function: This should be a combinational module that performs a 16-bit binary addition of `A`, `B`, and `Cin`, producing the 16-bit sum `S` and the carry-out `Cout`.\n\n3.  **`final_module` Module:**\n    *   Interface:\n        *   Inputs: `clk` (1-bit), `reset` (1-bit), `A` (16-bit), `B` (16-bit), `Cin` (1-bit)\n        *   Output: `final_output` (16-bit)\n    *   Function: This module should instantiate the `square_wave_generator` and `adder` modules. It should also calculate the difference `A - B`. The module's `final_output` should be determined by the state of the `square_wave` signal from the `square_wave_generator`.\n        *   When `square_wave` is high, `final_output` should be the sum of the `adder`'s output (with inputs `A`, `B`, `Cin`) and the difference `(A - B)`.\n        *   When `square_wave` is low, `final_output` should be the difference between the `adder`'s output (with inputs `A`, `B`, `Cin`) and the difference `(A - B)`.\n    *   Note: The carry-out from the `adder` instance is not used in the `final_output` calculation.\n\n4.  **`top_module` Module:**\n    *   Interface:\n        *   Inputs: `clk` (1-bit), `reset` (1-bit), `A` (16-bit), `B` (16-bit), `Cin` (1-bit)\n        *   Output: `final_output` (16-bit)\n    *   Function: This module should instantiate the `final_module` and connect its inputs and outputs directly to the top-level ports.\n\nWrite the Verilog code for all four modules following the specified interfaces and functionality.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule square_wave_generator (\n    input clk,\n    input reset,\n    output reg square_wave\n);\n\nreg [31:0] counter;\n\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        square_wave <= 1'b0;\n        counter <= 32'd0;\n    end else begin\n        if (counter == 32'd49999999) begin\n            counter <= 32'd0;\n            square_wave <= ~square_wave;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nendmodule\n\nmodule adder (\n    input [15:0] A,\n    input [15:0] B,\n    input Cin,\n    output [15:0] S,\n    output Cout\n);\n\nassign {Cout, S} = A + B + Cin;\n\nendmodule\n\nmodule final_module (\n    input clk,\n    input reset,\n    input [15:0] A,\n    input [15:0] B,\n    input Cin,\n    output [15:0] final_output\n);\n\nwire square_wave;\nwire [15:0] adder_output;\nwire [15:0] subtractor_output;\n\nsquare_wave_generator square_wave_gen (\n    .clk(clk),\n    .reset(reset),\n    .square_wave(square_wave)\n);\n\nadder adder_inst (\n    .A(A),\n    .B(B),\n    .Cin(Cin),\n    .S(adder_output),\n    .Cout()\n);\n\nassign subtractor_output = A - B;\n\nassign final_output = square_wave ? adder_output + subtractor_output : adder_output - subtractor_output;\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [15:0] A,\n    input [15:0] B,\n    input Cin,\n    output [15:0] final_output\n);\n\nfinal_module final_inst (\n    .clk(clk),\n    .reset(reset),\n    .A(A),\n    .B(B),\n    .Cin(Cin),\n    .final_output(final_output)\n);\n\nendmodule\n\nCODE END"}, "clean_code": "module square_wave_generator (\n    input clk,\n    input reset,\n    output reg square_wave\n);\n\nreg [31:0] counter;\n\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        square_wave <= 1'b0;\n        counter <= 32'd0;\n    end else begin\n        if (counter == 32'd49999999) begin\n            counter <= 32'd0;\n            square_wave <= ~square_wave;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nendmodule\n\nmodule adder (\n    input [15:0] A,\n    input [15:0] B,\n    input Cin,\n    output [15:0] S,\n    output Cout\n);\n\nassign {Cout, S} = A + B + Cin;\n\nendmodule\n\nmodule final_module (\n    input clk,\n    input reset,\n    input [15:0] A,\n    input [15:0] B,\n    input Cin,\n    output [15:0] final_output\n);\n\nwire square_wave;\nwire [15:0] adder_output;\nwire [15:0] subtractor_output;\n\nsquare_wave_generator square_wave_gen (\n    .clk(clk),\n    .reset(reset),\n    .square_wave(square_wave)\n);\n\nadder adder_inst (\n    .A(A),\n    .B(B),\n    .Cin(Cin),\n    .S(adder_output),\n    .Cout()\n);\n\nassign subtractor_output = A - B;\n\nassign final_output = square_wave ? adder_output + subtractor_output : adder_output - subtractor_output;\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [15:0] A,\n    input [15:0] B,\n    input Cin,\n    output [15:0] final_output\n);\n\nfinal_module final_inst (\n    .clk(clk),\n    .reset(reset),\n    .A(A),\n    .B(B),\n    .Cin(Cin),\n    .final_output(final_output)\n);\n\nendmodule", "corrupted_code": "module square_wave_generator (\n    input clk,\n    input reset,\n    output reg square_wave\n);\n\nreg [31:0] counter;\n\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        square_wave <= 1'b0;\n        counter <= 32'd0;\n    end else begin\n        if (counter == 32'd49999999) begin\n            counter <= 32'd0;\n            square_wave <= ~square_wave;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nendmodule\n\nmodule adder (\n    input [15:0] A,\n    input [15:0] B,\n    input Cin,\n    output [15:0] S,\n    output Cout\n);\n\nassign {Cout, S} = A + B + Cin;\n\nendmodule\n\nmodule final_module (\n    input clk,\n    input reset,\n    input [15:0] A,\n    input [15:0] B,\n    input Cin,\n    output [15:0] final_output\n);\n\nwire square_wave;\nwire [15:0] adder_output;\nwire [15:0] subtractor_output;\n\nsquare_wave_generator square_wave_gen (\n    .clk(clk),\n    .reset(reset),\n    .square_wave(square_wave)\n);\n\nadder adder_inst (\n    .A(A),\n    .B(B),\n    .Cin(Cin),\n    .S(adder_output),\n    .Cout()\n);\n\nassign subtractor_output = A - B;\nassign subtractor_output = 1'b0;  // Conflicting assignment\n\nassign final_output = square_wave ? adder_output + subtractor_output : adder_output - subtractor_output;\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [15:0] A,\n    input [15:0] B,\n    input Cin,\n    output [15:0] final_output\n);\n\nfinal_module final_inst (\n    .clk(clk),\n    .reset(reset),\n    .A(A),\n    .B(B),\n    .Cin(Cin),\n    .final_output(final_output)\n);\n\nendmodule", "corruption_explanation": "Added conflicting driver for signal 'subtractor_output'", "modification_type": "add_multiple_driver", "modification_line": 63, "original_snippet": "assign subtractor_output = A - B;", "modified_snippet": "assign subtractor_output = A - B;\nassign subtractor_output = 1'b0;  // Conflicting assignment", "issue_description": "The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_multiple_driver modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added conflicting driver for signal 'subtractor_output'\n   \u2022 Line 63: Original: assign subtractor_output = A - B;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 63.\n   \u2022 Restore the original code: assign subtractor_output = A - B;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add multiple driver.", "complexity": 13, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "swap_port_signals", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.275838"}
{"original_entry": {"instruction": "\nWrite Verilog code for a module hierarchy consisting of three modules: `top_module`, `barrel_shifter`, and `adder_subtractor`.\n\n**Module `barrel_shifter`:**\nImplement a synchronous 4-bit barrel left shifter with a registered output.\n*   Inputs:\n    *   `DATA [3:0]`: The data to be shifted.\n    *   `SHIFT signed [3:0]`: The shift amount.\n    *   `RESET`: Synchronous reset (active high).\n    *   `clk`: Clock signal.\n*   Output:\n    *   `OUT [3:0]`: The registered shifted data.\nOn the positive clock edge, if `RESET` is high, the output should be reset to 4'b0000. Otherwise, the output should be the result of shifting `DATA` left by the amount specified by `SHIFT`.\n\n**Module `adder_subtractor`:**\nImplement a synchronous 4-bit adder/subtractor with a registered output.\n*   Inputs:\n    *   `A [3:0]`: First operand.\n    *   `B [3:0]`: Second operand.\n    *   `SUB`: Control signal (1 for subtract, 0 for add).\n    *   `RESET`: Synchronous reset (active high).\n    *   `clk`: Clock signal.\n*   Output:\n    *   `OUT [3:0]`: The registered arithmetic result.\nOn the positive clock edge, if `RESET` is high, the output should be reset to 4'b0000. Otherwise, if `SUB` is high, the output should be `A - B`. If `SUB` is low, the output should be `A + B`.\n\n**Module `top_module`:**\nImplement the top-level module that instantiates and connects the `barrel_shifter` and `adder_subtractor` modules, and computes its final output.\n*   Inputs:\n    *   `DATA [3:0]`: Input data.\n    *   `SHIFT signed [3:0]`: Shift amount for the barrel shifter.\n    *   `SUB`: Control signal used both for the adder/subtractor and the final output logic.\n    *   `RESET`: Synchronous reset (active high).\n    *   `clk`: Clock signal.\n*   Output:\n    *   `OUT reg [3:0]`: The final registered output.\nOn the positive clock edge, if `RESET` is high, the output `OUT` should be reset to 4'b0000. Otherwise, the logic should proceed as follows:\n1.  Instantiate the `barrel_shifter` module, passing `DATA`, `SHIFT`, `RESET`, and `clk`. Let the output of the shifter be `shifted_data`.\n2.  Instantiate the `adder_subtractor` module, passing `shifted_data` as the first operand (`A`), `DATA` as the second operand (`B`), the `SUB` input, `RESET`, and `clk`. Let the output of the adder/subtractor be `add_sub_out`.\n3.  Update the `OUT` register:\n    *   If the `SUB` input is high, `OUT` should be updated with the value of `add_sub_out`.\n    *   If the `SUB` input is low, `OUT` should be updated with the sum of `add_sub_out` and `shifted_data`.\n\nEnsure all inputs and outputs are named exactly as specified and have the correct widths and signedness where indicated.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule top_module (\n    input [3:0] DATA,\n    input signed [3:0] SHIFT,\n    input SUB,\n    input RESET,\n    input clk,\n    output reg [3:0] OUT\n);\n\nwire [3:0] shifted_data;\nwire [3:0] add_sub_out;\n\nbarrel_shifter barrel_shifter_inst (\n    .DATA(DATA),\n    .SHIFT(SHIFT),\n    .OUT(shifted_data),\n    .RESET(RESET),\n    .clk(clk)\n);\n\nadder_subtractor add_sub_inst (\n    .A(shifted_data),\n    .B(DATA),\n    .SUB(SUB),\n    .OUT(add_sub_out),\n    .RESET(RESET),\n    .clk(clk)\n);\n\nalways @ (posedge clk) begin\n    if (RESET) begin\n        OUT <= 4'b0000;\n    end else begin\n        if (SUB) begin\n            OUT <= add_sub_out;\n        end else begin\n            OUT <= add_sub_out + shifted_data;\n        end\n    end\nend\n\nendmodule\n\nmodule barrel_shifter (\n    input [3:0] DATA,\n    input signed [3:0] SHIFT,\n    output [3:0] OUT,\n    input RESET,\n    input clk\n);\n\nreg [3:0] OUT_reg;\n\nalways @ (posedge clk) begin\n    if (RESET) begin\n        OUT_reg <= 4'b0000;\n    end else begin\n        OUT_reg <= DATA << SHIFT;\n    end\nend\n\nassign OUT = OUT_reg;\n\nendmodule\n\nmodule adder_subtractor (\n    input [3:0] A,\n    input [3:0] B,\n    input SUB,\n    output [3:0] OUT,\n    input RESET,\n    input clk\n);\n\nreg [3:0] OUT_reg;\n\nalways @ (posedge clk) begin\n    if (RESET) begin\n        OUT_reg <= 4'b0000;\n    end else begin\n        if (SUB) begin\n            OUT_reg <= A - B;\n        end else begin\n            OUT_reg <= A + B;\n        end\n    end\nend\n\nassign OUT = OUT_reg;\n\nendmodule\n\nCODE END"}, "clean_code": "module top_module (\n    input [3:0] DATA,\n    input signed [3:0] SHIFT,\n    input SUB,\n    input RESET,\n    input clk,\n    output reg [3:0] OUT\n);\n\nwire [3:0] shifted_data;\nwire [3:0] add_sub_out;\n\nbarrel_shifter barrel_shifter_inst (\n    .DATA(DATA),\n    .SHIFT(SHIFT),\n    .OUT(shifted_data),\n    .RESET(RESET),\n    .clk(clk)\n);\n\nadder_subtractor add_sub_inst (\n    .A(shifted_data),\n    .B(DATA),\n    .SUB(SUB),\n    .OUT(add_sub_out),\n    .RESET(RESET),\n    .clk(clk)\n);\n\nalways @ (posedge clk) begin\n    if (RESET) begin\n        OUT <= 4'b0000;\n    end else begin\n        if (SUB) begin\n            OUT <= add_sub_out;\n        end else begin\n            OUT <= add_sub_out + shifted_data;\n        end\n    end\nend\n\nendmodule\n\nmodule barrel_shifter (\n    input [3:0] DATA,\n    input signed [3:0] SHIFT,\n    output [3:0] OUT,\n    input RESET,\n    input clk\n);\n\nreg [3:0] OUT_reg;\n\nalways @ (posedge clk) begin\n    if (RESET) begin\n        OUT_reg <= 4'b0000;\n    end else begin\n        OUT_reg <= DATA << SHIFT;\n    end\nend\n\nassign OUT = OUT_reg;\n\nendmodule\n\nmodule adder_subtractor (\n    input [3:0] A,\n    input [3:0] B,\n    input SUB,\n    output [3:0] OUT,\n    input RESET,\n    input clk\n);\n\nreg [3:0] OUT_reg;\n\nalways @ (posedge clk) begin\n    if (RESET) begin\n        OUT_reg <= 4'b0000;\n    end else begin\n        if (SUB) begin\n            OUT_reg <= A - B;\n        end else begin\n            OUT_reg <= A + B;\n        end\n    end\nend\n\nassign OUT = OUT_reg;\n\nendmodule", "corrupted_code": "module top_module (\n    input [3:0] DATA,\n    input signed [3:0] SHIFT,\n    input SUB,\n    input RESET,\n    input clk,\n    output reg [3:0] OUT\n);\n\nwire [3:0] shifted_data;\nwire [3:0] add_sub_out;\n\nbarrel_shifter barrel_shifter_inst (\n    .DATA(DATA),\n    .SHIFT(SHIFT),\n    .OUT(shifted_data),\n    .RESET(RESET),\n    .clk(clk)\n);\n\nadder_subtractor add_sub_inst (\n    .A(shifted_data),\n    .B(DATA),\n    .SUB(SUB),\n    .OUT(add_sub_out),\n    .RESET(RESET),\n    .clk(clk)\n);\n\nalways @ (posedge clk) begin\n    if (RESET) begin\n        OUT <= 4'b0000;\n    end else begin\n        if (SUB) begin\n            OUT <= add_sub_out;\n        end else begin\n            OUT <= add_sub_out + shifted_data;\n        end\n    end\nend\n\nendmodule\n\nmodule barrel_shifter (\n    input [3:0] DATA,\n    input signed [3:0] SHIFT,\n    output [3:0] OUT,\n    input RESET,\n    input clk\n);\n\nreg [3:0] OUT_reg;\n\nalways @ (posedge clk) begin\n    if (RESET) begin\n        OUT_reg <= 4'b0000;\n    end else begin\n        OUT_reg >= DATA << SHIFT;\n    end\nend\n\nassign OUT = OUT_reg;\n\nendmodule\n\nmodule adder_subtractor (\n    input [3:0] A,\n    input [3:0] B,\n    input SUB,\n    output [3:0] OUT,\n    input RESET,\n    input clk\n);\n\nreg [3:0] OUT_reg;\n\nalways @ (posedge clk) begin\n    if (RESET) begin\n        OUT_reg <= 4'b0000;\n    end else begin\n        if (SUB) begin\n            OUT_reg <= A - B;\n        end else begin\n            OUT_reg <= A + B;\n        end\n    end\nend\n\nassign OUT = OUT_reg;\n\nendmodule", "corruption_explanation": "Changed operator from '<=' to '>='", "modification_type": "change_operator", "modification_line": 58, "original_snippet": "g <= D", "modified_snippet": "g >= D", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '<=' to '>='\n   \u2022 Line 58: Original: g <= D\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 58.\n   \u2022 Restore the original code: g <= D\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 20, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "swap_port_signals", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.278507"}
{"original_entry": {"instruction": "\nDesign two Verilog modules as described below.\n\n1.  **Module Name:** `detect_input_change`\n    *   **Inputs:**\n        *   `clk`: Clock input.\n        *   `in`: 32-bit input data.\n    *   **Outputs:**\n        *   `out`: 32-bit registered output.\n    *   **Behavior:** On the positive edge of the clock, for each bit position in the 32-bit input `in`, the corresponding bit in the 32-bit output `out` should be set to 1 if and only if that bit in `in` has just transitioned from a 1 to a 0 on this clock edge. Otherwise, the output bit should be 0.\n\n2.  **Module Name:** `top_module`\n    *   **Inputs:**\n        *   `clk`: Clock input.\n        *   `reset`: Reset input (synchronous or asynchronous reset behavior is not specified by the provided code, but the port should be included).\n        *   `in`: 32-bit input data.\n    *   **Outputs:**\n        *   `out`: 32-bit output data.\n    *   **Behavior:** Instantiate the `detect_input_change` module. Connect the top-level `clk` and `in` ports to the corresponding ports of the instantiated module. The top-level `out` port should be directly connected to the `out` port of the instantiated `detect_input_change` module.\n\nImplement the Verilog code for these two modules based on the specified interfaces and behaviors.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule detect_input_change (\n    input clk,\n    input [31:0] in,\n    output reg [31:0] out\n);\n\nreg [31:0] prev_in;\n\nalways @(posedge clk) begin\n    prev_in <= in;\n    out <= (prev_in ^ in) & ~in;\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output [31:0] out\n);\n\nwire [31:0] detect_change;\n\ndetect_input_change detect_inst (\n    .clk(clk),\n    .in(in),\n    .out(detect_change)\n);\n\nassign out = detect_change;\n\nendmodule\nCODE END"}, "clean_code": "module detect_input_change (\n    input clk,\n    input [31:0] in,\n    output reg [31:0] out\n);\n\nreg [31:0] prev_in;\n\nalways @(posedge clk) begin\n    prev_in <= in;\n    out <= (prev_in ^ in) & ~in;\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output [31:0] out\n);\n\nwire [31:0] detect_change;\n\ndetect_input_change detect_inst (\n    .clk(clk),\n    .in(in),\n    .out(detect_change)\n);\n\nassign out = detect_change;\n\nendmodule", "corrupted_code": "module detect_input_change (\n    input clk,\n    input [31:0] in,\n    output reg [31:0] out\n);\n\nreg [31:0] prev_in;\n\nalways @(posedge clk) begin\n    in <= prev_in;\n    out <= (prev_in ^ in) & ~in;\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output [31:0] out\n);\n\nwire [31:0] detect_change;\n\ndetect_input_change detect_inst (\n    .clk(clk),\n    .in(in),\n    .out(detect_change)\n);\n\nassign out = detect_change;\n\nendmodule", "corruption_explanation": "Swapped operands: 'prev_in <= in' -> 'in <= prev_in'", "modification_type": "swap_operands", "modification_line": 10, "original_snippet": "prev_in <= in", "modified_snippet": "in <= prev_in", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'prev_in <= in' -> 'in <= prev_in'\n   \u2022 Line 10: Original: prev_in <= in\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 10.\n   \u2022 Restore the original code: prev_in <= in\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 3, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "remove_always_block", "swap_port_signals", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.282660"}
{"original_entry": {"instruction": "\nWrite the Verilog code for a combinational module named `num_3`.\nThe module should have the following interface:\n- Input: `input [2:0] in_row`\n- Output: `output reg [4:0] out_code`\n\nThe module should implement a mapping from the `in_row` value to the `out_code` based on the following rules. Consider the following specific 5-bit output patterns:\n- Pattern_1 is 5'b01110\n- Pattern_2 is 5'b10001\n- Pattern_3 is 5'b01000\n- Pattern_4 is 5'b10000\n\nThe mapping from `in_row` to `out_code` is defined as follows:\n- If `in_row` is 3'b000 or 3'b101, the output is Pattern_1.\n- If `in_row` is 3'b001 or 3'b100, the output is Pattern_2.\n- If `in_row` is 3'b010, the output is Pattern_3.\n- If `in_row` is 3'b011, the output is Pattern_4.\n- For any other value of `in_row`, the output is 5'b00000.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule num_3(\n    input [2:0] in_row,\n    output reg [4:0] out_code\n    );\n\nparameter [4:0] d_0 = 5'b01110; parameter [4:0] d_1 = 5'b10001; parameter [4:0] d_2 = 5'b01000; parameter [4:0] d_3 = 5'b10000; always @ *\nbegin\n\tcase (in_row)\n\t\t3'b000:\n\t\t\tout_code = d_0;\n\t\t3'b001:\n\t\t\tout_code = d_1;\n\t\t3'b010:\n\t\t\tout_code = d_2;\n\t\t3'b011:\n\t\t\tout_code = d_3;\n\t\t3'b100:\n\t\t\tout_code = d_1;\n\t\t3'b101:\n\t\t\tout_code = d_0;\n\t\tdefault:\n\t\t\tout_code = 5'b0;\n\tendcase\nend\n\n\nendmodule\n\nCODE END"}, "clean_code": "module num_3(\n    input [2:0] in_row,\n    output reg [4:0] out_code\n    );\n\nparameter [4:0] d_0 = 5'b01110; parameter [4:0] d_1 = 5'b10001; parameter [4:0] d_2 = 5'b01000; parameter [4:0] d_3 = 5'b10000; always @ *\nbegin\n\tcase (in_row)\n\t\t3'b000:\n\t\t\tout_code = d_0;\n\t\t3'b001:\n\t\t\tout_code = d_1;\n\t\t3'b010:\n\t\t\tout_code = d_2;\n\t\t3'b011:\n\t\t\tout_code = d_3;\n\t\t3'b100:\n\t\t\tout_code = d_1;\n\t\t3'b101:\n\t\t\tout_code = d_0;\n\t\tdefault:\n\t\t\tout_code = 5'b0;\n\tendcase\nend\n\n\nendmodule", "corrupted_code": "module num_3(\n    input [2:0] in_row,\n    output reg [4:0] out_code\n    );\n\nparameter [4:0] d_0 = 5'b01110; parameter [3:0] d_1 = 5'b10001; parameter [4:0] d_2 = 5'b01000; parameter [4:0] d_3 = 5'b10000; always @ *\nbegin\n\tcase (in_row)\n\t\t3'b000:\n\t\t\tout_code = d_0;\n\t\t3'b001:\n\t\t\tout_code = d_1;\n\t\t3'b010:\n\t\t\tout_code = d_2;\n\t\t3'b011:\n\t\t\tout_code = d_3;\n\t\t3'b100:\n\t\t\tout_code = d_1;\n\t\t3'b101:\n\t\t\tout_code = d_0;\n\t\tdefault:\n\t\t\tout_code = 5'b0;\n\tendcase\nend\n\n\nendmodule", "corruption_explanation": "Changed bit width from [4:0] to [3:0]", "modification_type": "change_bit_width", "modification_line": 6, "original_snippet": "[4:0]", "modified_snippet": "[3:0]", "issue_description": "The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_bit_width modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed bit width from [4:0] to [3:0]\n   \u2022 Line 6: Original: [4:0]\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 6.\n   \u2022 Restore the original code: [4:0]\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change bit width.", "complexity": 2, "applicable_modifications": ["remove_case_default", "change_constant", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "shuffle_case_items", "remove_always_block"], "timestamp": "2025-12-09T21:43:36.283568"}
{"original_entry": {"instruction": "\nDesign a synchronous digital module named `four_bit_adder`. This module should operate on the positive edge of the clock signal `clk`. It should have an active-high reset input `rst`.\n\nThe module takes two 4-bit inputs, `a` and `b`, and a 1-bit carry-in `cin`. It should produce a 4-bit output `sum` and a 1-bit output `cout`.\n\nThe interface for the module is as follows:\nModule Name: `four_bit_adder`\nInputs:\n`clk`\n`rst`\n`a` [3:0]\n`b` [3:0]\n`cin`\nOutputs:\n`sum` [3:0]\n`cout`\n\nOn the positive edge of `clk`, if `rst` is high, both the `sum` and `cout` outputs should be reset to 0.\n\nOtherwise (when `rst` is low), the module should perform two calculations:\n1.  Calculate the 4-bit sum of the inputs `a`, `b`, and `cin`. This 4-bit sum should be registered and output as `sum`.\n2.  Calculate a separate 1-bit signal based *only* on the most significant bits of the inputs (`a[3]`, `b[3]`) and the carry-in `cin`. This signal should represent the carry-out that would be generated by a single-bit full adder whose inputs are `a[3]`, `b[3]`, and `cin`. This specific 1-bit signal should be registered and output as `cout`.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule four_bit_adder(clk, rst, a, b, cin, sum, cout);\n\n  input clk, rst;\n  input [3:0] a, b;\n  input cin;\n  output [3:0] sum;\n  output cout;\n\n  reg [3:0] sum_reg;\n  reg cout_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      sum_reg <= 4'b0;\n      cout_reg <= 1'b0;\n    end\n    else begin\n      sum_reg <= a + b + cin;\n      cout_reg <= (a[3] & b[3]) | (a[3] & cin) | (b[3] & cin);\n    end\n  end\n\n  assign sum = sum_reg;\n  assign cout = cout_reg;\n\nendmodule\nCODE END"}, "clean_code": "module four_bit_adder(clk, rst, a, b, cin, sum, cout);\n\n  input clk, rst;\n  input [3:0] a, b;\n  input cin;\n  output [3:0] sum;\n  output cout;\n\n  reg [3:0] sum_reg;\n  reg cout_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      sum_reg <= 4'b0;\n      cout_reg <= 1'b0;\n    end\n    else begin\n      sum_reg <= a + b + cin;\n      cout_reg <= (a[3] & b[3]) | (a[3] & cin) | (b[3] & cin);\n    end\n  end\n\n  assign sum = sum_reg;\n  assign cout = cout_reg;\n\nendmodule", "corrupted_code": "module four_bit_adder(clk, rst, a, b, cin, sum, cout);\n\n  input clk, rst;\n  input [3:0] a, b;\n  input cin;\n  output [3:0] sum;\n  output cout;\n\n  reg [3:0] sum_reg;\n  reg cout_reg;\n\n  \n    else begin\n      sum_reg <= a + b + cin;\n      cout_reg <= (a[3] & b[3]) | (a[3] & cin) | (b[3] & cin);\n    end\n  end\n\n  assign sum = sum_reg;\n  assign cout = cout_reg;\n\nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 12, "original_snippet": "always @(posedge clk) begin\n    if (rst) begin\n      sum_reg <= 4'b0;\n      cout_reg <= 1'b0;\n    end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 12: Original: always @(posedge clk) begin\n    if (rst) begin\n      sum_reg <= 4'b0;\n      cout_reg <= 1'b0;\n    end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 12.\n   \u2022 Restore the original code: always @(posedge clk) begin\n    if (rst) begin\n      sum_reg <= 4'b0;\n      cout_reg <= 1'b0;\n    end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 6, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.285071"}
{"original_entry": {"instruction": "\nWrite Verilog code for a combinational logic module named `my_module`. The module has inputs `input1`, `input2`, `input3`, `input4`, `input5`, `input6`, `input7`, `input8`, and an output `output1`.\n\nThe output `output1` should be determined by the following prioritized conditions:\n- If `input1` and `input2` are both logic high, `output1` is set to logic high.\n- Otherwise, if both `input3` and `input4` are logic low, `output1` is set to logic low.\n- Otherwise, if `input5`, `input6`, and `input7` are all logic high, `output1` is set to logic high.\n- In all other cases, `output1` should follow the value of `input8`.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule my_module(\n    input input1, \n    input input2, \n    input input3, \n    input input4, \n    input input5, \n    input input6, \n    input input7, \n    input input8, \n    output reg output1\n);\n\nalways @(*) begin\n    if(input1 && input2) begin\n        output1 = 1;\n    end else if(!input3 && !input4) begin\n        output1 = 0;\n    end else if(input5 && input6 && input7) begin\n        output1 = 1;\n    end else begin\n        output1 = input8;\n    end\nend\n\nendmodule\nCODE END"}, "clean_code": "module my_module(\n    input input1, \n    input input2, \n    input input3, \n    input input4, \n    input input5, \n    input input6, \n    input input7, \n    input input8, \n    output reg output1\n);\n\nalways @(*) begin\n    if(input1 && input2) begin\n        output1 = 1;\n    end else if(!input3 && !input4) begin\n        output1 = 0;\n    end else if(input5 && input6 && input7) begin\n        output1 = 1;\n    end else begin\n        output1 = input8;\n    end\nend\n\nendmodule", "corrupted_code": "module my_module(\n    input input1, \n    input input2, \n    input input3, \n    input input4, \n    input input5, \n    input input6, \n    input input7, \n    input input8, \n    output reg output1\n);\n\nalways @(*) begin\n    if(input1 && input2) begin\n        output1 = 1;\n    end else if(!input3 && !input4) begin\n        output1 = 0;\n    end else if(input5 && input6 && input7) begin\n        output1 = 1;\n    end else begin\n        output1 = input8;\n    end\nend\n\nendmodule", "corruption_explanation": "Changed constant from 0 to 0", "modification_type": "change_constant", "modification_line": 17, "original_snippet": "0", "modified_snippet": "0", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 0 to 0\n   \u2022 Line 17: Original: 0\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 17.\n   \u2022 Restore the original code: 0\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 6, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "invert_condition", "remove_always_block"], "timestamp": "2025-12-09T21:43:36.286729"}
{"original_entry": {"instruction": "\nDesign a Verilog module named `Reset_Delay` that generates three active-high signals (`oRST_0`, `oRST_1`, `oRST_2`) that become high sequentially after an asynchronous active-low reset (`iRST`) is de-asserted.\n\nThe module should have the following interface:\ninputs:\n`iCLK` (clock)\n`iRST` (asynchronous active-low reset)\n\noutputs:\n`oRST_0`\n`oRST_1`\n`oRST_2`\n\nWhen `iRST` is low, all outputs and an internal counter should be held at 0.\n\nWhen `iRST` is high, on the positive edge of `iCLK`:\n1.  An internal counter should increment. This counter should be wide enough to reach the specified threshold values. The counter should stop incrementing once it reaches the highest threshold value.\n2.  The output `oRST_0` should become high when the counter reaches or exceeds the value `32'h1FFFFF`.\n3.  The output `oRST_1` should become high when the counter reaches or exceeds the value `32'h2FFFFF`.\n4.  The output `oRST_2` should become high when the counter reaches or exceeds the value `32'h114FFFF`.\n5.  All outputs (`oRST_0`, `oRST_1`, `oRST_2`) should be registered.\n\nWrite the Verilog code for this module.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule\tReset_Delay(iCLK,iRST,oRST_0,oRST_1,oRST_2);\ninput\t\tiCLK;\ninput\t\tiRST;\noutput reg\toRST_0;\noutput reg\toRST_1;\noutput reg\toRST_2;\n\nreg\t[31:0]\tCont;\n\nalways@(posedge iCLK or negedge iRST)\nbegin\n\tif(!iRST)\n\tbegin\n\t\tCont\t<=\t0;\n\t\toRST_0\t<=\t0;\n\t\toRST_1\t<=\t0;\n\t\toRST_2\t<=\t0;\n\tend\n\telse\n\tbegin\n\t\tif(Cont!=32'h114FFFF)\n\t\tCont\t<=\tCont+1;\n\t\tif(Cont>=32'h1FFFFF)\n\t\toRST_0\t<=\t1;\n\t\tif(Cont>=32'h2FFFFF)\n\t\toRST_1\t<=\t1;\n\t\tif(Cont>=32'h114FFFF)\n\t\toRST_2\t<=\t1;\n\tend\nend\n\nendmodule\nCODE END"}, "clean_code": "module\tReset_Delay(iCLK,iRST,oRST_0,oRST_1,oRST_2);\ninput\t\tiCLK;\ninput\t\tiRST;\noutput reg\toRST_0;\noutput reg\toRST_1;\noutput reg\toRST_2;\n\nreg\t[31:0]\tCont;\n\nalways@(posedge iCLK or negedge iRST)\nbegin\n\tif(!iRST)\n\tbegin\n\t\tCont\t<=\t0;\n\t\toRST_0\t<=\t0;\n\t\toRST_1\t<=\t0;\n\t\toRST_2\t<=\t0;\n\tend\n\telse\n\tbegin\n\t\tif(Cont!=32'h114FFFF)\n\t\tCont\t<=\tCont+1;\n\t\tif(Cont>=32'h1FFFFF)\n\t\toRST_0\t<=\t1;\n\t\tif(Cont>=32'h2FFFFF)\n\t\toRST_1\t<=\t1;\n\t\tif(Cont>=32'h114FFFF)\n\t\toRST_2\t<=\t1;\n\tend\nend\n\nendmodule", "corrupted_code": "module\tReset_Delay(iCLK,iRST,oRST_0,oRST_1,oRST_2);\ninput\t\tiCLK;\ninput\t\tiRST;\noutput reg\toRST_0;\noutput reg\toRST_1;\noutput reg\toRST_2;\n\nreg\t[31:0]\tCont;\n\nalways@(posedge iCLK or negedge iRST)\nbegin\n\tif(!iRST)\n\tbegin\n\t\tCont\t>=\t0;\n\t\toRST_0\t<=\t0;\n\t\toRST_1\t<=\t0;\n\t\toRST_2\t<=\t0;\n\tend\n\telse\n\tbegin\n\t\tif(Cont!=32'h114FFFF)\n\t\tCont\t<=\tCont+1;\n\t\tif(Cont>=32'h1FFFFF)\n\t\toRST_0\t<=\t1;\n\t\tif(Cont>=32'h2FFFFF)\n\t\toRST_1\t<=\t1;\n\t\tif(Cont>=32'h114FFFF)\n\t\toRST_2\t<=\t1;\n\tend\nend\n\nendmodule", "corruption_explanation": "Changed operator from '<=' to '>='", "modification_type": "change_operator", "modification_line": 14, "original_snippet": "t\t<=\t0", "modified_snippet": "t\t>=\t0", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '<=' to '>='\n   \u2022 Line 14: Original: t\t<=\t0\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 14.\n   \u2022 Restore the original code: t\t<=\t0\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 15, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.287704"}
{"original_entry": {"instruction": "\nDesign two Verilog modules.\n\n1.  **Module `DFFE`**:\n    *   Inputs: `CLK`, `D`, `EN`\n    *   Output: `Q`\n    *   This module should implement a standard D-type flip-flop with a synchronous enable. On the positive edge of `CLK`, the output `Q` should be updated with the value of `D` only if the `EN` input is high. If `EN` is low, `Q` should retain its current value.\n\n2.  **Module `d_ff_en_gate`**:\n    *   Inputs: `CLK`, `D`, `EN`, `TE`\n    *   Outputs: `Q`, `ENCLK`\n    *   This module should implement a D-type flip-flop (`Q`) which updates based on a *derived* clock signal.\n    *   This derived clock signal, which should also be output as `ENCLK`, should be generated by instantiating the `DFFE` module you designed previously. The `DFFE` instance should be clocked by the main `CLK`, enabled by the `TE` input, and capture the value of the `EN` input.\n    *   The main D-type flip-flop (`Q`) should use the output of this `DFFE` instance (the derived clock/`ENCLK`) as its clock source.\n    *   Additionally, the main D-type flip-flop (`Q`) should *only* update if the main `EN` input is high *at the time of the derived clock edge*.\n\nEnsure all module names and signal names match the ones specified exactly.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule DFFE(CLK, D, EN, Q);\n  input CLK, D, EN;\n  output Q;\n\n  reg Q;\n\n  always @(posedge CLK) begin\n    if (EN) begin\n      Q <= D;\n    end\n  end\n\nendmodule\n\nmodule d_ff_en_gate(CLK, D, EN, TE, Q, ENCLK);\n  input CLK, D, EN, TE;\n  output Q, ENCLK;\n\n  reg Q;\n  wire gated_clk;\n\n  DFFE gated_clk_inst(.CLK(CLK), .D(EN), .EN(TE), .Q(gated_clk));\n\n  always @(posedge gated_clk) begin\n    if (EN) begin\n      Q <= D;\n    end\n  end\n\n  assign ENCLK = gated_clk;\n\nendmodule\n\nCODE END"}, "clean_code": "module DFFE(CLK, D, EN, Q);\n  input CLK, D, EN;\n  output Q;\n\n  reg Q;\n\n  always @(posedge CLK) begin\n    if (EN) begin\n      Q <= D;\n    end\n  end\n\nendmodule\n\nmodule d_ff_en_gate(CLK, D, EN, TE, Q, ENCLK);\n  input CLK, D, EN, TE;\n  output Q, ENCLK;\n\n  reg Q;\n  wire gated_clk;\n\n  DFFE gated_clk_inst(.CLK(CLK), .D(EN), .EN(TE), .Q(gated_clk));\n\n  always @(posedge gated_clk) begin\n    if (EN) begin\n      Q <= D;\n    end\n  end\n\n  assign ENCLK = gated_clk;\n\nendmodule", "corrupted_code": "module DFFE(CLK, D, EN, Q);\n  input CLK, D, EN;\n  output Q;\n\n  reg Q;\n\n  always @(CLK) begin\n    if (EN) begin\n      Q <= D;\n    end\n  end\n\nendmodule\n\nmodule d_ff_en_gate(CLK, D, EN, TE, Q, ENCLK);\n  input CLK, D, EN, TE;\n  output Q, ENCLK;\n\n  reg Q;\n  wire gated_clk;\n\n  DFFE gated_clk_inst(.CLK(CLK), .D(EN), .EN(TE), .Q(gated_clk));\n\n  always @(posedge gated_clk) begin\n    if (EN) begin\n      Q <= D;\n    end\n  end\n\n  assign ENCLK = gated_clk;\n\nendmodule", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 7, "original_snippet": "always @(posedge CLK)", "modified_snippet": "always @(CLK)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 7: Original: always @(posedge CLK)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 7.\n   \u2022 Restore the original code: always @(posedge CLK)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 6, "applicable_modifications": ["change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "swap_port_signals", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.288608"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `register`. This module should implement a synchronous register with an asynchronous reset and a clock enable.\n\nThe module should have the following inputs:\n*   `CLK`: The clock signal.\n*   `RST`: The asynchronous reset signal.\n*   `EN`: The clock enable signal.\n*   `D_IN`: The data input.\n\nThe module should have the following output:\n*   `Q_OUT`: The registered data output.\n\nThe module should be parameterized by:\n*   `width`: The width of the data path (defaulting to 1).\n*   `init`: The initial value loaded upon reset (defaulting to all zeros for the specified width).\n\nThe behavior should be as follows:\n*   When `RST` is asserted (high), the output `Q_OUT` should asynchronously reset to the value specified by the `init` parameter.\n*   When `RST` is deasserted (low), on the positive edge of `CLK`:\n    *   If `EN` is asserted (high), the value of `D_IN` should be loaded into the register, and `Q_OUT` should update to this new value.\n    *   If `EN` is deasserted (low), the register should retain its current value (i.e., `Q_OUT` should not change).\n\nProvide the Verilog code for this module.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule register(CLK, RST, Q_OUT, D_IN, EN);\n\n   parameter width = 1;\n   parameter init = { width {1'b0}} ;\n\n   input     CLK;\n   input     RST;\n   input     EN;\n   input [width - 1 : 0] D_IN;\n   output [width - 1 : 0] Q_OUT;\n\n   reg [width - 1 : 0]    Q_OUT;\n\n   always@(posedge CLK or posedge RST) begin\n      if (RST) begin\n        Q_OUT <= init;\n      end else if (EN) begin\n        Q_OUT <= D_IN;\n      end\n   end // always@ (posedge CLK or posedge RST)\n\nendmodule\nCODE END"}, "clean_code": "module register(CLK, RST, Q_OUT, D_IN, EN);\n\n   parameter width = 1;\n   parameter init = { width {1'b0}} ;\n\n   input     CLK;\n   input     RST;\n   input     EN;\n   input [width - 1 : 0] D_IN;\n   output [width - 1 : 0] Q_OUT;\n\n   reg [width - 1 : 0]    Q_OUT;\n\n   always@(posedge CLK or posedge RST) begin\n      if (RST) begin\n        Q_OUT <= init;\n      end else if (EN) begin\n        Q_OUT <= D_IN;\n      end\n   end // always@ (posedge CLK or posedge RST)\n\nendmodule", "corrupted_code": "module register(CLK, RST, Q_OUT, D_IN, EN);\n\n   parameter width = 1;\n   parameter init = { width {1'b0}} ;\n\n   input     CLK;\n   input     RST;\n   input     EN;\n   input [width - 1 : 0] D_IN;\n   output [width - 1 : 0] Q_OUT;\n\n   reg [1 - width : 0]    Q_OUT;\n\n   always@(posedge CLK or posedge RST) begin\n      if (RST) begin\n        Q_OUT <= init;\n      end else if (EN) begin\n        Q_OUT <= D_IN;\n      end\n   end // always@ (posedge CLK or posedge RST)\n\nendmodule", "corruption_explanation": "Swapped operands: 'width - 1' -> '1 - width'", "modification_type": "swap_operands", "modification_line": 12, "original_snippet": "width - 1", "modified_snippet": "1 - width", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'width - 1' -> '1 - width'\n   \u2022 Line 12: Original: width - 1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 12.\n   \u2022 Restore the original code: width - 1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 8, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.290240"}
{"original_entry": {"instruction": "\nDesign the following two Verilog modules:\n\n1.  **Module `dff_8`**:\n    This module should implement an 8-bit D-type flip-flop. It should have the following interface:\n    *   Inputs: `clk` (single bit), `reset` (single bit), `d` (8-bit wide, [7:0])\n    *   Output: `q` (8-bit wide, [7:0])\n\n    The flip-flop should capture the value of the input `d` on the positive edge of the `clk` signal. It must also include an *asynchronous*, *active-low* reset capability. When the `reset` signal is asserted (logic low), the output `q` should immediately be cleared to zero, regardless of the clock state.\n\n2.  **Module `top_module`**:\n    This module should act as a simple wrapper. It should instantiate one instance of the `dff_8` module you designed. The `top_module` should have the following interface, which is identical to `dff_8`:\n    *   Inputs: `clk` (single bit), `reset` (single bit), `d` (8-bit wide, [7:0])\n    *   Output: `q` (8-bit wide, [7:0])\n\n    Connect the inputs and outputs of `top_module` directly to the corresponding ports of the instantiated `dff_8` module.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule dff_8 (\n    input clk,\n    input reset,            // Asynchronous reset\n    input [7:0] d,\n    output reg [7:0] q\n);\n\nalways @ (posedge clk or negedge reset) begin\n    if (reset == 1'b0) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule\nmodule top_module (\n    input clk,\n    input reset,            // Asynchronous reset\n    input [7:0] d,\n    output [7:0] q\n);\n\ndff_8 dff_0 (.clk(clk), .reset(reset), .d(d), .q(q));\n\nendmodule\nCODE END"}, "clean_code": "module dff_8 (\n    input clk,\n    input reset,            // Asynchronous reset\n    input [7:0] d,\n    output reg [7:0] q\n);\n\nalways @ (posedge clk or negedge reset) begin\n    if (reset == 1'b0) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule\nmodule top_module (\n    input clk,\n    input reset,            // Asynchronous reset\n    input [7:0] d,\n    output [7:0] q\n);\n\ndff_8 dff_0 (.clk(clk), .reset(reset), .d(d), .q(q));\n\nendmodule", "corrupted_code": "module dff_8 (\n    input clk,\n    input reset,            // Asynchronous reset\n    input [7:0] d,\n    output reg [6:0] q\n);\n\nalways @ (posedge clk or negedge reset) begin\n    if (reset == 1'b0) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule\nmodule top_module (\n    input clk,\n    input reset,            // Asynchronous reset\n    input [7:0] d,\n    output [7:0] q\n);\n\ndff_8 dff_0 (.clk(clk), .reset(reset), .d(d), .q(q));\n\nendmodule", "corruption_explanation": "Changed bit width from [7:0] to [6:0]", "modification_type": "change_bit_width", "modification_line": 5, "original_snippet": "[7:0]", "modified_snippet": "[6:0]", "issue_description": "The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_bit_width modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed bit width from [7:0] to [6:0]\n   \u2022 Line 5: Original: [7:0]\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 5.\n   \u2022 Restore the original code: [7:0]\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change bit width.", "complexity": 5, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "swap_port_signals", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.291851"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `alu` with the following interface:\n\nInputs:\n- `A`: a 4-bit input\n- `B`: a 4-bit input\n- `operation`: a 3-bit input\n\nOutput:\n- `result`: a 4-bit output of type `reg`\n\nImplement the logic within the module such that the `result` is determined by the `operation` input as follows:\n- If `operation` is `3'b000`, `result` should be the sum of `A` and `B`.\n- If `operation` is `3'b001`, `result` should be the difference of `A` and `B`.\n- If `operation` is `3'b010`, `result` should be the bitwise AND of `A` and `B`.\n- If `operation` is `3'b011`, `result` should be the bitwise OR of `A` and `B`.\n- If `operation` is `3'b100`, `result` should be the bitwise XOR of `A` and `B`.\n- For any other value of `operation`, `result` should be `4'b0`.\n\nEnsure the logic is combinational, updating the output whenever any input changes.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule alu (\n    input [3:0] A,\n    input [3:0] B,\n    input [2:0] operation,\n    output reg [3:0] result\n);\n\n    always @(*) begin\n        case(operation)\n            3'b000: result = A + B; // Addition\n            3'b001: result = A - B; // Subtraction\n            3'b010: result = A & B; // AND\n            3'b011: result = A | B; // OR\n            3'b100: result = A ^ B; // XOR\n            default: result = 4'b0; // Default case\n        endcase\n    end\n\nendmodule\nCODE END"}, "clean_code": "module alu (\n    input [3:0] A,\n    input [3:0] B,\n    input [2:0] operation,\n    output reg [3:0] result\n);\n\n    always @(*) begin\n        case(operation)\n            3'b000: result = A + B; // Addition\n            3'b001: result = A - B; // Subtraction\n            3'b010: result = A & B; // AND\n            3'b011: result = A | B; // OR\n            3'b100: result = A ^ B; // XOR\n            default: result = 4'b0; // Default case\n        endcase\n    end\n\nendmodule", "corrupted_code": "module alu (\n    input [3:0] A,\n    input [3:0] B,\n    input [2:0] operation,\n    output reg [3:0] result\n);\n\n    always @(a) begin\n        case(operation)\n            3'b000: result = A + B; // Addition\n            3'b001: result = A - B; // Subtraction\n            3'b010: result = A & B; // AND\n            3'b011: result = A | B; // OR\n            3'b100: result = A ^ B; // XOR\n            default: result = 4'b0; // Default case\n        endcase\n    end\n\nendmodule", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 8, "original_snippet": "always @(*)", "modified_snippet": "always @(a)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 8: Original: always @(*)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 8.\n   \u2022 Restore the original code: always @(*)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 7, "applicable_modifications": ["remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "shuffle_case_items", "remove_always_block"], "timestamp": "2025-12-09T21:43:36.294289"}
{"original_entry": {"instruction": "\nDesign a Verilog module named `Immediate_Extend`.\nThis module has the following interface:\n- Input: `load` (3 bits)\n- Input: `data_in` (16 bits)\n- Output: `data_out` (16 bits)\n\nThe module should perform an immediate extension operation based on the value of the `load` input. The output `data_out` is determined as follows:\n- If `load` is 3'h0: The 8-bit value `data_in[7:0]` is sign-extended to 16 bits.\n- If `load` is 3'h1: The 4-bit value `data_in[3:0]` is sign-extended to 16 bits.\n- If `load` is 3'h2: The 11-bit value `data_in[10:0]` is sign-extended to 16 bits.\n- If `load` is 3'h3: The 4-bit value `data_in[3:0]` is zero-extended to 16 bits.\n- If `load` is 3'h4: The 8-bit value `data_in[7:0]` is zero-extended to 16 bits.\n- If `load` is 3'h5: The 5-bit value `data_in[4:0]` is sign-extended to 16 bits.\n- For any other value of `load`: The 3-bit value `data_in[4:2]` is zero-extended to 16 bits.\n\nWrite the Verilog code for this module.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule Immediate_Extend(\n    output [15 : 0] data_out,\n    input [2 : 0] load,\n    input [15 : 0] data_in\n    );\n\n\tassign data_out =\n\t\t(load == 0) ? {{8{data_in[7]}}, data_in[7 : 0]} :\n\t\t(load == 1) ? {{12{data_in[3]}}, data_in[3 : 0]} :\n\t\t(load == 2) ? {{5{data_in[10]}}, data_in[10 : 0]} :\n\t\t(load == 3) ? {12'b0, data_in[3 : 0]} :\n\t\t(load == 4) ? {8'b0, data_in[7 : 0]} :\n\t\t(load == 5) ? {{11{data_in[4]}}, data_in[4 : 0]} :\n\t\t{13'b0, data_in[4 : 2]};\n\t\t\nendmodule\n\nCODE END"}, "clean_code": "module Immediate_Extend(\n    output [15 : 0] data_out,\n    input [2 : 0] load,\n    input [15 : 0] data_in\n    );\n\n\tassign data_out =\n\t\t(load == 0) ? {{8{data_in[7]}}, data_in[7 : 0]} :\n\t\t(load == 1) ? {{12{data_in[3]}}, data_in[3 : 0]} :\n\t\t(load == 2) ? {{5{data_in[10]}}, data_in[10 : 0]} :\n\t\t(load == 3) ? {12'b0, data_in[3 : 0]} :\n\t\t(load == 4) ? {8'b0, data_in[7 : 0]} :\n\t\t(load == 5) ? {{11{data_in[4]}}, data_in[4 : 0]} :\n\t\t{13'b0, data_in[4 : 2]};\n\t\t\nendmodule", "corrupted_code": "module Immediate_Extend(\n    output [15 : 0] data_out,\n    input [2 : 0] load,\n    input [15 : 0] data_in\n    );\n\n\tassign data_out =\n\t\t(load == 0) ? {{8{data_in[7]}}, data_in[7 : 0]} :\n\t\t(load == 1) ? {{12{data_in[3]}}, data_in[3 : 0]} :\n\t\t(load == 2) ? {{5{data_in[10]}}, data_in[10 : 0]} :\n\t\t(load == 3) ? {12'b0, data_in[3 : 0]} :\n\t\t(load == 4) ? {8'b0, data_in[7 : 0]} :\n\t\t(load == 5) ? {{11{data_in[4]}}, data_in[4 : 0]} :\n\t\t{13'b0, data_in[4 : 2]};\nassign data_out = 1'b0;  // Conflicting assignment\n\t\t\nendmodule", "corruption_explanation": "Added conflicting driver for signal 'data_out'", "modification_type": "add_multiple_driver", "modification_line": 6, "original_snippet": "assign data_out =\n\t\t(load == 0) ? {{8{data_in[7]}}, data_in[7 : 0]} :\n\t\t(load == 1) ? {{12{data_in[3]}}, data_in[3 : 0]} :\n\t\t(load == 2) ? {{5{data_in[10]}}, data_in[10 : 0]} :\n\t\t(load == 3) ? {12'b0, data_in[3 : 0]} :\n\t\t(load == 4) ? {8'b0, data_in[7 : 0]} :\n\t\t(load == 5) ? {{11{data_in[4]}}, data_in[4 : 0]} :\n\t\t{13'b0, data_in[4 : 2]};", "modified_snippet": "assign data_out =\n\t\t(load == 0) ? {{8{data_in[7]}}, data_in[7 : 0]} :\n\t\t(load == 1) ? {{12{data_in[3]}}, data_in[3 : 0]} :\n\t\t(load == 2) ? {{5{data_in[10]}}, data_in[10 : 0]} :\n\t\t(load == 3) ? {12'b0, data_in[3 : 0]} :\n\t\t(load == 4) ? {8'b0, data_in[7 : 0]} :\n\t\t(load == 5) ? {{11{data_in[4]}}, data_in[4 : 0]} :\n\t\t{13'b0, data_in[4 : 2]};\nassign data_out = 1'b0;  // Conflicting assignment", "issue_description": "The buggy code has multiple drivers on the same signal. This creates a contention where different parts of the design try to drive the same signal to different values. Linting tools will flag MULTIDRIVEN errors, and synthesis may fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a add_multiple_driver modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Added conflicting driver for signal 'data_out'\n   \u2022 Line 6: Original: assign data_out =\n\t\t(load == 0) ? {{8{data_in[7]}}, data_in[7 : 0]} :\n\t\t(load == 1) ? {{12{data_in[3]}}, data_in[3 : 0]} :\n\t\t(load == 2) ? {{5{data_in[10]}}, data_in[10 : 0]} :\n\t\t(load == 3) ? {12'b0, data_in[3 : 0]} :\n\t\t(load == 4) ? {8'b0, data_in[7 : 0]} :\n\t\t(load == 5) ? {{11{data_in[4]}}, data_in[4 : 0]} :\n\t\t{13'b0, data_in[4 : 2]};\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 6.\n   \u2022 Restore the original code: assign data_out =\n\t\t(load == 0) ? {{8{data_in[7]}}, data_in[7 : 0]} :\n\t\t(load == 1) ? {{12{data_in[3]}}, data_in[3 : 0]} :\n\t\t(load == 2) ? {{5{data_in[10]}}, data_in[10 : 0]} :\n\t\t(load == 3) ? {12'b0, data_in[3 : 0]} :\n\t\t(load == 4) ? {8'b0, data_in[7 : 0]} :\n\t\t(load == 5) ? {{11{data_in[4]}}, data_in[4 : 0]} :\n\t\t{13'b0, data_in[4 : 2]};\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to add multiple driver.", "complexity": 6, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver"], "timestamp": "2025-12-09T21:43:36.296086"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `time_signal`.\nThe module should have the following interface:\n- Inputs: `clk` (clock), `reset` (active-low asynchronous reset)\n- Output: `time_out`\n\nThe module should generate a periodic signal on the `time_out` output. This signal should have a period of exactly 25,000,002 clock cycles of the input `clk`. The signal should have a 50% duty cycle, meaning it is high for 12,500,001 clock cycles and low for the remaining 12,500,001 clock cycles within each period.\n\nThe `reset` input should be active low and asynchronous. When `reset` is low, the `time_out` output should be forced low, and any internal state should be reset to its initial condition, preparing for normal operation when `reset` goes high.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule time_signal ( input wire clk,\n\t\tinput wire reset,\n\t\toutput wire time_out\n\t\t);\n\t\n\treg [24:0] clk_number; reg [0:0] sec_kp;\t\t  assign time_out = sec_kp; always @(posedge clk) begin\n\t\tif (!reset) begin\t\t\t\t\tclk_number <= 25'd0;\n\t\t\t\tsec_kp <= 1'd0; end\n\t\telse\t\t\tbegin\n\t\t\t\tif (clk_number <= 25'd25000000) \t\tclk_number <= clk_number + 25'd1; else\t\t\t\tclk_number <= 25'd0; if (clk_number > 25'd12500000) sec_kp <= 1'd1; else\n\t\t\t\t\tsec_kp <= 1'd0; end\n\t\t\t\n\tend\t\n\t\nendmodule\nCODE END"}, "clean_code": "module time_signal ( input wire clk,\n\t\tinput wire reset,\n\t\toutput wire time_out\n\t\t);\n\t\n\treg [24:0] clk_number; reg [0:0] sec_kp;\t\t  assign time_out = sec_kp; always @(posedge clk) begin\n\t\tif (!reset) begin\t\t\t\t\tclk_number <= 25'd0;\n\t\t\t\tsec_kp <= 1'd0; end\n\t\telse\t\t\tbegin\n\t\t\t\tif (clk_number <= 25'd25000000) \t\tclk_number <= clk_number + 25'd1; else\t\t\t\tclk_number <= 25'd0; if (clk_number > 25'd12500000) sec_kp <= 1'd1; else\n\t\t\t\t\tsec_kp <= 1'd0; end\n\t\t\t\n\tend\t\n\t\nendmodule", "corrupted_code": "module time_signal ( input wire clk,\n\t\tinput wire reset,\n\t\toutput wire time_out\n\t\t);\n\t\n\treg [24:0] clk_number; reg [0:0] sec_kp;\t\t  assign time_out = sec_kp; always @(posedge clk) begin\n\t\tif (!reset) begin\n\t\t\t\tif (clk_number <= 25'd25000000) \t\tclk_number <= clk_number + 25'd1; else\t\t\t\tclk_number <= 25'd0; if (clk_number > 25'd12500000) sec_kp <= 1'd1; else\n\t\t\t\t\tsec_kp <= 1'd0; end\n\t\telse\t\t\tbegin\t\t\t\t\tclk_number <= 25'd0;\n\t\t\t\tsec_kp <= 1'd0; end\n\t\t\t\n\tend\t\n\t\nendmodule", "corruption_explanation": "Swapped if and else bodies", "modification_type": "invert_if_else", "modification_line": 7, "original_snippet": "if (!reset) begin\t\t\t\t\tclk_number <= 25'd0;\n\t\t\t\tsec_kp <= 1'd0; end\n\t\telse\t\t\tbegin\n\t\t\t\tif (clk_number <= 25'd25000000) \t\tclk_number <= clk_number + 25'd1; else\t\t\t\tclk_number <= 25'd0; if (clk_number > ", "modified_snippet": "if (!reset) begin\n\t\t\t\tif (clk_number <= 25'd25000000) \t\tclk_number <= clk_number + 25'd1; else\t\t\t\tclk_number <= 25'd0; if (clk_number > 25'd12500000) sec_kp <= 1'd1; else\n\t\t\t\t\tsec_kp <= 1'd0; end\n\t\tel", "issue_description": "The buggy code has swapped if and else bodies in a conditional block. This causes the logic to execute the opposite branch for each condition, leading to incorrect behavior when the condition is true vs false. Test cases that depend on the conditional logic will fail because the intended branch is not executed.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module contains conditional logic that should execute different code paths based on a condition.\n   \u2022 The if branch should handle the true case, and the else branch should handle the false case.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Identified a conditional block with both if and else branches.\n   \u2022 The branches contain different assignments or logic operations.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The if and else bodies have been swapped.\n   \u2022 Logic that should execute when condition is true now executes when false, and vice versa.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The conditional bodies are inverted.\n   \u2022 Impact: All conditional behavior is reversed, causing incorrect outputs for all test cases.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Swap the if and else bodies back to their correct positions.\n   \u2022 Verify that the condition evaluates correctly and executes the intended branch.\n\n6. RTL Design Principle Violated:\n   \u2022 Correct conditional logic requires matching the intended behavior with the branch bodies.", "complexity": 11, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.296900"}
{"original_entry": {"instruction": "\nDesign a Verilog module named `up_down_counter`.\nThis module should implement a 4-bit synchronous counter.\nThe module has the following ports:\n- An input clock signal named `CLK`.\n- A control input signal named `UD`.\n- A 4-bit output register named `Q`.\n\nThe counter's behavior is determined by the `UD` input:\n- When `UD` is logic 0, the counter should increment on the positive edge of `CLK`.\n- When `UD` is logic 1, the counter should decrement on the positive edge of `CLK`.\n\nThe counter should wrap around:\n- When counting up from its maximum value (4'b1111), it should transition to its minimum value (4'b0000).\n- When counting down from its minimum value (4'b0000), it should transition to its maximum value (4'b1111).\n\nImplement this functionality in Verilog.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule up_down_counter (\n    input CLK,\n    input UD,\n    output reg [3:0] Q\n);\n\n    always @(posedge CLK) begin\n        if (UD == 1'b0) begin\n            if (Q == 4'b1111) begin\n                Q <= 4'b0000;\n            end else begin\n                Q <= Q + 1;\n            end\n        end else begin\n            if (Q == 4'b0000) begin\n                Q <= 4'b1111;\n            end else begin\n                Q <= Q - 1;\n            end\n        end\n    end\n\nendmodule\nCODE END"}, "clean_code": "module up_down_counter (\n    input CLK,\n    input UD,\n    output reg [3:0] Q\n);\n\n    always @(posedge CLK) begin\n        if (UD == 1'b0) begin\n            if (Q == 4'b1111) begin\n                Q <= 4'b0000;\n            end else begin\n                Q <= Q + 1;\n            end\n        end else begin\n            if (Q == 4'b0000) begin\n                Q <= 4'b1111;\n            end else begin\n                Q <= Q - 1;\n            end\n        end\n    end\n\nendmodule", "corrupted_code": "module up_down_counter (\n    input CLK,\n    input UD,\n    output reg [3:0] Q\n);\n\n    always @(posedge CLK) begin\n        if (UD == 1'b0) begin\n            if (Q == 4'b1111) begin\n                Q <= 4'b0000;\n            end else begin\n                Q <= Q + 1;\n            end\n        end else begin\n            if (Q == 4'b0000) begin\n                4 <= Q'b1111;\n            end else begin\n                Q <= Q - 1;\n            end\n        end\n    end\n\nendmodule", "corruption_explanation": "Swapped operands: 'Q <= 4' -> '4 <= Q'", "modification_type": "swap_operands", "modification_line": 16, "original_snippet": "Q <= 4", "modified_snippet": "4 <= Q", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'Q <= 4' -> '4 <= Q'\n   \u2022 Line 16: Original: Q <= 4\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 16.\n   \u2022 Restore the original code: Q <= 4\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 13, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.297792"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `mem_encryption`.\n\nThe module should have the following interface:\n*   Inputs:\n    *   `clk`: Clock signal.\n    *   `reset`: Synchronous reset signal.\n    *   `data_in` [31:0]: 32-bit input data.\n    *   `key` [31:0]: 32-bit key.\n*   Output:\n    *   `data_out` [31:0]: 32-bit output data.\n\nThe module should operate synchronously on the positive edge of the `clk` signal.\n\nImplement the following behavior:\n1.  When the `reset` signal is high, a 32-bit internal state register and the `data_out` register should be synchronously cleared to zero.\n2.  When the `reset` signal is low:\n    *   If the `key` input is zero, the module should act as a bypass, setting `data_out` equal to `data_in`.\n    *   If the `key` input is non-zero, the module should perform a transformation:\n        *   The internal state register should be updated with a value derived from the current `data_in` and `key` using a bitwise operation.\n        *   The `data_out` should be generated by applying the *same* bitwise operation to the *previous* value of the internal state register and the current `key`.\n\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule mem_encryption (\n  input clk,\n  input reset,\n  input [31:0] data_in,\n  input [31:0] key,\n  output reg [31:0] data_out\n);\n\n  reg [31:0] internal_state;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      internal_state <= 0;\n      data_out <= 0;\n    end else begin\n      if (key == 0) begin\n        data_out <= data_in;\n      end else begin\n        internal_state <= data_in ^ key;\n        data_out <= internal_state ^ key;\n      end\n    end\n  end\n\nendmodule\nCODE END"}, "clean_code": "module mem_encryption (\n  input clk,\n  input reset,\n  input [31:0] data_in,\n  input [31:0] key,\n  output reg [31:0] data_out\n);\n\n  reg [31:0] internal_state;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      internal_state <= 0;\n      data_out <= 0;\n    end else begin\n      if (key == 0) begin\n        data_out <= data_in;\n      end else begin\n        internal_state <= data_in ^ key;\n        data_out <= internal_state ^ key;\n      end\n    end\n  end\n\nendmodule", "corrupted_code": "module mem_encryption (\n  input clk,\n  input reset,\n  input [31:0] data_in,\n  input [31:0] key,\n  output reg [31:0] data_out\n);\n\n  reg [31:0] internal_state;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      internal_state <= 0;\n      data_out >= 0;\n    end else begin\n      if (key == 0) begin\n        data_out <= data_in;\n      end else begin\n        internal_state <= data_in ^ key;\n        data_out <= internal_state ^ key;\n      end\n    end\n  end\n\nendmodule", "corruption_explanation": "Changed operator from '<=' to '>='", "modification_type": "change_operator", "modification_line": 14, "original_snippet": "t <= 0", "modified_snippet": "t >= 0", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '<=' to '>='\n   \u2022 Line 14: Original: t <= 0\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 14.\n   \u2022 Restore the original code: t <= 0\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 11, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.300678"}
{"original_entry": {"instruction": "\nDesign a Verilog module named `six_to_one`.\nThe module should have the following interface:\n- Inputs: `in0`, `in1`, `in2`, `in3`, `in4`, `in5` (all single-bit)\n- Output: `out` (single-bit, registered)\n\nThe functionality of the module should be such that the output `out` is high (`1`) if at least one of the inputs `in0` through `in5` is high. If all inputs `in0` through `in5` are low (`0`), the output `out` should be low (`0`).\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule six_to_one (\n    input in0,\n    input in1,\n    input in2,\n    input in3,\n    input in4,\n    input in5,\n    output reg out\n);\n\nalways @(*) begin\n    if (in0) begin\n        out = 1;\n    end else if (in1) begin\n        out = 1;\n    end else if (in2) begin\n        out = 1;\n    end else if (in3) begin\n        out = 1;\n    end else if (in4) begin\n        out = 1;\n    end else if (in5) begin\n        out = 1;\n    end else begin\n        out = 0;\n    end\nend\n\nendmodule\nCODE END"}, "clean_code": "module six_to_one (\n    input in0,\n    input in1,\n    input in2,\n    input in3,\n    input in4,\n    input in5,\n    output reg out\n);\n\nalways @(*) begin\n    if (in0) begin\n        out = 1;\n    end else if (in1) begin\n        out = 1;\n    end else if (in2) begin\n        out = 1;\n    end else if (in3) begin\n        out = 1;\n    end else if (in4) begin\n        out = 1;\n    end else if (in5) begin\n        out = 1;\n    end else begin\n        out = 0;\n    end\nend\n\nendmodule", "corrupted_code": "module six_to_one (\n    input in0,\n    input in1,\n    input in2,\n    input in3,\n    input in4,\n    input in5,\n    output reg out\n);\n\n else if (in1) begin\n        out = 1;\n    end else if (in2) begin\n        out = 1;\n    end else if (in3) begin\n        out = 1;\n    end else if (in4) begin\n        out = 1;\n    end else if (in5) begin\n        out = 1;\n    end else begin\n        out = 0;\n    end\nend\n\nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 11, "original_snippet": "always @(*) begin\n    if (in0) begin\n        out = 1;\n    end", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 11: Original: always @(*) begin\n    if (in0) begin\n        out = 1;\n    end\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 11.\n   \u2022 Restore the original code: always @(*) begin\n    if (in0) begin\n        out = 1;\n    end\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 7, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "invert_condition", "remove_always_block"], "timestamp": "2025-12-09T21:43:36.301531"}
{"original_entry": {"instruction": "\nWrite Verilog code for two modules.\n\nModule 1:\nName: `xor_gate`\nInputs: `a`, `b`\nOutput: `out`\nThis module should implement a standard 2-input XOR logic function.\n\nModule 2:\nName: `top_module`\nInputs: `a`, `b`\nOutputs: `out_behavioral`, `out_structural`\nThis module should also implement the XOR function (`a ^ b`), but in two distinct ways:\n1.  Assign the result directly to `out_behavioral` using a continuous assignment.\n2.  Instantiate the `xor_gate` module defined above and connect its inputs `a` and `b` to the corresponding inputs of `top_module`, and its output `out` to the `top_module` output `out_structural`.\n\nEnsure all specified module names and port names (inputs and outputs) match exactly.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule xor_gate(\n    input a,\n    input b,\n    output wire out\n);\n\n    assign out = a ^ b;\n\nendmodule\n\nmodule top_module(\n    input a, \n    input b,\n    output out_behavioral,\n    output out_structural\n);\n\n    // Behavioral approach\n    wire behavioral_out;\n    assign behavioral_out = a ^ b;\n    assign out_behavioral = behavioral_out;\n    \n    // Structural approach\n    xor_gate xor_inst(\n        .a(a),\n        .b(b),\n        .out(out_structural)\n    );\n\nendmodule\n\nCODE END"}, "clean_code": "module xor_gate(\n    input a,\n    input b,\n    output wire out\n);\n\n    assign out = a ^ b;\n\nendmodule\n\nmodule top_module(\n    input a, \n    input b,\n    output out_behavioral,\n    output out_structural\n);\n\n    // Behavioral approach\n    wire behavioral_out;\n    assign behavioral_out = a ^ b;\n    assign out_behavioral = behavioral_out;\n    \n    // Structural approach\n    xor_gate xor_inst(\n        .a(a),\n        .b(b),\n        .out(out_structural)\n    );\n\nendmodule", "corrupted_code": "module xor_gate(\n    input a,\n    input b,\n    output wire out\n);\n\n    assign out = a ^ b;\n\nendmodule\n\nmodule top_module(\n    input a, \n    input b,\n    output out_behavioral,\n    output out_structural\n);\n\n    // Behavioral approach\n    wire behavioral_out;\n    assign behavioral_out = a & b;\n    assign out_behavioral = behavioral_out;\n    \n    // Structural approach\n    xor_gate xor_inst(\n        .a(a),\n        .b(b),\n        .out(out_structural)\n    );\n\nendmodule", "corruption_explanation": "Changed operator from '^' to '&'", "modification_type": "change_operator", "modification_line": 20, "original_snippet": "^", "modified_snippet": "&", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '^' to '&'\n   \u2022 Line 20: Original: ^\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 20.\n   \u2022 Restore the original code: ^\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 2, "applicable_modifications": ["change_operator", "swap_operands", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "timestamp": "2025-12-09T21:43:36.303293"}
{"original_entry": {"instruction": "\nWrite Verilog code for two modules, `mux2` and `mux4`.\n\nThe `mux2` module should implement a 2-to-1 multiplexer with inputs `A0`, `A1`, and `S`, and output `X`. The output `X` should be `A0` when `S` is 0, and `A1` when `S` is 1.\n\nThe `mux4` module should implement a 4-to-1 multiplexer. It should have a 4-bit input `A` (indexed 3 down to 0), a 2-bit input `S` (indexed 1 down to 0), and an output `X`. The output `X` should select one of the bits from `A` based on the value of the 2-bit input `S` (e.g., if `S` is 00, `X` is `A[0]`; if `S` is 01, `X` is `A[1]`, etc.). The `mux4` module *must* be implemented by instantiating and connecting three instances of the `mux2` module. Consider how the bits of `S` can be used hierarchically to select the final output.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule mux4 (\n    input [3:0] A,\n    input [1:0] S,\n    output X\n);\n\n    wire w0, w1, w2, w3;\n\n    mux2 U0 (\n        .X(w0),\n        .A0(A[0]),\n        .A1(A[1]),\n        .S(S[0])\n    );\n\n    mux2 U1 (\n        .X(w1),\n        .A0(A[2]),\n        .A1(A[3]),\n        .S(S[0])\n    );\n\n    mux2 U2 (\n        .X(X),\n        .A0(w0),\n        .A1(w1),\n        .S(S[1])\n    );\n\nendmodule\nmodule mux2 (\n    input A0, A1, S,\n    output X\n);\n\n    assign X = S ? A1 : A0;\n\nendmodule\nCODE END"}, "clean_code": "module mux4 (\n    input [3:0] A,\n    input [1:0] S,\n    output X\n);\n\n    wire w0, w1, w2, w3;\n\n    mux2 U0 (\n        .X(w0),\n        .A0(A[0]),\n        .A1(A[1]),\n        .S(S[0])\n    );\n\n    mux2 U1 (\n        .X(w1),\n        .A0(A[2]),\n        .A1(A[3]),\n        .S(S[0])\n    );\n\n    mux2 U2 (\n        .X(X),\n        .A0(w0),\n        .A1(w1),\n        .S(S[1])\n    );\n\nendmodule\nmodule mux2 (\n    input A0, A1, S,\n    output X\n);\n\n    assign X = S ? A1 : A0;\n\nendmodule", "corrupted_code": "module mux4 (\n    input [3:0] A,\n    input [1:0] S,\n    output X\n);\n\n    wire w0, w1, w2, w3;\n\n    mux2 U0 (\n        .X(w0),\n        .A0(A[0]),\n        .A1(A[1]),\n        .S(S[0])\n    );\n\n    mux2 U1 (\n        .X(w1),\n        .A0(A[2]),\n        .A1(A[3]),\n        .S(S[0])\n    );\n\n    mux2 U2 (\n        .X(X),\n        .A0(w0),\n        .A1(w1),\n        .S(S[1])\n    );\n\nendmodule\nmodule mux2 (\n    input A0, A1, S,\n    output X\n);\n\nendmodule", "corruption_explanation": "Removed an assignment statement", "modification_type": "remove_assignment", "modification_line": 35, "original_snippet": "assign X = S ? A1 : A0;", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an assignment statement. This leaves a signal undriven or with stale values, causing incorrect behavior or synthesis warnings about undriven nets. Signals may be inferred as latches or remain at unknown values.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_assignment modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an assignment statement\n   \u2022 Line 35: Original: assign X = S ? A1 : A0;\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 35.\n   \u2022 Restore the original code: assign X = S ? A1 : A0;\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove assignment.", "complexity": 0, "applicable_modifications": ["change_constant", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "timestamp": "2025-12-09T21:43:36.304015"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `logic_unit` that implements a simple logic unit.\n\nThe module should have the following interface:\n*   Inputs:\n    *   `opA`: a 32-bit input.\n    *   `opB`: a 32-bit input.\n    *   `op`: a 2-bit input that selects the operation.\n*   Output:\n    *   `result`: a 32-bit output representing the result of the operation.\n\nThe functionality of the module should be determined by the `op` input as follows:\n*   When `op` is `2'b00`, the `result` should be the bitwise AND of `opA` and `opB`.\n*   When `op` is `2'b01`, the `result` should be the bitwise OR of `opA` and `opB`.\n*   When `op` is `2'b10`, the `result` should be the bitwise XOR of `opA` and `opB`.\n*   When `op` is `2'b11`, the `result` should be the bitwise NOR of `opA` and `opB`.\n\nImplement this logic in Verilog.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule logic_unit (\n            opB, opA,\n            op,\n            result);\n\ninput [31:0] opA;\ninput [31:0] opB;\ninput [1:0] op;\noutput [31:0] result;\n\nreg [31:0] logic_result;\n\nalways@(opA or opB or op )\n    case(op)\n        2'b00:\n            logic_result=opA&opB;\n        2'b01:\n            logic_result=opA|opB;\n        2'b10:\n            logic_result=opA^opB;\n        2'b11:\n            logic_result=~(opA|opB);\n    endcase\n\nassign result=logic_result;\n\nendmodule\nCODE END"}, "clean_code": "module logic_unit (\n            opB, opA,\n            op,\n            result);\n\ninput [31:0] opA;\ninput [31:0] opB;\ninput [1:0] op;\noutput [31:0] result;\n\nreg [31:0] logic_result;\n\nalways@(opA or opB or op )\n    case(op)\n        2'b00:\n            logic_result=opA&opB;\n        2'b01:\n            logic_result=opA|opB;\n        2'b10:\n            logic_result=opA^opB;\n        2'b11:\n            logic_result=~(opA|opB);\n    endcase\n\nassign result=logic_result;\n\nendmodule", "corrupted_code": "module logic_unit (\n            opB, opA,\n            op,\n            result);\n\ninput [31:0] opA;\ninput [31:0] opB;\ninput [1:0] op;\noutput [31:0] result;\n\nreg [31:0] logic_result;\n\nalways@(opA or opB or op )\n    case(op)\n        2'b00:\n            logic_result=opA&opB;\n        2'b11:\n            logic_result=~(opA|opB);\n    \n        2'b01:\n            logic_result=opA|opB;\n        2'b10:\n            logic_result=opA^opB;endcase\n\nassign result=logic_result;\n\nendmodule", "corruption_explanation": "Shuffled case items order", "modification_type": "shuffle_case_items", "modification_line": 14, "original_snippet": "case(op)\n        2'b00:\n            logic_result=opA&opB;\n        2'b01:\n            logic_result=opA|opB;\n        2'b10:\n            logic_result=opA^opB;\n        2'b11:\n            logic_result=~(op", "modified_snippet": "case(op)\n        2'b00:\n            logic_result=opA&opB;\n        2'b11:\n            logic_result=~(opA|opB);\n    \n        2'b01:\n            logic_result=opA|opB;\n        2'b10:\n            logic_res", "issue_description": "The buggy code has reordered case items in a case statement. For priority-encoded case statements (casex, casez), the order matters. Reordering breaks the intended priority, causing incorrect item matching. Test cases may pass for some inputs but fail for overlapping patterns.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a shuffle_case_items modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Shuffled case items order\n   \u2022 Line 14: Original: case(op)\n        2'b00:\n            logic_result=opA&opB;\n        2'b01:\n            logic_result=opA|opB;\n        2'b10:\n            logic_result=opA^opB;\n        2'b11:\n            logic_result=~(op\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 14.\n   \u2022 Restore the original code: case(op)\n        2'b00:\n            logic_result=opA&opB;\n        2'b01:\n            logic_result=opA|opB;\n        2'b10:\n            logic_result=opA^opB;\n        2'b11:\n            logic_result=~(op\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to shuffle case items.", "complexity": 5, "applicable_modifications": ["remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "shuffle_case_items"], "timestamp": "2025-12-09T21:43:36.306000"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `altera_tse_false_path_marker`. This module should act as a simple registered stage, often used to break timing paths or synchronize signals.\n\nThe module should include a parameter named `MARKER_WIDTH` with a default value of 1, which defines the width of the data path.\n\nThe module's interface should be defined as follows:\n*   Input `reset`: An asynchronous reset signal.\n*   Input `clk`: The clock signal.\n*   Input `data_in`: The input data, with a width determined by `MARKER_WIDTH`.\n*   Output `data_out`: The registered output data, with a width determined by `MARKER_WIDTH`.\n\nImplement the module such that:\n*   The output `data_out` is continuously driven by the value held in an internal register.\n*   On the positive edge of the `clk` signal, the value of `data_in` is loaded into the internal register.\n*   On the positive edge of the `reset` signal, the internal register is asynchronously cleared to a value of all zeros, regardless of the clock signal.\n\nDesign the Verilog code to meet these specifications.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\n\nmodule altera_tse_false_path_marker \n#(\n   parameter MARKER_WIDTH = 1\n)\n(\n   input    reset,\n   input    clk,\n   input    [MARKER_WIDTH - 1 : 0] data_in,\n   output   [MARKER_WIDTH - 1 : 0] data_out\n);\n\n reg [MARKER_WIDTH - 1 : 0] data_out_reg;\n\n\nassign data_out = data_out_reg;\n\nalways @(posedge clk or posedge reset) \nbegin\n   if (reset)\n   begin\n      data_out_reg <= {MARKER_WIDTH{1'b0}};\n   end\n   else\n   begin\n      data_out_reg <= data_in;\n   end\nend\n\nendmodule\n\nCODE END"}, "clean_code": "module altera_tse_false_path_marker \n#(\n   parameter MARKER_WIDTH = 1\n)\n(\n   input    reset,\n   input    clk,\n   input    [MARKER_WIDTH - 1 : 0] data_in,\n   output   [MARKER_WIDTH - 1 : 0] data_out\n);\n\n reg [MARKER_WIDTH - 1 : 0] data_out_reg;\n\n\nassign data_out = data_out_reg;\n\nalways @(posedge clk or posedge reset) \nbegin\n   if (reset)\n   begin\n      data_out_reg <= {MARKER_WIDTH{1'b0}};\n   end\n   else\n   begin\n      data_out_reg <= data_in;\n   end\nend\n\nendmodule", "corrupted_code": "module altera_tse_false_path_marker \n#(\n   parameter MARKER_WIDTH = 1\n)\n(\n   input    reset,\n   input    clk,\n   input    [1 - MARKER_WIDTH : 0] data_in,\n   output   [MARKER_WIDTH - 1 : 0] data_out\n);\n\n reg [MARKER_WIDTH - 1 : 0] data_out_reg;\n\n\nassign data_out = data_out_reg;\n\nalways @(posedge clk or posedge reset) \nbegin\n   if (reset)\n   begin\n      data_out_reg <= {MARKER_WIDTH{1'b0}};\n   end\n   else\n   begin\n      data_out_reg <= data_in;\n   end\nend\n\nendmodule", "corruption_explanation": "Swapped operands: 'MARKER_WIDTH - 1' -> '1 - MARKER_WIDTH'", "modification_type": "swap_operands", "modification_line": 8, "original_snippet": "MARKER_WIDTH - 1", "modified_snippet": "1 - MARKER_WIDTH", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: 'MARKER_WIDTH - 1' -> '1 - MARKER_WIDTH'\n   \u2022 Line 8: Original: MARKER_WIDTH - 1\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 8.\n   \u2022 Restore the original code: MARKER_WIDTH - 1\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 6, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.306978"}
{"original_entry": {"instruction": "\nWrite Verilog code for a module named `transmission_gate_full_adder`.\nThe module should have inputs `a`, `b`, `cin` and outputs `sum`, `cout`.\nImplement the logic for a full adder using a specific coding style:\n1.  Declare and use several intermediate `wire` signals derived from the inputs (`a`, `b`, `cin`) to represent partial logic results.\n2.  Declare two `reg` signals, `sum_reg` and `cout_reg`.\n3.  Update `sum_reg` and `cout_reg` in *separate* `always @` blocks. The sensitivity lists for these blocks must be carefully chosen based on the intermediate signals used to compute the logic for `sum_reg` and `cout_reg`.\n4.  Assign the final outputs `sum` and `cout` using `assign` statements that read directly from `sum_reg` and `cout_reg`.\nImplement the standard full adder sum logic (the XOR of the three inputs). Implement the carry-out logic as the OR of three specific AND terms: one involving `a` and `cin`, one involving `b` and `cin`, and one involving the XOR of `a` and `b` with `cin`.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule transmission_gate_full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\nwire t1, t2, t3, t4, t5, t6;\n\nassign t1 = a & b;\nassign t2 = a ^ b;\nassign t3 = t2 & cin;\nassign t4 = t1 | t3;\nassign t5 = a & cin;\nassign t6 = b & cin;\n\nreg sum_reg;\nreg cout_reg;\n\nalways @(t2, cin) begin\n    sum_reg <= t2 ^ cin;\nend\n\nalways @(t6, t5, t3) begin\n    cout_reg <= t6 | t5 | t3;\nend\n\nassign sum = sum_reg;\nassign cout = cout_reg;\n\nendmodule\n\nCODE END"}, "clean_code": "module transmission_gate_full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\nwire t1, t2, t3, t4, t5, t6;\n\nassign t1 = a & b;\nassign t2 = a ^ b;\nassign t3 = t2 & cin;\nassign t4 = t1 | t3;\nassign t5 = a & cin;\nassign t6 = b & cin;\n\nreg sum_reg;\nreg cout_reg;\n\nalways @(t2, cin) begin\n    sum_reg <= t2 ^ cin;\nend\n\nalways @(t6, t5, t3) begin\n    cout_reg <= t6 | t5 | t3;\nend\n\nassign sum = sum_reg;\nassign cout = cout_reg;\n\nendmodule", "corrupted_code": "module transmission_gate_full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\nwire t1, t2, t3, t4, t5, t6;\n\nassign t1 <= a & b;\nassign t2 = a ^ b;\nassign t3 = t2 & cin;\nassign t4 = t1 | t3;\nassign t5 = a & cin;\nassign t6 = b & cin;\n\nreg sum_reg;\nreg cout_reg;\n\nalways @(t2, cin) begin\n    sum_reg <= t2 ^ cin;\nend\n\nalways @(t6, t5, t3) begin\n    cout_reg <= t6 | t5 | t3;\nend\n\nassign sum = sum_reg;\nassign cout = cout_reg;\n\nendmodule", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 11, "original_snippet": "1 = a & b;", "modified_snippet": "1 <= a & b;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 12, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_always_block"], "timestamp": "2025-12-09T21:43:36.308070"}
{"original_entry": {"instruction": "\nDesign the following two Verilog modules:\n\n1.  **Module `full_adder`**:\n    *   Inputs: `a`, `b`, `ci` (all 1-bit)\n    *   Outputs: `s`, `co` (all 1-bit)\n    *   Implement a standard full adder using basic logic gates (AND, OR, XOR).\n\n2.  **Module `adder4bit`**:\n    *   Inputs: `A` (4-bit, range `[3:0]`), `B` (4-bit, range `[3:0]`), `Ci` (1-bit)\n    *   Outputs: `S` (4-bit, range `[3:0]`), `Co` (1-bit)\n    *   This module performs two parallel 4-bit arithmetic calculations internally:\n        *   Calculation 1: `A + B + Ci`\n        *   Calculation 2: `A - B + Ci` (where `-B` is represented as the two's complement of B)\n    *   The module outputs the 4-bit sum from Calculation 1 as `S`.\n    *   The module outputs the *inverted* 1-bit carry-out from Calculation 1 as `Co`.\n    *   The 4-bit sum and 1-bit carry-out from Calculation 2 are computed internally but are not connected to any module outputs.\n    *   Implement `adder4bit` using instances of the `full_adder` module. Use a ripple-carry structure and a `generate` block for the bit-wise instantiation where appropriate.\n\nEnsure all input and output ports match the names specified above exactly.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule adder4bit (A, B, Ci, S, Co);\n  input [3:0] A, B;\n  input Ci;\n  output [3:0] S;\n  output Co;\n\n  wire [3:0] c;\n  wire [3:0] x;\n  wire [3:0] y;\n\n  // Full adder for the least significant bit\n  full_adder FA0 (.a(A[0]), .b(B[0]), .ci(Ci), .s(S[0]), .co(c[0]));\n\n  // Full adders for the remaining bits\n  genvar i;\n  generate\n    for (i = 1; i < 4; i = i + 1) begin\n      full_adder FA (.a(A[i]), .b(B[i]), .ci(c[i-1]), .s(S[i]), .co(c[i]));\n    end\n  endgenerate\n\n  // Invert carry out to get Co\n  assign Co = ~c[3];\n\n  // Invert B to get 2's complement\n  assign y = ~B;\n  assign y[0] = y[0] ^ 1'b1;\n\n  // Add inverted B to A\n  full_adder FA1 (.a(A[0]), .b(y[0]), .ci(Ci), .s(x[0]), .co());\n  generate\n    for (i = 1; i < 4; i = i + 1) begin\n      full_adder FA (.a(A[i]), .b(y[i]), .ci(c[i-1]), .s(x[i]), .co());\n    end\n  endgenerate\nendmodule\nmodule full_adder (a, b, ci, s, co);\n  input a, b, ci;\n  output s, co;\n\n  wire x1, x2, x3;\n\n  // First XOR gate\n  assign x1 = a ^ b;\n\n  // Second XOR gate\n  assign s = x1 ^ ci;\n\n  // AND gate\n  assign x2 = a & b;\n\n  // Third XOR gate\n  assign x3 = x1 & ci;\n\n  // OR gate\n  assign co = x2 | x3;\nendmodule\nCODE END"}, "clean_code": "module adder4bit (A, B, Ci, S, Co);\n  input [3:0] A, B;\n  input Ci;\n  output [3:0] S;\n  output Co;\n\n  wire [3:0] c;\n  wire [3:0] x;\n  wire [3:0] y;\n\n  // Full adder for the least significant bit\n  full_adder FA0 (.a(A[0]), .b(B[0]), .ci(Ci), .s(S[0]), .co(c[0]));\n\n  // Full adders for the remaining bits\n  genvar i;\n  generate\n    for (i = 1; i < 4; i = i + 1) begin\n      full_adder FA (.a(A[i]), .b(B[i]), .ci(c[i-1]), .s(S[i]), .co(c[i]));\n    end\n  endgenerate\n\n  // Invert carry out to get Co\n  assign Co = ~c[3];\n\n  // Invert B to get 2's complement\n  assign y = ~B;\n  assign y[0] = y[0] ^ 1'b1;\n\n  // Add inverted B to A\n  full_adder FA1 (.a(A[0]), .b(y[0]), .ci(Ci), .s(x[0]), .co());\n  generate\n    for (i = 1; i < 4; i = i + 1) begin\n      full_adder FA (.a(A[i]), .b(y[i]), .ci(c[i-1]), .s(x[i]), .co());\n    end\n  endgenerate\nendmodule\nmodule full_adder (a, b, ci, s, co);\n  input a, b, ci;\n  output s, co;\n\n  wire x1, x2, x3;\n\n  // First XOR gate\n  assign x1 = a ^ b;\n\n  // Second XOR gate\n  assign s = x1 ^ ci;\n\n  // AND gate\n  assign x2 = a & b;\n\n  // Third XOR gate\n  assign x3 = x1 & ci;\n\n  // OR gate\n  assign co = x2 | x3;\nendmodule", "corrupted_code": "module adder4bit (A, B, Ci, S, Co);\n  input [3:0] A, B;\n  input Ci;\n  output [3:0] S;\n  output Co;\n\n  wire [3:0] c;\n  wire [3:0] x;\n  wire [3:0] y;\n\n  // Full adder for the least significant bit\n  full_adder FA0 (.a(A[0]), .b(B[0]), .ci(Ci), .s(S[0]), .co(c[0]));\n\n  // Full adders for the remaining bits\n  genvar i;\n  generate\n    for (i = 1; i < 4; i = i + 1) begin\n      full_adder FA (.a(A[i]), .b(B[i]), .ci(c[i-1]), .s(S[i]), .co(c[i]));\n    end\n  endgenerate\n\n  // Invert carry out to get Co\n  assign Co = ~c[3];\n\n  // Invert B to get 2's complement\n  assign y = ~B;\n  assign y[0] = y[0] ^ 1'b1;\n\n  // Add inverted B to A\n  full_adder FA1 (.a(A[0]), .b(y[0]), .ci(Ci), .s(x[0]), .co());\n  generate\n    for (i = 1; i < 4; i = i + 1) begin\n      full_adder FA (.a(A[i]), .b(y[i]), .ci(c[i-1]), .s(x[i]), .co());\n    end\n  endgenerate\nendmodule\nmodule full_adder (a, b, ci, s, co);\n  input a, b, ci;\n  output s, co;\n\n  wire x1, x2, x3;\n\n  // First XOR gate\n  assign x1 = a & b;\n\n  // Second XOR gate\n  assign s = x1 ^ ci;\n\n  // AND gate\n  assign x2 = a & b;\n\n  // Third XOR gate\n  assign x3 = x1 & ci;\n\n  // OR gate\n  assign co = x2 | x3;\nendmodule", "corruption_explanation": "Changed operator from '^' to '&'", "modification_type": "change_operator", "modification_line": 44, "original_snippet": "^", "modified_snippet": "&", "issue_description": "The buggy code uses the wrong operator in an expression. For example, using subtraction instead of addition, or AND instead of OR. This causes incorrect arithmetic or logical results. Test cases will fail because the computed values don't match expectations.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_operator modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed operator from '^' to '&'\n   \u2022 Line 44: Original: ^\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 44.\n   \u2022 Restore the original code: ^\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change operator.", "complexity": 13, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_loop", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "timestamp": "2025-12-09T21:43:36.310183"}
{"original_entry": {"instruction": "\nWrite the Verilog code for a module named `acciones_to_bcd`.\n\nThe module has the following interface:\nInputs:\n*   `clk` (1 bit)\n*   `rst` (1 bit)\n*   `piso` (2 bits)\n*   `accion` (2 bits)\n*   `puertas` (1 bit)\nOutputs:\n*   `BCD1` (4 bits)\n*   `BCD2` (4 bits)\n*   `BCD3` (4 bits)\n*   `BCD4` (4 bits)\n\nAll outputs should be of type `reg`.\n\nAt simulation time 0, the outputs should be initialized to:\n*   `BCD4 = 4'd1`\n*   `BCD3 = 4'd9`\n*   `BCD2 = 4'd6`\n*   `BCD1 = 4'd0`\n\nThe module should update its outputs on the positive edge of the clock (`clk`).\n\nWhen the reset signal `rst` is high on a clock edge, the outputs should take on specific values with simulation delays:\n*   `BCD4` should immediately become `4'b1110`, and then 10 time units later become `4'b0001`.\n*   `BCD3` should immediately become `4'b0110`, and then 10 time units later become `4'b1001`.\n*   `BCD1` should immediately become `4'b1111`, and then 10 time units later become `4'b0000`.\n*   `BCD2` should immediately become `4'b1001`, and then 10 time units later become `4'b0110`.\n\nWhen the reset signal `rst` is low on a clock edge, the outputs should behave as follows:\n*   `BCD4` should represent the BCD digit corresponding to the value of `piso`:\n    *   If `piso = 2'b00`, `BCD4` is BCD 1 (`4'b0001`).\n    *   If `piso = 2'b01`, `BCD4` is BCD 2 (`4'b0010`).\n    *   If `piso = 2'b10`, `BCD4` is BCD 3 (`4'b0011`).\n    *   If `piso = 2'b11`, `BCD4` is BCD 4 (`4'b0100`).\n*   `BCD1` should represent a BCD digit based on `accion`:\n    *   If `accion = 2'b00`, `BCD1` is BCD 0 (`4'b0000`).\n    *   If `accion = 2'b01`, `BCD1` is BCD 5 (`4'b0101`).\n    *   If `accion = 2'b10`, `BCD1` is BCD 8 (`4'b1000`).\n    *   If `accion = 2'b11`, `BCD1` is BCD 0 (`4'b0000`).\n*   `BCD2` should represent a BCD digit based on `puertas`:\n    *   If `puertas = 1'b0`, `BCD2` is BCD 7 (`4'b0111`).\n    *   If `puertas = 1'b1`, `BCD2` is BCD 6 (`4'b0110`).\n*   `BCD3` should retain its current value (set by the initial condition or the last reset) and is not updated during normal operation.\n\nImplement this behavior using appropriate Verilog constructs for sequential logic and initial states, including the specified simulation delays during reset.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule acciones_to_bcd(\n\t input clk,\n\t input rst,\n\t input [1:0] piso, input [1:0] accion, input puertas, output reg [3:0] BCD1,\n\t output reg [3:0] BCD2,\n\t output reg [3:0] BCD3,\n\t output reg [3:0] BCD4\n    );\n\ninitial begin\n\tBCD4 = 1;\n\tBCD3 = 9;\n\tBCD2 = 6;\n\tBCD1 = 0;\nend\n\nalways @ (posedge clk)\n\tbegin\n\t\tif (rst == 1)\n\t\t\tbegin\n\t\t\t\tBCD4 = 4'b1110;\n\t\t\t\t#10 BCD4 = 4'b0001;\n\t\t\t\tBCD3 = 4'b0110;\n\t\t\t\t#10 BCD3 = 4'b1001;\n\t\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\t\tif (piso == 2'b00)\n\t\t\t\t\tBCD4 = 4'b0001;\n\t\t\t\telse if (piso == 2'b01)\n\t\t\t\t\tBCD4 = 4'b0010;\n\t\t\t\telse if (piso == 2'b10)\n\t\t\t\t\tBCD4 = 4'b0011;\n\t\t\t\telse\n\t\t\t\t\tBCD4 = 4'b0100;\n\t\t\tend\n\tend\n\nalways @ (posedge clk)\n\tbegin\n\t\tif (rst == 1)\n\t\t\tbegin\n\t\t\t\tBCD1 = 4'b1111;\n\t\t\t\t#10 BCD1 = 4'b0000;\n\t\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\t\tif (accion == 2'b00)\n\t\t\t\t\tBCD1 = 4'b0000;\n\t\t\t\telse if (accion == 2'b01)\n\t\t\t\t\tBCD1 = 4'b0101;\n\t\t\t\telse if (accion == 2'b10)\n\t\t\t\t\tBCD1 = 4'b1000;\n\t\t\t\telse\n\t\t\t\t\tBCD1 = 0;\n\t\t\tend\n\tend\n\nalways @ (posedge clk)\n\tbegin\n\t\tif (rst == 1)\n\t\t\tbegin\n\t\t\t\tBCD2 = 4'b1001;\n\t\t\t\t#10 BCD2 = 4'b0110;\n\t\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\t\tif (puertas == 1'b0)\n\t\t\t\t\tBCD2 = 4'b0111;\n\t\t\t\telse\n\t\t\t\t\tBCD2 = 4'b0110;\n\t\t\tend\n\tend\n\nendmodule\n\nCODE END"}, "clean_code": "module acciones_to_bcd(\n\t input clk,\n\t input rst,\n\t input [1:0] piso, input [1:0] accion, input puertas, output reg [3:0] BCD1,\n\t output reg [3:0] BCD2,\n\t output reg [3:0] BCD3,\n\t output reg [3:0] BCD4\n    );\n\ninitial begin\n\tBCD4 = 1;\n\tBCD3 = 9;\n\tBCD2 = 6;\n\tBCD1 = 0;\nend\n\nalways @ (posedge clk)\n\tbegin\n\t\tif (rst == 1)\n\t\t\tbegin\n\t\t\t\tBCD4 = 4'b1110;\n\t\t\t\t#10 BCD4 = 4'b0001;\n\t\t\t\tBCD3 = 4'b0110;\n\t\t\t\t#10 BCD3 = 4'b1001;\n\t\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\t\tif (piso == 2'b00)\n\t\t\t\t\tBCD4 = 4'b0001;\n\t\t\t\telse if (piso == 2'b01)\n\t\t\t\t\tBCD4 = 4'b0010;\n\t\t\t\telse if (piso == 2'b10)\n\t\t\t\t\tBCD4 = 4'b0011;\n\t\t\t\telse\n\t\t\t\t\tBCD4 = 4'b0100;\n\t\t\tend\n\tend\n\nalways @ (posedge clk)\n\tbegin\n\t\tif (rst == 1)\n\t\t\tbegin\n\t\t\t\tBCD1 = 4'b1111;\n\t\t\t\t#10 BCD1 = 4'b0000;\n\t\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\t\tif (accion == 2'b00)\n\t\t\t\t\tBCD1 = 4'b0000;\n\t\t\t\telse if (accion == 2'b01)\n\t\t\t\t\tBCD1 = 4'b0101;\n\t\t\t\telse if (accion == 2'b10)\n\t\t\t\t\tBCD1 = 4'b1000;\n\t\t\t\telse\n\t\t\t\t\tBCD1 = 0;\n\t\t\tend\n\tend\n\nalways @ (posedge clk)\n\tbegin\n\t\tif (rst == 1)\n\t\t\tbegin\n\t\t\t\tBCD2 = 4'b1001;\n\t\t\t\t#10 BCD2 = 4'b0110;\n\t\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\t\tif (puertas == 1'b0)\n\t\t\t\t\tBCD2 = 4'b0111;\n\t\t\t\telse\n\t\t\t\t\tBCD2 = 4'b0110;\n\t\t\tend\n\tend\n\nendmodule", "corrupted_code": "module acciones_to_bcd(\n\t input clk,\n\t input rst,\n\t input [1:0] piso, input [1:0] accion, input puertas, output reg [3:0] BCD1,\n\t output reg [3:0] BCD2,\n\t output reg [3:0] BCD3,\n\t output reg [3:0] BCD4\n    );\n\ninitial begin\n\tBCD4 = 1;\n\tBCD3 = 9;\n\tBCD2 = 6;\n\tBCD1 = 0;\nend\n\nalways @ (posedge clk)\n\tbegin\n\t\tif (rst == 1)\n\t\t\tbegin\n\t\t\t\tBCD4 = 4'b1110;\n\t\t\t\t#10 BCD4 = 4'b0001;\n\t\t\t\tBCD3 = 4'b0110;\n\t\t\t\t#10 BCD3 = 4'b1001;\n\t\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\t\tif (piso == 2'b00)\n\t\t\t\t\tBCD4 = 4'b0001;\n\t\t\t\telse if (piso == 2'b01)\n\t\t\t\t\tBCD4 = 4'b0010;\n\t\t\t\telse if (piso == 2'b10)\n\t\t\t\t\tBCD4 = 4'b0011;\n\t\t\t\telse\n\t\t\t\t\tBCD4 = 4'b0100;\n\t\t\tend\n\tend\n\nalways @ (posedge clk)\n\tbegin\n\t\tif (rst == 1)\n\t\t\tbegin\n\t\t\t\tBCD1 = 4'b1111;\n\t\t\t\t#10 BCD1 = 4'b0001;\n\t\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\t\tif (accion == 2'b00)\n\t\t\t\t\tBCD1 = 4'b0000;\n\t\t\t\telse if (accion == 2'b01)\n\t\t\t\t\tBCD1 = 4'b0101;\n\t\t\t\telse if (accion == 2'b10)\n\t\t\t\t\tBCD1 = 4'b1000;\n\t\t\t\telse\n\t\t\t\t\tBCD1 = 0;\n\t\t\tend\n\tend\n\nalways @ (posedge clk)\n\tbegin\n\t\tif (rst == 1)\n\t\t\tbegin\n\t\t\t\tBCD2 = 4'b1001;\n\t\t\t\t#10 BCD2 = 4'b0110;\n\t\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\t\tif (puertas == 1'b0)\n\t\t\t\t\tBCD2 = 4'b0111;\n\t\t\t\telse\n\t\t\t\t\tBCD2 = 4'b0110;\n\t\t\tend\n\tend\n\nendmodule", "corruption_explanation": "Changed constant from 4'b0000 to 4'b0001", "modification_type": "change_constant", "modification_line": 44, "original_snippet": "4'b0000", "modified_snippet": "4'b0001", "issue_description": "The buggy code has an incorrect numeric constant value. This off-by-one or similar error causes incorrect computations, timing issues, or boundary condition failures. Test cases that rely on exact numeric values will fail.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_constant modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed constant from 4'b0000 to 4'b0001\n   \u2022 Line 44: Original: 4'b0000\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 44.\n   \u2022 Restore the original code: 4'b0000\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change constant.", "complexity": 16, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.312025"}
{"original_entry": {"instruction": "\nDesign a Verilog module named `top_module` that implements a system which first selects one of four 4-bit inputs based on a 2-bit select signal, and then adds the constant value 4'b0011 to the selected input.\n\nThe design should be modular and composed of two sub-modules: a 4-to-1 multiplexer and a 4-bit binary adder.\n\n1.  Implement the 4-to-1 multiplexer as a module named `mux_4to1`.\n    *   It should have the following interface:\n        *   Inputs: `input [3:0] in0`, `input [3:0] in1`, `input [3:0] in2`, `input [3:0] in3`, `input [1:0] sel`\n        *   Output: `output [3:0] out`\n    *   Based on the value of `sel`, the module should select one of the four inputs (`in0`, `in1`, `in2`, or `in3`) and output it on `out`. Specifically, `out` should be `in0` when `sel` is 2'b00, `in1` when `sel` is 2'b01, `in2` when `sel` is 2'b10, and `in3` when `sel` is 2'b11.\n\n2.  Implement the 4-bit binary adder as a module named `binary_adder`.\n    *   It should have the following interface:\n        *   Inputs: `input [3:0] a`, `input [3:0] b`\n        *   Output: `output [3:0] sum`\n    *   The module should compute the 4-bit sum of the two inputs `a` and `b`.\n\n3.  Implement the main module named `top_module`.\n    *   It should have the following interface:\n        *   Inputs: `input [3:0] in0`, `input [3:0] in1`, `input [3:0] in2`, `input [3:0] in3`, `input [1:0] sel`\n        *   Output: `output [3:0] out`\n    *   Inside `top_module`, instantiate one instance of the `mux_4to1` module and one instance of the `binary_adder` module.\n    *   Connect the inputs `in0`, `in1`, `in2`, `in3`, and `sel` of `top_module` to the corresponding inputs of the `mux_4to1` instance.\n    *   Connect the output of the `mux_4to1` instance to the input `a` of the `binary_adder` instance.\n    *   Connect the input `b` of the `binary_adder` instance to the constant value 4'b0011.\n    *   Connect the output `sum` of the `binary_adder` instance to the output `out` of `top_module`.\n\nProvide the complete Verilog code for all three modules.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule top_module(\n    input [3:0] in0,\n    input [3:0] in1,\n    input [3:0] in2,\n    input [3:0] in3,\n    input [1:0] sel,\n    output [3:0] out\n);\n\nwire [3:0] mux_out;\nwire [3:0] adder_out;\n\nmux_4to1 mux(\n    .in0(in0),\n    .in1(in1),\n    .in2(in2),\n    .in3(in3),\n    .sel(sel),\n    .out(mux_out)\n);\n\nbinary_adder adder(\n    .a(mux_out),\n    .b(4'b0011),\n    .sum(adder_out)\n);\n\nassign out = adder_out;\n\nendmodule\n\nmodule mux_4to1(\n    input [3:0] in0,\n    input [3:0] in1,\n    input [3:0] in2,\n    input [3:0] in3,\n    input [1:0] sel,\n    output [3:0] out\n);\n\nwire [3:0] and0_out;\nwire [3:0] and1_out;\nwire [3:0] and2_out;\nwire [3:0] and3_out;\nwire [3:0] or0_out;\nwire [3:0] or1_out;\n\nassign and0_out = sel[1] & sel[0] ? in3 : 4'b0000;\nassign and1_out = sel[1] & ~sel[0] ? in2 : 4'b0000;\nassign and2_out = ~sel[1] & sel[0] ? in1 : 4'b0000;\nassign and3_out = ~sel[1] & ~sel[0] ? in0 : 4'b0000;\n\nassign or0_out = and0_out | and1_out;\nassign or1_out = and2_out | and3_out;\n\nassign out = or0_out | or1_out;\n\nendmodule\n\nmodule binary_adder(\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] sum\n);\n\nalways @* begin\n    sum = a + b;\nend\n\nendmodule\nCODE END"}, "clean_code": "module top_module(\n    input [3:0] in0,\n    input [3:0] in1,\n    input [3:0] in2,\n    input [3:0] in3,\n    input [1:0] sel,\n    output [3:0] out\n);\n\nwire [3:0] mux_out;\nwire [3:0] adder_out;\n\nmux_4to1 mux(\n    .in0(in0),\n    .in1(in1),\n    .in2(in2),\n    .in3(in3),\n    .sel(sel),\n    .out(mux_out)\n);\n\nbinary_adder adder(\n    .a(mux_out),\n    .b(4'b0011),\n    .sum(adder_out)\n);\n\nassign out = adder_out;\n\nendmodule\n\nmodule mux_4to1(\n    input [3:0] in0,\n    input [3:0] in1,\n    input [3:0] in2,\n    input [3:0] in3,\n    input [1:0] sel,\n    output [3:0] out\n);\n\nwire [3:0] and0_out;\nwire [3:0] and1_out;\nwire [3:0] and2_out;\nwire [3:0] and3_out;\nwire [3:0] or0_out;\nwire [3:0] or1_out;\n\nassign and0_out = sel[1] & sel[0] ? in3 : 4'b0000;\nassign and1_out = sel[1] & ~sel[0] ? in2 : 4'b0000;\nassign and2_out = ~sel[1] & sel[0] ? in1 : 4'b0000;\nassign and3_out = ~sel[1] & ~sel[0] ? in0 : 4'b0000;\n\nassign or0_out = and0_out | and1_out;\nassign or1_out = and2_out | and3_out;\n\nassign out = or0_out | or1_out;\n\nendmodule\n\nmodule binary_adder(\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] sum\n);\n\nalways @* begin\n    sum = a + b;\nend\n\nendmodule", "corrupted_code": "module top_module(\n    input [3:0] in0,\n    input [3:0] in1,\n    input [3:0] in2,\n    input [3:0] in3,\n    input [1:0] sel,\n    output [3:0] out\n);\n\nwire [3:0] mux_out;\nwire [3:0] adder_out;\n\nmux_4to1 mux(\n    .in0(in0),\n    .in1(in1),\n    .in2(in2),\n    .in3(in3),\n    .sel(sel),\n    .out(mux_out)\n);\n\nbinary_adder adder(\n    .a(mux_out),\n    .b(4'b0011),\n    .sum(adder_out)\n);\n\nassign out = adder_out;\n\nendmodule\n\nmodule mux_4to1(\n    input [3:0] in0,\n    input [3:0] in1,\n    input [3:0] in2,\n    input [3:0] in3,\n    input [1:0] sel,\n    output [3:0] out\n);\n\nwire [3:0] and0_out;\nwire [3:0] and1_out;\nwire [3:0] and2_out;\nwire [3:0] and3_out;\nwire [3:0] or0_out;\nwire [3:0] or1_out;\n\nassign and0_out = sel[1] & sel[0] ? in3 : 4'b0000;\nassign and1_out = sel[1] & ~sel[0] ? in2 : 4'b0000;\nassign and2_out = ~sel[1] & sel[0] ? in1 : 4'b0000;\nassign and3_out = ~sel[1] & ~sel[0] ? in0 : 4'b0000;\n\nassign or0_out = and0_out | and1_out;\nassign or1_out = and2_out | and3_out;\n\nassign out = or0_out | or1_out;\n\nendmodule\n\nmodule binary_adder(\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] sum\n);\n\n\n\nendmodule", "corruption_explanation": "Removed an always block", "modification_type": "remove_always_block", "modification_line": 66, "original_snippet": "always @* begin\n    sum = a + b;\nend", "modified_snippet": "(removed)", "issue_description": "The buggy code is missing an entire always block. This removes either sequential (flip-flop) or combinational logic entirely. Signals that were driven by this block are now undriven, causing synthesis failures or simulation X-propagation. Critical functionality is lost.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a remove_always_block modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Removed an always block\n   \u2022 Line 66: Original: always @* begin\n    sum = a + b;\nend\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 66.\n   \u2022 Restore the original code: always @* begin\n    sum = a + b;\nend\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to remove always block.", "complexity": 5, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_always_block", "swap_port_signals"], "timestamp": "2025-12-09T21:43:36.313812"}
{"original_entry": {"instruction": "\nWrite the Verilog code for a module named `multiplexer`.\n\nThis module should implement a 16-to-1 multiplexer with the following interface:\nInputs:\n*   `in1`, `in2`, `in3`, `in4`, `in5`, `in6`, `in7`, `in8`, `in9`, `in10`, `in11`, `in12`, `in13`, `in14`, `in15`, `in16`: Sixteen separate 6-bit data inputs.\n*   `sel`: A 4-bit select input.\nOutput:\n*   `out`: A single 6-bit output.\n\nThe module should select one of the sixteen 6-bit inputs based on the 4-bit select input `sel`. When `sel` has the binary value corresponding to the integer `N` (where `N` ranges from 0 to 15), the output `out` should be equal to the input `in(N+1)`. For example, when `sel` is 4'b0000 (integer 0), `out` should be `in1`; when `sel` is 4'b1111 (integer 15), `out` should be `in16`.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule multiplexer (in1, in2, in3, in4, in5, in6, in7, in8, in9, in10, in11, in12, in13, in14, in15, in16, sel, out);\n    input[5:0] in1;\n    input[5:0] in2;\n    input[5:0] in3;\n    input[5:0] in4;\n    input[5:0] in5;\n    input[5:0] in6;\n    input[5:0] in7;\n    input[5:0] in8;\n    input[5:0] in9;\n    input[5:0] in10;\n    input[5:0] in11;\n    input[5:0] in12;\n    input[5:0] in13;\n    input[5:0] in14;\n    input[5:0] in15;\n    input[5:0] in16;\n    input[3:0] sel;\n    output[5:0] out;\n    reg[5:0] out;\n    \n    \n    always @(in1, in2, in3, in4, in5, in6, in7, in8, in9, in10, in11, in12, in13, in14, in15, in16, sel)\n    begin \n    case(sel)\n        4'b0000: out = in1;\n        4'b0001: out = in2;\n        4'b0010: out = in3;\n        4'b0011: out = in4;\n        4'b0100: out = in5;\n        4'b0101: out = in6;\n        4'b0110: out = in7;\n        4'b0111: out = in8;\n        4'b1000: out = in9;\n        4'b1001: out = in10;\n        4'b1010: out = in11;\n        4'b1011: out = in12;\n        4'b1100: out = in13;\n        4'b1101: out = in14;\n        4'b1110: out = in15;\n        4'b1111: out = in16;\n        default: out = 0;\n    endcase\n    end\nendmodule\nCODE END"}, "clean_code": "module multiplexer (in1, in2, in3, in4, in5, in6, in7, in8, in9, in10, in11, in12, in13, in14, in15, in16, sel, out);\n    input[5:0] in1;\n    input[5:0] in2;\n    input[5:0] in3;\n    input[5:0] in4;\n    input[5:0] in5;\n    input[5:0] in6;\n    input[5:0] in7;\n    input[5:0] in8;\n    input[5:0] in9;\n    input[5:0] in10;\n    input[5:0] in11;\n    input[5:0] in12;\n    input[5:0] in13;\n    input[5:0] in14;\n    input[5:0] in15;\n    input[5:0] in16;\n    input[3:0] sel;\n    output[5:0] out;\n    reg[5:0] out;\n    \n    \n    always @(in1, in2, in3, in4, in5, in6, in7, in8, in9, in10, in11, in12, in13, in14, in15, in16, sel)\n    begin \n    case(sel)\n        4'b0000: out = in1;\n        4'b0001: out = in2;\n        4'b0010: out = in3;\n        4'b0011: out = in4;\n        4'b0100: out = in5;\n        4'b0101: out = in6;\n        4'b0110: out = in7;\n        4'b0111: out = in8;\n        4'b1000: out = in9;\n        4'b1001: out = in10;\n        4'b1010: out = in11;\n        4'b1011: out = in12;\n        4'b1100: out = in13;\n        4'b1101: out = in14;\n        4'b1110: out = in15;\n        4'b1111: out = in16;\n        default: out = 0;\n    endcase\n    end\nendmodule", "corrupted_code": "module multiplexer (in1, in2, in3, in4, in5, in6, in7, in8, in9, in10, in11, in12, in13, in14, in15, in16, sel, out);\n    input[5:0] in1;\n    input[5:0] in2;\n    input[5:0] in3;\n    input[5:0] in4;\n    input[5:0] in5;\n    input[5:0] in6;\n    input[5:0] in7;\n    input[5:0] in8;\n    input[5:0] in9;\n    input[5:0] in10;\n    input[5:0] in11;\n    input[5:0] in12;\n    input[5:0] in13;\n    input[5:0] in14;\n    input[5:0] in15;\n    input[5:0] in16;\n    input[3:0] sel;\n    output[5:0] out;\n    reg[5:0] out;\n    \n    \n    always @(in1, in2, in3, in4, in5, in6, in7, in8, in9, in10, in11, in12, in13, in14, in15, in16, sel)\n    begin \n    case(sel)\n        4'b0000: out = in1;\n        4'b0001: out = in2;\n        4'b0010: out = in3;\n        4'b0011: out = in4;\n        4'b0100: out = in5;\n        4'b0101: out = in6;\n        4'b0110: out = in7;\n        4'b0111: out = in8;\n        4'b1000: out = in9;\n        4'b1001: out = in10;\n        4'b1010: out = in11;\n        4'b1011: out = in12;\n        4'b1100: out = in13;\n        4'b1101: out <= in14;\n        4'b1110: out = in15;\n        4'b1111: out = in16;\n        default: out = 0;\n    endcase\n    end\nendmodule", "corruption_explanation": "Changed blocking (=) to non-blocking (<=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 39, "original_snippet": "out = in14;", "modified_snippet": "out <= in14;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 2, "applicable_modifications": ["remove_case_default", "change_constant", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "shuffle_case_items", "remove_always_block"], "timestamp": "2025-12-09T21:43:36.315830"}
{"original_entry": {"instruction": "\nWrite the Verilog code for a module named `data_adapter`.\nThis module acts as an adapter for a streaming interface that includes channel information.\nThe module has the following inputs and outputs:\nInputs:\n- `clk`\n- `reset_n`\n- `in_valid`\n- `in_data [7:0]`\n- `in_channel [7:0]`\n- `in_startofpacket`\n- `in_endofpacket`\n- `out_ready`\nOutputs:\n- `in_ready`\n- `out_valid`\n- `out_data [7:0]`\n- `out_startofpacket`\n- `out_endofpacket`\n\nThe module should define a parameter named `MAX_CHANNEL` with a default value of 15.\n\nThe primary function of the module is to pass the input stream signals to the corresponding output stream signals, but with a specific filtering requirement based on the channel number:\n1.  The `in_ready` output should be directly driven by the `out_ready` input.\n2.  The module should suppress any data associated with an `in_channel` value that is greater than the `MAX_CHANNEL` parameter. This suppression is implemented by setting `out_valid` to 0 when `in_channel` exceeds `MAX_CHANNEL`, regardless of the state of `in_valid`.\n3.  If the value of `in_channel` is not greater than `MAX_CHANNEL`, the `out_valid` output should simply follow the state of the `in_valid` input.\n4.  The `out_data`, `out_startofpacket`, and `out_endofpacket` outputs should reflect their corresponding input values.\n5.  The core logic should be combinational.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule data_adapter (\n    input              clk,\n    input              reset_n,\n    output reg         in_ready,\n    input              in_valid,\n    input      [ 7: 0] in_data,\n    input      [ 7: 0] in_channel,\n    input              in_startofpacket,\n    input              in_endofpacket,\n    input              out_ready,\n    output reg         out_valid,\n    output reg [ 7: 0] out_data,\n    output reg         out_startofpacket,\n    output reg         out_endofpacket\n);\n\n   reg          out_channel;\n   parameter    MAX_CHANNEL = 15;\n\n   // ---------------------------------------------------------------------\n   //| Payload Mapping\n   // ---------------------------------------------------------------------\n   always @* begin\n      in_ready = out_ready;\n      out_valid = 0;\n      out_data = in_data;\n      out_startofpacket = in_startofpacket;\n      out_endofpacket = in_endofpacket;\n\n      out_channel = in_channel;\n      // Suppress channels that are higher than the destination's max_channel.\n      if (in_channel > MAX_CHANNEL) begin\n         out_valid = 0;\n      end else begin\n         out_valid = in_valid;\n      end\n   end\n\nendmodule\nCODE END"}, "clean_code": "module data_adapter (\n    input              clk,\n    input              reset_n,\n    output reg         in_ready,\n    input              in_valid,\n    input      [ 7: 0] in_data,\n    input      [ 7: 0] in_channel,\n    input              in_startofpacket,\n    input              in_endofpacket,\n    input              out_ready,\n    output reg         out_valid,\n    output reg [ 7: 0] out_data,\n    output reg         out_startofpacket,\n    output reg         out_endofpacket\n);\n\n   reg          out_channel;\n   parameter    MAX_CHANNEL = 15;\n\n   // ---------------------------------------------------------------------\n   //| Payload Mapping\n   // ---------------------------------------------------------------------\n   always @* begin\n      in_ready = out_ready;\n      out_valid = 0;\n      out_data = in_data;\n      out_startofpacket = in_startofpacket;\n      out_endofpacket = in_endofpacket;\n\n      out_channel = in_channel;\n      // Suppress channels that are higher than the destination's max_channel.\n      if (in_channel > MAX_CHANNEL) begin\n         out_valid = 0;\n      end else begin\n         out_valid = in_valid;\n      end\n   end\n\nendmodule", "corrupted_code": "module data_adapter (\n    input              clk,\n    input              reset_n,\n    output reg         in_ready,\n    input              in_valid,\n    input      [ 7: 0] in_data,\n    input      [ 7: 0] in_channel,\n    input              in_startofpacket,\n    input              in_endofpacket,\n    input              out_ready,\n    output reg         out_valid,\n    output reg [ 7: 0] out_data,\n    output reg         out_startofpacket,\n    output reg         out_endofpacket\n);\n\n   reg          out_channel;\n   parameter    MAX_CHANNEL = 15;\n\n   // ---------------------------------------------------------------------\n   //| Payload Mapping\n   // ---------------------------------------------------------------------\n   always @* begin\n      in_ready = out_ready;\n      out_valid = 0;\n      out_data = in_data;\n      out_startofpacket = in_startofpacket;\n      out_endofpacket = in_endofpacket;\n\n      out_channel = in_channel;\n      // Suppress channels that are higher than the destination's max_channel.\n      if (in_channel > MAX_CHANNEL) begin\n         out_valid = in_valid;\n      end else begin\n         out_valid = 0;\n      end\n   end\n\nendmodule", "corruption_explanation": "Swapped if and else bodies", "modification_type": "invert_if_else", "modification_line": 32, "original_snippet": "if (in_channel > MAX_CHANNEL) begin\n         out_valid = 0;\n      end else begin\n         out_valid = in_valid;\n      end", "modified_snippet": "if (in_channel > MAX_CHANNEL) begin\n         out_valid = in_valid;\n      end else begin\n         out_valid = 0;\n      end", "issue_description": "The buggy code has swapped if and else bodies in a conditional block. This causes the logic to execute the opposite branch for each condition, leading to incorrect behavior when the condition is true vs false. Test cases that depend on the conditional logic will fail because the intended branch is not executed.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module contains conditional logic that should execute different code paths based on a condition.\n   \u2022 The if branch should handle the true case, and the else branch should handle the false case.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Identified a conditional block with both if and else branches.\n   \u2022 The branches contain different assignments or logic operations.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The if and else bodies have been swapped.\n   \u2022 Logic that should execute when condition is true now executes when false, and vice versa.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The conditional bodies are inverted.\n   \u2022 Impact: All conditional behavior is reversed, causing incorrect outputs for all test cases.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Swap the if and else bodies back to their correct positions.\n   \u2022 Verify that the condition evaluates correctly and executes the intended branch.\n\n6. RTL Design Principle Violated:\n   \u2022 Correct conditional logic requires matching the intended behavior with the branch bodies.", "complexity": 3, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "invert_condition", "remove_always_block"], "timestamp": "2025-12-09T21:43:36.317954"}
{"original_entry": {"instruction": "\nDesign a digital system in Verilog composed of multiple modules.\n\nFirst, create a module named `counter`.\nThis module should implement a 3-bit synchronous up/down counter with a synchronous reset.\nIts interface is defined as:\n`input clk`\n`input reset`\n`input direction`\n`output reg [2:0] count`\nOn the positive edge of `clk`, if `reset` is asserted (high), the counter should reset to 3'b000. Otherwise, if `direction` is high, the counter should increment. If `direction` is low, the counter should decrement. The counter should wrap around naturally at its limits.\n\nSecond, create a module named `comparator`.\nThis module should implement a combinational equality comparator for two 4-bit values.\nIts interface is defined as:\n`input [3:0] a`\n`input [3:0] b`\n`output wire equal`\nThe output `equal` should be logic high if and only if the inputs `a` and `b` are equal.\n\nThird, create a module named `final_output`.\nThis module should implement combinational logic based on a control signal.\nIts interface is defined as:\n`input [2:0] count`\n`input equal`\n`output reg [2:0] out_final`\nThe output `out_final` should be assigned the value of the input `count` when the input `equal` is logic high. Otherwise, `out_final` should be assigned the value 3'b000.\n\nFinally, create a top-level module named `top_module`.\nThis module should instantiate the `counter`, `comparator`, and `final_output` modules and connect them appropriately.\nIts interface is defined as:\n`input clk`\n`input reset`\n`input direction`\n`input [3:0] a`\n`input [3:0] b`\n`output [2:0] count`\n`output wire equal`\n`output [2:0] out_final`\nConnect the `clk`, `reset`, and `direction` inputs of `top_module` to the corresponding inputs of the `counter`. Connect the `a` and `b` inputs of `top_module` to the corresponding inputs of the `comparator`. Connect the `count` output of the `counter` module and the `equal` output of the `comparator` module to the inputs of the `final_output` module. The `count` output of the `counter`, the `equal` output of the `comparator`, and the `out_final` output of the `final_output` module should also be connected directly to the corresponding outputs of the `top_module`.\n\nWrite the Verilog code for all four modules.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule counter (\n    input clk,\n    input reset,\n    input direction,\n    output reg [2:0] count\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 3'b000;\n    end else if (direction) begin\n        count <= count + 1;\n    end else if (!direction) begin\n        count <= count - 1;\n    end\nend\n\nendmodule\nmodule comparator (\n    input [3:0] a,\n    input [3:0] b,\n    output wire equal\n);\n\nassign equal = (a == b);\n\nendmodule\nmodule final_output (\n    input [2:0] count,\n    input equal,\n    output reg [2:0] out_final\n);\n\nalways @(*) begin\n    if (equal) begin\n        out_final = count;\n    end else begin\n        out_final = 3'b000;\n    end\nend\n\nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    input direction,\n    input [3:0] a,\n    input [3:0] b,\n    output [2:0] count,\n    output wire equal,\n    output [2:0] out_final\n);\n\ncounter counter_inst (\n    .clk(clk),\n    .reset(reset),\n    .direction(direction),\n    .count(count)\n);\n\ncomparator comparator_inst (\n    .a(a),\n    .b(b),\n    .equal(equal)\n);\n\nfinal_output final_output_inst (\n    .count(count),\n    .equal(equal),\n    .out_final(out_final)\n);\n\nendmodule\nCODE END"}, "clean_code": "module counter (\n    input clk,\n    input reset,\n    input direction,\n    output reg [2:0] count\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 3'b000;\n    end else if (direction) begin\n        count <= count + 1;\n    end else if (!direction) begin\n        count <= count - 1;\n    end\nend\n\nendmodule\nmodule comparator (\n    input [3:0] a,\n    input [3:0] b,\n    output wire equal\n);\n\nassign equal = (a == b);\n\nendmodule\nmodule final_output (\n    input [2:0] count,\n    input equal,\n    output reg [2:0] out_final\n);\n\nalways @(*) begin\n    if (equal) begin\n        out_final = count;\n    end else begin\n        out_final = 3'b000;\n    end\nend\n\nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    input direction,\n    input [3:0] a,\n    input [3:0] b,\n    output [2:0] count,\n    output wire equal,\n    output [2:0] out_final\n);\n\ncounter counter_inst (\n    .clk(clk),\n    .reset(reset),\n    .direction(direction),\n    .count(count)\n);\n\ncomparator comparator_inst (\n    .a(a),\n    .b(b),\n    .equal(equal)\n);\n\nfinal_output final_output_inst (\n    .count(count),\n    .equal(equal),\n    .out_final(out_final)\n);\n\nendmodule", "corrupted_code": "module counter (\n    input clk,\n    input reset,\n    input direction,\n    output reg [2:0] count\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        out_final = 3'b000;\n    end else begin\n        count <= 3'b000;\n    end else if (direction) begin\n        count <= count + 1;\n    end else if (!direction) begin\n        count <= count - 1;\n    end\nend\n\nendmodule\nmodule comparator (\n    input [3:0] a,\n    input [3:0] b,\n    output wire equal\n);\n\nassign equal = (a == b);\n\nendmodule\nmodule final_output (\n    input [2:0] count,\n    input equal,\n    output reg [2:0] out_final\n);\n\nalways @(*) begin\n    if (equal) begin\n        out_final = count;\n    end\nend\n\nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    input direction,\n    input [3:0] a,\n    input [3:0] b,\n    output [2:0] count,\n    output wire equal,\n    output [2:0] out_final\n);\n\ncounter counter_inst (\n    .clk(clk),\n    .reset(reset),\n    .direction(direction),\n    .count(count)\n);\n\ncomparator comparator_inst (\n    .a(a),\n    .b(b),\n    .equal(equal)\n);\n\nfinal_output final_output_inst (\n    .count(count),\n    .equal(equal),\n    .out_final(out_final)\n);\n\nendmodule", "corruption_explanation": "Swapped if and else bodies", "modification_type": "invert_if_else", "modification_line": 9, "original_snippet": "if (reset) begin\n        count <= 3'b000;\n    end else if (direction) begin\n        count <= count + 1;\n    end else if (!direction) begin\n        count <= count - 1;\n    end\nend\n\nendmodule\nmodule com", "modified_snippet": "if (reset) begin\n        out_final = 3'b000;\n    end else begin\n        count <= 3'b000;\n    end else if (direction) begin\n        count <= count + 1;\n    end else if (!direction) begin\n        count ", "issue_description": "The buggy code has swapped if and else bodies in a conditional block. This causes the logic to execute the opposite branch for each condition, leading to incorrect behavior when the condition is true vs false. Test cases that depend on the conditional logic will fail because the intended branch is not executed.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module contains conditional logic that should execute different code paths based on a condition.\n   \u2022 The if branch should handle the true case, and the else branch should handle the false case.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Identified a conditional block with both if and else branches.\n   \u2022 The branches contain different assignments or logic operations.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 The if and else bodies have been swapped.\n   \u2022 Logic that should execute when condition is true now executes when false, and vice versa.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The conditional bodies are inverted.\n   \u2022 Impact: All conditional behavior is reversed, causing incorrect outputs for all test cases.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Swap the if and else bodies back to their correct positions.\n   \u2022 Verify that the condition evaluates correctly and executes the intended branch.\n\n6. RTL Design Principle Violated:\n   \u2022 Correct conditional logic requires matching the intended behavior with the branch bodies.", "complexity": 12, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "swap_port_signals", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.319872"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `stratixiv_bias_generator`.\nThis module should have a parameter `TOTAL_REG` with a default value of 202.\nThe module interface should be:\nInputs:\n    `din`\n    `mainclk`\n    `updateclk`\n    `capture`\n    `update`\nOutput:\n    `dout`\n\nThe module should implement a system with two internal storage elements, each capable of holding `TOTAL_REG` bits. Let's refer to these as Storage A and Storage B.\n\nOn the positive edge of `updateclk`:\n*   The output `dout` should reflect the most significant bit of Storage B, registered on this clock edge.\n*   If `capture` is 0 and `update` is 0, Storage B should operate as a right-shifting register, with `din` entering the least significant bit.\n*   If `capture` is 1 and `update` is 0, Storage B should be loaded with the current contents of Storage A.\n*   In all other `capture`/`update` combinations, Storage B should retain its current value.\n\nOn the positive edge of `mainclk`:\n*   If `capture` is 0 and `update` is 1, Storage A should be loaded with the current contents of Storage B.\n*   In all other `capture`/`update` combinations, Storage A should retain its current value.\n\nUpon initialization, both Storage A and Storage B, as well as the register driving the output `dout`, should be cleared to zero.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule stratixiv_bias_generator (\n    input din,\n    input mainclk,\n    input updateclk,\n    input capture,\n    input update,\n    output reg dout\n);\n\nparameter TOTAL_REG = 202;\n\nreg dout_tmp;\nreg [TOTAL_REG-1:0] generator_reg;\nreg [TOTAL_REG-1:0] update_reg;\ninteger i;\n\ninitial begin\n    dout_tmp = 1'b0;\n    for (i = 0; i < TOTAL_REG; i = i + 1) begin\n        generator_reg[i] = 1'b0;\n        update_reg[i] = 1'b0;\n    end\nend\n\nalways @(posedge mainclk) begin\n    if ((capture == 1'b0) && (update == 1'b1)) begin\n        for (i = 0; i < TOTAL_REG; i = i + 1) begin\n            generator_reg[i] <= update_reg[i];\n        end\n    end\nend\n\nalways @(posedge updateclk) begin\n    dout_tmp <= update_reg[TOTAL_REG - 1];\n\n    if ((capture == 1'b0) && (update == 1'b0)) begin\n        for (i = (TOTAL_REG - 1); i > 0; i = i - 1) begin\n            update_reg[i] <= update_reg[i - 1];\n        end\n        update_reg[0] <= din; \n    end else if ((capture == 1'b1) && (update == 1'b0)) begin\n        for (i = 0; i < TOTAL_REG; i = i + 1) begin\n            update_reg[i] <= generator_reg[i];\n        end\n    end\nend\n\nalways @* begin\n    dout = dout_tmp;\nend\n\nendmodule\nCODE END"}, "clean_code": "module stratixiv_bias_generator (\n    input din,\n    input mainclk,\n    input updateclk,\n    input capture,\n    input update,\n    output reg dout\n);\n\nparameter TOTAL_REG = 202;\n\nreg dout_tmp;\nreg [TOTAL_REG-1:0] generator_reg;\nreg [TOTAL_REG-1:0] update_reg;\ninteger i;\n\ninitial begin\n    dout_tmp = 1'b0;\n    for (i = 0; i < TOTAL_REG; i = i + 1) begin\n        generator_reg[i] = 1'b0;\n        update_reg[i] = 1'b0;\n    end\nend\n\nalways @(posedge mainclk) begin\n    if ((capture == 1'b0) && (update == 1'b1)) begin\n        for (i = 0; i < TOTAL_REG; i = i + 1) begin\n            generator_reg[i] <= update_reg[i];\n        end\n    end\nend\n\nalways @(posedge updateclk) begin\n    dout_tmp <= update_reg[TOTAL_REG - 1];\n\n    if ((capture == 1'b0) && (update == 1'b0)) begin\n        for (i = (TOTAL_REG - 1); i > 0; i = i - 1) begin\n            update_reg[i] <= update_reg[i - 1];\n        end\n        update_reg[0] <= din; \n    end else if ((capture == 1'b1) && (update == 1'b0)) begin\n        for (i = 0; i < TOTAL_REG; i = i + 1) begin\n            update_reg[i] <= generator_reg[i];\n        end\n    end\nend\n\nalways @* begin\n    dout = dout_tmp;\nend\n\nendmodule", "corrupted_code": "module stratixiv_bias_generator (\n    input din,\n    input mainclk,\n    input updateclk,\n    input capture,\n    input update,\n    output reg dout\n);\n\nparameter TOTAL_REG = 202;\n\nreg dout_tmp;\nreg [TOTAL_REG-1:0] generator_reg;\nreg [TOTAL_REG-1:0] update_reg;\ninteger i;\n\ninitial begin\n    dout_tmp = 1'b0;\n    for (i = 0; i < TOTAL_REG; i = i + 1) begin\n        generator_reg[i] = 1'b0;\n        update_reg[i] = 1'b0;\n    end\nend\n\nalways @(mainclk) begin\n    if ((capture == 1'b0) && (update == 1'b1)) begin\n        for (i = 0; i < TOTAL_REG; i = i + 1) begin\n            generator_reg[i] <= update_reg[i];\n        end\n    end\nend\n\nalways @(posedge updateclk) begin\n    dout_tmp <= update_reg[TOTAL_REG - 1];\n\n    if ((capture == 1'b0) && (update == 1'b0)) begin\n        for (i = (TOTAL_REG - 1); i > 0; i = i - 1) begin\n            update_reg[i] <= update_reg[i - 1];\n        end\n        update_reg[0] <= din; \n    end else if ((capture == 1'b1) && (update == 1'b0)) begin\n        for (i = 0; i < TOTAL_REG; i = i + 1) begin\n            update_reg[i] <= generator_reg[i];\n        end\n    end\nend\n\nalways @* begin\n    dout = dout_tmp;\nend\n\nendmodule", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 25, "original_snippet": "always @(posedge mainclk)", "modified_snippet": "always @(mainclk)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 25: Original: always @(posedge mainclk)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 25.\n   \u2022 Restore the original code: always @(posedge mainclk)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 26, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_loop", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "remove_always_block", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.324036"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `top_module` with the following interface:\nInputs: `in1 [3:0]`, `in2 [3:0]`, `sel1`, `sel2`, `comp_in1 [3:0]`, `comp_in2 [3:0]`\nOutputs: `mux_out [3:0]`, `eq_out`, `gt_out`, `lt_out`\n\nThis module should implement two distinct functionalities:\n\n1.  A 4-bit data selection: The output `mux_out` should be assigned the value of `in2` when the logical AND of `sel1` and `sel2` is true. In all other cases, `mux_out` should be assigned the value of `in1`.\n2.  A 4-bit value comparison: Evaluate the relationship between `comp_in1` and `comp_in2`. The output `eq_out` should be true if the inputs are equal. The output `gt_out` should be true if `comp_in1` holds a value greater than `comp_in2`. The output `lt_out` should be true if `comp_in1` holds a value less than `comp_in2`. All three comparison outputs should reflect the current state of the inputs.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule top_module (\n    input [3:0] in1,    // First 4-bit input for the multiplexer\n    input [3:0] in2,    // Second 4-bit input for the multiplexer\n    input sel1,         // First select input for the multiplexer\n    input sel2,         // Second select input for the multiplexer\n    output reg [3:0] mux_out,   // 4-bit output from the multiplexer\n    input [3:0] comp_in1,   // First 4-bit input for the comparator\n    input [3:0] comp_in2,   // Second 4-bit input for the comparator\n    output reg eq_out,      // 1-bit output indicating if the two inputs are equal\n    output reg gt_out,      // 1-bit output indicating if the first input is greater than the second input\n    output reg lt_out       // 1-bit output indicating if the first input is less than the second input\n);\n\n    // 2-to-1 multiplexer\n    always @(*) begin\n        if (sel1 & sel2) begin\n            mux_out <= in2;\n        end else begin\n            mux_out <= in1;\n        end\n    end\n\n    // 4-bit binary comparator\n    always @* begin\n        eq_out = (comp_in1 == comp_in2);\n        gt_out = (comp_in1 > comp_in2);\n        lt_out = (comp_in1 < comp_in2);\n    end\n\nendmodule\nCODE END"}, "clean_code": "module top_module (\n    input [3:0] in1,    // First 4-bit input for the multiplexer\n    input [3:0] in2,    // Second 4-bit input for the multiplexer\n    input sel1,         // First select input for the multiplexer\n    input sel2,         // Second select input for the multiplexer\n    output reg [3:0] mux_out,   // 4-bit output from the multiplexer\n    input [3:0] comp_in1,   // First 4-bit input for the comparator\n    input [3:0] comp_in2,   // Second 4-bit input for the comparator\n    output reg eq_out,      // 1-bit output indicating if the two inputs are equal\n    output reg gt_out,      // 1-bit output indicating if the first input is greater than the second input\n    output reg lt_out       // 1-bit output indicating if the first input is less than the second input\n);\n\n    // 2-to-1 multiplexer\n    always @(*) begin\n        if (sel1 & sel2) begin\n            mux_out <= in2;\n        end else begin\n            mux_out <= in1;\n        end\n    end\n\n    // 4-bit binary comparator\n    always @* begin\n        eq_out = (comp_in1 == comp_in2);\n        gt_out = (comp_in1 > comp_in2);\n        lt_out = (comp_in1 < comp_in2);\n    end\n\nendmodule", "corrupted_code": "module top_module (\n    input [3:0] in1,    // First 4-bit input for the multiplexer\n    input [3:0] in2,    // Second 4-bit input for the multiplexer\n    input sel1,         // First select input for the multiplexer\n    input sel2,         // Second select input for the multiplexer\n    output reg [3:0] mux_out,   // bit - 4 output from the multiplexer\n    input [3:0] comp_in1,   // First 4-bit input for the comparator\n    input [3:0] comp_in2,   // Second 4-bit input for the comparator\n    output reg eq_out,      // 1-bit output indicating if the two inputs are equal\n    output reg gt_out,      // 1-bit output indicating if the first input is greater than the second input\n    output reg lt_out       // 1-bit output indicating if the first input is less than the second input\n);\n\n    // 2-to-1 multiplexer\n    always @(*) begin\n        if (sel1 & sel2) begin\n            mux_out <= in2;\n        end else begin\n            mux_out <= in1;\n        end\n    end\n\n    // 4-bit binary comparator\n    always @* begin\n        eq_out = (comp_in1 == comp_in2);\n        gt_out = (comp_in1 > comp_in2);\n        lt_out = (comp_in1 < comp_in2);\n    end\n\nendmodule", "corruption_explanation": "Swapped operands: '4 - bit' -> 'bit - 4'", "modification_type": "swap_operands", "modification_line": 6, "original_snippet": "4-bit", "modified_snippet": "bit - 4", "issue_description": "The buggy code has swapped operands in a non-commutative operation. For operations like subtraction, division, or comparisons, this changes the result entirely. For example, 'a - b' becomes 'b - a'. Test cases will fail due to incorrect computation results.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_operands modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped operands: '4 - bit' -> 'bit - 4'\n   \u2022 Line 6: Original: 4-bit\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 6.\n   \u2022 Restore the original code: 4-bit\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap operands.", "complexity": 19, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "invert_condition", "remove_always_block"], "timestamp": "2025-12-09T21:43:36.326192"}
{"original_entry": {"instruction": "\nWrite Verilog code for the following three modules:\n\n1.  **Module Name:** `shift_register`\n    *   **Interface:** `input [3:0] D, input LD, input CLK, input CLR, output reg [3:0] Q`\n    *   **Behavior:** This is a 4-bit register. It has an asynchronous clear input `CLR` (high active) which resets the output `Q` to zero. If not cleared, on the positive edge of `CLK`, if `LD` is high, the data input `D` is loaded into `Q`. If neither `CLR` nor `LD` is high, the register performs a left rotation, where the most significant bit of the current value of `Q` moves to the least significant bit position, and the other bits shift one position left.\n\n2.  **Module Name:** `adder`\n    *   **Interface:** `input [3:0] A, B, output [3:0] sum`\n    *   **Behavior:** This module performs a simple 4-bit unsigned addition of inputs `A` and `B`, outputting the 4-bit sum.\n\n3.  **Module Name:** `top_module`\n    *   **Interface:** `input [3:0] D1, D2, input LD1, LD2, input CLK, input CLR, output [3:0] sum`\n    *   **Structure:** This module should instantiate two instances of the `shift_register` and one instance of the `adder`.\n        *   The first shift register instance (`sr1`) should be controlled by inputs `D1`, `LD1`, `CLK`, and `CLR`. Its output should be connected internally (`Q1`).\n        *   The second shift register instance (`sr2`) should use the output of the *first* shift register (`Q1`) as its data input `D`. It should be controlled by inputs `LD2`, `CLK`, and `CLR`. Its output should be connected internally (`Q2`). Note that the `D2` input to the `top_module` is not connected to the data input (`D`) of `sr2` in this specific design.\n        *   The adder instance should take the outputs of the two shift registers (`Q1` and `Q2`) as its inputs `A` and `B`. Its output should be connected to the `sum` output of the `top_module`.\n\nWrite the Verilog code for these three modules.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule shift_register (\n    input [3:0] D, // Data input\n    input LD, // Load input\n    input CLK, // Clock input\n    input CLR, // Clear input\n    output reg [3:0] Q // Data output\n);\n\n    always @(posedge CLK, posedge CLR) begin\n        if (CLR) begin\n            Q <= 4'b0000; // Reset to all zeros\n        end else if (LD) begin\n            Q <= D; // Load data into register\n        end else begin\n            Q <= {Q[2:0], Q[3]}; // Shift data left\n        end\n    end\n\nendmodule\nmodule adder (\n    input [3:0] A, B,\n    output [3:0] sum\n);\n\n    assign sum = A + B;\n\nendmodule\nmodule top_module (\n    input [3:0] D1, D2,\n    input LD1, LD2, CLK, CLR,\n    output [3:0] sum\n);\n\n    wire [3:0] Q1, Q2; // Declare wires for shift register outputs\n\n    shift_register sr1 (\n        .D(D1),\n        .LD(LD1),\n        .CLK(CLK),\n        .CLR(CLR),\n        .Q(Q1) // Connect wire to shift_register output\n    );\n\n    shift_register sr2 (\n        .D(Q1),\n        .LD(LD2),\n        .CLK(CLK),\n        .CLR(CLR),\n        .Q(Q2) // Connect wire to shift_register output\n    );\n\n    adder add (\n        .A(Q1),\n        .B(Q2),\n        .sum(sum)\n    );\n\nendmodule\nCODE END"}, "clean_code": "module shift_register (\n    input [3:0] D, // Data input\n    input LD, // Load input\n    input CLK, // Clock input\n    input CLR, // Clear input\n    output reg [3:0] Q // Data output\n);\n\n    always @(posedge CLK, posedge CLR) begin\n        if (CLR) begin\n            Q <= 4'b0000; // Reset to all zeros\n        end else if (LD) begin\n            Q <= D; // Load data into register\n        end else begin\n            Q <= {Q[2:0], Q[3]}; // Shift data left\n        end\n    end\n\nendmodule\nmodule adder (\n    input [3:0] A, B,\n    output [3:0] sum\n);\n\n    assign sum = A + B;\n\nendmodule\nmodule top_module (\n    input [3:0] D1, D2,\n    input LD1, LD2, CLK, CLR,\n    output [3:0] sum\n);\n\n    wire [3:0] Q1, Q2; // Declare wires for shift register outputs\n\n    shift_register sr1 (\n        .D(D1),\n        .LD(LD1),\n        .CLK(CLK),\n        .CLR(CLR),\n        .Q(Q1) // Connect wire to shift_register output\n    );\n\n    shift_register sr2 (\n        .D(Q1),\n        .LD(LD2),\n        .CLK(CLK),\n        .CLR(CLR),\n        .Q(Q2) // Connect wire to shift_register output\n    );\n\n    adder add (\n        .A(Q1),\n        .B(Q2),\n        .sum(sum)\n    );\n\nendmodule", "corrupted_code": "module shift_register (\n    input [3:0] D, // Data input\n    input LD, // Load input\n    input CLK, // Clock input\n    input CLR, // Clear input\n    output reg [3:0] Q // Data output\n);\n\n    always @(posedge CLK, posedge CLR) begin\n        if (CLR) begin\n            Q <= 4'b0000; // Reset to all zeros\n        end else if (LD) begin\n            Q <= D; // Load data into register\n        end else begin\n            Q <= {Q[2:0], Q[3]}; // Shift data left\n        end\n    end\n\nendmodule\nmodule adder (\n    input [3:0] A, B,\n    output [3:0] sum\n);\n\n    assign sum = A + B;\n\nendmodule\nmodule top_module (\n    input [3:0] D1, D2,\n    input LD1, LD2, CLK, CLR,\n    output [3:0] sum\n);\n\n    wire [3:0] Q1, Q2; // Declare wires for shift register outputs\n\n    shift_register sr1 (\n        .D(D1),\n        .LD(LD1),\n        .CLK(CLK),\n        .CLR(CLR),\n        .Q(Q1) // Connect wire to shift_register output\n    );\n\n    shift_register sr2(\n        .D(Q1),\n        .LD(LD2),\n        .CLK(Q2),\n        .CLR(CLR),\n        .Q(CLK) // Connect wire to shift_register output\n    );\n\n    adder add (\n        .A(Q1),\n        .B(Q2),\n        .sum(sum)\n    );\n\nendmodule", "corruption_explanation": "Swapped signals: .CLK(CLK) <-> .Q(Q2)", "modification_type": "swap_port_signals", "modification_line": 44, "original_snippet": "shift_register sr2 (\n        .D(Q1),\n        .LD(LD2),\n        .CLK(CLK),\n        .CLR(CLR),\n        .Q(Q2) // Connect wire to shift_register output\n    );", "modified_snippet": "shift_register sr2(\n        .D(Q1),\n        .LD(LD2),\n        .CLK(Q2),\n        .CLR(CLR),\n        .Q(CLK) // Connect wire to shift_register output\n    );", "issue_description": "The buggy code has swapped signal connections in a module instantiation. Signals are connected to the wrong ports, causing data to flow incorrectly between modules. This is a classic integration bug that causes functional failures in hierarchical designs.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a swap_port_signals modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Swapped signals: .CLK(CLK) <-> .Q(Q2)\n   \u2022 Line 44: Original: shift_register sr2 (\n        .D(Q1),\n        .LD(LD2),\n        .CLK(CLK),\n        .CLR(CLR),\n        .Q(Q2) // Connect wire to shift_register output\n    );\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 44.\n   \u2022 Restore the original code: shift_register sr2 (\n        .D(Q1),\n        .LD(LD2),\n        .CLK(CLK),\n        .CLR(CLR),\n        .Q(Q2) // Connect wire to shift_register output\n    );\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to swap port signals.", "complexity": 6, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "swap_port_signals", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.328078"}
{"original_entry": {"instruction": "\nDesign a Verilog module named `top_module` with the following interface:\nInputs:\n- `clk`: Clock signal.\n- `reset`: Synchronous active-high reset.\n- `sel [7:0]`: An 8-bit select input.\n- `in [1023:0]`: A 1024-bit input vector.\n\nOutputs:\n- `out [3:0]`: A 4-bit output.\n- `Q [15:0]`: A 16-bit registered output.\n\nThe module should implement the following logic:\n1.  The `out` output should function as a 256-to-1 multiplexer. It should select a 4-bit slice from the `in` vector based on the value of `sel`. Specifically, if `sel` has value N (0 <= N <= 255), `out` should be equal to the slice of `in` starting at bit index N*4 and extending for 4 bits.\n2.  The `Q` output should be a 16-bit register that implements a counter. The counter should reset to all zeros synchronously on the positive edge of `reset`. When not in reset, the counter should update on the positive edge of `clk` based on its current state using a specific feedback mechanism.\n\nYour Verilog code should implement this functionality.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule top_module(\n  input              clk,\n  input              reset,      // Synchronous active-high reset\n  input  [7:0]       sel,        // Select input to choose between multiplexer and counter\n  input  [1023:0]    in,         // 1024-bit input vector for the multiplexer\n  output [3:0]       out,        // 4-bit output of the multiplexer\n  output reg [15:0]  Q          // 16-bit output of the Johnson counter\n);\n\n  // 256-to-1 multiplexer\n  wire [3:0] mux_out;\n  assign mux_out = in[sel*4 +: 4];\n  assign out = mux_out;\n\n  // 16-bit Johnson counter\n  reg [15:0] Q_next;\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      Q_next <= 16'b0000000000000000;\n    end else begin\n      Q_next <= {Q[14:0], Q[15] ^ Q[14]};\n    end\n  end\n  always @(posedge clk) begin\n    Q <= Q_next;\n  end\n\n  // Functional module\n  reg [3:0] mux_out_delayed; // Changed from wire to reg\n  reg [15:0] Q_delayed;\n  always @(posedge clk) begin\n    mux_out_delayed <= mux_out;\n    Q_delayed <= Q;\n  end\n  reg [19:0] final_output; // Changed from assign \n  always @(*) begin\n    final_output = {mux_out_delayed, Q_delayed};\n  end // Fixed RTL\n\nendmodule\nCODE END"}, "clean_code": "module top_module(\n  input              clk,\n  input              reset,      // Synchronous active-high reset\n  input  [7:0]       sel,        // Select input to choose between multiplexer and counter\n  input  [1023:0]    in,         // 1024-bit input vector for the multiplexer\n  output [3:0]       out,        // 4-bit output of the multiplexer\n  output reg [15:0]  Q          // 16-bit output of the Johnson counter\n);\n\n  // 256-to-1 multiplexer\n  wire [3:0] mux_out;\n  assign mux_out = in[sel*4 +: 4];\n  assign out = mux_out;\n\n  // 16-bit Johnson counter\n  reg [15:0] Q_next;\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      Q_next <= 16'b0000000000000000;\n    end else begin\n      Q_next <= {Q[14:0], Q[15] ^ Q[14]};\n    end\n  end\n  always @(posedge clk) begin\n    Q <= Q_next;\n  end\n\n  // Functional module\n  reg [3:0] mux_out_delayed; // Changed from wire to reg\n  reg [15:0] Q_delayed;\n  always @(posedge clk) begin\n    mux_out_delayed <= mux_out;\n    Q_delayed <= Q;\n  end\n  reg [19:0] final_output; // Changed from assign \n  always @(*) begin\n    final_output = {mux_out_delayed, Q_delayed};\n  end // Fixed RTL\n\nendmodule", "corrupted_code": "module top_module(\n  input              clk,\n  input              reset,      // Synchronous active-high reset\n  input  [7:0]       sel,        // Select input to choose between multiplexer and counter\n  input  [1023:0]    in,         // 1024-bit input vector for the multiplexer\n  output [3:0]       out,        // 4-bit output of the multiplexer\n  output reg [15:0]  Q          // 16-bit output of the Johnson counter\n);\n\n  // 256-to-1 multiplexer\n  wire [3:0] mux_out;\n  assign mux_out = in[sel*4 +: 4];\n  assign out = mux_out;\n\n  // 16-bit Johnson counter\n  reg [15:0] Q_next;\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      Q_next <= 16'b0000000000000000;\n    end else begin\n      Q_next <= {Q[14:0], Q[15] ^ Q[14]};\n    end\n  end\n  always @(posedge clk) begin\n    Q = Q_next;\n  end\n\n  // Functional module\n  reg [3:0] mux_out_delayed; // Changed from wire to reg\n  reg [15:0] Q_delayed;\n  always @(posedge clk) begin\n    mux_out_delayed <= mux_out;\n    Q_delayed <= Q;\n  end\n  reg [19:0] final_output; // Changed from assign \n  always @(*) begin\n    final_output = {mux_out_delayed, Q_delayed};\n  end // Fixed RTL\n\nendmodule", "corruption_explanation": "Changed non-blocking (<=) to blocking (=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 25, "original_snippet": "Q <= Q_next;", "modified_snippet": "Q = Q_next;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 16, "applicable_modifications": ["invert_if_else", "remove_else_branch", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "remove_always_block", "invert_reset_polarity", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.331654"}
{"original_entry": {"instruction": "\nDesign a Verilog module named `openhmc_counter48` that implements a synchronous counter.\n\nThe module should have a parameter `DATASIZE` specifying the width of the counter, with a default value of 16.\n\nThe module interface should be as follows:\n*   Inputs:\n    *   `clk`: Clock input.\n    *   `res_n`: Active-low reset input. The reset should set the counter value to 0. The design should accommodate both synchronous and asynchronous reset behavior based on a compile-time define.\n    *   `increment`: When high, causes the counter to increment.\n    *   `load_enable`: When high, triggers a reset of the counter value to 0.\n*   Output:\n    *   `value`: A wire of width `DATASIZE` representing the current counter value.\n\nThe counter operates on the positive edge of the `clk` signal.\n\nImplement the following logic:\n1.  The counter value should be reset to 0 when `res_n` is low.\n2.  The `increment` signal should cause the counter value to increase by 1 on the next clock edge, provided no load/reset operation is taking precedence.\n3.  The `load_enable` signal should initiate a reset of the counter value to 0. However, this reset should occur *one clock cycle after* `load_enable` is asserted.\n4.  If, in the clock cycle where the delayed `load_enable` reset takes effect, the `increment` signal is also high, the counter should first reset to 0 and then increment to 1 in that same cycle.\n5.  If neither the delayed `load_enable` reset nor the `increment` signal is active, the counter should hold its current value.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\n\nmodule openhmc_counter48 #(\n        parameter DATASIZE  = 16    ) (\n        input wire                  clk,\n        input wire                  res_n,\n        input wire                  increment,\n        input wire                  load_enable,\n        output wire [DATASIZE-1:0]  value\n);\n\n    reg [DATASIZE-1:0]  value_reg;\n    reg                 load_enable_reg;\n\n    assign value    = value_reg;\n\n    `ifdef ASYNC_RES\n    always @(posedge clk or negedge res_n) `else\n    always @(posedge clk) `endif\n    begin\n        if(!res_n) begin\n            value_reg               <= {DATASIZE{1'b0}};\n            load_enable_reg         <= 1'b0;\n        end else begin\n            load_enable_reg         <= load_enable;\n            case ({load_enable_reg,increment})\n                    2'b00:\n                        value_reg   <= value_reg;\n                    2'b01:\n                        value_reg   <= (value_reg + 1'b1);\n                    2'b10:\n                        value_reg   <= {DATASIZE{1'b0}};\n                    2'b11:\n                        value_reg   <= {DATASIZE{1'b0}} + 1'b1;\n            endcase\n        end\n    end\n\nendmodule\n\nCODE END"}, "clean_code": "module openhmc_counter48 #(\n        parameter DATASIZE  = 16    ) (\n        input wire                  clk,\n        input wire                  res_n,\n        input wire                  increment,\n        input wire                  load_enable,\n        output wire [DATASIZE-1:0]  value\n);\n\n    reg [DATASIZE-1:0]  value_reg;\n    reg                 load_enable_reg;\n\n    assign value    = value_reg;\n\n    `ifdef ASYNC_RES\n    always @(posedge clk or negedge res_n) `else\n    always @(posedge clk) `endif\n    begin\n        if(!res_n) begin\n            value_reg               <= {DATASIZE{1'b0}};\n            load_enable_reg         <= 1'b0;\n        end else begin\n            load_enable_reg         <= load_enable;\n            case ({load_enable_reg,increment})\n                    2'b00:\n                        value_reg   <= value_reg;\n                    2'b01:\n                        value_reg   <= (value_reg + 1'b1);\n                    2'b10:\n                        value_reg   <= {DATASIZE{1'b0}};\n                    2'b11:\n                        value_reg   <= {DATASIZE{1'b0}} + 1'b1;\n            endcase\n        end\n    end\n\nendmodule", "corrupted_code": "module openhmc_counter48 #(\n        parameter DATASIZE  = 16    ) (\n        input wire                  clk,\n        input wire                  res_n,\n        input wire                  increment,\n        input wire                  load_enable,\n        output wire [DATASIZE-1:0]  value\n);\n\n    reg [DATASIZE-1:0]  value_reg;\n    reg                 load_enable_reg;\n\n    assign value    = value_reg;\n\n    `ifdef ASYNC_RES\n    always @(posedge clk or negedge res_n) `else\n    always @(posedge clk) `endif\n    begin\n        if(res_n) begin\n            value_reg               <= {DATASIZE{1'b0}};\n            load_enable_reg         <= 1'b0;\n        end else begin\n            load_enable_reg         <= load_enable;\n            case ({load_enable_reg,increment})\n                    2'b00:\n                        value_reg   <= value_reg;\n                    2'b01:\n                        value_reg   <= (value_reg + 1'b1);\n                    2'b10:\n                        value_reg   <= {DATASIZE{1'b0}};\n                    2'b11:\n                        value_reg   <= {DATASIZE{1'b0}} + 1'b1;\n            endcase\n        end\n    end\n\nendmodule", "corruption_explanation": "Inverted condition: '!res_n' -> 'res_n'", "modification_type": "invert_condition", "modification_line": 19, "original_snippet": "if(!res_n) begin", "modified_snippet": "if(res_n) begin", "issue_description": "The buggy code has an inverted condition in an if statement. Instead of checking if(x), it checks if(!x), causing the logic to execute when it shouldn't and skip execution when it should. All conditional behavior is reversed from intended functionality.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a invert_condition modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Inverted condition: '!res_n' -> 'res_n'\n   \u2022 Line 19: Original: if(!res_n) begin\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 19.\n   \u2022 Restore the original code: if(!res_n) begin\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to invert condition.", "complexity": 8, "applicable_modifications": ["invert_if_else", "remove_else_branch", "remove_case_default", "change_constant", "change_operator", "swap_operands", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "add_multiple_driver", "invert_condition", "shuffle_case_items"], "timestamp": "2025-12-09T21:43:36.333479"}
{"original_entry": {"instruction": "\nDesign a Verilog module named `johnson_counter`.\n\nThe module should have the following interface:\n*   Inputs:\n    *   `clk`: Clock signal.\n    *   `rst_n`: Active-low asynchronous reset signal.\n*   Output:\n    *   `out`: An 8-bit wide wire (`[7:0]`) representing the current state of the counter.\n\nThe module should implement an 8-bit counter that cycles through a specific sequence of 16 unique states. Upon an active-low assertion of `rst_n`, the counter should asynchronously reset to the state `8'b00000000`. On each positive edge of `clk` thereafter, the counter should transition to the next state in its sequence. The sequence involves shifting bits to the right, but the bit shifted into the most significant position (`out[7]`) is determined by a specific logic derived from the least significant bit (`out[0]`) of the *current* state.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule johnson_counter (\n    input clk,\n    input rst_n,\n    output wire [7:0] out\n);\n\n    reg [7:0] state;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            state <= 8'b00000000;\n        end else begin\n            case (state)\n                8'b00000000: state <= 8'b10000000;\n                8'b10000000: state <= 8'b11000000;\n                8'b11000000: state <= 8'b11100000;\n                8'b11100000: state <= 8'b11110000;\n                8'b11110000: state <= 8'b11111000;\n                8'b11111000: state <= 8'b11111100;\n                8'b11111100: state <= 8'b11111110;\n                8'b11111110: state <= 8'b11111111;\n                8'b11111111: state <= 8'b01111111;\n                8'b01111111: state <= 8'b00111111;\n                8'b00111111: state <= 8'b00011111;\n                8'b00011111: state <= 8'b00001111;\n                8'b00001111: state <= 8'b00000111;\n                8'b00000111: state <= 8'b00000011;\n                8'b00000011: state <= 8'b00000001;\n                8'b00000001: state <= 8'b00000000;\n            endcase\n        end\n    end\n\n    assign out = state;\n\nendmodule\n\nCODE END"}, "clean_code": "module johnson_counter (\n    input clk,\n    input rst_n,\n    output wire [7:0] out\n);\n\n    reg [7:0] state;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            state <= 8'b00000000;\n        end else begin\n            case (state)\n                8'b00000000: state <= 8'b10000000;\n                8'b10000000: state <= 8'b11000000;\n                8'b11000000: state <= 8'b11100000;\n                8'b11100000: state <= 8'b11110000;\n                8'b11110000: state <= 8'b11111000;\n                8'b11111000: state <= 8'b11111100;\n                8'b11111100: state <= 8'b11111110;\n                8'b11111110: state <= 8'b11111111;\n                8'b11111111: state <= 8'b01111111;\n                8'b01111111: state <= 8'b00111111;\n                8'b00111111: state <= 8'b00011111;\n                8'b00011111: state <= 8'b00001111;\n                8'b00001111: state <= 8'b00000111;\n                8'b00000111: state <= 8'b00000011;\n                8'b00000011: state <= 8'b00000001;\n                8'b00000001: state <= 8'b00000000;\n            endcase\n        end\n    end\n\n    assign out = state;\n\nendmodule", "corrupted_code": "module johnson_counter (\n    input clk,\n    input rst_n,\n    output wire [6:0] out\n);\n\n    reg [7:0] state;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            state <= 8'b00000000;\n        end else begin\n            case (state)\n                8'b00000000: state <= 8'b10000000;\n                8'b10000000: state <= 8'b11000000;\n                8'b11000000: state <= 8'b11100000;\n                8'b11100000: state <= 8'b11110000;\n                8'b11110000: state <= 8'b11111000;\n                8'b11111000: state <= 8'b11111100;\n                8'b11111100: state <= 8'b11111110;\n                8'b11111110: state <= 8'b11111111;\n                8'b11111111: state <= 8'b01111111;\n                8'b01111111: state <= 8'b00111111;\n                8'b00111111: state <= 8'b00011111;\n                8'b00011111: state <= 8'b00001111;\n                8'b00001111: state <= 8'b00000111;\n                8'b00000111: state <= 8'b00000011;\n                8'b00000011: state <= 8'b00000001;\n                8'b00000001: state <= 8'b00000000;\n            endcase\n        end\n    end\n\n    assign out = state;\n\nendmodule", "corruption_explanation": "Changed bit width from [7:0] to [6:0]", "modification_type": "change_bit_width", "modification_line": 4, "original_snippet": "[7:0]", "modified_snippet": "[6:0]", "issue_description": "The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_bit_width modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed bit width from [7:0] to [6:0]\n   \u2022 Line 4: Original: [7:0]\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 4.\n   \u2022 Restore the original code: [7:0]\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change bit width.", "complexity": 20, "applicable_modifications": ["invert_if_else", "remove_else_branch", "remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "remove_conditional", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "remove_reset_assignment", "invert_condition", "shuffle_case_items", "remove_always_block", "invert_reset_polarity", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "remove_async_reset", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.336543"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `exercise_8_10`.\nThe module should have the following interface:\nInputs: `x`, `y`, `Clk`\nOutput: `reg [1:0] state`\n\nThis module implements a synchronous state machine. The state transitions occur on the positive edge of the `Clk` signal. The `state` output should be initialized to `2'b00`.\n\nThe state transitions are determined by the current value of `state` and the combined input `{x, y}` according to the following rules:\n\n- When the input `{x, y}` is `2'b00`:\n    - If the current `state` is `2'b00`, the next state is `2'b00`.\n    - If the current `state` is `2'b01`, the next state is `2'b10`.\n    - If the current `state` is `2'b10`, the next state is `2'b00`.\n    - If the current `state` is `2'b11`, the next state is `2'b10`.\n\n- When the input `{x, y}` is `2'b01`:\n    - If the current `state` is `2'b00`, the next state is `2'b00`.\n    - If the current `state` is `2'b01`, the next state is `2'b11`.\n    - If the current `state` is `2'b10`, the next state is `2'b00`.\n    - If the current `state` is `2'b11`, the next state is `2'b11`.\n\n- When the input `{x, y}` is `2'b10`:\n    - If the current `state` is `2'b00`, the next state is `2'b01`.\n    - If the current `state` is `2'b01`, the next state is `2'b10`.\n    - If the current `state` is `2'b10`, the next state is `2'b10`.\n    - If the current `state` is `2'b11`, the next state is `2'b00`.\n\n- When the input `{x, y}` is `2'b11`:\n    - If the current `state` is `2'b00`, the next state is `2'b01`.\n    - If the current `state` is `2'b01`, the next state is `2'b11`.\n    - If the current `state` is `2'b10`, the next state is `2'b11`.\n    - If the current `state` is `2'b11`, the next state is `2'b00`.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule exercise_8_10 (output reg [1:0] state, input x, y, Clk);\n    initial state = 2'b00;\n    always @ (posedge Clk) begin\n        case ({x,y})\n            2'b00: begin if (state == 2'b00) state <= state; \n                else if (state == 2'b01) state <= 2'b10; \n                else if (state == 2'b10) state <= 2'b00; \n                else state <= 2'b10;\n                end\n            2'b01: begin if (state == 2'b00) state <= state;\n                    else if (state == 2'b01) state <= 2'b11;\n                    else if (state == 2'b10) state <= 2'b00;\n                    else state <= state;\n                    end\n            2'b10: begin if (state == 2'b00) state <= 2'b01;\n                    else if (state == 2'b01) state <= 2'b10;\n                    else if (state == 2'b10) state <= state;\n                    else state <= 2'b00;\n                    end\n            2'b11: begin if (state == 2'b00) state <= 2'b01;\n                    else if (state == 2'b01) state <= 2'b11;\n                    else if (state == 2'b10) state <= 2'b11;\n                    else state <= 2'b00;\n                    end\n        endcase\n    end\nendmodule\n\nCODE END"}, "clean_code": "module exercise_8_10 (output reg [1:0] state, input x, y, Clk);\n    initial state = 2'b00;\n    always @ (posedge Clk) begin\n        case ({x,y})\n            2'b00: begin if (state == 2'b00) state <= state; \n                else if (state == 2'b01) state <= 2'b10; \n                else if (state == 2'b10) state <= 2'b00; \n                else state <= 2'b10;\n                end\n            2'b01: begin if (state == 2'b00) state <= state;\n                    else if (state == 2'b01) state <= 2'b11;\n                    else if (state == 2'b10) state <= 2'b00;\n                    else state <= state;\n                    end\n            2'b10: begin if (state == 2'b00) state <= 2'b01;\n                    else if (state == 2'b01) state <= 2'b10;\n                    else if (state == 2'b10) state <= state;\n                    else state <= 2'b00;\n                    end\n            2'b11: begin if (state == 2'b00) state <= 2'b01;\n                    else if (state == 2'b01) state <= 2'b11;\n                    else if (state == 2'b10) state <= 2'b11;\n                    else state <= 2'b00;\n                    end\n        endcase\n    end\nendmodule", "corrupted_code": "module exercise_8_10 (output reg [1:0] state, input x, y, Clk);\n    initial state = 2'b00;\n    always @ (posedge Clk) begin\n        case ({x,y})\n            2'b00: begin if (state == 2'b00) state <= state; \n                else if (state == 2'b01) state <= 2'b10; \n                else if (state == 2'b10) state <= 2'b00; \n                else state <= 2'b10;\n                end\n            2'b01: begin if (state == 2'b00) state <= state;\n                    else if (state == 2'b01) state <= 2'b11;\n                    else if (state == 2'b10) state <= 2'b00;\n                    else state <= state;\n                    end\n            2'b10: begin if (state == 2'b00) state <= 2'b01;\n                    else if (state == 2'b01) state <= 2'b10;\n                    else if (state == 2'b10) state <= state;\n                    else state <= 2'b00;\n                    end\n            2'b11: begin if (state == 2'b00) state <= 2'b01;\n                    else if (state == 2'b01) state <= 2'b11;\n                    else if (state == 2'b10) state <= 2'b11;\n                    else state = 2'b00;\n                    end\n        endcase\n    end\nendmodule", "corruption_explanation": "Changed non-blocking (<=) to blocking (=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 23, "original_snippet": "state <= 2'b00;", "modified_snippet": "state = 2'b00;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 30, "applicable_modifications": ["remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "remove_reset_assignment", "shuffle_case_items", "remove_always_block", "remove_state_transition", "add_unreachable_state", "swap_state_encoding", "remove_state_update", "duplicate_clock_signal", "modify_cdc"], "timestamp": "2025-12-09T21:43:36.337844"}
{"original_entry": {"instruction": "\nWrite Verilog code for two modules.\n\nThe first module is named `full_adder`. It takes three single-bit inputs, `A`, `B`, and `cin`, and produces two single-bit outputs, `sum` and `cout`. This module should implement the logic of a standard full adder.\n\nThe second module is named `binary_multiplier`. It takes a 4-bit input `A` and a 4-bit input `B`, and produces an 8-bit output `P`. This module should utilize instances of the `full_adder` module you defined. The module performs calculations that result in four intermediate 4-bit sum vectors. For each bit `i` from 0 to 3, it calculates the 4-bit sum of the input vector `A` added to the single bit `B[i]` broadcast across 4 bits (conceptually `A + {4{B[i]}}`). Let S0 be the 4-bit sum corresponding to `B[0]`, S1 to `B[1]`, S2 to `B[2]`, and S3 to `B[3]`. The final 8-bit output `P` is constructed by concatenating the 4-bit sum S1 as the most significant bits (P[7:4]) with the 4-bit sum S0 as the least significant bits (P[3:0]). Intermediate carries from the additions and the results involving B[2] and B[3] are not used in the final output P.\n\nEnsure your modules have the exact names and port names as specified.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\nmodule full_adder (\n  input A,\n  input B,\n  input cin,\n  output sum,\n  output cout\n);\n\nassign sum = A ^ B ^ cin;\nassign cout = (A & B) | (cin & (A ^ B));\n\nendmodule\nmodule binary_multiplier (\n  input [3:0] A,\n  input [3:0] B,\n  output [7:0] P\n);\n\nwire [3:0] S0, S1, S2, S3;\nwire [3:0] C0, C1, C2, C3;\n\nfull_adder fa0(A[0], B[0], 1'b0, S0[0], C0[0]);\nfull_adder fa1(A[1], B[0], C0[0], S0[1], C0[1]);\nfull_adder fa2(A[2], B[0], C0[1], S0[2], C0[2]);\nfull_adder fa3(A[3], B[0], C0[2], S0[3], C0[3]);\n\nfull_adder fa4(A[0], B[1], 1'b0, S1[0], C1[0]);\nfull_adder fa5(A[1], B[1], C1[0], S1[1], C1[1]);\nfull_adder fa6(A[2], B[1], C1[1], S1[2], C1[2]);\nfull_adder fa7(A[3], B[1], C1[2], S1[3], C1[3]);\n\nfull_adder fa8(A[0], B[2], 1'b0, S2[0], C2[0]);\nfull_adder fa9(A[1], B[2], C2[0], S2[1], C2[1]);\nfull_adder fa10(A[2], B[2], C2[1], S2[2], C2[2]);\nfull_adder fa11(A[3], B[2], C2[2], S2[3], C2[3]);\n\nfull_adder fa12(A[0], B[3], 1'b0, S3[0], C3[0]);\nfull_adder fa13(A[1], B[3], C3[0], S3[1], C3[1]);\nfull_adder fa14(A[2], B[3], C3[1], S3[2], C3[2]);\nfull_adder fa15(A[3], B[3], C3[2], S3[3], C3[3]);\n\nassign P = {C3[3], C3[2], C3[1], C3[0], S3, S2, S1, S0};\n\nendmodule\nCODE END"}, "clean_code": "module full_adder (\n  input A,\n  input B,\n  input cin,\n  output sum,\n  output cout\n);\n\nassign sum = A ^ B ^ cin;\nassign cout = (A & B) | (cin & (A ^ B));\n\nendmodule\nmodule binary_multiplier (\n  input [3:0] A,\n  input [3:0] B,\n  output [7:0] P\n);\n\nwire [3:0] S0, S1, S2, S3;\nwire [3:0] C0, C1, C2, C3;\n\nfull_adder fa0(A[0], B[0], 1'b0, S0[0], C0[0]);\nfull_adder fa1(A[1], B[0], C0[0], S0[1], C0[1]);\nfull_adder fa2(A[2], B[0], C0[1], S0[2], C0[2]);\nfull_adder fa3(A[3], B[0], C0[2], S0[3], C0[3]);\n\nfull_adder fa4(A[0], B[1], 1'b0, S1[0], C1[0]);\nfull_adder fa5(A[1], B[1], C1[0], S1[1], C1[1]);\nfull_adder fa6(A[2], B[1], C1[1], S1[2], C1[2]);\nfull_adder fa7(A[3], B[1], C1[2], S1[3], C1[3]);\n\nfull_adder fa8(A[0], B[2], 1'b0, S2[0], C2[0]);\nfull_adder fa9(A[1], B[2], C2[0], S2[1], C2[1]);\nfull_adder fa10(A[2], B[2], C2[1], S2[2], C2[2]);\nfull_adder fa11(A[3], B[2], C2[2], S2[3], C2[3]);\n\nfull_adder fa12(A[0], B[3], 1'b0, S3[0], C3[0]);\nfull_adder fa13(A[1], B[3], C3[0], S3[1], C3[1]);\nfull_adder fa14(A[2], B[3], C3[1], S3[2], C3[2]);\nfull_adder fa15(A[3], B[3], C3[2], S3[3], C3[3]);\n\nassign P = {C3[3], C3[2], C3[1], C3[0], S3, S2, S1, S0};\n\nendmodule", "corrupted_code": "module full_adder (\n  input A,\n  input B,\n  input cin,\n  output sum,\n  output cout\n);\n\nassign sum = A ^ B ^ cin;\nassign cout = (A & B) | (cin & (A ^ B));\n\nendmodule\nmodule binary_multiplier (\n  input [4:0] A,\n  input [3:0] B,\n  output [7:0] P\n);\n\nwire [3:0] S0, S1, S2, S3;\nwire [3:0] C0, C1, C2, C3;\n\nfull_adder fa0(A[0], B[0], 1'b0, S0[0], C0[0]);\nfull_adder fa1(A[1], B[0], C0[0], S0[1], C0[1]);\nfull_adder fa2(A[2], B[0], C0[1], S0[2], C0[2]);\nfull_adder fa3(A[3], B[0], C0[2], S0[3], C0[3]);\n\nfull_adder fa4(A[0], B[1], 1'b0, S1[0], C1[0]);\nfull_adder fa5(A[1], B[1], C1[0], S1[1], C1[1]);\nfull_adder fa6(A[2], B[1], C1[1], S1[2], C1[2]);\nfull_adder fa7(A[3], B[1], C1[2], S1[3], C1[3]);\n\nfull_adder fa8(A[0], B[2], 1'b0, S2[0], C2[0]);\nfull_adder fa9(A[1], B[2], C2[0], S2[1], C2[1]);\nfull_adder fa10(A[2], B[2], C2[1], S2[2], C2[2]);\nfull_adder fa11(A[3], B[2], C2[2], S2[3], C2[3]);\n\nfull_adder fa12(A[0], B[3], 1'b0, S3[0], C3[0]);\nfull_adder fa13(A[1], B[3], C3[0], S3[1], C3[1]);\nfull_adder fa14(A[2], B[3], C3[1], S3[2], C3[2]);\nfull_adder fa15(A[3], B[3], C3[2], S3[3], C3[3]);\n\nassign P = {C3[3], C3[2], C3[1], C3[0], S3, S2, S1, S0};\n\nendmodule", "corruption_explanation": "Changed bit width from [3:0] to [4:0]", "modification_type": "change_bit_width", "modification_line": 14, "original_snippet": "[3:0]", "modified_snippet": "[4:0]", "issue_description": "The buggy code has an incorrect bit width specification. This causes width mismatches that can lead to truncation, sign extension issues, or synthesis warnings. Linting tools will flag WIDTH warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_bit_width modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Changed bit width from [3:0] to [4:0]\n   \u2022 Line 14: Original: [3:0]\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 14.\n   \u2022 Restore the original code: [3:0]\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change bit width.", "complexity": 3, "applicable_modifications": ["change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "swap_port_signals"], "timestamp": "2025-12-09T21:43:36.339653"}
{"original_entry": {"instruction": "\nWrite a Verilog module named `shift_data` that implements a combinational logical left shifter with a specific behavior for a control value of 15. The module should have the following interface:\n\n*   Input `data_in` (16 bits)\n*   Input `ctrl` (4 bits)\n*   Output `data_out` (16 bits)\n\nThe functionality should be as follows:\n*   If the `ctrl` input is 0, the output `data_out` should be the same as the input `data_in` (no shift).\n*   If the `ctrl` input is a value between 1 and 14 (inclusive), the output `data_out` should be the result of logically shifting `data_in` left by the number of bit positions specified by the value of `ctrl`. The least significant bits should be filled with zeros.\n*   If the `ctrl` input is 15, the output `data_out` should be zero.\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\nmodule shift_data(\n  input [15:0] data_in,\n  input [3:0] ctrl,\n  output [15:0] data_out\n);\n\n  reg [15:0] shifted_data;\n\n  always @(*) begin\n    case(ctrl)\n      4'b0000: shifted_data = data_in;\n      4'b0001: shifted_data = {data_in[14:0], 1'b0};\n      4'b0010: shifted_data = {data_in[13:0], 2'b00};\n      4'b0011: shifted_data = {data_in[12:0], 3'b000};\n      4'b0100: shifted_data = {data_in[11:0], 4'b0000};\n      4'b0101: shifted_data = {data_in[10:0], 5'b00000};\n      4'b0110: shifted_data = {data_in[9:0], 6'b000000};\n      4'b0111: shifted_data = {data_in[8:0], 7'b0000000};\n      4'b1000: shifted_data = {data_in[7:0], 8'b00000000};\n      4'b1001: shifted_data = {data_in[6:0], 9'b000000000};\n      4'b1010: shifted_data = {data_in[5:0], 10'b0000000000};\n      4'b1011: shifted_data = {data_in[4:0], 11'b00000000000};\n      4'b1100: shifted_data = {data_in[3:0], 12'b000000000000};\n      4'b1101: shifted_data = {data_in[2:0], 13'b0000000000000};\n      4'b1110: shifted_data = {data_in[1:0], 14'b00000000000000};\n      4'b1111: shifted_data = 15'b0;\n      default: shifted_data = 16'b0;\n    endcase\n  end\n\n  assign data_out = shifted_data;\n\nendmodule\nCODE END"}, "clean_code": "module shift_data(\n  input [15:0] data_in,\n  input [3:0] ctrl,\n  output [15:0] data_out\n);\n\n  reg [15:0] shifted_data;\n\n  always @(*) begin\n    case(ctrl)\n      4'b0000: shifted_data = data_in;\n      4'b0001: shifted_data = {data_in[14:0], 1'b0};\n      4'b0010: shifted_data = {data_in[13:0], 2'b00};\n      4'b0011: shifted_data = {data_in[12:0], 3'b000};\n      4'b0100: shifted_data = {data_in[11:0], 4'b0000};\n      4'b0101: shifted_data = {data_in[10:0], 5'b00000};\n      4'b0110: shifted_data = {data_in[9:0], 6'b000000};\n      4'b0111: shifted_data = {data_in[8:0], 7'b0000000};\n      4'b1000: shifted_data = {data_in[7:0], 8'b00000000};\n      4'b1001: shifted_data = {data_in[6:0], 9'b000000000};\n      4'b1010: shifted_data = {data_in[5:0], 10'b0000000000};\n      4'b1011: shifted_data = {data_in[4:0], 11'b00000000000};\n      4'b1100: shifted_data = {data_in[3:0], 12'b000000000000};\n      4'b1101: shifted_data = {data_in[2:0], 13'b0000000000000};\n      4'b1110: shifted_data = {data_in[1:0], 14'b00000000000000};\n      4'b1111: shifted_data = 15'b0;\n      default: shifted_data = 16'b0;\n    endcase\n  end\n\n  assign data_out = shifted_data;\n\nendmodule", "corrupted_code": "module shift_data(\n  input [15:0] data_in,\n  input [3:0] ctrl,\n  output [15:0] data_out\n);\n\n  reg [15:0] shifted_data;\n\n  always @(a) begin\n    case(ctrl)\n      4'b0000: shifted_data = data_in;\n      4'b0001: shifted_data = {data_in[14:0], 1'b0};\n      4'b0010: shifted_data = {data_in[13:0], 2'b00};\n      4'b0011: shifted_data = {data_in[12:0], 3'b000};\n      4'b0100: shifted_data = {data_in[11:0], 4'b0000};\n      4'b0101: shifted_data = {data_in[10:0], 5'b00000};\n      4'b0110: shifted_data = {data_in[9:0], 6'b000000};\n      4'b0111: shifted_data = {data_in[8:0], 7'b0000000};\n      4'b1000: shifted_data = {data_in[7:0], 8'b00000000};\n      4'b1001: shifted_data = {data_in[6:0], 9'b000000000};\n      4'b1010: shifted_data = {data_in[5:0], 10'b0000000000};\n      4'b1011: shifted_data = {data_in[4:0], 11'b00000000000};\n      4'b1100: shifted_data = {data_in[3:0], 12'b000000000000};\n      4'b1101: shifted_data = {data_in[2:0], 13'b0000000000000};\n      4'b1110: shifted_data = {data_in[1:0], 14'b00000000000000};\n      4'b1111: shifted_data = 15'b0;\n      default: shifted_data = 16'b0;\n    endcase\n  end\n\n  assign data_out = shifted_data;\n\nendmodule", "corruption_explanation": "Modified sensitivity list", "modification_type": "change_sensitivity_list", "modification_line": 9, "original_snippet": "always @(*)", "modified_snippet": "always @(a)", "issue_description": "The buggy code has an incorrect or incomplete sensitivity list. This causes the always block to not trigger on all relevant signal changes, leading to simulation mismatches and incorrect behavior. Linting tools may flag COMBORDER or similar warnings.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 The module implements specific RTL functionality.\n   \u2022 The design should follow RTL best practices.\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Analyzed the module structure and identified key constructs.\n   \u2022 Found a location where a change_sensitivity_list modification was applied.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Modified sensitivity list\n   \u2022 Line 9: Original: always @(*)\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: The modification introduces a semantic error.\n   \u2022 Impact: The design behavior differs from the intended functionality.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Identify the modified code at line 9.\n   \u2022 Restore the original code: always @(*)\n\n6. RTL Design Principle Violated:\n   \u2022 The modification violates standard RTL design practices.\n   \u2022 Proper RTL requires careful attention to change sensitivity list.", "complexity": 2, "applicable_modifications": ["remove_case_default", "change_constant", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "change_sensitivity_list", "add_multiple_driver", "shuffle_case_items", "remove_always_block"], "timestamp": "2025-12-09T21:43:36.341877"}
{"original_entry": {"instruction": "\nWrite the Verilog code for a module named `jmp_cond` that determines a jump condition based on input flags and a condition code.\n\nThe module interface should be defined as follows:\nInputs:\n- `logic_flags` (5 bits): Contains status flags. Bit 4 is Overflow Flag (OF), Bit 3 is Sign Flag (SF), Bit 2 is Zero Flag (ZF), Bit 1 is Parity Flag (PF), and Bit 0 is Carry Flag (CF).\n- `cond` (4 bits): Selects the specific condition to evaluate.\n- `is_cx` (1 bit): Determines which set of conditions to use.\n- `cx` (16 bits): A register value used in one set of conditions.\n\nOutput:\n- `jmp` (1 bit): The resulting jump condition (1 if true, 0 if false). This output should be registered.\n\nThe module should evaluate the jump condition `jmp` based on the inputs:\n\n1.  If `is_cx` is high: The condition is based on the `cond` input and whether the `cx` register is zero (let's call this `cx_zero`).\n    *   If `cond` is 4'b0000: `jmp` is true if `cx_zero` is true.\n    *   If `cond` is 4'b0001: `jmp` is true if `cx_zero` is false.\n    *   If `cond` is 4'b0010: `jmp` is true if ZF is true AND `cx_zero` is false.\n    *   For any other value of `cond` (4'b0011 through 4'b1111): `jmp` is true if ZF is false AND `cx_zero` is false.\n\n2.  If `is_cx` is low: The condition is based on the `cond` input and the individual flags derived from `logic_flags`.\n    *   If `cond` is 4'b0000: `jmp` is true if OF is true.\n    *   If `cond` is 4'b0001: `jmp` is true if OF is false.\n    *   If `cond` is 4'b0010: `jmp` is true if CF is true.\n    *   If `cond` is 4'b0011: `jmp` is true if CF is false.\n    *   If `cond` is 4'b0100: `jmp` is true if ZF is true.\n    *   If `cond` is 4'b0101: `jmp` is true if ZF is false.\n    *   If `cond` is 4'b0110: `jmp` is true if CF is true OR ZF is true.\n    *   If `cond` is 4'b0111: `jmp` is true if neither CF nor ZF is true.\n    *   If `cond` is 4'b1000: `jmp` is true if SF is true.\n    *   If `cond` is 4'b1001: `jmp` is true if SF is false.\n    *   If `cond` is 4'b1010: `jmp` is true if PF is true.\n    *   If `cond` is 4'b1011: `jmp` is true if PF is false.\n    *   If `cond` is 4'b1100: `jmp` is true if SF XOR OF is true.\n    *   If `cond` is 4'b1101: `jmp` is true if SF XOR NOT OF is true.\n    *   If `cond` is 4'b1110: `jmp` is true if ZF is true OR (SF XOR OF is true).\n    *   If `cond` is 4'b1111: `jmp` is true if ZF is false AND (SF XOR NOT OF is true).\n\nImplement this logic in Verilog, ensuring the output `jmp` is updated appropriately based on the condition inputs.\n\nMake sure your input and output interface has the same names as described in the question. \nPlease start your Verilog code with CODE BEGIN and end with CODE END.", "input": "", "output": "CODE BEGIN\n\n\nmodule jmp_cond (\n    input [4:0]  logic_flags,\n    input [3:0]  cond,\n    input        is_cx,\n    input [15:0] cx,\n    output reg   jmp\n  );\n\n  wire of, sf, zf, pf, cf;\n  wire cx_zero;\n\n  assign of = logic_flags[4];\n  assign sf = logic_flags[3];\n  assign zf = logic_flags[2];\n  assign pf = logic_flags[1];\n  assign cf = logic_flags[0];\n  assign cx_zero = ~(|cx);\n\n  always @(cond or is_cx or cx_zero or zf or of or cf or sf or pf)\n    if (is_cx) case (cond)\n        4'b0000: jmp <= cx_zero;         \n        4'b0001: jmp <= ~cx_zero;        \n        4'b0010: jmp <= zf & ~cx_zero;   \n        default: jmp <= ~zf & ~cx_zero; \n      endcase\n    else case (cond)\n      4'b0000: jmp <= of;\n      4'b0001: jmp <= ~of;\n      4'b0010: jmp <= cf;\n      4'b0011: jmp <= ~cf;\n      4'b0100: jmp <= zf;\n      4'b0101: jmp <= ~zf;\n      4'b0110: jmp <= cf | zf;\n      4'b0111: jmp <= ~cf & ~zf;\n\n      4'b1000: jmp <= sf;\n      4'b1001: jmp <= ~sf;\n      4'b1010: jmp <= pf;\n      4'b1011: jmp <= ~pf;\n      4'b1100: jmp <= (sf ^ of);\n      4'b1101: jmp <= (sf ^~ of);\n      4'b1110: jmp <= zf | (sf ^ of);\n      4'b1111: jmp <= ~zf & (sf ^~ of);\n    endcase\nendmodule\n\nCODE END"}, "clean_code": "module jmp_cond (\n    input [4:0]  logic_flags,\n    input [3:0]  cond,\n    input        is_cx,\n    input [15:0] cx,\n    output reg   jmp\n  );\n\n  wire of, sf, zf, pf, cf;\n  wire cx_zero;\n\n  assign of = logic_flags[4];\n  assign sf = logic_flags[3];\n  assign zf = logic_flags[2];\n  assign pf = logic_flags[1];\n  assign cf = logic_flags[0];\n  assign cx_zero = ~(|cx);\n\n  always @(cond or is_cx or cx_zero or zf or of or cf or sf or pf)\n    if (is_cx) case (cond)\n        4'b0000: jmp <= cx_zero;         \n        4'b0001: jmp <= ~cx_zero;        \n        4'b0010: jmp <= zf & ~cx_zero;   \n        default: jmp <= ~zf & ~cx_zero; \n      endcase\n    else case (cond)\n      4'b0000: jmp <= of;\n      4'b0001: jmp <= ~of;\n      4'b0010: jmp <= cf;\n      4'b0011: jmp <= ~cf;\n      4'b0100: jmp <= zf;\n      4'b0101: jmp <= ~zf;\n      4'b0110: jmp <= cf | zf;\n      4'b0111: jmp <= ~cf & ~zf;\n\n      4'b1000: jmp <= sf;\n      4'b1001: jmp <= ~sf;\n      4'b1010: jmp <= pf;\n      4'b1011: jmp <= ~pf;\n      4'b1100: jmp <= (sf ^ of);\n      4'b1101: jmp <= (sf ^~ of);\n      4'b1110: jmp <= zf | (sf ^ of);\n      4'b1111: jmp <= ~zf & (sf ^~ of);\n    endcase\nendmodule", "corrupted_code": "module jmp_cond (\n    input [4:0]  logic_flags,\n    input [3:0]  cond,\n    input        is_cx,\n    input [15:0] cx,\n    output reg   jmp\n  );\n\n  wire of, sf, zf, pf, cf;\n  wire cx_zero;\n\n  assign of = logic_flags[4];\n  assign sf = logic_flags[3];\n  assign zf = logic_flags[2];\n  assign pf = logic_flags[1];\n  assign cf = logic_flags[0];\n  assign cx_zero = ~(|cx);\n\n  always @(cond or is_cx or cx_zero or zf or of or cf or sf or pf)\n    if (is_cx) case (cond)\n        4'b0000: jmp <= cx_zero;         \n        4'b0001: jmp <= ~cx_zero;        \n        4'b0010: jmp <= zf & ~cx_zero;   \n        default: jmp <= ~zf & ~cx_zero; \n      endcase\n    else case (cond)\n      4'b0000: jmp <= of;\n      4'b0001: jmp <= ~of;\n      4'b0010: jmp <= cf;\n      4'b0011: jmp <= ~cf;\n      4'b0100: jmp <= zf;\n      4'b0101: jmp = ~zf;\n      4'b0110: jmp <= cf | zf;\n      4'b0111: jmp <= ~cf & ~zf;\n\n      4'b1000: jmp <= sf;\n      4'b1001: jmp <= ~sf;\n      4'b1010: jmp <= pf;\n      4'b1011: jmp <= ~pf;\n      4'b1100: jmp <= (sf ^ of);\n      4'b1101: jmp <= (sf ^~ of);\n      4'b1110: jmp <= zf | (sf ^ of);\n      4'b1111: jmp <= ~zf & (sf ^~ of);\n    endcase\nendmodule", "corruption_explanation": "Changed non-blocking (<=) to blocking (=)", "modification_type": "swap_blocking_nonblocking", "modification_line": 32, "original_snippet": "jmp <= ~zf;", "modified_snippet": "jmp = ~zf;", "issue_description": "The buggy code uses the wrong assignment type (blocking vs non-blocking). Using blocking (=) in always_ff blocks causes BLKSEQ lint warnings and potential simulation/synthesis mismatches. Using non-blocking (<=) in combinational blocks can cause unexpected behavior. This violates fundamental RTL coding guidelines.", "reasoning_trace": "1. Overall Design Intent:\n   \u2022 Sequential logic (always_ff) should use non-blocking assignments (<=).\n   \u2022 Combinational logic (always_comb) should use blocking assignments (=).\n\n2. Code Structure and Signal Flow Analysis:\n   \u2022 Found an assignment using the wrong assignment operator for the block type.\n   \u2022 This violates standard RTL coding practices.\n\n3. Identification of Specific Differences/Bugs:\n   \u2022 Blocking assignment (=) used in sequential block, or\n   \u2022 Non-blocking assignment (<=) used in combinational block.\n\n4. Root Cause and Impact:\n   \u2022 Root Cause: Incorrect assignment operator for the always block type.\n   \u2022 Impact: Simulation/synthesis mismatches, BLKSEQ lint warnings, race conditions.\n\n5. Clear Path to Fixing the Issue:\n   \u2022 Use non-blocking (<=) in always_ff blocks for sequential logic.\n   \u2022 Use blocking (=) in always_comb blocks for combinational logic.\n\n6. RTL Design Principle Violated:\n   \u2022 BLKSEQ: Blocking assignment in sequential block is a common RTL error.\n   \u2022 Proper use of blocking vs non-blocking is essential for correct synthesis.", "complexity": 14, "applicable_modifications": ["remove_case_default", "change_constant", "change_operator", "swap_operands", "change_bit_width", "remove_assignment", "swap_blocking_nonblocking", "add_multiple_driver", "shuffle_case_items"], "timestamp": "2025-12-09T21:43:36.344024"}
